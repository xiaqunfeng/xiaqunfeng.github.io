<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[caffe code of SyncedMemory]]></title>
      <url>http://xiaqunfeng.cc/2018/12/22/caffe-code-of-SyncedMemory/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 SyncedMemory，本文分析记录了SyncedMemory内存管理模块的数据成员和成员函数，源码文件注释详见 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/syncedmem-annotation.hpp" target="_blank" rel="external">syncedmem-annotation.hpp</a>，<a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/syncedmem-annotation.cpp" target="_blank" rel="external">syncedmem-annotation.cpp</a>。<br><a id="more"></a></p>
<h2 id="SyncedMemory类"><a href="#SyncedMemory类" class="headerlink" title="SyncedMemory类"></a>SyncedMemory类</h2><p>该类用来管理caffe中Blob的内存，所以在看blob代码之前先看一下该类的实现。内存管理的方法代码都封装在syncedmem.hpp与syncedmem.cpp两个文件中，两个文件代码都比较短，读起来比较方便。</p>
<p><code>SyncedMemory</code>的两个优点：</p>
<ul>
<li>屏蔽了CPU和GPU上的内存管理以及数据同步细节</li>
<li>使用lazy的内存分配方式（通过<code>enum SyncedHead</code>状态控制来实现），在数据访问时才分配，而不是立马分配，提高效率以及节省内存</li>
</ul>
<h3 id="类的数据成员"><a href="#类的数据成员" class="headerlink" title="类的数据成员"></a>类的数据成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class SyncedMemory &#123;</div><div class="line">...</div><div class="line">   private:</div><div class="line">        ...</div><div class="line">        void* cpu_ptr_;</div><div class="line">        void* gpu_ptr_;</div><div class="line">        size_t size_;  </div><div class="line">        SyncedHead head_;</div><div class="line">        bool own_cpu_data_;</div><div class="line">        bool cpu_malloc_use_cuda_;</div><div class="line">        bool own_gpu_data_;</div><div class="line">        int device_;</div><div class="line">        ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>1、其中 head_ 指向目前最新数据块的位置，即最后更新过数据的位置，用于cpu和gpu数据同步。这是一个枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum SyncedHead &#123; UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED &#125;;</div></pre></td></tr></table></figure>
<p>依次表示：数据未初始化、最新数据在cpu上、最新数据在gpu上、最新数据cpu和gpu共享。</p>
<p>2、size_ 表示数据所占内存大小</p>
<p>3、cpu<em>ptr</em> 和 gpu<em>ptr</em> 分别表示指向cpu和gpu侧的指针，通过该指针访问数据</p>
<p>这两个指针指向的数据空间有两种来源，一种是对象自己内部分配的，一种是外部指定的</p>
<p>4、own_cpu<em>data</em> 和 own_gpu<em>data</em> 表示对象是否是自己内部分配的</p>
<ul>
<li>own_cpu<em>data</em> 为true时，表示cpu<em>ptr</em>是对象内部调用CaffeMallocHost分配的CPU内存</li>
<li>own_gpu<em>data</em> 为true时，表示gpu<em>ptr</em>是对象内部调用cudaMalloc分配的GPU内存</li>
</ul>
<p>这两个标志位在 set_cpu/gpu_data() 及函数析构的时候会用于判断是否需要释放当前的数据，如果是自己内部申请的，就要内部释放。</p>
<p>5、cpu_malloc_use<em>cuda</em> 为true时，使用cudaMallocHost分配页锁定内存，否则使用系统malloc分配可分页内存</p>
<p>6、device_ 表示gpu的设备编号</p>
<h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class SyncedMemory &#123;</div><div class="line"> public:</div><div class="line">  ...</div><div class="line">  const void* cpu_data();</div><div class="line">  void set_cpu_data(void* data);</div><div class="line">  const void* gpu_data();</div><div class="line">  void set_gpu_data(void* data);</div><div class="line">  void* mutable_cpu_data();</div><div class="line">  void* mutable_gpu_data();</div><div class="line">  ...</div><div class="line"></div><div class="line">#ifndef CPU_ONLY</div><div class="line">  void async_gpu_push(const cudaStream_t&amp; stream);</div><div class="line">#endif</div><div class="line"></div><div class="line"> private:</div><div class="line">  void check_device();</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>1、<code>cpu_data()</code> 函数用于获取cpu数据的const指针，只读不写</p>
<p>cpu_data()函数的核心是to_cpu()函数（在syncedmem.cpp中定义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">inline void SyncedMemory::to_cpu() &#123;</div><div class="line">  check_device();</div><div class="line">  switch (head_) &#123;</div><div class="line">  case UNINITIALIZED:</div><div class="line">    CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_);</div><div class="line">    caffe_memset(size_, 0, cpu_ptr_);</div><div class="line">    head_ = HEAD_AT_CPU;</div><div class="line">    own_cpu_data_ = true;</div><div class="line">    break;</div><div class="line">  case HEAD_AT_GPU:</div><div class="line">#ifndef CPU_ONLY</div><div class="line">    if (cpu_ptr_ == NULL) &#123;</div><div class="line">      CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_);</div><div class="line">      own_cpu_data_ = true;</div><div class="line">    &#125;</div><div class="line">    caffe_gpu_memcpy(size_, gpu_ptr_, cpu_ptr_);</div><div class="line">    head_ = SYNCED;</div><div class="line">#else</div><div class="line">    NO_GPU;</div><div class="line">#endif</div><div class="line">    break;</div><div class="line">  case HEAD_AT_CPU:</div><div class="line">  case SYNCED:</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用是检查最新数据的位置（即查看 head_ 的标志）</p>
<ul>
<li>数据未初始化 —— 初始化，并将最新数据标志置为位于cpu</li>
<li>最新数据在gpu上 —— 如果指定了CPU_ONLY，则输出NO_GPU并什么都不做；否则将数据复制到cpu，并将数据标志置为共享</li>
<li>最新数据在cpu上或者是共享的 —— 什么都不做</li>
</ul>
<p>2、<code>mutable_cpu_data()</code> 返回可写的cpu指针</p>
<p>它与 cpu_data() 的区别是：在执行 to<em>cpu() 后，不论 head</em> 当前状态如何，将最新数据的位置置为位于cpu上，认为cpu侧数据是最新的，所以调用者可以修改cpu侧数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void* SyncedMemory::mutable_cpu_data() &#123;</div><div class="line">  check_device();</div><div class="line">  to_cpu();</div><div class="line">  head_ = HEAD_AT_CPU;</div><div class="line">  return cpu_ptr_;</div><div class="line">&#125;</div><div class="line">const void* SyncedMemory::cpu_data() &#123;</div><div class="line">  check_device();</div><div class="line">  to_cpu();</div><div class="line">  return (const void*)cpu_ptr_;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、<code>set_cpu_data(void* data)</code></p>
<p>设置cpu数据，即将cpu<em>ptr</em> 指针指向外部数据。</p>
<p>4、<code>gpu_data(), mutable_gpu_data(), set_gpu_data(void* data)</code> 功能同cpu</p>
<p>5、<code>async_gpu_push(const cudaStream_t&amp; stream)</code></p>
<p>功能就是以流的形式将数据同步到gpu上。具体操作就是在gpu上分配存储空间，将cpu的数据同步至gpu，并将head_ 置为共享。</p>
<p>总结一下CPU/GPU数据同步的功能：</p>
<ul>
<li>第一次访问某一侧数据时分配该侧内存，如果不曾访问过则不分配内存，按需分配来节省内存。</li>
<li>用<code>head_</code>来指示最近一次数据更新发生在哪一侧，仅在调用另一侧数据时才将该侧数据同步过去，如果访问的仍是该侧，则不会发生同步。</li>
<li>当两侧已同步都是最新时，即<code>head_=SYNCED</code>，访问任何一侧都不会发生数据同步。</li>
</ul>
<blockquote>
<p>其他成员函数的实现代码详见syncedmem-annotation.cpp</p>
</blockquote>
<h2 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h2><p>在 syncedmem.hpp 中有两个内联函数，不属于 SyncedMemory 类：CaffeMallocHost，CaffeFreeHost，用于内存的申请和释放。</p>
<p>代码逻辑比较简单，如果是CPU模式，那么调用malloc和free（或者intel的mkl模块）来申请/释放内存，否则调用CUDA的 cudaMallocHost 和 cudaFreeHost 来申请/释放显存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">inline void CaffeMallocHost(void** ptr, size_t size, bool* use_cuda) &#123;</div><div class="line">#ifndef CPU_ONLY</div><div class="line">  if (Caffe::mode() == Caffe::GPU) &#123;</div><div class="line">    CUDA_CHECK(cudaMallocHost(ptr, size));</div><div class="line">    *use_cuda = true;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">#endif</div><div class="line">#ifdef USE_MKL</div><div class="line">  *ptr = mkl_malloc(size ? size:1, 64);</div><div class="line">#else</div><div class="line">  *ptr = malloc(size);</div><div class="line">#endif</div><div class="line">  *use_cuda = false;</div><div class="line">  CHECK(*ptr) &lt;&lt; &quot;host allocation of size &quot; &lt;&lt; size &lt;&lt; &quot; failed&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于-Pinned-和-Non-Pinned-Memory"><a href="#关于-Pinned-和-Non-Pinned-Memory" class="headerlink" title="关于 Pinned 和 Non-Pinned Memory"></a>关于 Pinned 和 Non-Pinned Memory</h3><p>当需要分配CPU内存且会传输到GPU时，有两种方式可以选择：<code>pinned</code> 和 <code>non-pinned</code>。</p>
<p>Pinned memory使用<code>cudaMallocHost</code>来分配CPU内存，可以防止内存页被交换出去，因此可以提供更高的传输速度。Non-pinned memory使用<code>malloc</code>函数分配CPU内存。但是Pinned memory 比Non-pinned memory有更昂贵的内存分配和释放，因为<code>cudaMallocHost</code>分配和释放CPU内存相比<code>malloc</code>更加耗时。</p>
<p>结论：</p>
<ul>
<li>使用<code>Pinned Memory</code>方式的CPU和GPU之间传输速度更大，但是分配和释放的耗时更大</li>
<li>使用<code>Non-Pinned Memory</code>的方式CPU和GPU之间传输耗时更大，但是分配和释放更快</li>
<li>当传输的数据比较大，且均需从CPU传至GPU和从GPU传至CPU时，使用<code>Pinned Memory</code>可以获得更好的性能</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【源码分析】caffe code of layer factory]]></title>
      <url>http://xiaqunfeng.cc/2018/12/22/caffe-code-of-layer-factory/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 layer factory，本文分析记录了layer的注册和创建过程，源码文件注释详见<a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/layer_factory-annotation.hpp" target="_blank" rel="external">layer_factory-annotation.hpp</a>。<br><a id="more"></a></p>
<h2 id="layer-factory"><a href="#layer-factory" class="headerlink" title="layer factory"></a>layer factory</h2><h3 id="LayerRegistry类"><a href="#LayerRegistry类" class="headerlink" title="LayerRegistry类"></a>LayerRegistry类</h3><p>主要的实现是由该类来完成的。内部维护了一个map，key为layer的string（类型名称），value为对应Creator（工厂函数），caffe就是通过该map来管理string和Creator映射关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*Creator)(const LayerParameter&amp;);</div><div class="line">typedef std::map&lt;string, Creator&gt; CreatorRegistry;</div></pre></td></tr></table></figure>
<p>map类型为<code>CreatorRegistry</code>，实际类型为<code>std::map&lt;string, Creator&gt;</code>。</p>
<h3 id="layer的注册"><a href="#layer的注册" class="headerlink" title="layer的注册"></a>layer的注册</h3><p>caffe通过两组宏来实现layer的注册：</p>
<p>1、先来看宏 <code>REGISTER_LAYER_CLASS</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define REGISTER_LAYER_CLASS(type)                                             \</div><div class="line">  template &lt;typename Dtype&gt;                                                    \</div><div class="line">  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; Creator_##type##Layer(const LayerParameter&amp; param) \</div><div class="line">  &#123;                                                                            \</div><div class="line">    return shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(new type##Layer&lt;Dtype&gt;(param));           \</div><div class="line">  &#125;                                                                            \</div><div class="line">  REGISTER_LAYER_CREATOR(type, Creator_##type##Layer)`</div></pre></td></tr></table></figure>
<p>该宏实现为指定type的Layer创建一个Creator工厂函数，然后调用<code>REGISTER_LAYER_CREATOR</code>将工厂函数和Layer的类型名进行注册，支持两种Layer的数据类型，float和double。</p>
<p>在每个XX_layer.cpp文件末尾处调用，进行layer的添加注册，比如在<code>bias_layer.cpp</code>的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">REGISTER_LAYER_CLASS(Bias);</div></pre></td></tr></table></figure>
<p>2、再来看宏 <code>REGISTER_LAYER_CREATOR</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define REGISTER_LAYER_CREATOR(type, creator)                                  \</div><div class="line">  static LayerRegisterer&lt;float&gt; g_creator_f_##type(#type, creator&lt;float&gt;);     \</div><div class="line">  static LayerRegisterer&lt;double&gt; g_creator_d_##type(#type, creator&lt;double&gt;)    \</div></pre></td></tr></table></figure>
<p>声明了两个变量，分别对应float和double两种类型，两个变量通过调用LayerRegisterer类的构造函数来完成初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class LayerRegisterer &#123;</div><div class="line"> public:</div><div class="line">  LayerRegisterer(const string&amp; type,</div><div class="line">                  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*creator)(const LayerParameter&amp;)) &#123;</div><div class="line">    // LOG(INFO) &lt;&lt; &quot;Registering layer type: &quot; &lt;&lt; type;</div><div class="line">    LayerRegistry&lt;Dtype&gt;::AddCreator(type, creator);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="LayerRegisterer类"><a href="#LayerRegisterer类" class="headerlink" title="LayerRegisterer类"></a>LayerRegisterer类</h3><p>代码如上，该类只有一个方法，即构造函数，在LayerRegisterer的构造方法中调用了<code>LayerRegistry</code>类的静态方法<code>AddCreator</code>，将新的layer和creator注册并添加到registry list中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class LayerRegistry &#123;</div><div class="line">...</div><div class="line">  static CreatorRegistry&amp; Registry() &#123;</div><div class="line">    static CreatorRegistry* g_registry_ = new CreatorRegistry();</div><div class="line">    return *g_registry_;</div><div class="line">  &#125;</div><div class="line">  // Adds a creator.</div><div class="line">  static void AddCreator(const string&amp; type, Creator creator) &#123;</div><div class="line">    CreatorRegistry&amp; registry = Registry();</div><div class="line">    CHECK_EQ(registry.count(type), 0)</div><div class="line">        &lt;&lt; &quot;Layer type &quot; &lt;&lt; type &lt;&lt; &quot; already registered.&quot;;</div><div class="line">    registry[type] = creator;</div><div class="line">  &#125;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上实现了动态注册</p>
<h3 id="创建layer"><a href="#创建layer" class="headerlink" title="创建layer"></a>创建layer</h3><p>注册完后，在xxnet.prototxt中定义相关的layer参数，比如mnist文件夹下的lenet.prototxt中定义type为Pooling的layer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">layer &#123;</div><div class="line">  name: &quot;pool1&quot;</div><div class="line">  type: &quot;Pooling&quot;</div><div class="line">  bottom: &quot;conv1&quot;</div><div class="line">  top: &quot;pool1&quot;</div><div class="line">  pooling_param &#123;</div><div class="line">    pool: MAX</div><div class="line">    kernel_size: 2</div><div class="line">    stride: 2</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在net.cpp中创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void Net&lt;Dtype&gt;::Init(const NetParameter&amp; in_param) &#123;</div><div class="line">...</div><div class="line">    // Setup layer.</div><div class="line">    const LayerParameter&amp; layer_param = param.layer(layer_id);</div><div class="line">    if (layer_param.propagate_down_size() &gt; 0) &#123;</div><div class="line">      CHECK_EQ(layer_param.propagate_down_size(),</div><div class="line">          layer_param.bottom_size())</div><div class="line">          &lt;&lt; &quot;propagate_down param must be specified &quot;</div><div class="line">          &lt;&lt; &quot;either 0 or bottom_size times &quot;;</div><div class="line">    &#125;</div><div class="line">    layers_.push_back(LayerRegistry&lt;Dtype&gt;::CreateLayer(layer_param));</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用<code>LayerRegistry</code>类的静态方法<code>CreateLayer</code>来实现layer的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class LayerRegistry &#123;</div><div class="line">  ...</div><div class="line">  // Get a layer using a LayerParameter.</div><div class="line">  static shared_ptr&lt;Layer&lt;Dtype&gt; &gt; CreateLayer(const LayerParameter&amp; param) &#123;</div><div class="line">    if (Caffe::root_solver()) &#123;</div><div class="line">      LOG(INFO) &lt;&lt; &quot;Creating layer &quot; &lt;&lt; param.name();</div><div class="line">    &#125;</div><div class="line">    const string&amp; type = param.type();</div><div class="line">    CreatorRegistry&amp; registry = Registry();</div><div class="line">    CHECK_EQ(registry.count(type), 1) &lt;&lt; &quot;Unknown layer type: &quot; &lt;&lt; type</div><div class="line">        &lt;&lt; &quot; (known types: &quot; &lt;&lt; LayerTypeListString() &lt;&lt; &quot;)&quot;;</div><div class="line">    return registry[type](param);</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>caffe layer的设计用到了设计模式里<a href="https://blog.csdn.net/wuzhekai1985/article/details/6660462" target="_blank" rel="external">工厂模式</a>中的工厂方法模式。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用kubeadm在Ubuntu1604上构建k8s集群]]></title>
      <url>http://xiaqunfeng.cc/2018/11/06/kubernetes-deploy/</url>
      <content type="html"><![CDATA[<p>介绍在部署k8s集群的过程，以及遇到的问题及解决方法。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>本次一共安装3台机器，一台master，两台slave。整个安装过程将在Ubuntu1604服务器上进行，安装kubeadm，以及kubernetes的基本集群，包括calico网络。</p>
<p>注：服务器访问不了外网，所以采用国内源的方式。</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1、更新Package索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div></pre></td></tr></table></figure>
<p>2、添加Https支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install \</div><div class="line">    apt-transport-https \</div><div class="line">    ca-certificates \</div><div class="line">    curl \</div><div class="line">    software-properties-common -y</div></pre></td></tr></table></figure>
<p>3、添加Docker官方的GPG key:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</div><div class="line"></div><div class="line">## 如果上面的地址不能下载，可以使用国内镜像</div><div class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg  | sudo apt-key add -</div></pre></td></tr></table></figure>
<p>4、添加Docker-CE稳定版仓储地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository \</div><div class="line">   &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</div><div class="line">   $(lsb_release -cs) \</div><div class="line">   stable&quot;</div></pre></td></tr></table></figure>
<p>注：由于Docker官方仓储<code>download.docker.com</code>的访问较慢，故使用了中科大镜像源替代。</p>
<p>5、安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install docker-ce</div></pre></td></tr></table></figure>
<p>6、验证：</p>
<p>运行<code>Hello Word</code>来验证一下是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run hello-world</div></pre></td></tr></table></figure>
<p>7、释放sudo</p>
<p>默认情况下，Docker需要使用root身份来访问，每次都使用<code>sudo</code>命令较为麻烦，我们可以将当前用户添加到<code>docker</code>用户组来实现非root用户访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod -aG docker $USER</div></pre></td></tr></table></figure>
<p>重新登录一下，便可以不使用<code>sudo</code>命令来操作docker了。</p>
<h3 id="禁用swap文件"><a href="#禁用swap文件" class="headerlink" title="禁用swap文件"></a>禁用swap文件</h3><p>编辑<code>/etc/fstab</code>文件，注释掉引用<code>swap</code>的行，保存并重启后输入<code>sudo swapoff -a</code>即可。</p>
<h2 id="在所有机器上安装kubeadm-kubelet-and-kubectl"><a href="#在所有机器上安装kubeadm-kubelet-and-kubectl" class="headerlink" title="在所有机器上安装kubeadm, kubelet and kubectl"></a>在所有机器上安装kubeadm, kubelet and kubectl</h2><ul>
<li>kubeadm: 引导启动k8s集群的命令工具。</li>
<li>kubelet: 在群集中的所有计算机上运行的组件, 并用来执行如启动pods和containers等操作。</li>
<li>kubectl: 用于操作运行中的集群的命令行工具。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</div><div class="line"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -</div><div class="line"># cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</div><div class="line">deb https://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</div><div class="line">EOF</div><div class="line"># apt-get update</div><div class="line"># apt-get install -y kubelet kubeadm kubectl</div></pre></td></tr></table></figure>
<p>Q&amp;A</p>
<p>出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">W: GPG error: https://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 6A030B21BA07F4FB</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6A030B21BA07F4FB</div></pre></td></tr></table></figure>
<p>再次之行 <code>apt-get update</code>，成功。</p>
<h2 id="初始化master节点"><a href="#初始化master节点" class="headerlink" title="初始化master节点"></a>初始化master节点</h2><p>1、拉取镜像</p>
<p>首先查询下当前版本需要哪些docker image。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubeadm config images list --kubernetes-version v1.12.2</div><div class="line">k8s.gcr.io/kube-apiserver:v1.12.2</div><div class="line">k8s.gcr.io/kube-controller-manager:v1.12.2</div><div class="line">k8s.gcr.io/kube-scheduler:v1.12.2</div><div class="line">k8s.gcr.io/kube-proxy:v1.12.2</div><div class="line">k8s.gcr.io/pause:3.1</div><div class="line">k8s.gcr.io/etcd:3.2.24</div><div class="line">k8s.gcr.io/coredns:1.2.2</div></pre></td></tr></table></figure>
<blockquote>
<p>因为服务器没有翻墙，所以提前拉取k8s初始化需要用到的Images，并添加对应的<code>k8s.gcr.io</code>标签。推荐使用镜像：<a href="https://github.com/anjia0532/gcr.io_mirror来拉取，机器人自动跟官方同步，非常及时。" target="_blank" rel="external">https://github.com/anjia0532/gcr.io_mirror来拉取，机器人自动跟官方同步，非常及时。</a></p>
</blockquote>
<p>写了个脚本<code>pull-tag-rm-image.sh</code>，先pull，再改tag，最后移除pull的image：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># cat pull-tag-rm-image.sh</div><div class="line">#!/usr/bin/env bash</div><div class="line"></div><div class="line">images=(</div><div class="line">    kube-apiserver:v1.12.2</div><div class="line">    kube-controller-manager:v1.12.2</div><div class="line">    kube-scheduler:v1.12.2</div><div class="line">    kube-proxy:v1.12.2</div><div class="line">    pause:3.1</div><div class="line">    etcd:3.2.24</div><div class="line">    coredns:1.2.2</div><div class="line">)</div><div class="line"></div><div class="line">for imagename in $&#123;images[@]&#125; ; do</div><div class="line">    docker pull anjia0532/google-containers.$imagename</div><div class="line">    docker tag anjia0532/google-containers.$imagename k8s.gcr.io/$imagename</div><div class="line">    docker rmi anjia0532/google-containers.$imagename</div><div class="line">done</div></pre></td></tr></table></figure>
<p>运行脚本：<code>bash pull-tag-rm-image.sh</code></p>
<p>查看image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# docker image ls</div><div class="line">REPOSITORY                                                  TAG                 </div><div class="line">k8s.gcr.io/kube-proxy                                       v1.12.2            </div><div class="line">k8s.gcr.io/kube-apiserver                                   v1.12.2                </div><div class="line">k8s.gcr.io/kube-controller-manager                          v1.12.2            </div><div class="line">k8s.gcr.io/kube-scheduler                                   v1.12.2            </div><div class="line">ubuntu                                                      16.04              </div><div class="line">k8s.gcr.io/etcd                                             3.2.24             </div><div class="line">hello-world                                                 latest             </div><div class="line">k8s.gcr.io/coredns                                          1.2.2              </div><div class="line">k8s.gcr.io/pause                                            3.1</div></pre></td></tr></table></figure>
<p>2、选择pod network</p>
<p>这里选择网络为calico，具体参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network" target="_blank" rel="external">官网 pod-network</a></p>
<p>3、初始化master</p>
<p>Master节点就是运行着控制组件的机器，包括etcd(集群数据库)和API服务(kubectl CLI通讯服务)。<br>初始化master节点, 只需运行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubeadm init --pod-network-cidr=192.168.0.0/16 --kubernetes-version=1.12.2</div><div class="line">...</div><div class="line">[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</div><div class="line">[addons] Applied essential addon: CoreDNS</div><div class="line">[addons] Applied essential addon: kube-proxy</div><div class="line"></div><div class="line">Your Kubernetes master has initialized successfully!</div><div class="line"></div><div class="line">To start using your cluster, you need to run the following as a regular user:</div><div class="line"></div><div class="line">  mkdir -p $HOME/.kube</div><div class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</div><div class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</div><div class="line"></div><div class="line">You should now deploy a pod network to the cluster.</div><div class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</div><div class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</div><div class="line"></div><div class="line">You can now join any number of machines by running the following on each node</div><div class="line">as root:</div><div class="line"></div><div class="line">  kubeadm join 192.168.212.103:6443 --token 4eqoi9.xekqw6hsc7hbqm9l --discovery-token-ca-cert-hash sha256:64a06d1fc3883066fcf94109399cb68eb6626ed2969153dbd08279e0124eb424</div></pre></td></tr></table></figure>
<ul>
<li><code>--pod-network-cidr=192.168.0.0/16</code> ：指定pod网络的IP地址范围，它的值取决于下一步选择的网络插件类型。这里选择calico网络。</li>
<li><code>--kubernetes-version=1.12.2</code>：指定Kubenetes版本，如果不指定该参数，会从google网站下载最新的版本信息。这里选择版本v1.12.2。</li>
<li><code>--apiserver-advertise-address</code>: 指定master服务发布的Ip地址，如果不指定，则会自动检测网络接口，通常是内网IP。</li>
<li><code>--feature-gates=CoreDNS</code>: 是否使用CoreDNS，值为true/false，CoreDNS插件在1.10中提升到了Beta阶段，最终会成为Kubernetes的缺省选项。</li>
</ul>
<p>4、设置使用kubectl的权限</p>
<p>如果想在非root用户下使用<code>kubectl</code>，可以执行如下命令(也是<code>kubeadm init</code>输出的一部分)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir -p <span class="variable">$HOME</span>/.kube</div><div class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</div><div class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</div></pre></td></tr></table></figure>
<p>如果已是root用户，只需执行如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</div></pre></td></tr></table></figure>
<h2 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h2><p>检查节点的状态，发现节点的状态为not ready：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl get nodes</div><div class="line">NAME      STATUS     ROLES    AGE   VERSION</div><div class="line">jqgpu34   NotReady   master   14m   v1.12.2</div></pre></td></tr></table></figure>
<p>原因是还没有配置网络。配置网络，具体参考参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network" target="_blank" rel="external">官网 pod-network</a>。</p>
<p>pods之间需要通过网络插件进行彼此通信。网络部署必须是优先于任何应用的部署，如<code>kube-dns</code>(本文中使用的是<code>coredns</code>)在网络部署成功之前是无法使用的。k8s下通信需要CNI（Container Network Interface），（kubeadm不支持kubenet）。比较常见的network addon有：Calico, Canal, Flannel, Kube-router, Romana, Weave Net等。</p>
<p>1、安装网络插件</p>
<p>使用下列命令来安装网络插件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl apply -f &lt;add-on.yaml&gt;</div></pre></td></tr></table></figure>
<p>在本文中，我使用的是Calico网络，安装如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</div><div class="line"># kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</div></pre></td></tr></table></figure>
<blockquote>
<p>为了Calico可以正常运行，必须在执行kubeadm init时使用 <code>--pod-network-cidr=192.168.0.0/16</code>。</p>
</blockquote>
<p>这时候，发现节点的状态变为ready了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl get nodes</div><div class="line">NAME      STATUS   ROLES    AGE   VERSION</div><div class="line">jqgpu34   Ready    master   18m   v1.12.2</div></pre></td></tr></table></figure>
<p>网络插件安装完成后，可以通过检查<code>coredns pod</code>的运行状态来判断网络插件是否正常运行，一旦<code>CoreDNS pod</code>起来并运行，就可以继续加入节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl get pods --all-namespaces</div><div class="line">NAMESPACE     NAME                              READY   STATUS    RESTARTS   AGE</div><div class="line">kube-system   calico-node-vps6h                 2/2     Running   0          2m8s</div><div class="line">kube-system   coredns-576cbf47c7-56kmg          1/1     Running   0          18m</div><div class="line">kube-system   coredns-576cbf47c7-wrvzn          1/1     Running   0          18m</div><div class="line">kube-system   etcd-jqgpu34                      1/1     Running   0          17m</div><div class="line">kube-system   kube-apiserver-jqgpu34            1/1     Running   0          17m</div><div class="line">kube-system   kube-controller-manager-jqgpu34   1/1     Running   0          18m</div><div class="line">kube-system   kube-proxy-7jdqx                  1/1     Running   0          18m</div><div class="line">kube-system   kube-scheduler-jqgpu34            1/1     Running   0          18m</div></pre></td></tr></table></figure>
<p>2、隔离主节点</p>
<p>默认情况下，出于安全的考虑，并不会在主节点上运行pod，如果你想在主节点上运行pod，比如：运行一个单机版的kubernetes集群时，可运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl taint nodes --all node-role.kubernetes.io/master-</div><div class="line">node/jqgpu34 untainted</div></pre></td></tr></table></figure>
<blockquote>
<p>我这里就三台机器，两台计算节点不够用，所以也把master加入计算节点。这时候Scheduler便可以在任何节点上安排运行pod了。</p>
</blockquote>
<h2 id="slave节点加入集群"><a href="#slave节点加入集群" class="headerlink" title="slave节点加入集群"></a>slave节点加入集群</h2><p>节点就是负载（容器和pod等等）运行的地方。ssh到slave机器上执行<code>kubeadm init</code>输出的那句命令，即可将slave节点加入集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm join 192.168.212.103:6443 --token 4eqoi9.xekqw6hsc7hbqm9l --discovery-token-ca-cert-hash sha256:64a06d1fc3883066fcf94109399cb68eb6626ed2969153dbd08279e0124eb424</div></pre></td></tr></table></figure>
<p>随后就可以在master节点上通过命令<code>kubectl get nodes</code>看到新加入的机器了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl get nodes</div><div class="line">NAME      STATUS     ROLES    AGE   VERSION</div><div class="line">jqgpu34   Ready      master   27m   v1.12.2</div><div class="line">jqgpu35   NotReady   &lt;none&gt;   27s   v1.12.2</div><div class="line">jqgpu36   NotReady   &lt;none&gt;   10s   v1.12.2</div></pre></td></tr></table></figure>
<p>其他可选安装步骤参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="external">官网</a>.</p>
<p>其他参考资料：</p>
<ul>
<li><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="external">https://kubernetes.io/docs/setup/independent/install-kubeadm/</a></li>
<li><a href="https://docs.projectcalico.org/v3.3/getting-started/kubernetes/" target="_blank" rel="external">https://docs.projectcalico.org/v3.3/getting-started/kubernetes/</a></li>
<li><a href="https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-ubuntu-server-16.04-with-kubeadm.html" target="_blank" rel="external">https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-ubuntu-server-16.04-with-kubeadm.html</a></li>
<li><a href="https://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster.html" target="_blank" rel="external">https://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster.html</a></li>
</ul>
<h2 id="slave节点一直not-ready"><a href="#slave节点一直not-ready" class="headerlink" title="slave节点一直not ready"></a>slave节点一直not ready</h2><blockquote>
<p>这个问题花了挺多时间，记录一下</p>
</blockquote>
<p>和该问题一模一样：<a href="https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state，但是并没有说解决方法，需要看日志。" target="_blank" rel="external">https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state，但是并没有说解决方法，需要看日志。</a></p>
<p>1、master上查看kubelet log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># journalctl -u kubelet</div></pre></td></tr></table></figure>
<p>发现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dns.go:131] Nameserver limits were exceeded, some nameservers have been omitted,</div></pre></td></tr></table></figure>
<p>网上找到遇到类似问题的：</p>
<p><a href="https://www.reddit.com/r/kubernetes/comments/7ruq0f/kubelet_nameserver_limits_were_exceeded/" target="_blank" rel="external">https://www.reddit.com/r/kubernetes/comments/7ruq0f/kubelet_nameserver_limits_were_exceeded/</a></p>
<p><a href="https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state" target="_blank" rel="external">https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state</a></p>
<p>是dns的问题。查看resol.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat /etc/resolv.conf</div><div class="line">nameserver 119.28.28.28</div><div class="line">nameserver 119.29.29.29</div><div class="line">nameserver 114.114.114.114</div><div class="line">nameserver 114.114.115.115</div><div class="line">options timeout:2 attempts:1</div></pre></td></tr></table></figure>
<p>也没找到其他解决方法。</p>
<p>2、slave节点上查看日志</p>
<p>除了上述dns的错误外，还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cni.go:188] Unable to update cni config: No networks found in /etc/cni/net.d</div><div class="line">kubelet.go:2167] Container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</div></pre></td></tr></table></figure>
<p>在master上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ls /etc/cni/net.d/</div><div class="line">10-calico.conflist  calico-kubeconfig</div></pre></td></tr></table></figure>
<p>而两个slave节点没有<code>/etc/cni/net.d/</code>这个目录。在slave节点上创建两个目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p /etc/cni/net.d</div><div class="line">mkdir -p /opt/cni/bin</div></pre></td></tr></table></figure>
<p>3、回到master上操作</p>
<p>查看etcd的状态，正常running</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># kubectl -n kube-system get pod -o wide | grep etcd</div></pre></td></tr></table></figure>
<p>查看calico的状态，只有master和etcd是runing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># kubectl -n kube-system get pod -o wide  | grep calico</div></pre></td></tr></table></figure>
<p>查看非running pod <code>calico-node-222fg</code>的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># kubectl -n kube-system describe pod calico-node-222fg</div></pre></td></tr></table></figure>
<p>发现没有这个镜像<code>k8s.gcr.io/pause:3.1</code>，可能之前脚本拉的时候没有成功，在每台机器上再拉一下。</p>
<p>下载应用的calico yaml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/rbac.yaml</div><div class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/calico.yaml</div></pre></td></tr></table></figure>
<p>Calico.yaml里的IP为: <code>etcd_endpoints: &quot;http://10.96.232.136:6666&quot;</code></p>
<p>修改里面的IP，重新应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kubectl delete -f rbac.yaml</div><div class="line">kubectl delete -f calico.yaml</div><div class="line">kubectl apply -f rbac.yaml</div><div class="line">kubectl apply -f calico.yaml</div></pre></td></tr></table></figure>
<p>修改kube-apiserver.yaml文件，修改IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ls /etc/kubernetes/manifests/</div><div class="line">etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml</div><div class="line"></div><div class="line"># docker ps -a |grep kube-api</div><div class="line">567dfc84a46c        51a9c329b7c5           &quot;kube-apiserver --au…&quot;   19 hours ago        Up 19 hours                                       k8s_kube-apiserver_kube-apiserver-jqgpu34_kube-system_ce9a856edd3006dfeece62c00bf608a8_0</div><div class="line">b0110d62f45f        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 19 hours ago        Up 19 hours                                       k8s_POD_kube-apiserver-jqgpu34_kube-system_ce9a856edd3006dfeece62c00bf608a8_0</div></pre></td></tr></table></figure>
<p>看看etcd都监听了哪些端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># netstat -natlp | grep etcd</div><div class="line">tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      1226075/etcd</div><div class="line">tcp        0      0 127.0.0.1:2380          0.0.0.0:*               LISTEN      1226075/etcd</div><div class="line">...</div><div class="line">tcp6       0      0 :::6666                 :::*                    LISTEN      1232066/etcd</div><div class="line">tcp6       0      0 :::6667                 :::*                    LISTEN      1232066/etcd</div></pre></td></tr></table></figure>
<p>上面整理的有一点乱，究其根源就是etcd占用了<code>127.0.0.1</code>的网段，而calico</p>
<p>解决以后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# kubectl get nodes</div><div class="line">NAME      STATUS   ROLES    AGE   VERSION</div><div class="line">jqgpu34   Ready    master   20h   v1.12.2</div><div class="line">jqgpu35   Ready    &lt;none&gt;   19h   v1.12.2</div><div class="line">jqgpu36   Ready    &lt;none&gt;   19h   v1.12.2</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> k8s </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装nvidia显卡驱动]]></title>
      <url>http://xiaqunfeng.cc/2018/10/30/nvidia-driver-install/</url>
      <content type="html"><![CDATA[<p>记录在GPU机器上安装显卡驱动的过程。<br><a id="more"></a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1、系统版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04.2 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div></pre></td></tr></table></figure>
<p>2、内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# uname -r</div><div class="line">4.4.0-62-generic</div></pre></td></tr></table></figure>
<p>3、显卡</p>
<p>显卡型号：Tesla P4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# lspci | grep -i nvidia</div><div class="line">04:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">05:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">08:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">09:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">85:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">86:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">89:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div><div class="line">8a:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</div></pre></td></tr></table></figure>
<p>显示有8张卡。</p>
<h2 id="卸载掉原有驱动"><a href="#卸载掉原有驱动" class="headerlink" title="卸载掉原有驱动"></a>卸载掉原有驱动</h2><p>如果没有安装驱动，忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove –purge nvidia*</div></pre></td></tr></table></figure>
<h2 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h2><p>安装NVIDIA需要把系统自带的驱动禁用</p>
<p>禁用前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# lsmod | grep nouveau</div><div class="line">nouveau              1495040  0</div><div class="line">video                  40960  1 nouveau</div><div class="line">ttm                    94208  2 ast,nouveau</div><div class="line">drm_kms_helper        155648  2 ast,nouveau</div><div class="line">mxm_wmi                16384  1 nouveau</div><div class="line">i2c_algo_bit           16384  3 ast,igb,nouveau</div><div class="line">drm                   364544  5 ast,ttm,drm_kms_helper,nouveau</div><div class="line">wmi                    20480  2 mxm_wmi,nouveau</div></pre></td></tr></table></figure>
<p>1、打开文件: <code>/etc/modprobe.d/blacklist.conf</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blacklist nouveau</div></pre></td></tr></table></figure>
<p>2、执行生效命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# update-initramfs -u</div><div class="line">update-initramfs: Generating /boot/initrd.img-4.4.0-62-generic</div><div class="line">cryptsetup: WARNING: could not determine root device from /etc/fstab</div><div class="line">W: Possible missing firmware /lib/firmware/ast_dp501_fw.bin for module ast</div><div class="line">W: mdadm: /etc/mdadm/mdadm.conf defines no arrays.</div></pre></td></tr></table></figure>
<p>忽略warning。</p>
<p>3、重启并输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# lsmod | grep nouveau</div></pre></td></tr></table></figure>
<p>无任何输出，表示禁用成功。</p>
<h2 id="安装nvidia显卡驱动"><a href="#安装nvidia显卡驱动" class="headerlink" title="安装nvidia显卡驱动"></a>安装nvidia显卡驱动</h2><p>1、下载并安装</p>
<p>下载驱动：<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="external">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p>
<p>根据系统和显卡情况正确选择并下载驱动</p>
<p>将下载的驱动文件拷贝到GPU机器上</p>
<p>添加可执行权限并运行</p>
<p>注：Tesla P4 + Ubuntu1604 + 64-bit + CUDA Toolkit 10.0 + Chinese <a href="http://p926l57yp.bkt.clouddn.com/NVIDIA-Linux-x86_64-410.72.run" target="_blank" rel="external">下载链接</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# chmod a+x NVIDIA-Linux-x86_64-410.72.run</div><div class="line">root@jqgpu34:~# ./NVIDIA-Linux-x86_64-410.72.run</div><div class="line">Verifying archive integrity... OK</div><div class="line">Uncompressing NVIDIA Accelerated Graphics Driver for Linux-x86_64 410.72...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</div></pre></td></tr></table></figure>
<p>中间会出现 <code>WARNING</code>，一路回车忽略。</p>
<p>2、检查是否安装成功</p>
<p>显示如下表示安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">root@jqgpu34:~# nvidia-smi</div><div class="line">Tue Oct 30 16:37:24 2018</div><div class="line">+-----------------------------------------------------------------------------+</div><div class="line">| NVIDIA-SMI 410.72       Driver Version: 410.72       CUDA Version: 10.0     |</div><div class="line">|-------------------------------+----------------------+----------------------+</div><div class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class="line">|===============================+======================+======================|</div><div class="line">|   0  Tesla P4            Off  | 00000000:04:00.0 Off |                  N/A |</div><div class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   1  Tesla P4            Off  | 00000000:05:00.0 Off |                  N/A |</div><div class="line">| N/A   39C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   2  Tesla P4            Off  | 00000000:08:00.0 Off |                  N/A |</div><div class="line">| N/A   39C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   3  Tesla P4            Off  | 00000000:09:00.0 Off |                  N/A |</div><div class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   4  Tesla P4            Off  | 00000000:85:00.0 Off |                  N/A |</div><div class="line">| N/A   35C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   5  Tesla P4            Off  | 00000000:86:00.0 Off |                  N/A |</div><div class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   6  Tesla P4            Off  | 00000000:89:00.0 Off |                  N/A |</div><div class="line">| N/A   37C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   7  Tesla P4            Off  | 00000000:8A:00.0 Off |                  N/A |</div><div class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      4%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line"></div><div class="line">+-----------------------------------------------------------------------------+</div><div class="line">| Processes:                                                       GPU Memory |</div><div class="line">|  GPU       PID   Type   Process name                             Usage      |</div><div class="line">|=============================================================================|</div><div class="line">|  No running processes found                                                 |</div><div class="line">+-----------------------------------------------------------------------------+</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive架构及应用介绍【转】]]></title>
      <url>http://xiaqunfeng.cc/2018/10/18/Hive/</url>
      <content type="html"><![CDATA[<p>介绍Hive的架构及应用<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hive这个框架在Hadoop的生态体系结构中占有及其重要的地位，在实际的业务当中用的也非常多，可以说Hadoop之所以这么流行在很大程度上是因为Hive的存在。那么Hive究竟是什么，为什么在Hadoop家族中占有这么重要的地位，本篇文章将围绕Hive的体系结构(架构)、Hive的操作、Hive与Hbase的区别等对Hive进行全方面的阐述。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在此之前，先给大家介绍一个业务场景，让大家感受一下为什么Hive如此的受欢迎： </p>
<p>业务描述：统计业务表consumer.txt中北京的客户有多少位？下面是相应的业务数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">id      city    name    sex           </div><div class="line">0001    beijing zhangli man </div><div class="line">0002    guizhou lifang  woman </div><div class="line">0003    tianjin wangwei man </div><div class="line">0004    chengde wanghe  woman </div><div class="line">0005    beijing lidong  man </div><div class="line">0006    lanzhou wuting  woman </div><div class="line">0007    beijing guona   woman </div><div class="line">0008    chengde houkuo  man</div></pre></td></tr></table></figure>
<p>首先我先用大家所熟悉的MapReduce程序来实现这个业务分析，完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">package IT;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.net.URI;</div><div class="line"></div><div class="line">import org.apache.hadoop.conf.Configuration;</div><div class="line">import org.apache.hadoop.fs.FSDataInputStream;</div><div class="line">import org.apache.hadoop.fs.FileSystem;</div><div class="line">import org.apache.hadoop.fs.Path;</div><div class="line">import org.apache.hadoop.io.IOUtils;</div><div class="line">import org.apache.hadoop.io.LongWritable;</div><div class="line">import org.apache.hadoop.io.Text;</div><div class="line">import org.apache.hadoop.mapreduce.Job;</div><div class="line">import org.apache.hadoop.mapreduce.Mapper;</div><div class="line">import org.apache.hadoop.mapreduce.Reducer;</div><div class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</div><div class="line">import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</div><div class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</div><div class="line">import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</div><div class="line">import org.apache.hadoop.mapreduce.lib.partition.HashPartitioner;</div><div class="line"></div><div class="line">public class Consumer</div><div class="line">&#123;</div><div class="line">    public static String path1 = &quot;hdfs://192.168.80.80:9000/consumer.txt&quot;;</div><div class="line">    public static String path2 = &quot;hdfs://192.168.80.80:9000/dir&quot;;</div><div class="line">    public static void main(String[] args) throws Exception</div><div class="line">    &#123;</div><div class="line">          FileSystem fileSystem = FileSystem.get(new URI(path1) , new Configuration());</div><div class="line">          if(fileSystem.exists(new Path(path2)))</div><div class="line">          &#123;</div><div class="line">              fileSystem.delete(new Path(path2), true);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          Job job = new Job(new Configuration(),&quot;Consumer&quot;);</div><div class="line">          FileInputFormat.setInputPaths(job, new Path(path1));</div><div class="line">          job.setInputFormatClass(TextInputFormat.class);</div><div class="line">          job.setMapperClass(MyMapper.class);</div><div class="line">          job.setMapOutputKeyClass(Text.class);</div><div class="line">          job.setMapOutputValueClass(LongWritable.class);</div><div class="line"></div><div class="line">          job.setNumReduceTasks(1);</div><div class="line">          job.setPartitionerClass(HashPartitioner.class);</div><div class="line"></div><div class="line">          job.setReducerClass(MyReducer.class);</div><div class="line">          job.setOutputKeyClass(Text.class);</div><div class="line">          job.setOutputValueClass(LongWritable.class);</div><div class="line">          job.setOutputFormatClass(TextOutputFormat.class);</div><div class="line">          FileOutputFormat.setOutputPath(job, new Path(path2));</div><div class="line">          job.waitForCompletion(true);</div><div class="line">          //查看执行结果</div><div class="line">          FSDataInputStream fr = fileSystem.open(new Path(&quot;hdfs://hadoop80:9000/dir/part-r-00000&quot;));</div><div class="line">          IOUtils.copyBytes(fr, System.out, 1024, true);</div><div class="line">     &#125;</div><div class="line">    public static class MyMapper extends Mapper&lt;LongWritable, Text, Text, LongWritable&gt;</div><div class="line">    &#123;      </div><div class="line">            public static long sum = 0L;</div><div class="line">            protected void map(LongWritable k1, Text v1,Context context) throws IOException, InterruptedException</div><div class="line">            &#123;</div><div class="line">                  String[] splited = v1.toString().split(&quot;\t&quot;);</div><div class="line">                  if(splited[1].equals(&quot;beijing&quot;))</div><div class="line">                  &#123;</div><div class="line">                      sum++;</div><div class="line">                  &#125;</div><div class="line">            &#125;</div><div class="line">            protected void cleanup(Context context)throws IOException, InterruptedException</div><div class="line">            &#123;</div><div class="line">                  String str = &quot;beijing&quot;;</div><div class="line">                  context.write(new Text(str),new LongWritable(sum));</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    public static class MyReducer extends Reducer&lt;Text, LongWritable, Text, LongWritable&gt;</div><div class="line">    &#123;</div><div class="line">            protected void reduce(Text k2, Iterable&lt;LongWritable&gt; v2s,Context context)throws IOException, InterruptedException</div><div class="line">            &#123;</div><div class="line">                  for (LongWritable v2 : v2s)</div><div class="line">                 &#123;</div><div class="line">                     context.write(k2, v2);</div><div class="line">                 &#125;</div><div class="line">            &#125;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MapReduce程序代码运行结果如下： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive1.jpg" alt="PIC1"></p>
<p>从运行结果可以看出：在consumer.txt业务表中，北京的客户共有三位。下面我们将用Hive来实现相同的功能，即统计业务表consumer.txt中北京的客户有多少位？<br>Hive操作如下： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive2.jpg" alt="PIC2"></p>
<p>Hive运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OK</div><div class="line">beijing 3</div><div class="line">Time taken: 19.768 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure>
<p>到这里，是不是感觉Hive这个运行框架很神奇—–对于相同的业务逻辑只需要写几行Sql命令就可以获取我们所需要的结果，这也恰恰是Hive为什么这么流行的原因。</p>
<p>Hive的优势主要体现在：<br>①Hive支持标准的SQL语法，免去了用户编写MapReduce程序的过程，大大减少了公司的开发成本<br>②Hive的出现可以让那些精通SQL技能、但是不熟悉MapReduce 、编程能力较弱与不擅长Java语言的用户能够在HDFS大规模数据集上很方便地利用SQL 语言查询、汇总、分析数据，毕竟精通SQL语言的人要比精通Java语言的多得多<br>③Hive是为大数据批量处理而生的，Hive的出现解决了传统的关系型数据库(MySql、Oracle)在大数据处理上的瓶颈<br>好了，上面通过一个简单的小业务场景说明了Hive的巨大优势，接下来将进入本篇文章的正题。 </p>
<h2 id="（一）Hive体系结构-架构-的介绍"><a href="#（一）Hive体系结构-架构-的介绍" class="headerlink" title="（一）Hive体系结构(架构)的介绍"></a>（一）Hive体系结构(架构)的介绍</h2><h3 id="1、Hive的概念："><a href="#1、Hive的概念：" class="headerlink" title="1、Hive的概念："></a>1、Hive的概念：</h3><p>①Hive是为了简化用户编写MapReduce程序而生成的一种框架，使用MapReduce做过数据分析的人都知道，很多分析程序除业务逻辑不同外，程序流程基本一样。在这种情况下，就需要Hive这样的用户编程接口。Hive提供了一套类SQL的查询语言，称为QL，而在创造Hive框架的过程中之所以使用SQL实现Hive是因为大家对SQL语言非常的熟悉，转换成本低，可以大大普及我们Hadoop用户使用的范围，类似作用的Pig就不是通过SQL实现的。<br>Hive是基于Hadoop的一个开源数据仓库系统，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，Hive可以把SQL中的表、字段转换为HDFS中的目录、文件。 </p>
<p>②Hive是建立在Hadoop之上的数据仓库基础构架、是为了减少MapReduce编写工作的批处理系统，Hive本身不存储和计算数据，它完全依赖于HDFS和MapReduce。Hive可以理解为一个客户端工具，将我们的sql操作转换为相应的MapReduce jobs，然后在Hadoop上面运行。 </p>
<p>在开始为大家列举的consumer.txt小业务当中，从编写Sql到最后得出Beijing 3的分析结果实际上中间走的是MapReduce程序， 只不过这个MapReduce程序不用用户自己编写，而是由Hive这个客户端工具将我们的sql操作转化为了相应的MapReduce程序，下面是我们运行sql命令时显示的相关日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">hive&gt; select city,count(*)</div><div class="line">    &gt; from t4    </div><div class="line">    &gt; where city=&apos;beijing&apos;</div><div class="line">    &gt; group by city;</div><div class="line">Total MapReduce jobs = 1</div><div class="line">Launching Job 1 out of 1</div><div class="line">Number of reduce tasks not specified. Estimated from input data size: 1</div><div class="line">In order to change the average load for a reducer (in bytes):</div><div class="line">  set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</div><div class="line">In order to limit the maximum number of reducers:</div><div class="line">  set hive.exec.reducers.max=&lt;number&gt;</div><div class="line">In order to set a constant number of reducers:</div><div class="line">  set mapred.reduce.tasks=&lt;number&gt;</div><div class="line">Starting Job = job_1478233923484_0902, Tracking URL = http://hadoop22:8088/proxy/application_1478233923484_0902/</div><div class="line">Kill Command = /usr/local/hadoop/bin/hadoop job  -kill job_1478233923484_0902</div><div class="line">Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1</div><div class="line">2016-11-09 11:36:36,688 Stage-1 map = 0%,  reduce = 0%</div><div class="line">2016-11-09 11:36:42,018 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:43,062 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:44,105 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:45,149 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:46,193 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:47,237 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:48,283 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</div><div class="line">2016-11-09 11:36:49,329 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 3.7 sec</div><div class="line">2016-11-09 11:36:50,384 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 3.7 sec</div><div class="line">MapReduce Total cumulative CPU time: 3 seconds 700 msec</div><div class="line">Ended Job = job_1478233923484_0902</div><div class="line">MapReduce Jobs Launched: </div><div class="line">Job 0: Map: 1  Reduce: 1   Cumulative CPU: 3.7 sec   HDFS Read: 419 HDFS Write: 10 SUCCESS</div><div class="line">Total MapReduce CPU Time Spent: 3 seconds 700 msec</div><div class="line">OK</div><div class="line">beijing 3</div><div class="line">Time taken: 19.768 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure>
<p>从日志可以看出，Hive将我们的sql命令解析成了相应的MapReduce任务，最后得到了我们的分析结果。 </p>
<p>③Hive可以认为是MapReduce的一个封装、包装。Hive的意义就是在业务分析中将用户容易编写、会写的Sql语言转换为复杂难写的MapReduce程序，从而大大降低了Hadoop学习的门槛，让更多的用户可以利用Hadoop进行数据挖掘分析。 </p>
<p>为了让大家容易理解Hive的实质——-“Hive就是一个SQL解析引擎，将SQL语句转化为相应的MapReduce程序”这句话，博主用一个图示进行示例：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive3.jpg" alt="PIC3"></p>
<p>从图示可以看出，Hive从某种程度上讲就是很多“SQL—MapReduce”框架的一个封装，可以将用户编写的Sql语言解析成对应的MapReduce程序，最终通过MapReduce运算框架形成运算结果提交给Client。 </p>
<h3 id="2、Hive体系结构的介绍"><a href="#2、Hive体系结构的介绍" class="headerlink" title="2、Hive体系结构的介绍"></a>2、Hive体系结构的介绍</h3><p>下面是Hive的体系结构图： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive4.jpg" alt="PIC4"></p>
<p>Hive的体系结构可以分为以下几个部分： </p>
<p>①用户接口：包括shell命令、Jdbc/Odbc和WebUi，其中最常用的是shell这个客户端方式对Hive进行相应操作 </p>
<p>②Hive解析器(驱动Driver)：Hive解析器的核心功能就是根据用户编写的Sql语法匹配出相应的MapReduce模板，形成对应的MapReduce job进行执行。 </p>
<p>③Hive元数据库(MetaStore)：Hive将表中的元数据信息存储在数据库中，如derby(自带的)、Mysql(实际工作中配置的)，Hive中的元数据信息包括表的名字、表的列和分区、表的属性(是否为外部表等)、表的数据所在的目录等。Hive中的解析器在运行的时候会读取元数据库MetaStore中的相关信息。<br>在这里和大家说一下为什么我们在实际业务当中不用Hive自带的数据库derby，而要重新为其配置一个新的数据库Mysql，是因为derby这个数据库具有很大的局限性：derby这个数据库不允许用户打开多个客户端对其进行共享操作，只能有一个客户端打开对其进行操作，即同一时刻只能有一个用户使用它，自然这在工作当中是很不方便的，所以我们要重新为其配置一个数据库。 </p>
<p>④Hadoop：Hive用HDFS进行存储，用MapReduce进行计算——-Hive这个数据仓库的数据存储在HDFS中，业务实际分析计算是利用MapReduce执行的。 </p>
<p>从上面的体系结构中可以看出，在Hadoop的HDFS与MapReduce以及MySql的辅助下，Hive其实就是利用Hive解析器将用户的SQl语句解析成对应的MapReduce程序而已，即Hive仅仅是一个客户端工具，这也是为什么我们在Hive的搭建过程中没有分布与伪分布搭建的原因。</p>
<h3 id="3、Hive的运行机制"><a href="#3、Hive的运行机制" class="headerlink" title="3、Hive的运行机制"></a>3、Hive的运行机制</h3><p>Hive的运行机制如下图所示： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive5.jpg" alt="PIC5"></p>
<p>Hive的运行机制正如图所示：创建完表之后，用户只需要根据业务需求编写Sql语句，而后将由Hive框架将Sql语句解析成对应的MapReduce程序，通过MapReduce计算框架运行job，便得到了我们最终的分析结果。 </p>
<p>在Hive的运行过程中，用户只需要创建表、导入数据、编写Sql分析语句即可，剩下的过程将由Hive框架自动完成，而创建表、导入数据、编写Sql分析语句其实就是数据库的知识了，Hive的运行过程也说明了为什么Hive的存在大大降低了Hadoop的学习门槛以及为什么Hive在Hadoop家族中占有着那么重要的地位。 </p>
<h2 id="（二）Hive的操作"><a href="#（二）Hive的操作" class="headerlink" title="（二）Hive的操作"></a>（二）Hive的操作</h2><p>Hive的操作对于用户来说实际上就是表的操作、数据库的操作。下面我们将围绕两个方面进行介绍： </p>
<h3 id="1、Hive表——内部表、外部表、分区表的创建"><a href="#1、Hive表——内部表、外部表、分区表的创建" class="headerlink" title="1、Hive表——内部表、外部表、分区表的创建"></a>1、Hive表——内部表、外部表、分区表的创建</h3><p>所谓内部表就是普通表，创建语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive6.jpg" alt="PIC6"></p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive7.jpg" alt="PIC7"></p>
<p>外部表(external table)的创建语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive8.jpg" alt="PIC8"></p>
<p>注意：最后一行写到的是目录dir，文件就不用写了，Hive表会自动到dir目录下读取所有的文件file<br><strong>我在实际的操作过程当中发现，location关联到的目录下面必须都是文件，不能含有其余的文件夹，不然读取数据的时候会报错。</strong> </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive9.jpg" alt="PIC9"></p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive10.jpg" alt="PIC10"></p>
<p><strong>内部表与外部表的区别：</strong> </p>
<ul>
<li>内部表在加载数据的过程中，实际数据会被移动到数据仓库目录中(hive.metastore.warehouse.dir),之后用户对数据的访问将会直接在数据仓库目录中完成；删除内部表时，内部表中的数据和元数据信息会被同时删除。 </li>
<li>外部表在加载数据的过程中，实际数据并不会被移动到数据仓库目录中，只是与外部表建立一个链接(相当于文件的快捷方式一样)；删除外部表时，仅删除该链接。 </li>
<li>补充：在工作中发现，对于外部表，即使hive中的表删除了，但是在HDFS中表的location仍然存在。 </li>
</ul>
<p>分区表的概念：指的是我们的数据可以分区，即按照某个字段将文件划分为不同的标准，分区表的创建是通过在创建表时启用partitioned by来实现的。</p>
<p>分区表的创建语法格式为：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive11.jpg" alt="PIC11"></p>
<p>注意：分区表在加载数据的过程中要指定分区字段，否则会报错，正确的加载方式如下： </p>
<p><code>load data local inpath ‘/usr/local/consumer.txt’ into table t1 partition (day=2) ;</code></p>
<p>其余的操作和内部表、外部表是一样的。 </p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive12.jpg" alt="PIC12"></p>
<h3 id="2、将数据文件加载-导入-到Hive表中"><a href="#2、将数据文件加载-导入-到Hive表中" class="headerlink" title="2、将数据文件加载(导入)到Hive表中"></a>2、将数据文件加载(导入)到Hive表中</h3><p>在Hive中创建完表之后，我们随后自然要向表中导入数据，但是在导入数据的时候和我们的传统数据库(MySql、Oracle)是不同的：Hive不支持一条一条的用insert语句进行插入操作，也不支持update的操作。Hive表中的数据是以load的方式，加载到建立好的表中。数据一旦导入，则不可修改。要么drop掉整个表，要么建立新的表，导入新的数据。 </p>
<p>导入数据的语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive13.jpg" alt="PIC13"></p>
<p>导入数据时要注意一下几点： </p>
<p>①local inpath表示从本地linux中向Hive表中导入数据，inpath表示从HDFS中向Hive表中导入数据 </p>
<p>②默认是向原Hive表中追加数据，overwrite表示覆盖表中的原数据进行导入 </p>
<p>③partition是分区表特有的，而且在导入数据数据时是必须添加的，否则会报错 </p>
<p>④load 操作只是单纯的复制/移动操作，将数据文件复制/移动到 Hive 表对应的位置,即Hive 在加载数据的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的表中</p>
<h2 id="（三）Hive与Hbase的区别"><a href="#（三）Hive与Hbase的区别" class="headerlink" title="（三）Hive与Hbase的区别"></a>（三）Hive与Hbase的区别</h2><p>其实从严格意义上讲，Hive与Hbase就不应该谈区别，谈区别的原因无非就是Hive与Hbase本身都涉及到了表的创建、向表中插入数据等等。所以我们希望找到Hive与Hbase的区别，但是为什么两者谈不上区别呢，原因如下： </p>
<ul>
<li>1、根据上文分析，Hive从某种程度上讲就是很多“SQL—MapReduce”框架的一个封装，即Hive就是MapReduce的一个封装，Hive的意义就是在业务分析中将用户容易编写、会写的Sql语言转换为复杂难写的MapReduce程序。 </li>
<li>2、Hbase可以认为是hdfs的一个包装。他的本质是数据存储，是个NoSql数据库；hbase部署于hdfs之上，并且克服了hdfs在随机读写方面的缺点。 </li>
</ul>
<p>因此若要问Hive与Hbase之前的区别，就相当于问HDFS与MapReduce之间的区别，而HDFS与MapReduce两者之间谈区别意义并不大。 </p>
<p>但是当我们非要谈Hbase与Hive的区别时，可以从以下几个方面进行讨论： </p>
<ul>
<li>Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。 </li>
<li>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。 </li>
<li>Hbase非常适合用来进行大数据的实时查询。Facebook用Hive进行消息和实时的分析。它也可以用来统计Facebook的连接数。 </li>
</ul>
<p>Hbase与Hive的区别就谈到此，同时Hive入门笔记也写到此处，如有问题欢迎留言。</p>
<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/a2011480169/article/details/51482799" target="_blank" rel="external">Hive架构以及应用介绍</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> architecture </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Deep Learning Flow for Video Recognition]]></title>
      <url>http://xiaqunfeng.cc/2018/09/17/dff/</url>
      <content type="html"><![CDATA[<p>目前唯一一个End to End的Video Detection方法。<br><a id="more"></a></p>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>深度卷积神经网络在图像识别任务上取得巨大成功。然而在视频任务上对单帧进行检测太慢。</p>
<p>因此，论文中提出深度特征流（Deep Feature Flow）框架用于快速精确的视频识别。该框架仅在稀疏关键帧上运行卷积网络的子网络，并通过流场（flow field）将关键帧的特征传递到其他帧。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-1.jpg" alt="1"></p>
<p>因为流场计算和特征传播比计算卷积特征快很多，所以可以显著提升速度。整个架构采用端到端的训练，识别精度显著提升。</p>
<p>论文声称是第一次在深度学习框架中联合训练流和视频识别任务。与单帧方法比，实现了巨大的提升（10X），精度稍有损失。</p>
<h2 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h2><p>1、图像识别</p>
<ul>
<li>目标检测：基于区域方法（R-CNN, Fast R-CNN, SPP-Net, Faster R-CNN, R-FCN）</li>
<li><p>语义分割：全卷积神经网络（FCN）</p>
</li>
<li><p>对每一帧都运用这些网络，计算开销太大。</p>
</li>
</ul>
<p>2、网络加速</p>
<ul>
<li>矩阵分解：将大的网络layers分解层多个小layers</li>
<li>量化网络权重</li>
</ul>
<p>3、光流</p>
<ul>
<li>光流主要针对小偏移量，目前一些针对大偏移和组合匹配的方法（DeepFlow和EpicFlow），但是都是手工设计。</li>
<li>FlowNet第一次应用CNN直接估计运动，取得了不错的结果。最近的金字塔网络简化了架构。</li>
<li>论文中开发光流用于加速一般的视频识别任务。</li>
</ul>
<p>4、视频识别中的开发时序信息</p>
<ul>
<li>T-CNN在视频的tubelets中融合时序和上下文信息。</li>
<li>密集3D CRF提出大范围的时空归一化进行语义视频分割。</li>
<li>STFCN考虑用于视频语义分割的空间-时间FCN。</li>
<li>上诉工作能够提升精度但同时极大的增加计算开销。</li>
<li>本论文方法旨在通过利用视频上的时间连贯性来减少计算量。</li>
</ul>
<p>5、缓慢特征分析</p>
<ul>
<li>在视频中，图像的高级语义特征一般比低级语义特征变化更慢，因此在连续视频帧上，深度特征变化的缓慢且连续。</li>
<li>该特点已经被用于视频特征学习的调整中。本文也可因此受益。</li>
</ul>
<p>6、Clockwork卷积网络</p>
<ul>
<li>该工作与本论文最接近，在某些视频帧上禁用网络中的某些层，并重复使用之前的特征。该方法减少了一些帧中一些层的计算（如1/3或2/3）。</li>
<li>本文的工作减少大部分帧的大部分层的计算（如9/10）。</li>
<li>Clockwork并没有考利用帧之间的关系，并简单地复制特征。它只重新编排现成网络中的推理计算，并未执行微调或重新训练。较小的速度提升却带来了较大的精度损失。</li>
<li>本文重新训练了一个两帧网络，其运动被认为是端到端的。在速度提升3倍的情况下仅带来很小的精度下降。</li>
</ul>
<h2 id="三、DFF（Deep-Feature-Flow）"><a href="#三、DFF（Deep-Feature-Flow）" class="headerlink" title="三、DFF（Deep Feature Flow）"></a>三、DFF（Deep Feature Flow）</h2><h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p>对于给定的前馈神经网络N ，I为图像输入，输出结果为y=N(I)</p>
<p>这里将N分解为两个连续的子网络:</p>
<ul>
<li>第一个子网络：$N<em>{feat}$，被称为特征网络，该网络是全卷积且输出一些中间特征图，$f=N</em>{feat}(I)$。</li>
<li>第二个子网络：$N<em>{task}$，被称为任务网络，具有特定的任务结构，并在特征图上执行识别任务，$y=N</em>{task}(f)$。</li>
</ul>
<p>连续的视频帧具有高度的相似性，且越深的特征层相似性越高，我们通过该相似性减少计算开销。具体的，$N<em>{feat}$ 仅运行在特定稀疏关键帧上，非关键帧 $I</em>{i}$ 的特征通过其之前的关键帧 $I_{k}$ 传播得到。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-2.jpg" alt="2"></p>
<p>$M<em>{i \rightarrow k}$ 是一个二维的流场，其通过一个流估计算法 F 得到。然后通过双线性缩放到与用于传播的特征图相同的大小。当前帧 i 的位置 p 通过流场得到其与关键帧 k 的位置偏差得到，偏差 $\delta p=M</em>{i \rightarrow k}(p)$。</p>
<p>因此特征扭曲可以通过双线性差值得到：</p>
<p>$f^c_i(p)=∑_qG(q,p+δp)f^c_k(q)$            (1)</p>
<p>c表示特征通道，q是特征图的所有空间位置，G(·,·)为双线性差值核，是二维的，因此将其分解为两个一维核：</p>
<p>$G(q,p+δp)=g(q_x,p_x+δp_x)⋅g(q_y,p_y+δp_y)$        (2)</p>
<p>$g(a,b)=max(0,1−|a−b|)$</p>
<p>空间扭曲可能由于流估计错误导致不准确。为了更好估计特征，其强度通过尺度场（scale field）进行调节。尺度场通过尺度函数 S 得到 $Si→k=S(I_k,I_i)$。最后，特征传播方程定义为：</p>
<p>$f_i=W(f<em>k,M</em>{i\rightarrow k},S_{i \rightarrow k})$        (3)</p>
<p>该函数对所有位置、所有通道的特征进行处理，并对特征乘以尺度因子。</p>
<p>该视频识别算法被称为深度特征流。F 流场函数是手工设计的低级别流，如SIFT-Flow，不需要训练，马上可用。尺度函数 S 的每个位置为1。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-3.jpg" alt="3"></p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>流函数最初用于获得低级图像像素的相关性，推理很快，但是对于识别任务不够准确，并且高级特征图的改变通常比像素慢。</p>
<p>为了对这些变量建模，这里提出使用一个CNN来估计流场和尺度场，这样所有的组件都能够端到端训练。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-4.jpg" alt="4"></p>
<p>使用SGD训练，在每个mini-batch，随机选择一对邻近帧，${I <em>k,I</em> i}, 0\le i-k \le 9$。</p>
<ul>
<li>前向传播时，特征网络 $N_{feat}$ 对关键帧图像 $I_k$ 计算得到特征图 $f_k$。</li>
<li>然后在帧  $I_k, I_i$ 上运行流网络 F，来计算流场和尺度场。当 i &gt; k时，根据公式（3）特征 $f_k$ 传播至 $f_i$，否则不传播。最后，任务网络，否则不传播。</li>
<li>最后，在特征图 $f<em>i$ 上应用任务网络 $N</em> {task}$ 生成结果，并产生损失值。反向传播损失到所以组件。可以发现，当 $i=k$ 时退化为每帧训练。</li>
</ul>
<p>流网络比特征网络快得多。</p>
<p>公式（3）中特征传播函数是无参且完全可微的，我们计算特征 $f_i$ 中关于特征 $f<em>k$ 的导数，尺度场 $S</em>{i\rightarrow j}$，流场 $M_{i\rightarrow j}$。前两个使用链式法则容易计算。对于后一个，导数为：</p>
<p>$\frac{\partial f<em>i^c(p)}{\partial M</em>{i\rightarrow j}}=S^c_{i\rightarrow j}(p)\sum<em>q \frac{\partial G(q,p+\delta p)}{\partial \delta p}f </em> k^c(q)$        （4） </p>
<p>Pre-frame训练方法只能使用已标注的帧，而DFF可以使用所有帧，只要帧 $I_i$是已标注的。 </p>
<h3 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h3><p>非关键帧计算开销与每帧计算开销的比例：</p>
<p>$r=\frac{O(F)+O(S)+O(W)+O(N<em>{task})}{O(N</em>{feat})+O(N _ {task})}$        （5）</p>
<p>$N<em>{task}$ 的复杂度通常很小，$N</em>{feat}$和 F 的复杂度较高：</p>
<p>$O(N<em>{task})  &lt;&lt; O(N</em>{teat})$</p>
<p>$O(N_{task})  &lt;&lt; O(F)$</p>
<p>因为W和S非常简单</p>
<p>$O(W) &lt;&lt; O(F)$</p>
<p>$O(S) &lt;&lt; O(F)$</p>
<p>所以公式（5）中的比率：</p>
<p>$r ≈ \frac{O(F)}{O(N_feat)}$         (6)</p>
<p>因此复杂度比例由流网络和特征网络决定。</p>
<p>另外，速度还跟关键帧的稀疏程度相关，如果定义每 $l$ 连续帧选一个关键帧，则加速因子为：</p>
<p>$s = \frac{l}{1+(l−1)∗r}$        （7）</p>
<h3 id="关键帧安排"><a href="#关键帧安排" class="headerlink" title="关键帧安排"></a>关键帧安排</h3><p>在本文中，采用的是简单的固定关键帧的安排，关键帧的应用区间 $l$ 固定，比较容易实施和调整。</p>
<p>然而根据图像内容的变化可能变化的 $l$ 能够实现更好的精度和速度的权衡。理想情况下，关键帧应该是图像内容具有显著变化时。</p>
<p>如何设计高效和调整关键帧的安排是后续需要改进的工作。不同的视频任务可能有不同的行为和需求。从数据中学习自适应关键帧的是一个更有吸引力的选择。</p>
<h2 id="四、网络架构"><a href="#四、网络架构" class="headerlink" title="四、网络架构"></a>四、网络架构</h2><p>1、流网络</p>
<p>我们采用基于CNN的 FlowNet 作为默认方法，并设计了两个低复杂度变体 </p>
<ul>
<li>FlowNet Half，每层减少一半的卷积核，复杂度为1/4</li>
<li>Inception 结构的FlowNet Inception，复杂度减少为1/8</li>
</ul>
<p>三个网络都在相同的数据集上预训练，输出的stride为4。输入图像缩小一半，因此流网络的输出是原图的1/8。</p>
<p>特征图的stride是16，使用双线性差值将流场降采样，双线性差值为网络的中的非参数层，且可微。</p>
<p>2、特征网络</p>
<ul>
<li>使用ResNet作为特征网络，ResNet-50和ResNet-101默认为ImageNet分类预训练模型，丢弃最后一层1000路分类层，特征stride从32减少为16得到分辨率更高的特征图。</li>
<li>后面接DeepLab用于语义分割和R-FCN用于物体检测。</li>
<li>conv5层的第一个block，其stride从2变为1。holing算法应用于 conv5 中所有 3*3 卷积核，以保持视野（dilation=2）。随机初始化的3×3卷积被附加到 conv5 以将特征通道维度减小到1024，holing算法也被应用（dilation=6）。该1024维的特征图作为后续任务的中间特征图。</li>
</ul>
<p>3、语义分割</p>
<ul>
<li>在中间特征图上应用随机初始化的1×1卷积层以产生（C + 1）得分图，其中C是类别的数量，1是用于背景类别。</li>
<li>之后跟一个softmax层输出每个像素的概率。因此任务网络仅有一个可学习的权重层，整体的网络类似于具有大视野的DeepLab。</li>
</ul>
<p>4、物体检测</p>
<p>采用R-FCN。对于中间特征图，两个全卷积网络分别应用于前512维特征和后512维特征，分别用于区域推荐（region proposal）任务和检测任务。</p>
<p>区域推荐分支，使用RPN。使用 n=9 个anchors，两个并排的1x1的卷积层得到2n维的物体得分和4n的回归值。对每个图像应用NMS（0.7）后得到300个ROI。</p>
<p>检测分支，两个并排的1x1卷积层输出位置敏感的得分图和bbox回归图。他们的维度是 $(C+1)k^2$ 和 $4k^2$，k是检测器/回归器数量。最后使用NMS（0.3）得到结果。</p>
<h2 id="五、实验"><a href="#五、实验" class="headerlink" title="五、实验"></a>五、实验</h2><p>在两个数据集上进行评测</p>
<ul>
<li>Cityscapes：用于语义分割</li>
<li>ImageNet VID：用于物体检测</li>
</ul>
<p>方法和结果详见原论文。</p>
<p>效果：<a href="https://www.youtube.com/watch?v=J0rMHE6ehGw" target="_blank" rel="external">https://www.youtube.com/watch?v=J0rMHE6ehGw</a></p>
<h2 id="六、未来工作"><a href="#六、未来工作" class="headerlink" title="六、未来工作"></a>六、未来工作</h2><ul>
<li>联合学习对于流场质量的影响，当前由于缺少gt数据无法评估。</li>
<li>目前的光流工作受限于合成数据或小的真实数据，对深度学习来说还不够。</li>
<li>流场估计和关键帧安排的改进可以使本文工作受益。</li>
<li>本文采用FlowNet主要原因是可选择的方法很少。设计更快更精确的流场网络在未来值得研究。</li>
<li>对于关键帧的安排，好的方法能够同时显著提升精度和速度。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chinese Whispers]]></title>
      <url>http://xiaqunfeng.cc/2018/08/14/Chinese-Whispers/</url>
      <content type="html"><![CDATA[<p>学习一下适用于大规模人脸的无监督聚类方法。不需要指定聚类个数。<br><a id="more"></a></p>
<h3 id="论文中CW描述"><a href="#论文中CW描述" class="headerlink" title="论文中CW描述"></a>论文中CW描述</h3><p>CW是一种非常基础的，但有效的算法，用来分割加权的无向图节点。它来源于同名的儿童游戏，孩子们在哪里低声互相耳语？游戏的目标是通过几个带干扰的通道传递后，将原来的信息衍生成一些更有趣的信息。CW算法的目标就是查找传播相同信息到相邻节点的节点组。它可以被看做一个基于代理的社交网络的模拟。</p>
<p>该算法的原理如下：</p>
<ul>
<li>首先，所有的节点都分成不同的类。</li>
<li>然后对节点进行少量的迭代处理，并继承它邻近节点中最大的类别，即对当前节点的边权重值最大的节点所在的类。如果有多个最大的类别，则随机选择一个。</li>
<li>同一类的区域在迭代过程中趋于稳定，直到到达另一个类的稳定区域边界为止。</li>
</ul>
<h3 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h3><p>构建无向图：</p>
<ul>
<li>将每个人脸做为无向图中的一个节点，人脸之间的相似度，作为节点之间的边</li>
<li>设定阈值threshold，当相似度超过threshold，将两个节点相连形成关联边，权重为相似度</li>
<li>如果人脸之间的相似度小于设定的阈值，那么这两个人脸对应的节点之间就没有边</li>
</ul>
<p>初始化：</p>
<p>将每个人脸都赋予一个id，该id作为该人脸的类别。初始化时,每个人脸都是一个类别。</p>
<p>迭代：</p>
<ul>
<li><p>随机选取某个节点，对该节点的所有邻居依次进行如下处理:</p>
</li>
<li><p>就将所有邻居中权重最大的节点对应的类做为该节点的类别，完成对该节点的类别更新。</p>
</li>
<li><p>如果有两个邻居属于同一个类，那么就将同一个类下的邻居权重累加。最后，比较该节点下的所有邻居节点所属的类别的累加权重，取权重最大的类别作为当前节点的类别。</p>
</li>
<li><p>当所有的节点都完成后，一次迭代完成。</p>
</li>
<li><p>重复迭代步骤，直到达到迭代次数</p>
</li>
</ul>
<blockquote>
<p>该算法的结果主要依赖于模型的效果和阈值的选择,在迭代时,将相似度作为权重.</p>
</blockquote>
<p>python代码实现参考: <a href="https://blog.csdn.net/shubao0071/article/details/79086096" target="_blank" rel="external">Chinese-whisper:一种简洁的分类方法</a></p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git rebase]]></title>
      <url>http://xiaqunfeng.cc/2018/07/11/git-rebase/</url>
      <content type="html"><![CDATA[<p>三种使用场景：一是合并多个commit；二是基于不同branch在执行merge时的rebase；三是拆分commit。</p>
<a id="more"></a>
<h2 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h2><p>使用场景：</p>
<p>在开发一个功能时，由于种种原因提交了多个临时和失误的 commit，而这些 commit 拼接起来才是一个完整的任务。为了避免过多 commit 造成的版本控制混乱，通常需要将这些 commit 合并成一个。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>选择了一个项目，查看log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">▶ git log</div><div class="line">commit 532c6e1481e78ba0e27c56f4492a7e8d3cc36597</div><div class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line">Date:   Tue Oct 10 13:35:28 2017 -0700</div><div class="line"></div><div class="line">    hm......</div><div class="line"></div><div class="line">commit fbd48ab606dd91f076eaa68588f285c1d5f436fb</div><div class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line">Date:   Wed Oct 4 16:51:41 2017 -0700</div><div class="line"></div><div class="line">    grouped convolutions :snake: :snake: :snake:</div><div class="line"></div><div class="line">commit 62b781af4d01fc5f074407590cf556b36c70e837</div><div class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line">Date:   Mon Oct 2 15:17:48 2017 -0700</div><div class="line"></div><div class="line">    resnet that works</div><div class="line">...</div></pre></td></tr></table></figure>
<p>需要将 <code>532c6e</code> 和 <code>fbd48a</code> 合并成一个commit，操作如下：</p>
<p>1、执行rebase命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i 62b781</div></pre></td></tr></table></figure>
<p>其中，-i 的参数是不需要合并的 commit 的 hash 值，也就是它们前一条 commit。接着就进入 vi 编辑模式，信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">pick fbd48ab grouped convolutions :snake: :snake: :snake:</div><div class="line">pick 532c6e1 hm......</div><div class="line"></div><div class="line"># Rebase 62b781a..532c6e1 onto 62b781a (2 command(s))</div><div class="line">#</div><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># r, reword = use commit, but edit the commit message</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</div><div class="line"># x, exec = run command (the rest of the line) using shell</div><div class="line"># d, drop = remove commit</div><div class="line">#</div><div class="line"># These lines can be re-ordered; they are executed from top to bottom.</div><div class="line">#</div><div class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</div><div class="line">#</div><div class="line"># However, if you remove everything, the rebase will be aborted.</div><div class="line">#</div><div class="line"># Note that empty commits are commented out</div></pre></td></tr></table></figure>
<p>未注释部分格式：<code>Command commit-hash commit-content</code></p>
<p>注释部分：指令使用说明</p>
<ul>
<li><strong>pick：正常选中</strong></li>
<li>reword：选中，并且修改提交信息</li>
<li>edit：选中，rebase时会暂停，允许你修改这个commit</li>
<li><strong>squash：选中，会将当前commit与上一个commit合并</strong></li>
<li><strong>fixup：与squash相同，但不会保存当前commit的提交信息</strong></li>
<li>exec：执行其他shell命令</li>
<li>drop：移除commit</li>
</ul>
<p>2、将第二个commit前的command修改为 <code>squash</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pick fbd48ab grouped convolutions :snake: :snake: :snake:</div><div class="line">squash 532c6e1 hm......</div></pre></td></tr></table></figure>
<p>保存退出（:x）</p>
<p>3、这时会进入 commit message 的编辑页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># This is a combination of 2 commits.</div><div class="line"># The first commit&apos;s message is:</div><div class="line"></div><div class="line">grouped convolutions :snake: :snake: :snake:</div><div class="line"></div><div class="line"># This is the 2nd commit message:</div><div class="line"></div><div class="line">hm......</div><div class="line"></div><div class="line"># Please enter the commit message for your changes. Lines starting</div><div class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</div><div class="line">#</div><div class="line"># Author:    Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line"># Date:      Wed Oct 4 16:51:41 2017 -0700</div><div class="line">#</div><div class="line"># interactive rebase in progress; onto 62b781a</div><div class="line"># Last commands done (2 commands done):</div><div class="line">#    pick fbd48ab grouped convolutions :snake: :snake: :snake:</div><div class="line">#    squash 532c6e1 hm......</div><div class="line"># No commands remaining.</div><div class="line"># You are currently editing a commit while rebasing branch &apos;master&apos; on &apos;62b781a&apos;.</div><div class="line">#</div><div class="line"># Changes to be committed:</div><div class="line">#       modified:   cfg/darknet.cfg</div><div class="line">#       modified:   cfg/tiny.cfg</div><div class="line">...</div></pre></td></tr></table></figure>
<p>将两次 commit message 修改成新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># This is a combination of 2 commits.</div><div class="line">This is a combination of 2 commmits by xiaqunfeng.</div><div class="line"></div><div class="line"># Please enter the commit message for your changes. Lines starting</div><div class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</div><div class="line">...</div></pre></td></tr></table></figure>
<p>4、保存退出</p>
<p>显示信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[detached HEAD 2863a92] This is a combination of 2 commmits by xiaqunfeng.</div><div class="line"> Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line"> Date: Wed Oct 4 16:51:41 2017 -0700</div><div class="line"> 16 files changed, 251 insertions(+), 175 deletions(-)</div><div class="line">Successfully rebased and updated refs/heads/master.</div></pre></td></tr></table></figure>
<p>5、再次查看 git log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">commit 2863a92ea8faef9d2172f8cee343e11cc22d5670</div><div class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line">Date:   Wed Oct 4 16:51:41 2017 -0700</div><div class="line"></div><div class="line">    This is a combination of 2 commmits by xiaqunfeng.</div><div class="line"></div><div class="line">commit 62b781af4d01fc5f074407590cf556b36c70e837</div><div class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</div><div class="line">Date:   Mon Oct 2 15:17:48 2017 -0700</div><div class="line"></div><div class="line">    resnet that works</div></pre></td></tr></table></figure>
<p>发现前两个commit已经被合并了。</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>如果还想将这两个commit合并，这时候前面没有其他commit了</p>
<p>使用命令，提取最近2笔commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i HEAD~2</div></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick 62b781a resnet that works</div><div class="line">pick 2863a92 This is a combination of 2 commmits by xiaqunfeng.</div><div class="line">...</div></pre></td></tr></table></figure>
<p>其余操作步骤同上。</p>
<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>继续实践，rebase最近3个commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i HEAD~3</div></pre></td></tr></table></figure>
<p>进入编辑界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pick a4ae313 FIX OPENCV :snake:</div><div class="line">pick 1b001a7 :bug: :bug: :bug:</div><div class="line">pick ce8cf62 resnet that works</div><div class="line"></div><div class="line"># Rebase 1e72980..ce8cf62 onto 1e72980 (3 command(s))</div></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick a4ae313 FIX OPENCV :snake:</div><div class="line">squash 1b001a7 :bug: :bug: :bug:</div><div class="line">fixup ce8cf62 resnet that works</div></pre></td></tr></table></figure>
<p>继续进入vim编辑界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># This is a combination of 3 commits.</div><div class="line"># The first commit&apos;s message is:</div><div class="line">FIX OPENCV :snake:</div><div class="line"></div><div class="line"># This is the 2nd commit message:</div><div class="line"></div><div class="line">:bug: :bug: :bug:</div><div class="line"></div><div class="line"># The 3rd commit message will be skipped:</div><div class="line"></div><div class="line">#       resnet that works</div></pre></td></tr></table></figure>
<p>修改方法和之前相同。</p>
<p>可以看出，fixup就相当于直接将该commit丢弃掉了。</p>
<blockquote>
<p>如果有两个commit，你想使用第一个作为最终的commit，那么就只需要将第二个commit直接fixup就好了，不需要squash，这样还省了一次编辑合并后的commit的时间。</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、如果你的 vim 配置了<code>YouCompleteMe</code>，会提示你如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">YouCompleteMe unavailable: requires Vim 7.4.1578+.</div></pre></td></tr></table></figure>
<p>导致你进不去vi编辑界面。</p>
<p>解决方法</p>
<p>将git默认的编辑器从vi改为vim，执行如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.editor /usr/bin/vim</div></pre></td></tr></table></figure>
<p>2、push的时候会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hint: Updates were rejected because the tip of your current branch is behind</div><div class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</div><div class="line">hint: &apos;git pull ...&apos;) before pushing again.</div><div class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</div></pre></td></tr></table></figure>
<p>解决方法：加 <code>-f</code> 进行push。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1、关于分支的rebase，参考<a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="external">rebase</a>。</p>
<p>2、修改最近一次commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -amend</div></pre></td></tr></table></figure>
<p>3、当然，还有拆分提交的功能，可以自行搜之。不过强烈不推荐，特别是代码两次提交代码耦合比较紧密的情况，很难拆分。</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文本工具]]></title>
      <url>http://xiaqunfeng.cc/2018/05/25/txt-tools/</url>
      <content type="html"><![CDATA[<p>一些处理文本的工具总结，记录之。<br><a id="more"></a></p>
<p>系统环境：Mac</p>
<h2 id="shuf"><a href="#shuf" class="headerlink" title="shuf"></a>shuf</h2><p>功能：将输入行的随机排列写入标准输出</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">▶ brew install coreutils</div><div class="line">...</div><div class="line">==&gt; make install</div><div class="line">==&gt; Caveats</div><div class="line">All commands have been installed with the prefix &apos;g&apos;.</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注意上面这一行说明，命令前加了一个前缀 <code>g</code>，即<code>gshuf</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">▶ gshuf --help</div><div class="line">Usage: gshuf [OPTION]... [FILE]</div><div class="line">  or:  gshuf -e [OPTION]... [ARG]...</div><div class="line">  or:  gshuf -i LO-HI [OPTION]...</div><div class="line">Write a random permutation of the input lines to standard output.</div><div class="line"></div><div class="line">With no FILE, or when FILE is -, read standard input.</div><div class="line"></div><div class="line">Mandatory arguments to long options are mandatory for short options too.</div><div class="line">  -e, --echo                treat each ARG as an input line</div><div class="line">  -i, --input-range=LO-HI   treat each number LO through HI as an input line</div><div class="line">  -n, --head-count=COUNT    output at most COUNT lines</div><div class="line">  -o, --output=FILE         write result to FILE instead of standard output</div><div class="line">      --random-source=FILE  get random bytes from FILE</div><div class="line">  -r, --repeat              output lines can be repeated</div><div class="line">  -z, --zero-terminated     line delimiter is NUL, not newline</div><div class="line">      --help     display this help and exit</div><div class="line">      --version  output version information and exit</div></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">▶ cat test.txt</div><div class="line">aaa</div><div class="line">bbb</div><div class="line">ccc</div><div class="line">ddd</div><div class="line">eeeee</div><div class="line">ff</div></pre></td></tr></table></figure>
<p>1、文本行乱序</p>
<p>将原文件里的行随机打乱输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">▶ gshuf test.txt</div><div class="line">bbb</div><div class="line">ccc</div><div class="line">ddd</div><div class="line">aaa</div><div class="line">eeeee</div><div class="line">ff</div></pre></td></tr></table></figure>
<p>2、随机抽取N行数据</p>
<p>使用参数 <code>-n</code>，指定随机抽取的行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▶ gshuf -n 3 test.txt</div><div class="line">eeeee</div><div class="line">bbb</div><div class="line">aaa</div></pre></td></tr></table></figure>
<p>以上两种都可以将输出指定存储到输出文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ gshuf test.txt -o test-random.txt</div></pre></td></tr></table></figure>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>功能：分割文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▶ split --help</div><div class="line">split: illegal option -- -</div><div class="line">usage: split [-a sufflen] [-b byte_count] [-l line_count] [-p pattern]</div><div class="line">             [file [prefix]]</div></pre></td></tr></table></figure>
<p>参数解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-a, --suffix-length=N   使用长度为 N 的后缀 (默认 2)，是字母后缀</div><div class="line">-b, --bytes=SIZE        设置输出文件的大小。支持单位：m,k</div><div class="line">-l, --lines=NUMBER      设备输出文件的行数</div><div class="line">-d, --numeric-suffixes  使用数字后缀代替字母(mac上不可用)</div><div class="line">file, prifix			指定分割后文件的前缀</div></pre></td></tr></table></figure>
<p>可以指定行数、文件大小分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ split -a 3 -l 100 test.json split-</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">split-aaa split-aab</div></pre></td></tr></table></figure>
<h3 id="找出文件的相同与不同"><a href="#找出文件的相同与不同" class="headerlink" title="找出文件的相同与不同"></a>找出文件的相同与不同</h3><p>有时候会遇到这样的需求，就是从一个文件中随机取一部分数据，然后又要取一部分数据，那么怎样保证数据是否有重复，这就需要比较。</p>
<p>有两个文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat test1.txt</div><div class="line">a</div><div class="line">bb</div><div class="line">ccc</div><div class="line">dddd</div><div class="line">eeeee</div><div class="line"># cat test2.txt</div><div class="line">111111</div><div class="line">33333</div><div class="line">8888</div><div class="line">ccc</div><div class="line">777777777</div><div class="line">dkahkah</div><div class="line">a</div></pre></td></tr></table></figure>
<p>1、列出两个文件中不同的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># cat test1.txt test2.txt | sort | uniq -u | sort -n</div><div class="line">bb</div><div class="line">dddd</div><div class="line">dkahkah</div><div class="line">eeeee</div><div class="line">8888</div><div class="line">33333</div><div class="line">111111</div><div class="line">777777777</div></pre></td></tr></table></figure>
<blockquote>
<p>uniq -u：仅显示出一次的行列</p>
</blockquote>
<p>2、列出两个文件中相同的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># grep -f test1.txt test2.txt</div><div class="line">ccc</div><div class="line">dkahkah</div><div class="line">a</div></pre></td></tr></table></figure>
<blockquote>
<p>这里发现第二行不对，以为此时是拿‘a’去匹配的，如果每一行都没有这么短的字符，那没什么问题</p>
</blockquote>
<p>查看<a href="http://man.linuxde.net/grep" target="_blank" rel="external">grep</a>的用法：</p>
<ul>
<li>-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</li>
<li>-v 反转查找。</li>
</ul>
<p>这里将test1.txt和test2.txt中的‘a’都改为‘aa’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># grep -f test1.txt test2.txt</div><div class="line">ccc</div><div class="line">aa</div></pre></td></tr></table></figure>
<p>3、列出文件 test2.txt 中有，test1.txt中没有的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># grep -vf test1.txt test2.txt</div><div class="line">111111</div><div class="line">33333</div><div class="line">8888</div><div class="line">777777777</div><div class="line">dkahkah</div></pre></td></tr></table></figure>
<p>注：还有一个命令<a href="http://man.linuxde.net/comm" target="_blank" rel="external">comm</a>也可以用来比较两个文件的交集、差集、求差。但是要求两个文件都是已排序过的。所以也可以sort后用该命令来实现上面的想法。</p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;s/oldstring/newstring/g&apos; full-path-file</div></pre></td></tr></table></figure>
<ul>
<li>如果字符串中含反斜杠<code>/</code>，则使用冒号<code>:</code>作为分隔符。如果在shell脚本中替换字符串是变量，需要使用双引号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NEW_STRING=&quot;CCC/DDD&quot;</div><div class="line">sed -i &quot;s:ccc/ddd:$&#123;NEW_STRING&#125;:&quot; test-sed.txt</div></pre></td></tr></table></figure>
<ul>
<li><p>如果字符串中同时含有反斜杠<code>/</code>和冒号<code>:</code>，如<code>http://xxx</code>则可使用井号<code>#</code>作为分割符。</p>
</li>
<li><p>如果字符串中含有引号，需要转义，使用反斜杠“\”，比如替换<code>&quot;&#39;&#39;div</code>，如果需要将它替换成<code>‘div</code>，可以使用<code>sed -i s#\&quot;\&#39;\&#39;#\&#39;#g</code>。</p>
</li>
</ul>
<h3 id="批量替换多个文件的字符串"><a href="#批量替换多个文件的字符串" class="headerlink" title="批量替换多个文件的字符串"></a>批量替换多个文件的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ./* 表示当前目录</div><div class="line">grep “oldString” -rl ./* | xargs sed -i ‘s/oldString/newString/g’</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># /path 表示指定的目录</div><div class="line">sed -i &apos;s/oldString/newString/g&apos; `grep “oldString” -rl /path`</div></pre></td></tr></table></figure>
<h3 id="删除匹配行"><a href="#删除匹配行" class="headerlink" title="删除匹配行"></a>删除匹配行</h3><ul>
<li>删除开头为a的匹配行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;/^a.*/d&apos; tmp.txt</div></pre></td></tr></table></figure>
<ul>
<li>删除开头为非a的匹配行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;/^a.*/!d&apos; tmp.txt</div></pre></td></tr></table></figure>
<h3 id="添加字符串"><a href="#添加字符串" class="headerlink" title="添加字符串"></a>添加字符串</h3><ul>
<li>sed在行首添加字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed ‘s/^/string/&apos;  filename &gt; output</div></pre></td></tr></table></figure>
<ul>
<li>sed在行尾添加字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed ‘s/$/string/&apos; filename &gt; output</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，写入原文件要加 -i</p>
</blockquote>
<h3 id="替换换行符"><a href="#替换换行符" class="headerlink" title="替换换行符"></a>替换换行符</h3><ul>
<li>linux下将字符串string替换成换行符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &quot;s/string/\n/g&quot;</div></pre></td></tr></table></figure>
<ul>
<li>mac下匹配换行符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed －i &apos;&apos; &apos;s/string/&lt;回车&gt;/g&apos; filename</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：mac下和linux不同，不能简单的写<code>\n</code>，&lt;回车&gt; 需要通过 ctrl + v，然后按回车键 按出，按出来长这样 <code>^M</code></p>
</blockquote>
<h3 id="删除行首行尾的空格"><a href="#删除行首行尾的空格" class="headerlink" title="删除行首行尾的空格"></a>删除行首行尾的空格</h3><p>删除行首空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;s/[ \t]*$//g&apos; file.txt</div></pre></td></tr></table></figure>
<p>删除行尾空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;s/^[ \t]*//g&apos; file.txt</div></pre></td></tr></table></figure>
<p>合并两个命令一次性去除行首、行末的空格和tab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed  -e &apos;s/^[ \t]*//g’ -e ‘s/[ \t]*$//g&apos; file.txt</div></pre></td></tr></table></figure>
<blockquote>
<p>sed在处理字符串的时候并不对源文件进行直接处理，先创建一个buffer，但是加g表示对原buffer进行替换</p>
<p>-e 用于多个匹配</p>
</blockquote>
<h3 id="打印匹配行"><a href="#打印匹配行" class="headerlink" title="打印匹配行"></a>打印匹配行</h3><p>命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># sed -n -e &apos;/string/p&apos; file.txt</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">▶ cat 11.txt</div><div class="line">myddddd</div><div class="line">dddddddd</div><div class="line">ddddmyddddd</div><div class="line">dddd</div><div class="line">▶ sed -e &apos;/my/p&apos; 11.txt</div><div class="line">myddddd</div><div class="line">myddddd</div><div class="line">dddddddd</div><div class="line">ddddmyddddd</div><div class="line">ddddmyddddd</div><div class="line">dddd</div><div class="line">▶ sed -n -e &apos;/my/p&apos; 11.txt</div><div class="line">myddddd</div><div class="line">ddddmyddddd</div></pre></td></tr></table></figure>
<blockquote>
<p>-n表示只输出匹配后的行，不加-n默认输出所有的行，如果匹配到，则匹配行再输出一遍</p>
</blockquote>
<h3 id="mac和linux下sed-i的区别"><a href="#mac和linux下sed-i的区别" class="headerlink" title="mac和linux下sed -i的区别"></a>mac和linux下<code>sed -i</code>的区别</h3><p>在mac上执行会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed: 1: command c expects \ followed by text</div></pre></td></tr></table></figure>
<p>而在centos和ubuntu上却没问题。</p>
<p>分别在mac和ubuntu/centos上使用命令<code>man sed</code>来查看命令参数<code>-i</code>的详细说明：</p>
<p>mac上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-i extension</div><div class="line">     Edit files in-place, saving backups with the specified extension.  If a zero-length extension is given, no backup will be saved.  It is not recommended to give a zero-length extension when in-place editing files, as you risk corruption or partial content in situations where disk space is exhausted, etc.</div></pre></td></tr></table></figure>
<p>替换之前是要求提供后缀进行备份的，当然也可以使用空字符串来取消备份。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 直接在file文件中替换</div><div class="line">sed -i &apos;&apos; &apos;s/oldstring/newstring/g&apos; file</div><div class="line"></div><div class="line"># 直接在file文件中替换，但同时备份原文件为 file_bak</div><div class="line">sed -i _bak &apos;s/oldstring/newstring/g&apos; file</div></pre></td></tr></table></figure>
<p>linux上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-i[SUFFIX], --in-place[=SUFFIX]</div><div class="line">      edit files in place (makes backup if SUFFIX supplied)</div></pre></td></tr></table></figure>
<p>默认不备份，如果提供后缀，则进行备份。</p>
<blockquote>
<p>注：也可在mac上通过安装gnu-sed来替代sed，和linux上sed表现一样</p>
<p>1.brew install gnu-sed –with-default-names</p>
<p>2.vim ~/.zshrc<br>export PATH=”/usr/local/opt/gnu-sed/libexec/gnubin:$PATH”</p>
<p>3.source ~/.zshrc </p>
<p>参考资料：<a href="https://stackoverflow.com/questions/30003570/how-to-use-gnu-sed-on-mac-os-x" target="_blank" rel="external">https://stackoverflow.com/questions/30003570/how-to-use-gnu-sed-on-mac-os-x</a></p>
</blockquote>
<h3 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h3><p>有时候需要一次替换多个模式，有两种方式，第一种是采用分号<code>;</code>，第二种是采用参数<code>-e</code>。</p>
<p>示例：第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That。</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,3s/my/your/g; 3,$s/This/That/g&apos; my.txt</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1,3s/my/your/g&apos; -e &apos;3,$s/This/That/g&apos; my.txt</div></pre></td></tr></table></figure>
<h3 id="a命令、i命令、c命令"><a href="#a命令、i命令、c命令" class="headerlink" title="a命令、i命令、c命令"></a>a命令、i命令、c命令</h3><p>a和i用来添加行：a命令就是append， i命令就是insert。c命令用来替换匹配行</p>
<p>1、<code>1i</code>表明，其要在第1行前插入一行（insert）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &quot;1 i hello, world&quot; my.txt</div></pre></td></tr></table></figure>
<p>2、<code>$a</code>表明，其要在最后一行后追加一行（append）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &quot;$ a goodbye&quot; my.txt</div></pre></td></tr></table></figure>
<p>3、匹配添加：<code>/fish/a</code>表明匹配到fish就在该行后追加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &quot;/fish/a xxxxxxxxxx&quot; my.txt</div></pre></td></tr></table></figure>
<p>4、c用法同a和i，只不过不是添加，是替换</p>
<blockquote>
<p>以上这几个在linux上通过，在mac上不同</p>
</blockquote>
<p>5、mac上追加示例</p>
<p>在第二行后追加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">▶ sed &apos;2 a\</div><div class="line">◀ xxx</div><div class="line">◀ &apos; my.txt</div><div class="line">This is my cat, my cat&apos;s name is betty</div><div class="line">This is my dog, my dog&apos;s name is frank</div><div class="line">xxx</div><div class="line">This is my fish, my fish&apos;s name is george</div><div class="line">This is my goat, my goat&apos;s name is adam</div></pre></td></tr></table></figure>
<p>匹配到my后追加<code>---</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">▶ sed &apos;/my/a\</div><div class="line">◀ ---</div><div class="line">◀ &apos; my.txt</div><div class="line">This is my cat, my cat&apos;s name is betty</div><div class="line">---</div><div class="line">This is my dog, my dog&apos;s name is frank</div><div class="line">---</div><div class="line">This is my fish, my fish&apos;s name is george</div><div class="line">---</div><div class="line">This is my goat, my goat&apos;s name is adam</div><div class="line">---</div></pre></td></tr></table></figure>
<h3 id="命令行嵌套"><a href="#命令行嵌套" class="headerlink" title="命令行嵌套"></a>命令行嵌套</h3><p>1、对3行到第6行，匹配到<code>This</code>则删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;3,6 &#123;/This/d&#125;&apos; test.txt</div></pre></td></tr></table></figure>
<p>2、对3行到第6行，匹配<code>This</code>成功后，再匹配<code>fish</code>，成功后执行d命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;3,6 &#123;/This/&#123;/fish/d&#125;&#125;&apos; test.txt</div></pre></td></tr></table></figure>
<p>3、从第一行到最后一行，如果匹配到<code>This</code>，则删除之；如果前面有空格，则去除空格（这里是多个匹配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed &apos;1,$&#123;/This/d;s/^ *//g&#125;&apos; test.txt</div></pre></td></tr></table></figure>
<blockquote>
<p>以上这几个在mac上还是有点问题，linux通过</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1、文本合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ cat 1.txt 2.txt 3.txt &gt; merge.txt</div></pre></td></tr></table></figure>
<p>2、批量文文件添加前后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ for i in split-*; do mv $i “pre-”$i&quot;.json&quot;; done</div></pre></td></tr></table></figure>
<p>3、TO BE ADD</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[KCF跟踪算法]]></title>
      <url>http://xiaqunfeng.cc/2018/05/09/kcf-tracking/</url>
      <content type="html"><![CDATA[<p>没有看论文原文及复杂的公式推理，查阅了一些KCF的资料，了解KCF算法的原理及优缺点，记录之。<br><a id="more"></a></p>
<p>KCF是João F. Henriques的论文High-Speed Tracking with Kernelized Correlation Filters提出的一种目标跟踪算法。算法主页<a href="http://www.robots.ox.ac.uk/~joao/circulant/index.html" target="_blank" rel="external">KCF</a>。</p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>目前跟踪的主流思想还是基于 tracking by detection，而训练样本的选择基本上是以目标中心提取正样本，然后基于周围的图像提取负样本。大部分算法都是采用非正既负的方法来标记训练样本，即正样本标签为1，负样本为0。这种标记方法有一个问题，就是不能很好的反应每个负样本的权重，即对离中心目标远的样本和离中心目标近的样本同样对待。所以有算法提出使用连续的标签进行标记样本，即根据样本中心离目标远近分别赋值 [0,1] 范围的数。离目标越近，值越趋近于1，越远越趋向于0。KCF通过使用 [0,1] 范围的值作为样本的回归值，从而给不同偏移下得到的样本不同的权重。</p>
<p>KCF是一种鉴别式追踪方法，这类方法一般都是在追踪过程中训练一个目标检测器，使用目标检测器去检测下一帧预测位置是否是目标，然后再使用新检测结果去更新训练集进而更新目标检测器。而在训练目标检测器时一般选取目标区域为正样本，目标的周围区域为负样本，当然越靠近目标的区域为正样本的可能性越大。</p>
<p>KCF跟踪算法是目标跟踪阶段中的<strong>目标搜索</strong>部分，因此目标特征表达可以有很多种选择，作者在论文用的是HOG，还有一些学者用了CNN之类的。</p>
<p>算法中使用轮转矩阵对样本进行采集，把图像向上、向下分别移动不同的像素得到新的样本图像，这就是循环之后的样本，直接增加了样本的数量，然后用这些样本去训练一个判别分类器，判断跟踪到的是目标还是周围的背景信息。</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>相关滤波法，就是根据当前帧的信息和之前帧的信息训练出一个相关滤波器，然后与新输入的帧进行相关性计算，得到的置信图就是预测的跟踪结果，得分最高的那个点（或者块）就是最可能的跟踪结果。</p>
<p>KCF，由目标区域形成循环矩阵，再利用循环矩阵在傅立叶空间可对角化等一些性质，通过岭回归得到通用的预测公式。该预测公式没有矩阵求逆的计算，大大减少的计算量。这归功于作者巧妙地将循环矩阵在傅立叶空间的性质与目标跟踪时循环采样相结合。</p>
<p>KCF的论文中分别实验了三种情形的岭回归：普通线性岭回归、多项式岭回归、核空间下的岭回归。前两种不必多说，最后一种核空间，大家可以回忆一下SVM将低维空间映射到高维空间的方法，可以将线性不可分的样本变得线性可分。当然在KCF里由于要利用循环矩阵的性质，所以这里的核矩阵是循环矩阵（必为方阵）。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>使用目标周围区域的循环矩阵采集正负样本，利用脊回归训练目标检测器，并成功的利用循环矩阵在傅里叶空间可对角化的性质将矩阵的运算转化为向量的Hadamad积，即元素的点乘，大大降低了运算量，提高了运算速度，使算法满足实时性要求。</li>
<li>将线性空间的脊回归通过核函数映射到非线性空间，在非线性空间通过求解一个对偶问题和某些常见的约束，同样的可以使用循环矩阵傅里叶空间对角化简化计算。</li>
<li>给出了一种将多通道数据融入该算法的途径。把以前只能用单通道的灰度特征改进为现在可以使用多通道的HOG特征或者其他特征。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>对特征图像进行cosine window加权，这主要是为了减轻由于边界移位导致图像不光滑。</li>
<li>padding的size是目标框的2.5倍，肯定要使用padding窗口，要不然移位一次目标就被分解重组合了。。。效果能好哪去。。</li>
<li>对于标签使用了高斯加权</li>
<li>对<img src="https://images2015.cnblogs.com/blog/1027162/201609/1027162-20160930215553266-1812662820.png" alt="img">前后帧结果进行了线性插值，为了让他长记性，不至于模型剧烈变化。</li>
<li>速度很快</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、依赖循环矩阵，对于多尺度的目标跟踪效果并不理想。当然可以通过设置多个size，在每个size上进行KCF运算，但这样的话很难确定应预先设置多少size，什么样的size，而且对size的遍历必将影响算法的速度。</p>
<p>2、对目标快速变形（假设用的是HOG特征）或颜色快速变化（假设用的是颜色特征）不鲁棒</p>
<p>这个好理解，毕竟HOG描述的就是形状信息，变化得太快必然会导致效果变差</p>
<p>3、对物体快速运动或者低帧率视频不太鲁棒。这两种情况都是意味着在跟踪过程中下一帧图像中目标得位置偏离search window中心太远，要么靠近边缘，要么出去一半，要么全出去，我们是给样本加了余弦窗的，也就是说目标位置靠近边缘会由于余弦窗的存在损失了部分目标信息，更不用说那些目标超出search window一半或者全超出去的情况了，这也就是CF类算法中的边界效应（Boundary Effets）。</p>
<p>4、虽然算法中对模型系数<img src="https://images2015.cnblogs.com/blog/1027162/201609/1027162-20160930215554656-848218783.png" alt="img">进行线性插值，但是对于目标一旦被遮挡若干帧之后，可能模型就再也回不去了。因为模型已经完全被遮挡物污染掉了。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、为什么对目标进行padding？</p>
<p>答：不padding的话怎么学习背景信息呢？你刚循环移位就把目标给打散了。所以padding就是能让样本中含有特别需要学习的背景信息，而且可以尽量保证样本中目标的完整性。</p>
<p>2、文中的给padding后的图像加余弦窗的目的是什么？</p>
<p>答：如果不加余弦窗，我们可以想象，除了那个最原始样本，其他移动样本的边缘都比较突兀，也就说这些样本数据是比较差的，会干扰训练的结果。而如果加了余弦窗，由于图像边缘像素值就都接近0了，循环移位过程中只要目标保持完整那这个样本就是合理的，不过加了余弦窗也会弱化掉目标的背景信息，对训练也有一定的影响，不过总的来看应该是利大于弊。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="余弦窗"><a href="#余弦窗" class="headerlink" title="余弦窗"></a>余弦窗</h3><p>引入余弦窗就是为了解决边界效应，而解决的方法就是在目标原始像素上乘一个余弦窗使接近边缘的像素值接近于零。</p>
<p>参考资料：<a href="https://blog.csdn.net/LRYUS_HJL/article/details/73302521" target="_blank" rel="external">相关滤波里余弦窗作用</a></p>
<h3 id="循环矩阵"><a href="#循环矩阵" class="headerlink" title="循环矩阵"></a>循环矩阵</h3><p><strong>循环矩阵</strong>是一种特殊形式的 <a href="https://zh.wikipedia.org/wiki/Toeplitz%E7%9F%A9%E9%99%A3" target="_blank" rel="external">Toeplitz矩阵</a>，它的行向量的每个元素都是前一个行向量各元素依次右移一个位置得到的结果。由于可以用<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="external">离散傅立叶变换</a>快速解循环矩阵，所以在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90" target="_blank" rel="external">数值分析</a>中有重要的应用。</p>
<p>特性：</p>
<p>循环矩阵遵循<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0" target="_blank" rel="external">代数</a>运算法则。对于两个循环矩阵 <em>A</em> 与 <em>B</em> 来说，<em>A</em> + <em>B</em> 也是循环矩阵。<em>AB</em> 也是循环矩阵，并且 AB=BA。</p>
<p>循环矩阵的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F" target="_blank" rel="external">特征向量</a>矩阵是同样维数的离散<a href="https://zh.wikipedia.org/wiki/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="external">傅立叶变换</a>矩阵，因此循环矩阵的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%80%BC" target="_blank" rel="external">特征值</a>可以很容易地通过<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="external">快速傅立叶变换</a>计算出来。 具体对应关系为傅里叶变换矩阵=N*特征矩阵，N为循环矩阵维度</p>
<p>参考资料：<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E7%9F%A9%E9%98%B5" target="_blank" rel="external">循环矩阵</a></p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="external">傅里叶变换wiki</a></p>
<h3 id="循环矩阵傅里叶对角化"><a href="#循环矩阵傅里叶对角化" class="headerlink" title="循环矩阵傅里叶对角化"></a>循环矩阵傅里叶对角化</h3><p><a href="https://blog.csdn.net/shenxiaolu1984/article/details/50884830" target="_blank" rel="external">循环矩阵傅里叶对角化</a></p>
<h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p>岭回归，又称脊回归、吉洪诺夫正则化（Tikhonov regularization），是对<a href="https://baike.baidu.com/item/%E4%B8%8D%E9%80%82%E5%AE%9A%E9%97%AE%E9%A2%98" target="_blank" rel="external">不适定问题</a>（ill-posed problem)进行回归分析时最经常使用的一种正则化方法。</p>
<p>岭回归(英文名：ridge regression, Tikhonov regularization)是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得<a href="https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0" target="_blank" rel="external">回归系数</a>更为符合实际、更可靠的回归方法，对病态数据的拟合要强于<a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="external">最小二乘法</a>。</p>
<p>参考资料：<a href="https://baike.baidu.com/item/%E5%B2%AD%E5%9B%9E%E5%BD%92/554917" target="_blank" rel="external">岭回归</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.cnblogs.com/YiXiaoZhou/p/5925019.html" target="_blank" rel="external">KCF目标跟踪方法分析与总结</a></p>
<p><a href="https://lidongxuan.github.io/blog/kcf" target="_blank" rel="external">目标跟踪：KCF</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26685032" target="_blank" rel="external">核化相关滤波器高速跟踪：KCF(2015PAMI)</a></p>
<p><a href="https://blog.csdn.net/crazyice521/article/details/53525366" target="_blank" rel="external">目标跟踪算法——KCF入门详解</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在Markdown上编辑数学公式]]></title>
      <url>http://xiaqunfeng.cc/2018/05/03/MathJax-Markdown/</url>
      <content type="html"><![CDATA[<p>使用 MathJax 在markdown上显示公式<br><a id="more"></a></p>
<p>最简单的用法是使用 MathJax 的<a href="https://docs.mathjax.org/en/latest/start.html#mathjax-cdn" target="_blank" rel="external">内容分发（CDN）</a>服务。</p>
<h2 id="本地编辑器"><a href="#本地编辑器" class="headerlink" title="本地编辑器"></a>本地编辑器</h2><p>1、在markdown文件中，添加 MathJax CDN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;</div><div class="line">   src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>此时，就可以在 md 文件中插入公式了。</p>
<p>2、显示方式</p>
<p>公式显示居中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$ 此处插入公式 $$</div></pre></td></tr></table></figure>
<p>公式显示靠左：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\( 此处插入公式 \\)</div></pre></td></tr></table></figure>
<p>3、示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$</div><div class="line">\\(x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;\\)</div></pre></td></tr></table></figure>
<p>显示公式如下：<br>$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$<br>\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>
<blockquote>
<p>注：</p>
<p>1、编辑器 Typora 不能正常显示公式，但是 Macdown、Markdownpad等编辑器都可以正常显示。</p>
<p>2、markdown文件中的<code>_</code>前需要加上<code>\</code> 转义字符</p>
</blockquote>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>如果是 Chrome 浏览器的话，安装一个插件 <a href="https://chrome.google.com/webstore/detail/github-with-mathjax/ioemnmodlmafdkllaclgeombjnmnbima" target="_blank" rel="external">Github with MathJax</a> 即可正常显示本地markdown 编辑的 MathJax 公式。</p>
<p>显示方式：（和以上略有不同）</p>
<p>公式显示居中（该行只显示该公式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$ 此处插入公式 $$</div></pre></td></tr></table></figure>
<p>行内公式（前后可以有文字）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ 此处插入公式 $</div></pre></td></tr></table></figure>
<blockquote>
<p>注：不需要在md文件中添加 mathjax cdn 代码段</p>
</blockquote>
<h2 id="Hexo博客"><a href="#Hexo博客" class="headerlink" title="Hexo博客"></a>Hexo博客</h2><p>1、安装 hexo-math 插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-math --save</div></pre></td></tr></table></figure>
<p>2、在根目录下的 <code>_config.yml</code> 文件中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plugins: </div><div class="line">  hexo-math</div></pre></td></tr></table></figure>
<p>3、重新生成并部署网站即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d -g</div></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<p><a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=8159393" target="_blank" rel="external">http://cwiki.apachecn.org/pages/viewpage.action?pageId=8159393</a></p>
<p><a href="https://weilai5432.github.io/2017/01/11/MathJax-%E5%9C%A8MarkDown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="external">https://weilai5432.github.io/2017/01/11/MathJax-%E5%9C%A8MarkDown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git全局忽略.DS_Store等文件]]></title>
      <url>http://xiaqunfeng.cc/2018/04/24/git-ignore-ds-store/</url>
      <content type="html"><![CDATA[<p>git提交代码时，全局忽略指定类型的文件，不需要每次都去 .gitignore 中声明。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mac 中每个目录都会有个文件叫<code>.DS_Store</code>, 用于存储当前文件夹的一些 Meta 信息。</p>
<p>每次提交代码时，都需要在代码仓库的 .gitignore 中声明，忽略这类文件。这里介绍的方法可以不用每次都去修改 .gitignore，一次配置，永久有效。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1、创建 <code>~/.gitignore_global</code> 文件</p>
<p>把需要全局忽略的文件类型添加到该文件里</p>
<p>我的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># .gitignore_global</div><div class="line"></div><div class="line"># OS generated files</div><div class="line">.DS_Store</div><div class="line">.DS_Store?</div><div class="line">Desktop.ini</div><div class="line"></div><div class="line"># swp and Icon files</div><div class="line">*.swp</div><div class="line">Icon?</div><div class="line"></div><div class="line"># Files that might appear on external disks</div><div class="line">.Spotlight-V100</div><div class="line">.Trashes</div><div class="line"></div><div class="line"># Thumbnail cache files</div><div class="line">._*</div><div class="line">ehthumbs.db</div><div class="line">Thumbs.db</div><div class="line"></div><div class="line"># Packages</div><div class="line">*.7z</div><div class="line">*.dmg</div><div class="line">*.gz</div><div class="line">*.iso</div><div class="line">*.jar</div><div class="line">*.rar</div><div class="line">*.tar</div><div class="line">*.zip</div><div class="line"></div><div class="line"># Compiled Python files</div><div class="line">*.pyc</div><div class="line"></div><div class="line"># Compiled C++ files</div><div class="line">*.out</div></pre></td></tr></table></figure>
<p>2、在 ~/.gitconfig 中引入 <code>.gitignore_global</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">    name = xiaqunfeng</div><div class="line">    email = XXXX@gmail.com</div><div class="line">[core]</div><div class="line">    excludefile = /Users/xiaqunfeng/.gitignore_global</div></pre></td></tr></table></figure>
<p>以上！</p>
<p>此时，在所有的文件夹下 .DS_Store  等在 <code>~/.gitignore_global</code>  中指定的文件类型会被 Git 自动忽略。</p>
<h2 id="删除github上文件"><a href="#删除github上文件" class="headerlink" title="删除github上文件"></a>删除github上文件</h2><p>将上传到github上指定的文件删除，但如果只是单纯地删除本地文件，再执行提交操作，删除的只是本地文件，远程的文件依然存在。</p>
<p>正确姿势：</p>
<p>1、先将stage中的文件删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached filename</div></pre></td></tr></table></figure>
<p>2、然后提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;rm filename&quot;</div></pre></td></tr></table></figure>
<p>3、再push到远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>这时github上的文件就不存在了。</p>
<blockquote>
<p>如果要将远程已经上传的 .DS_Store 删除，可使用该方法</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在jupyter中添加conda环境]]></title>
      <url>http://xiaqunfeng.cc/2018/04/13/jupyter-conda/</url>
      <content type="html"><![CDATA[<p>解决在mac下启动jupyter后不能应用conda环境的问题<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在本机利用conda启动了一个虚拟环境，通过命令行使用python环境没问题，但是通过 <code>jupyter notebook</code> 启动jupyter notebook之后却找不到虚拟环境。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在虚拟环境下缺少kernel.json文件</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、首先安装ipykernel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install ipykernel</div></pre></td></tr></table></figure>
<p>2、在虚拟环境下创建kernel文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install -n 环境名称 ipykernel</div></pre></td></tr></table></figure>
<p>我这里想要再自己创建的python36环境中创建kernel文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install -n python36 ipykernel</div></pre></td></tr></table></figure>
<blockquote>
<p>前两步不需要启动conda环境，当然，已经启动了也没关系</p>
</blockquote>
<p>3、激活conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source activate 环境名称</div></pre></td></tr></table></figure>
<p>我这里启动 python36</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source activate python36</div></pre></td></tr></table></figure>
<p>当然，在启动环境前，还需要执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>这是使conda环境生效的操作</p>
<p>4、将环境写入notebook的kernel中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;</div></pre></td></tr></table></figure>
<p>我这里的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ python -m ipykernel install --user --name 3.6env --display-name &quot;Python (3.6env)&quot;</div><div class="line">Installed kernelspec 3.6env in /Users/xiaqunfeng/Library/Jupyter/kernels/3.6env</div><div class="line">(python36)</div></pre></td></tr></table></figure>
<p>5、查看环境信息</p>
<p>查看所有conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">▶ conda info --envs</div><div class="line"># conda environments:</div><div class="line">#</div><div class="line">python27                 /Users/xiaqunfeng/anaconda2/envs/python27</div><div class="line">python36              *  /Users/xiaqunfeng/anaconda2/envs/python36</div><div class="line">root                     /Users/xiaqunfeng/anaconda2</div><div class="line"></div><div class="line">(python36)</div></pre></td></tr></table></figure>
<p>查看已安装的 jupyter kernel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ ls ~/Library/Jupyter/kernels</div><div class="line">3.6env</div><div class="line">(python36)</div></pre></td></tr></table></figure>
<p>当前只安装了一个jupter kernel</p>
<p>6、打开notebook服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jupyter notebook</div></pre></td></tr></table></figure>
<p>新建时指定python环境</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jupyter-conda-1.jpg" alt="1"></p>
<p>对于已有的 ipynb 文件，可以更换kernel</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jupyter-conda-2.jpg" alt="2"></p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DBSCAN聚类算法]]></title>
      <url>http://xiaqunfeng.cc/2018/04/10/DBSCAN-cluster/</url>
      <content type="html"><![CDATA[<p>一种基于密度的聚类算法，可用于非凸样本集。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。</p>
<p>它是一种基于高密度连通区域的、基于密度的聚类算法，能够将具有足够高密度的区域划分为簇，并在具有噪声的数据中发现任意形状的簇，即密度相连的点的最大集合。</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>假设样本集是D=(x1,x2,…,xm)</p>
<p>1） ϵ-邻域：对于xj∈D，其ϵ-邻域包含样本集D中与xj的距离不大于ϵ的子样本集</p>
<p>2) 核心对象：对于任一样本xj∈D，如果其ϵ-邻域对应的子样本集个数至少包含MinPts个样本，则xj是核心对象。　</p>
<p>3）密度直达：如果xi位于xj的ϵ-邻域中，且xj是核心对象，则称xi由xj密度直达。</p>
<p>4）密度可达：对于xi和xj,如果存在样本序列p1,p2,…,pT,满足p1=xi,pT=xj, 且pt+1由pt密度直达，则称xj由xi密度可达。也就是说，密度可达满足传递性。此时序列中的传递样本p1,p2,…,pT−1均为核心对象，因为只有核心对象才能使其他样本密度直达。</p>
<p>5）密度相连：对于xi和xj，如果存在核心对象样本xk，使xi和xj均由xk密度可达，则称xi和xj密度相连。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dbscan.jpg" alt="img"></p>
<blockquote>
<p>参考资料2</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、DBSCAN算法从一个未被访问的任意的数据点开始。这个点的邻域是用距离epsilon来定义（即该点ε距离范围内的所有点都是邻域点）。</p>
<p>2、如果在该邻域内有足够数量的点（根据minPoints的值），则聚类过程开始，并且当前数据点成为新簇中的第一个点。否则，该点将被标记为噪声（稍后，这个噪声点可能成为聚类中的一部分）。在这两种情况下，该点都会被标记为“已访问”。</p>
<p>3、对于新簇中的第一个点，它的ε距离邻域内的点也会成为同簇的一部分。这个过程使ε邻域内的所有点都属于同一个簇，然后对才添加到簇中的所有新点重复上述过程。</p>
<p>4、重复步骤2和3两个过程直到确定了聚类中的所有点才停止，即访问和标记了聚类的ε邻域内的所有点。</p>
<p>5、一旦我们完成了当前的聚类，就检索和处理新的未访问的点，就能进一步发现新的簇或者是噪声。重复上述过程，直到所有点被标记为已访问才停止。由于所有点已经被访问完毕，每个点都被标记为属于一个簇或是噪声。</p>
<blockquote>
<p>参考资料1</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>算法是基于一组邻域来描述样本集的紧密程度的，参数(ϵ, MinPts)用来描述邻域的样本分布紧密程度，即用户的输入。</p>
<ul>
<li>ϵ - 某一样本的邻域距离阈值（即领域半径）</li>
<li>MinPts - 某一样本的距离为 ϵ 的邻域中样本个数的阈值（即最少点个数）</li>
</ul>
<p>一般由经验得来，如果点P以 ϵ 为半径的邻域内至少包含MinPts个点，则称点P为核心点（核心对象）</p>
<blockquote>
<p>该算法需要选择一种距离度量，任意两个点之间的距离，反映了点之间的密度，由于DBSCAN算法对高维数据定义密度很困难，所以对于二维空间中的点，可以用欧氏距离来度量</p>
</blockquote>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p><strong>时间复杂度：</strong></p>
<p>DBSCAN 对数据库里的每一点进行访问，可能多于一次（例如作为不同聚类的候选者），但在现实的考虑中，时间复杂度主要受regionQuery 的调用次数影响，DBSCAN 对每点都进行刚好一次调用，且如果使用了特别的编号结构，则总平均时间复杂度为 O(n log n) ，最差时间复杂度则为 O(n^2) 。</p>
<p><strong>空间复杂度：</strong></p>
<p>可以使用 O(n^2) 空间复杂度的距离矩阵以避免重复计算距离，但若不使用距离矩阵，DBSCAN 的空间复杂度为 O(n)。</p>
<blockquote>
<p>参考资料3</p>
</blockquote>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>不需要确定簇的数量</li>
<li>不同于Mean-shift算法，当数据点非常不同时，会将它们单纯地引入簇中，DBSCAN能将异常值识别为噪声（对噪声不敏感）</li>
<li>与k-means算法相比，DBSCAN可以发现任意形状的簇类</li>
<li>DBSCAN 只需两个参数，且对数据库内的点的次序几乎不敏感</li>
<li>DBSCAN 被设计成能配合可加速范围访问的数据库结构，例如 <a href="https://zh.wikipedia.org/wiki/R*%E6%A0%91" target="_blank" rel="external">R*树</a>。</li>
<li>如果对资料有足够的了解，可以选择适当的参数以获得最佳的分类。</li>
<li>DBSCAN只需扫描一遍数据集即可完成聚类，而不用迭代执行</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当数据簇密度不均匀时，它的效果不如其他算法好。这是因为当密度变化时，用于识别邻近点的距离阈值ε和minPoints的设置将随着簇而变化。</li>
<li>DBSCAN 聚类分析的质量受所使用的度量影响，最常用的度量是欧几里得距离，尤其在高维度资料中，由于受所谓“维数灾难”影响，很难找出一个合适的 ε 。</li>
<li>如果没有对资料和比例的足够理解，将很难选择适合的 ε 参数。</li>
</ul>
<p><strong>其他阅读</strong></p>
<p>一种关于人脸聚类方法，里面使用了DBSCAN方法。</p>
<p>算法简要描述:</p>
<ul>
<li>获取第一照片类和第二照片类，所述第一照片类包括聚类得到的至少两张人脸照片；</li>
<li>对所述第一照片类中的所述人脸照片进行聚类，得到至少一个照片子类；</li>
<li>将所述至少一个照片子类中的一个照片子类确定为正确人脸子类； </li>
<li>计算所述正确人脸子类与所述第二照片类之间的距离；</li>
<li>若所述距离大于阈值，则将所述第一照片类和所述第二照片类分别聚类至不同的照片类。</li>
</ul>
<p>算法链接如下：<br><a href="https://patents.google.com/patent/CN105426878A/zh" target="_blank" rel="external">https://patents.google.com/patent/CN105426878A/zh</a></p>
<p><strong>参考资料：</strong><br>1、<a href="http://www.10tiao.com/html/368/201802/2650784228/1.html" target="_blank" rel="external">http://www.10tiao.com/html/368/201802/2650784228/1.html</a><br>2、<a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="external">https://www.cnblogs.com/pinard/p/6208966.html</a><br>3、<a href="https://zh.wikipedia.org/wiki/DBSCAN" target="_blank" rel="external">https://zh.wikipedia.org/wiki/DBSCAN</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cluster </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AP(affinity propagation)聚类算法]]></title>
      <url>http://xiaqunfeng.cc/2018/04/08/affinity-propagation/</url>
      <content type="html"><![CDATA[<p>一种半监督聚类算法，近邻传播聚类算法<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Affinity Propagation聚类算法简称AP， 是基于数据点间的”信息传递”的一种聚类算法。算法的基本思想是将全部样本看作网络的节点，然后通过网络中各条边的消息传递计算出各样本的聚类中心。聚类过程中，共有两种消息在各节点间传递，分别是吸引度( responsibility)和归属度(availability) 。AP算法通过迭代过程不断更新每一个点的吸引度和归属度值，直到产生m个高质量的Exemplar（类似于质心），同时将其余的数据点分配到相应的聚类中。</p>
<p>AP论文：<a href="http://www.psi.toronto.edu/affinitypropagation/FreyDueckScience07.pdf" target="_blank" rel="external">Clustering by Passing Messages Between Data Points</a></p>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ul>
<li>Exemplar：指的是聚类中心，K-Means中的质心。</li>
<li>Similarity：数据点i和点j的相似度记为s(i, j)，是指点j作为点i的聚类中心的相似度。一般使用欧氏距离来计算，一般点与点的相似度值全部取为负值；因此，相似度值越大说明点与点的距离越近，便于后面的比较计算。</li>
<li>Preference：数据点i的参考度称为p(i)或s(i,i)，是指点i作为聚类中心的参考度。一般取s相似度值的中值。</li>
<li>Responsibility：r(i,k)用来描述点k适合作为数据点i的聚类中心的程度。</li>
<li>Availability：a(i,k)用来描述点i选择点k作为其聚类中心的适合程度。</li>
<li>Damping factor(阻尼系数)：为了避免振荡，AP算法更新信息时引入了衰减系数 λ。每条信息被设置为它前次迭代更新值的 λ 倍加上本次信息更新值的1-λ倍。其中，衰减系数 λ 是介于0到1之间的实数。</li>
</ul>
<p>在实际计算应用中，最重要的两个参数（也是需要手动指定）：</p>
<ul>
<li>Preference - 指定聚类数量的多少，值越大聚类数量越多</li>
<li>Damping factor - 控制算法收敛效果</li>
</ul>
<p>阻尼系数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r(i,k)new = λ*r(i,k)old + (1-λ)*r(i,k)</div><div class="line">a(i,k)new = λ*a(i,k)old + (1-λ)*a(i,k)</div></pre></td></tr></table></figure>
<h3 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h3><p>有一些详细的原理上的东西就不说了，直接说计算过程吧。聚类就是个不断迭代的过程，迭代的过程主要更新两个矩阵：</p>
<ul>
<li>代表(Responsibility)矩阵<em>R =</em>[r(i,k)]N×N</li>
<li><p>适选(Availabilities)矩阵A=[a(i,k)]N×N</p>
<p>这两个矩阵才初始化为0，N是所有样本的数目。<em>r(i,k)</em>表示第<em>k</em>个样本适合作为第<em>i</em>个样本的类代表点的代表程度，<em>a(i,k)</em>表示第<em>i</em>个样本选择第<em>k</em>个样本作为类代表样本的适合程度。</p>
</li>
</ul>
<p>迭代更新公式如下：</p>
<p><img src="http://kylen314.com/wp-content/uploads/2013/11/APgengxingongshi.jpg" alt="1"></p>
<p>一个比较通俗的聚类过程解释：</p>
<ul>
<li>所有人都参加选举（大家都是选民也都是参选人），要选出几个作为代表 </li>
<li>s(i,k)就相当于i对选k这个人的一个固有的偏好程度 </li>
<li>r(i,k)表示用s(i,k)减去最强竞争者的评分，可以理解为k在对i这个选民的竞争中的优势程度 </li>
<li>r(i,k)的更新过程对应选民i对各个参选人的挑选（越出众越有吸引力） </li>
<li>a(i,k)：从公式里可以看到，所有r(i’,k)&gt;0的值都对a有正的加成。对应到我们这个比喻中，就相当于选民i通过网上关于k的民意调查看到：有很多人（即i’们）都觉得k不错（r(i’,k)&gt;0），那么选民i也就会相应地觉得k不错，是个可以相信的选择 </li>
<li>a(i,k)的更新过程对应关于参选人k的民意调查对于选民i的影响（已经有了很多跟随者的人更有吸引力） </li>
<li>两者交替的过程也就可以理解为选民在各个参选人之间不断地比较和不断地参考各个参选人给出的民意调查。 </li>
<li>r(i,k)的思想反映的是竞争，a(i,k)则是为了让聚类更成功。 </li>
</ul>
<blockquote>
<p>源于参考资料2</p>
</blockquote>
<h2 id="与k-means的比较"><a href="#与k-means的比较" class="headerlink" title="与k-means的比较"></a>与k-means的比较</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>AP聚类算法与经典的 K-Means 和 k-centers 聚类算法相比，具有很多独特之处：</p>
<ol>
<li>无需指定聚类“数量”参数。AP聚类不需要指定K（经典的K-Means）或者是其他描述聚类个数（SOM中的网络结构和规模）的参数，这使得先验经验成为应用的非必需条件，人群应用范围增加。</li>
<li>明确的质心（聚类中心点）。样本中的所有数据点都可能成为AP算法中的质心，叫做Examplar，而不是由多个数据点求平均而得到的聚类中心（如K-Means）。</li>
<li>对距离矩阵的对称性没要求。AP通过输入相似度矩阵来启动算法，因此允许数据呈非对称，数据适用范围非常大。</li>
<li>初始值不敏感。多次执行AP聚类算法，得到的结果是完全一样的，即不需要进行随机选取初值步骤（还是对比K-Means的随机初始值）。</li>
<li>若以误差平方和来衡量算法间的优劣，AP聚类比其他方法的误差平方和都要低。（无论k-center clustering重复多少次，都达不到AP那么低的误差平方和）</li>
<li>AP算法相对K-Means鲁棒性强且准确度较高</li>
</ol>
<blockquote>
<p>参考资料1</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>AP聚类应用中需要手动指定Preference和Damping factor，这其实是原有的聚类“数量”控制的变体。</p>
</li>
<li><p>算法复杂度较高，为O(N<em>N</em>logN)，而K-Means只是O(N*K)的复杂度。因此运行较慢。当N比较大时(N&gt;3000)，AP聚类算法往往需要算很久。</p>
<p>​</p>
</li>
</ul>
<p>参考资料：</p>
<p>1、<a href="https://www.dataivy.cn/blog/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95affinity-propagation_ap/" target="_blank" rel="external">https://www.dataivy.cn/blog/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95affinity-propagation_ap/</a></p>
<p>2、<a href="https://www.zhihu.com/question/25384514" target="_blank" rel="external">https://www.zhihu.com/question/25384514</a></p>
<p>3、<a href="http://www.cnblogs.com/huadongw/p/4202492.html（相关公式）" target="_blank" rel="external">http://www.cnblogs.com/huadongw/p/4202492.html（相关公式）</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cluster </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】A Rank-Order Distance based Clustering Algorithm for Face Tagging]]></title>
      <url>http://xiaqunfeng.cc/2018/04/04/rank-order-clustering/</url>
      <content type="html"><![CDATA[<p>一篇关于人脸聚类的文章<br><a id="more"></a></p>
<p>原文链接：<a href="https://pdfs.semanticscholar.org/efd6/4b7641bea8ca536f4e179be6e2dd25d519d6.pdf" target="_blank" rel="external">2011_CVPR_A Rank-Order Distance based Clustering Algorithm for Face Tagging</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Rank-Order distance, which measures the dissimilarity between two faces using their neighboring information in the dataset. </div><div class="line">The Rank-Order distance is motivated by an observation that faces of the same person usually share their top neigh- bors.</div></pre></td></tr></table></figure>
<p>由于人脸的复杂场景，比如光照、姿态、表情等因素，绝对距离的度量方式可能会造成相同人的不同照片相似度很低，而不同人的照片反而相似度很高，所以单纯的L1或L2距离已不再适用。</p>
<p>由于大部分家庭照片都拍摄于不同的环境，对于人脸聚类会有一些要求和挑战：</p>
<p>1、相册中的人脸通常会在高维空间形成几个脸部簇，并具有不同的密度，大小和形状。这种非均匀分布使得绝对距离（例如，两个人脸识别特征之间的L1或L2距离）容易失败。如下图所示，男孩的群集比女孩的群集更稀疏。如果我们在这个例子中使用绝对距离，那么这个在中间男孩的脸更接近女孩群。</p>
<p>2、人脸检测通常会返回一些背景中不感兴趣或不喜欢的人脸。通常，我们不想标记这些面孔。聚类算法应该能够处理这些噪声和异常值。</p>
<p>3、算法的运行时间应该满足快速用户交互的要求。</p>
<p>由于复杂的人脸分布，同一人的所有人脸通常由几个子集群组成。由于这些子聚类相对比较紧密，因此可以通过简单的阈值法以Rank-Order距离来强健地识别它们。然而，由于光照，姿态，表达等变化的干扰，子簇之间的连接通常较弱且稀疏。为了解决这个问题，我们提出了一种基于排序距离的聚类算法，以迭代方式合并子簇凝聚的方式。聚类算法结合了聚类级别的秩距离和聚类级别的距离。在每个迭代步骤中，合并任意两个具有较小Rank-Order距离和较小归一化距离的人脸聚类。以这种方式，来自同一个人的不同子集群被有效连接。</p>
<p>Rank-order distance来度量两个人脸的相似度。这个距离是基于一个有趣的观察：同一个人的两张脸有许多共享的top邻居，但是来自不同人的人脸的邻居通常差异很大。</p>
<p>Rank-Order Distance</p>
<p><img src="https://pminmin.github.io/img/rank-order-1.png" alt="1"></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><a href="https://pminmin.github.io/img/rank-order-2.png" target="_blank" rel="external"><img src="https://pminmin.github.io/img/rank-order-2.png" alt="img"></a></p>
<p>该算法的时间复杂度是O(N2)O(N2)，其中DRDR和DNDN对应的两个阈值是固定参数，而K近邻是可以选择的参数，该参数大小直接影响最后聚类的簇数目。</p>
<p>参考资料：<a href="https://pminmin.github.io/2016/12/13/rank-order/" target="_blank" rel="external">https://pminmin.github.io/2016/12/13/rank-order/</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决Mac不能写入NTFS磁盘的问题(免安装)]]></title>
      <url>http://xiaqunfeng.cc/2018/03/27/mac-NTFS/</url>
      <content type="html"><![CDATA[<p>使用Mac的同学都知道Mac默认不能在NTFS格式的磁盘中写入内容。下面介绍一个简单的方法，简单几行命令解决所有问题。<br><a id="more"></a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Mac自动挂载的时候没有开放写权限，我们自己手动挂载一遍，把写权限加上即可。</p>
<h3 id="第一步：查看磁盘设备文件名"><a href="#第一步：查看磁盘设备文件名" class="headerlink" title="第一步：查看磁盘设备文件名"></a>第一步：查看磁盘设备文件名</h3><p>这一步需要看一下，目标磁盘叫什么名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil list</div></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/diskutil.png" alt="diskutil_list"></p>
<p>可以看到我移动硬盘被挂载了disk2的位置上，其中Windows那个磁盘<strong>设备文件名</strong>为<strong>disk2s4</strong></p>
<p>以上信息告诉我们：1. 在<code>/dev</code>目录下； 2. 设备名称为<code>disk2s4</code></p>
<h3 id="第二步：新建挂载点"><a href="#第二步：新建挂载点" class="headerlink" title="第二步：新建挂载点"></a>第二步：新建挂载点</h3><p>其实他的意思也就是要告诉电脑，你这张盘要放在那里，就好像Windows电脑在你点击<strong>我的电脑</strong>之后可以看到所有的盘一样。<br>这里选择放在桌面。<br>其实是在桌面上新建一个叫<code>Windows</code>的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir ~/Desktop/Windows</div></pre></td></tr></table></figure>
<h3 id="第三步：推出磁盘（重新挂载）"><a href="#第三步：推出磁盘（重新挂载）" class="headerlink" title="第三步：推出磁盘（重新挂载）"></a>第三步：推出磁盘（重新挂载）</h3><p>Mac默认挂载的时候不可写磁盘，这里我们需要重新挂载一次，但是在此之前，需要先取消挂载（等同于鼠标右键菜单中的<strong>推出</strong>，但是不要选择推出全部）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo umount /dev/disk2s4</div></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/umount.png" alt="umount"></p>
<h3 id="第四部：重新挂载"><a href="#第四部：重新挂载" class="headerlink" title="第四部：重新挂载"></a>第四部：重新挂载</h3><p>手动挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount_ntfs -o rw,nobrowse /dev/disk2s4 ~/Desktop/Windows</div></pre></td></tr></table></figure>
<h5 id="成功，磁盘可以正常读写了！！！"><a href="#成功，磁盘可以正常读写了！！！" class="headerlink" title="成功，磁盘可以正常读写了！！！"></a>成功，磁盘可以正常读写了！！！</h5><blockquote>
<p>本文为转载，亲测可用。原文链接：<a href="https://blog.plcent.com/archives/209" target="_blank" rel="external">https://blog.plcent.com/archives/209</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[添加gitment评论系统]]></title>
      <url>http://xiaqunfeng.cc/2018/03/26/%E6%B7%BB%E5%8A%A0gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>给自己的博客配置了一个评论系统，该系统使用GitHub账号登陆，使用GitHub Issues来写评论，比较方便。<br><a id="more"></a></p>
<h2 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h2><p>链接: <a href="https://github.com/settings/applications/new" target="_blank" rel="external">https://github.com/settings/applications/new</a></p>
<p>因为Gitment使用了GitHub的服务，因此需要注册OAuth application。</p>
<p>注意：<strong>Authorization callback URL</strong>必须填写博客的域名。</p>
<p>注册成功之后将获取<strong>Client ID</strong>与<strong>Client Secret</strong>。</p>
<p>我的填写如下所示：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/OAuth-Application.jpg" alt="OAuth"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="主题带有gitment选项"><a href="#主题带有gitment选项" class="headerlink" title="主题带有gitment选项"></a>主题带有gitment选项</h3><p>那只需要填写以下信息就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#Gitment</div><div class="line">gitment_owner: &apos;#&apos;         #你的 GitHub ID</div><div class="line">gitment_repo: &apos;#&apos;          #存储评论的 repo</div><div class="line">gitment_oauth:</div><div class="line">  client_id: &apos;#&apos;           #client ID</div><div class="line">  client_secret: &apos;#&apos;       #client secret</div></pre></td></tr></table></figure>
<h3 id="主题带没有gitment选项"><a href="#主题带没有gitment选项" class="headerlink" title="主题带没有gitment选项"></a>主题带没有gitment选项</h3><p>如果主题没有gitment选项可配置，可手动添加，步骤如下</p>
<p>1、加载Gitment的CSS与JS文件</p>
<p>下载<a href="https://imsun.github.io/gitment/style/default.css" target="_blank" rel="external">gitment.css</a>与<a href="https://imsun.github.io/gitment/dist/gitment.browser.js" target="_blank" rel="external">gitment.js</a>，分别放入主题目录的<strong>source/css</strong>与<strong>source/js</strong>目录中</p>
<p>在<strong>layout/partial/head.ejs</strong>中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 加载gitment的css和js文件 --&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/gitment.css&quot;&gt; </div><div class="line">&lt;script src=&quot;/js/gitment.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>2、配置Gitment</p>
<p>添加<strong>layout/partial/gitment.ejs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;gitment&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!-- 主页不要加载gitment --&gt;</div><div class="line">&lt;% if (!index)&#123; %&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">var gitment = new Gitment(&#123;</div><div class="line">  owner: &apos;xiaqunfeng&apos;,</div><div class="line">  repo: &apos;xiaqunfeng.github.io&apos;,</div><div class="line">  oauth: &#123;</div><div class="line">    client_id: &apos;XXX&apos;,</div><div class="line">    client_secret: &apos;XXXX&apos;,</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line">gitment.render(&apos;gitment&apos;)</div><div class="line">&lt;/script&gt;</div><div class="line"> </div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
<ul>
<li><strong>client_id</strong>与<strong>client_secret</strong>为第1步注册OAuth Application所获取的<strong>Client ID</strong>与<strong>Client Secret</strong></li>
<li><strong>owner</strong>为你的GitHub账户名</li>
<li><strong>repo</strong>为你保存评论的GitHub仓库名称，所有的评论将保存在该仓库的Issues</li>
</ul>
<p>在<strong>layout/partial/article.ejs</strong>中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%- partial(&apos;gitment&apos;) %&gt;</div></pre></td></tr></table></figure>
<p>3、初始化Gitment</p>
<p>以上步骤完成后就可以在博客页面的最下方看到如图所示的评论框。使用GitHub账号登录之后，就可以对评论进行初始化，然后开始写评论了。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/gitment.jpg" alt="gitment"></p>
<blockquote>
<p>每一篇博客的评论，对应于GitHub仓库一个issue。但是这些issue是不存在的，因此对于每一篇博客都需要进行初始化Gitment去创建issue。</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、我遇到的坑</p>
<p>点击 <code>Initialize Comments</code> 的时候，出现 <code>Error: Validation Failed</code> </p>
<p>原因：</p>
<p>gitment有一项id配置是<code>window.location.pathname</code>，id有长度限制，当标题太长时，会导致id不合法</p>
<p>解决方法：</p>
<p>修改id，把id改成时间，或者其他的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id: &apos;&lt;%= page.date %&gt;&apos;</div></pre></td></tr></table></figure>
<p>我用的是yilia的主题，要修改的文件是 <code>gitment.ejs</code>，路径如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">▶ cat themes/yilia/layout/_partial/post/gitment.ejs</div><div class="line">&lt;div id=&quot;gitment-ctn&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//imsun.github.io/gitment/style/default.css&quot;&gt;</div><div class="line">&lt;script src=&quot;//imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var gitment = new Gitment(&#123;</div><div class="line">  id: &quot;&lt;%=url%&gt;&quot;,						// 要改这一行！</div><div class="line">  owner: &apos;&lt;%=theme.gitment_owner%&gt;&apos;,</div><div class="line">  repo: &apos;&lt;%=theme.gitment_repo%&gt;&apos;,</div><div class="line">  oauth: &#123;</div><div class="line">    client_id: &apos;&lt;%=theme.gitment_oauth.client_id%&gt;&apos;,</div><div class="line">    client_secret: &apos;&lt;%=theme.gitment_oauth.client_secret%&gt;&apos;,</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line">gitment.render(&apos;gitment-ctn&apos;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>2、其他各种坑，详见<a href="http://xichen.pub/2018/01/31/2018-01-31-gitment/" target="_blank" rel="external">添加Gitment评论系统踩过的坑</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】mtcnn]]></title>
      <url>http://xiaqunfeng.cc/2018/03/21/mtcnn-note/</url>
      <content type="html"><![CDATA[<p>一篇2016年的论文MTCNN阅读笔记<br><a id="more"></a></p>
<p>MTCNN 全称 Multi-task convolutional neural networks</p>
<p>论文首页：<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/index.html?from=timeline&amp;isappinstalled=1" target="_blank" rel="external">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a></p>
<p>Github: <a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="external">https://github.com/kpzhang93/MTCNN_face_detection_alignment</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>提供了一个新的框架，通过多任务学习统一级联CNN来整合面部检测和对齐这两项任务。提供的CNN由三个阶段组成。</p>
<p>第一阶段，通过一个浅的CNN快速产生候选窗口。</p>
<p>第二阶段，通过一个更复杂的CNN来优化，拒绝大量的非面部窗口。</p>
<p>最后阶段，用一个更加强大的CNN来优化结果并输出面部特征位置。</p>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><h3 id="Overall-Framework"><a href="#Overall-Framework" class="headerlink" title="Overall Framework"></a>Overall Framework</h3><p>给定一个图像，最初将它调整到不同比例以构建图像金字塔，作为接下来三阶段级联框架的输入：</p>
<p>第一阶段：我们实现一个完全卷积网络（fully convolutional network），叫做提案网络Proposal Network（P-Net），用以获取候选面部窗口以及它们的边界框回归向量。然后我们用估计的边界框回归向量来校准候选边框向量。之后，我们采用非极大值抑制（NMS）来合并高度重叠的候选框。</p>
<p>第二阶段：所有候选边框都被送到另一个CNN，叫做提取网络Refine Network（R-Net），进一步拒绝大量假候选框，用边界框回归执行校准，并用NMS合并候选框。</p>
<p>第三阶段：Output Network（O-Net），这个阶段跟第二阶段很相似，但是在这个阶段我们目标是更详细的描述面部。网络将输出五个面部特征位置。</p>
<p>如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160926111307080" alt="JDA Pipeline"></p>
<h3 id="CNN-Architectures"><a href="#CNN-Architectures" class="headerlink" title="CNN Architectures"></a>CNN Architectures</h3><p>当前用于面部识别的CNN受到以下限制：（1）一些过滤器缺少权重的多样性，这或许会他们产生歧义的描述。（2）与其他多分类对象检测和分类任务相比，面部检测是一个有挑战性的二分类任务，所以，它或许每层网络需要更少数量的过滤器。因此，减少过滤器的数量并且将5x5的过滤器改成3x3的过滤器以减少计算量，同时增加深度以获取更好的性能。有了这些改进，与之前的架构相比，在获得更好性能的同时获得更少的运行时间。文章在convolution和fully connection层后使用PReLU作为非线性激活函数。</p>
<p><strong>Stage1: Proposal Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113319264" alt="JDA Network1"></p>
<p>MP = Max Pooling</p>
<p><strong>Stage2: Refine Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113327249" alt="JDA Network2"></p>
<p><strong>Stage3: Output Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113334297" alt="JDA Network3"></p>
<p>prototxt参见mtcnn的python&amp;caffe版本：<a href="https://github.com/DuinoDu/mtcnn" target="_blank" rel="external">https://github.com/DuinoDu/mtcnn</a></p>
<p><strong>用Netscope画出来的网络结构图如下：</strong></p>
<p>1、P-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-pnet.jpg" alt="p-net"></p>
<p>2、R-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-rnet.jpg" alt="r-net"></p>
<p>3、O-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-onet.jpg" alt="o-net"></p>
<blockquote>
<p>更详细的网络结构图可用caffe工具 draw_net.py 来绘制。</p>
</blockquote>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>利用三个任务来训练我们的CNN检测器：面部/非面部分类器，边界框回归以及面部特征定位。</p>
<p>1、Face classification</p>
<p>学习目标被定义为一个二分类问题。对于每一个样本，使用交叉熵损失函数</p>
<p><img src="http://img.blog.csdn.net/20160927151710209" alt="img"></p>
<p>pi是网络产生的指示一个样本是一个面部的概率。符号yidet∈{0,1}表示 ground-truth 的标签。</p>
<p>2、Bounding box regression</p>
<p>对于每个候选窗口，预测它与最接近真实值（比如，边界框的左上角坐标，高和宽）的偏移。学习目标被定义为一个回归问题，并且对每个样本Xi使用欧几里得损失函数：</p>
<p><img src="http://img.blog.csdn.net/20160927151729296" alt="img"></p>
<p>上式为通过欧氏距离计算的回归损失。其中，带尖的y为通过网络预测得到，不带尖的y为实际的真实的背景坐标。其中，y为一组成的四元组。</p>
<p>带尖的yibox是从网络获得的回归目标，yibox是正确标注的坐标。y是一个四元组，有4个坐标，（左上角x，左上角y，长，宽）。</p>
<p>3、Facial landmark localization</p>
<p>与边界框回归任务类似，面部特征检测被定义为一个回归问题并且最小化欧氏距离损失函数。</p>
<p><img src="http://img.blog.csdn.net/20160927151747812" alt="img"></p>
<p>其中，带尖的y为通过网络预测得到，不带尖的y为实际的真实的坐标。有五个面部特征点，包括左眼，右眼，鼻子，左嘴角，右嘴角，每个点2个坐标，所以，y属于十元组。</p>
<p>4、Multi-source training</p>
<p>由于我们在每个CNN中采用不同的任务，因此在学习过程中有不同类型的训练图像，比如，面部，非面部以及部分对齐的面部。在这种情况下，一些损失函数没有被使用。举个例子，对于样本的背景区域，我们仅计算Li det，并且其它两个损失值被设置为0。这个可以直接用一个样本类型指示器来实现。那么整个学习目标就可以被定义为</p>
<p><img src="http://img.blog.csdn.net/20160927151808203" alt="img"></p>
<p>整个的训练学习过程就是最小化上面的这个函数，其中，N为训练样本数量，aj表示任务的重要性，bj为样本类型。在这种情况下，采用随机梯度下降来训练CNN是自然而然的。</p>
<p>5、Online Hard sample mining</p>
<p>在线难例挖掘：不同于在原始分类器被训练之后进行传统的难例挖掘，文章中在面部分类任务中进行在线难例挖掘，以适应训练过程。</p>
<p>在每个小批量中，对所有样本在正向传播阶段计算损失并进行排序，选择前70%做为难例。然后我们在反向传播阶段仅从计算难例中的梯度。这意味着，我们忽略了训练过程中对检测器强化鲜有帮助的容易样本（easy samples）</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>由于联合执行面部检测和对齐，训练过程中，使用4种不同类型的数据标注：</p>
<p>（i）Negatives：和ground-truth face交并比（Intersection-over-Union，IoU）小于0.3的特征数据；</p>
<p>（ii）Positives：IoU &gt; 0.65</p>
<p>（iii）Part faces：0.4 &lt; IoU &lt; 0.65</p>
<p>（iv）Landmark faces：标有5个landmark位置的人脸</p>
<ul>
<li>负样本和正样本用于面部分类任务</li>
<li>正样本和部分人脸样本用于边界框回归</li>
<li>landmark人脸样本用于面部landmark定位</li>
</ul>
<p>所有训练数据组成：</p>
<p>3:1:1:2（negatives/ positives/ part face/ landmark face)</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>FDDB上准确率</p>
<p><img src="http://img.blog.csdn.net/20160926115216571" alt="JDA Network3"></p>
<p>速度</p>
<p><img src="http://img.blog.csdn.net/20160926114956302" alt="JDA Network3"></p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac-Tensorflow-Keras]]></title>
      <url>http://xiaqunfeng.cc/2018/03/18/Mac-Tensorflow-Keras/</url>
      <content type="html"><![CDATA[<p>在mac上初步搭建keras，用tensorflow作为backend。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h3><p>激活环境conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source activate python27</div></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">conda install tensorflow</div><div class="line">conda install keras</div></pre></td></tr></table></figure>
<h3 id="正常安装"><a href="#正常安装" class="headerlink" title="正常安装"></a>正常安装</h3><p>python3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip3 install tensorflow</div><div class="line">pip3 install keras</div></pre></td></tr></table></figure>
<p>python2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow</div><div class="line">pip install keras</div></pre></td></tr></table></figure>
<h3 id="版本和配置"><a href="#版本和配置" class="headerlink" title="版本和配置"></a>版本和配置</h3><p><strong>版本信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import tensorflow as tf</div><div class="line">&gt;&gt;&gt; tf.__version__</div><div class="line">&apos;1.6.0&apos;</div><div class="line">&gt;&gt;&gt; import keras</div><div class="line">Using TensorFlow backend.</div><div class="line">&gt;&gt;&gt; keras.__version__</div><div class="line">&apos;2.1.5&apos;</div></pre></td></tr></table></figure>
<p>表示安装成功</p>
<p><strong>配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">▶ cat ~/.keras/keras.json</div><div class="line">&#123;</div><div class="line">    &quot;epsilon&quot;: 1e-07,</div><div class="line">    &quot;floatx&quot;: &quot;float32&quot;,</div><div class="line">    &quot;image_data_format&quot;: &quot;channels_last&quot;,</div><div class="line">    &quot;backend&quot;: &quot;tensorflow&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数 <code>image_data_format</code> 是 <code>channels_last</code> ，对于Theano来说，这个参数是<code>channels_first</code>。因为在TensorFlow中图像的存储方式是<code>[height, width, channels]</code>，Theano中是 <code>[channels, height, width]</code>。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Keras </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上Matplotlib中文乱码问题]]></title>
      <url>http://xiaqunfeng.cc/2018/03/13/mac%E4%B8%8AMatplotlib%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>解决自己再mac上用matplotlib绘图时中文显示乱码的问题<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/font_manager.py:1297: UserWarning: findfont: Font family [u&apos;sans-serif&apos;] not found. Falling back to DejaVu Sans</div><div class="line">  (prop.get_family(), self.defaultFamily[fontext]))</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>找不到字体，在绘制的图片中中文显示乱码</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、查看环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ python --version</div><div class="line">Python 2.7.14 :: Anaconda, Inc.</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>我这边起了一个名为 python27 的anaconda环境</p>
<p>2、查看配置路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import matplotlib</div><div class="line">&gt;&gt;&gt; print matplotlib.matplotlib_fname()</div><div class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</div></pre></td></tr></table></figure>
<p>3、下载字体 <a href="http://www.font5.com.cn/font_download.php?id=151&amp;part=1237887120" target="_blank" rel="external">simhei.ttf</a></p>
<p>4、将字体拷贝到 ttf 目录下</p>
<p>我这边具体目录为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/fonts/ttf/</div></pre></td></tr></table></figure>
<p>5、删除字体缓存文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf ~/.matplotlib/*.cache</div></pre></td></tr></table></figure>
<blockquote>
<p>如果没有删除的话，会出现有字体但还是显示小方块</p>
</blockquote>
<p>6、字体参数设置</p>
<p>方法一：在代码中动态设置参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line"># 指定默认字体</div><div class="line">plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] </div><div class="line">plt.rcParams[&apos;font.family&apos;]=&apos;sans-serif&apos; </div><div class="line"># 用来正常显示负号</div><div class="line">plt.rcParams[&apos;axes.unicode_minus&apos;]=False</div></pre></td></tr></table></figure>
<p>方法二：修改配置文件 matplotlibrc（一劳永逸）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># cat /Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</div><div class="line">...</div><div class="line">font.family         : sans-serif </div><div class="line">...</div><div class="line">font.sans-serif     : SimHei</div><div class="line">...</div><div class="line">axes.unicode_minus  : False # use unicode for the minus symbol</div><div class="line">...</div></pre></td></tr></table></figure>
<blockquote>
<p>意思就是知道字库族为 sans-serif，同时添加“SimHei”即宋体到字库族列表中，同时将找到axes.unicode_minus，将True改为False，作用就是解决负号’-‘显示为方块的问题</p>
</blockquote>
<p>7、字体显示</p>
<p>有中文出现的情况，需要 <code>u&#39;内容&#39;</code>，比如 <code>plt.xlabel(u&#39;横坐标&#39;)</code></p>
<p>同时还需在开头添加代码行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#coding:utf-8</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[inkscope安装配置]]></title>
      <url>http://xiaqunfeng.cc/2018/03/11/inkscope%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>关于inkscope监控配置实践手册。<br><a id="more"></a></p>
<h2 id="关于inkscope"><a href="#关于inkscope" class="headerlink" title="关于inkscope"></a>关于inkscope</h2><p><strong>Inkscope</strong> 是一个 Ceph 的管理和监控系统，依赖于 Ceph 提供的 API，使用 MongoDB  来存储实时的监控数据和历史信息。</p>
<p>inkscope是一个基于apache2部署的flask应用， flask项目只负责ceph监控页面展示，实际获取ceph集群状态信息，是通过向ceph-rest-api发起请求实现的。</p>
<p>github地址：<a href="https://github.com/inkscope/inkscope" target="_blank" rel="external">https://github.com/inkscope/inkscope</a></p>
<p><strong>架构图</strong> <img src="http://oow6unnib.bkt.clouddn.com/inkscope-platform.png" alt="inkscope-platform"></p>
<p><strong>各组件作用</strong></p>
<ul>
<li>ceph-rest-api：Ceph提供的restfulAPI接口，inkscope通过ceph-rest-api接口访问和操作Ceph集群；</li>
<li>cephprobe：用于获取Ceph集群的相关信息；</li>
<li>sysprobe：用于获取Ceph运行的物理节点的相关信息，如：CPU、内存、网络以及磁盘使用量等相关信息；</li>
<li>mongoDB：用于保存又cephprobe和sysprobe获取的实时和历史数据集合，该数据集合由inkscope web界面展示部分读取调用；</li>
<li>inkscope-admviz：inkscope对外提供web服务。用户通过web浏览器向inkscope-admviz发送restfulAPI格式的读写请求，之后inkscope-admviz通过访问mongoDB数据库或访问ceph-rest-api接口来完成用户的读写请求，之后将读写请求的结果返回给客户浏览器。</li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统版本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># cat /etc/redhat-release </div><div class="line">CentOS Linux release 7.3.1611 (Core) </div><div class="line"></div><div class="line"># getconf LONG_BIT</div><div class="line">64</div><div class="line"></div><div class="line"># cat /proc/version </div><div class="line">Linux version 3.10.0-514.16.1.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) #1 SMP Wed Apr 12 15:04:24 UTC 2017</div></pre></td></tr></table></figure>
<p>ceph集群信息</p>
<p>三个节点（ceph0，ceph1，ceph2）即使mon节点，也是osd节点。</p>
<p>这里将ceph0作为inkscope管理节点，配置公网IP。</p>
<p>软件包的安装情况一览</p>
<ul>
<li>集群的mon节点：cephprobe，ceph-rest-api</li>
<li>集群的osd节点：sysprobe，inkscope-common</li>
<li>inkscope管理控制台： inkscope-admviz，inkscope-monitor，mongodb</li>
</ul>
<h2 id="管理节点"><a href="#管理节点" class="headerlink" title="管理节点"></a>管理节点</h2><h3 id="1、安装依赖包"><a href="#1、安装依赖包" class="headerlink" title="1、安装依赖包"></a>1、安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install httpd python-setuptools lshw mod_wsgi -y</div></pre></td></tr></table></figure>
<h3 id="2、安装mongodb"><a href="#2、安装mongodb" class="headerlink" title="2、安装mongodb"></a>2、安装mongodb</h3><p>创建 repo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d/mongodb-org-3.4.repo</div><div class="line">[mongodb-org-3.4]   </div><div class="line">name=MongoDB Repository    </div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/    </div><div class="line">gpgcheck=1    </div><div class="line">enabled=1    </div><div class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</div></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install mongodb-org -y</div></pre></td></tr></table></figure>
<p>修改配置文件，让mongdb可以远程访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/mongod.conf</div></pre></td></tr></table></figure>
<p>bind_ip = 127.0.0.1修改为 bind_ip = 0.0.0.0</p>
<p>启动mongodb服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl start mongod.service</div></pre></td></tr></table></figure>
<p>查看服务是否已启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># netstat -tunlp | grep mongod</div><div class="line">tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      12115/mongod</div></pre></td></tr></table></figure>
<h3 id="3、安装inkscope相关的包"><a href="#3、安装inkscope相关的包" class="headerlink" title="3、安装inkscope相关的包"></a>3、安装inkscope相关的包</h3><h4 id="建立本地仓库"><a href="#建立本地仓库" class="headerlink" title="建立本地仓库"></a>建立本地仓库</h4><p>参考官方的方法：<a href="https://github.com/inkscope/inkscope-packaging" target="_blank" rel="external">https://github.com/inkscope/inkscope-packaging</a></p>
<p>1、从git上将源下载到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/inkscope/inkscope-packaging.git</div></pre></td></tr></table></figure>
<p>2、创建本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd inkscope-packaging/</div><div class="line">mkdir -p /var/www/html/inkscope-repo</div><div class="line">cp -r RPMS/* /var/www/html/inkscope-repo</div><div class="line">createrepo /var/www/html/inkscope-repo</div></pre></td></tr></table></figure>
<p>3、新建仓库配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d/inkscope.repo </div><div class="line">[inkscope]</div><div class="line">name=My inkScope Repo</div><div class="line">baseurl=http://172.20.2.117:8080/inkscope-repo</div><div class="line">enabled=1</div><div class="line">gpgcheck=0</div></pre></td></tr></table></figure>
<h4 id="安装inkscope相关软件"><a href="#安装inkscope相关软件" class="headerlink" title="安装inkscope相关软件"></a>安装inkscope相关软件</h4><p>1、安装并启动cephprobe和ceph-rest-api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># yum install inkscope-cephrestapi</div><div class="line"># /etc/init.d/ceph-rest-api start</div><div class="line">Starting ceph-rest-api python server</div><div class="line">* Running on http://0.0.0.0:5000/</div><div class="line"></div><div class="line"># yum install inkscope-cephprobe</div><div class="line"># /etc/init.d/cephprobe start</div></pre></td></tr></table></figure>
<blockquote>
<p>在安装cephprobe的时候，inkscope-common作为依赖被安装</p>
</blockquote>
<p>2、安装inkscope-sysprobe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># yum install inkscope-sysprobe -y</div><div class="line"># /etc/init.d/sysprobe start</div></pre></td></tr></table></figure>
<p>3、安装inskscopeviz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install inkscope-admviz -y</div></pre></td></tr></table></figure>
<blockquote>
<p>此时会生成/etc/httpd/conf.d/inkScope.conf</p>
</blockquote>
<h3 id="4、配置权限"><a href="#4、配置权限" class="headerlink" title="4、配置权限"></a>4、配置权限</h3><p>需要创建一个client.restapi的用户 拥有权限 [mds] allow, [mon] allow , [osd] allow </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.restapi mds &apos;allow&apos; osd &apos;allow *&apos; mon &apos;allow *&apos; &gt; /etc/ceph/ceph.client.restapi.keyring</div><div class="line"></div><div class="line">chmod 644 /etc/ceph/ceph.client.admin.keyring</div><div class="line">chmod 644 /etc/ceph/ceph.client.restapi.keyring</div></pre></td></tr></table></figure>
<p>在/etc/ceph/ceph.conf配置文件里面添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[client.restapi]</div><div class="line">    log_file = /dev/null</div><div class="line">    keyring = /etc/ceph/ceph.client.restapi.keyring</div></pre></td></tr></table></figure>
<h3 id="5、配置http"><a href="#5、配置http" class="headerlink" title="5、配置http"></a>5、配置http</h3><p>/etc/httpd/conf/httpd.conf 中间添加一条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Listen 8080</div></pre></td></tr></table></figure>
<p>因为inkscope的web 默认采用虚拟主机的方式使用了8080端口。这个地方是写的这台管理节点的地址和端口，因为本机实现了wsgi的方式的rest-api的接口，不是用的集群的5000的端口，而是直接使用web配置的8080的端口</p>
<h3 id="6、给目录访问权限"><a href="#6、给目录访问权限" class="headerlink" title="6、给目录访问权限"></a>6、给目录访问权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># chmod 777 -R /var/log/ceph/</div></pre></td></tr></table></figure>
<p>修改ceph-rest-api的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf.d/inkScope.conf</div></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># For a ceph_rest_api in wsgi mode</div><div class="line">ProxyPass /ceph-rest-api/ http://&lt;inkscope_host&gt;:&lt;inkscope_port&gt;/ceph_rest_api/api/v0.1/</div></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ProxyPass /ceph-rest-api/ http://172.20.2.117:8080/ceph_rest_api/api/v0.1/</div><div class="line">...</div></pre></td></tr></table></figure>
<p>启动http服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart httpd</div></pre></td></tr></table></figure>
<p>检查ceph-rest-api是否能访问</p>
<p>地址是上面修改的地址：<a href="http://183.136.239.36:8080/ceph_rest_api/api/v0.1/" target="_blank" rel="external">http://183.136.239.36:8080/ceph_rest_api/api/v0.1/</a></p>
<p>修改/opt/inkscope/etc/inkscope.conf配置文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;ceph_rest_api&quot;: &quot;172.20.2.117:8080&quot;,</div><div class="line">&quot;ceph_rest_api_subfolder&quot;: &quot;ceph_rest_api&quot;,</div><div class="line">&quot;mongodb_host&quot; : &quot;172.20.2.117&quot;,</div></pre></td></tr></table></figure>
<h3 id="7、启动cephprobe-服务"><a href="#7、启动cephprobe-服务" class="headerlink" title="7、启动cephprobe 服务"></a>7、启动cephprobe 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@inkscope ~]# /etc/init.d/cephprobe restart</div></pre></td></tr></table></figure>
<p>现在就可以访问<br><a href="http://123.59.204.199:8080/inkscopeViz/index.html" target="_blank" rel="external">http://123.59.204.199:8080/inkscopeViz/index.html</a></p>
<p>这个是没有用户名密码的，我们为了安全采用以下用户名密码的方式,需要安装flask-login</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@inkscope ~]# rpm -ivh python-flask-login-0.2.11-1.el7.centos.noarch.rpm</div></pre></td></tr></table></figure>
<h3 id="8、重启httpd服务"><a href="#8、重启httpd服务" class="headerlink" title="8、重启httpd服务"></a>8、重启httpd服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@inkscope ~]# systemctl restart httpd</div></pre></td></tr></table></figure>
<p>再次访问就需要用户名密码了</p>
<ul>
<li>默认用户名:admin</li>
<li>默认密码:admin</li>
</ul>
<h2 id="OSD节点"><a href="#OSD节点" class="headerlink" title="OSD节点"></a>OSD节点</h2><h3 id="配置sysprobe"><a href="#配置sysprobe" class="headerlink" title="配置sysprobe"></a>配置sysprobe</h3><p>sysprobe是获取集群节点的主机的信息的</p>
<p>管理节点同时也是OSD节点的话也要配置</p>
<p>1、安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rpm -ivh inkscope-common-1.3.1-2.noarch.rpm</div><div class="line"># rpm -ivh inkscope-sysprobe-1.3.1-2.noarch.rpm</div></pre></td></tr></table></figure>
<p>将主监控节点的inkscope配置文件拷贝到所有OSD节点上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># scp /opt/inkscope/etc/inkscope.conf 192.168.8.106:/opt/inkscope/etc/</div></pre></td></tr></table></figure>
<p>2、在osd节点启动sysprobe服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@lab8106 ~]# /etc/init.d/sysprobe start</div></pre></td></tr></table></figure>
<p>cephprobe是用来或者集群的相关信息和操作的<br>sysprobe是获取节点的磁盘分区等相关信息的</p>
<p>问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># /etc/init.d/sysprobe start</div><div class="line">Starting sysprob daemon</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/opt/inkscope/bin/sysprobe.py&quot;, line 24, in &lt;module&gt;</div><div class="line">    import psutil</div><div class="line">ImportError: No module named psutil</div></pre></td></tr></table></figure>
<p>原因：</p>
<p>没有按照系统性能信息模块psutil，该模块能够获取系统运行的进程和系统利用率（cpu、内存、磁盘、网络）等信息。</p>
<p>centos7下安装psutil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install python-psutil</div></pre></td></tr></table></figure>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p> <img src="http://oow6unnib.bkt.clouddn.com/inkscope-protal.png" alt="inkscope-protal"></p>
<p>更多相关截图可以在这里查阅：<a href="https://github.com/inkscope/inkscope/tree/master/screenshots" target="_blank" rel="external">https://github.com/inkscope/inkscope/tree/master/screenshots</a></p>
<p>ubuntu上的部署指南可以参考这里：<a href="http://gtcsq.readthedocs.io/en/latest/others/inkscope_install.html" target="_blank" rel="external">http://gtcsq.readthedocs.io/en/latest/others/inkscope_install.html</a></p>
<p>参考资料：<a href="http://www.zphj1987.com/2016/04/19/inkscope%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">http://www.zphj1987.com/2016/04/19/inkscope%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</a> </p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># /etc/init.d/cephprobe restart</div><div class="line">restarting  cephprob daemon</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/opt/inkscope/bin/cephprobe.py&quot;, line 25, in &lt;module&gt;</div><div class="line">    from daemon import Daemon</div><div class="line">  File &quot;/opt/inkscope/bin/daemon.py&quot;, line 6, in &lt;module&gt;</div><div class="line">    import psutil</div><div class="line">ImportError: No module named psutil</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install python-setuptools</div></pre></td></tr></table></figure>
<p>安装完以后我们就可以使用命令easy_install安装 系统性能信息模块psutil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">easy_install psutil</div></pre></td></tr></table></figure>
<p>这时候又出现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">psutil/_psutil_linux.c:12:20: 致命错误：Python.h：没有那个文件或目录</div></pre></td></tr></table></figure>
<p>解决方法</p>
<p>查看本地是否安装python-devel，这是Python的头文件和静态库包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm -qa |grep python-devel</div></pre></td></tr></table></figure>
<p>这时候没有输出，说明没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum search python |grep python-devel</div></pre></td></tr></table></figure>
<p>选一个安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install python-devel.x86_64 -y</div></pre></td></tr></table></figure>
<p>over</p>
<h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2><p>创建.repo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/mongodb-org-3.4.repo</div></pre></td></tr></table></figure>
<p>内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mongodb-org-3.4]   </div><div class="line">name=MongoDB Repository    </div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/    </div><div class="line">gpgcheck=1    </div><div class="line">enabled=1    </div><div class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</div></pre></td></tr></table></figure>
<p>验证MongoDB存储库是否存在于yum实用程序中。 repolist命令显示已启用的存储库的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># yum repolist</div><div class="line">...</div><div class="line">mongodb-org-3.4/7                               MongoDB Repository</div><div class="line">...</div></pre></td></tr></table></figure>
<p>安装mongodb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install mongodb-org</div></pre></td></tr></table></figure>
<p>mongodb-org将包含mongodb-org-server、mongodb-org-mongos、mongodb-org-shell、mongodb-org-tools</p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo chkconfig mongod on   </div><div class="line">sudo service mongod start    </div><div class="line">netstat -tunpl | grep 27017</div></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service mongod stop</div></pre></td></tr></table></figure>
<p>移除包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum erase $(rpm -qa | grep mongodb-org)</div></pre></td></tr></table></figure>
<p>移除数据和日志文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo rm -r /var/log/mongodb   </div><div class="line">sudo rm -r /var/lib/mongo</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> monitor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[客户端rbd环境检查]]></title>
      <url>http://xiaqunfeng.cc/2018/03/08/%E5%AE%A2%E6%88%B7%E7%AB%AFrbd%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5/</url>
      <content type="html"><![CDATA[<p>检查rbd客户端是否可以正常识别文件系统<br><a id="more"></a></p>
<h2 id="应付的场景"><a href="#应付的场景" class="headerlink" title="应付的场景"></a>应付的场景</h2><p>  编译10.2.6和11.2.1版本的rbd，执行发现，在sysfs_write_rbd_add(buf)步中(该块设备已经被文件系统xfs格式化)，创建的/run/udev/data/b251\:0都为异常状态，ID_FS_TYPE字段为空。执行mount都可以正常挂载。<br>  实际上，通过apt-get install ceph-common的rbd存在异常，而apt-get install ceph的rbd表现正常(ceph-deploy部署的rbd是通过apt-get install ceph实现的)。<br>这个异常与rbd源代码没关系，而是与安装的方式有关，这可能是有组件的依赖有关系。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>暂时无法从rbd代码层面定位问题，通过提供工具检测暂时绕过这个问题。<br>ceph-client-rbd-env-check.py可以协助检查rbd客户端是否可以正常识别文件系统。在rbd环境就绪后，可以运行脚本执行检查。</p>
<p>在rbd环境就绪后，可以运行脚本执行检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># python ceph-client-rbd-env-check.py</div><div class="line">EXAMPLE:</div><div class="line">python ceph-client-rbd-env-check.py $&#123;pool_name&#125;</div><div class="line"></div><div class="line"># python ceph-client-rbd-env-check.py rbd</div><div class="line">[PASS] get device fstype okay.</div></pre></td></tr></table></figure>
<p>脚本下载链接：<a href="https://github.com/xiaqunfeng/ceph-ansible/blob/master/tools/ceph-client-rbd-env-check.py" target="_blank" rel="external">ceph-client-rbd-env-check.py</a></p>
<h3 id="异常情形"><a href="#异常情形" class="headerlink" title="异常情形"></a>异常情形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># cat /run/udev/data/b251\:0 </div><div class="line">S:rbd/rbd/rbd0</div><div class="line">I:162920386411</div><div class="line">E:ID_FS_TYPE=</div><div class="line">G:systemd</div><div class="line"></div><div class="line"># python ceph-client-env-rbd-test.py rbd</div><div class="line">[FAIL] cmd=&apos;lsblk -nd -o FSTYPE /dev/rbd0&apos;, desc=&apos;get device fstype&apos;</div></pre></td></tr></table></figure>
<h3 id="正常情形"><a href="#正常情形" class="headerlink" title="正常情形"></a>正常情形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># cat /run/udev/data/b251\:0 </div><div class="line">S:rbd/rbd/rbd0</div><div class="line">I:163204714535</div><div class="line">E:ID_FS_UUID=d0296c84-56d7-4adb-89b1-9f60c6a54309</div><div class="line">E:ID_FS_UUID_ENC=d0296c84-56d7-4adb-89b1-9f60c6a54309</div><div class="line">E:ID_FS_TYPE=xfs</div><div class="line">E:ID_FS_USAGE=filesystem</div><div class="line">G:systemd</div><div class="line"></div><div class="line"># python ceph-client-env-rbd-test.py rbd</div><div class="line">[PASS] get device fstype okay.</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rbd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph osd权重调整]]></title>
      <url>http://xiaqunfeng.cc/2018/03/08/ceph-osd%E6%9D%83%E9%87%8D%E8%B0%83%E6%95%B4/</url>
      <content type="html"><![CDATA[<p>介绍调整何时该调整权重，以及调整权重的方法。<br><a id="more"></a></p>
<h2 id="为什么要调整权重？"><a href="#为什么要调整权重？" class="headerlink" title="为什么要调整权重？"></a>为什么要调整权重？</h2><p>ceph是一个去中心化的分布式存储系统，其数据的分布是按照<a href="[https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf](https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf">crush算法</a>)计算得到。</p>
<p>然而遗憾的是crush算法并不能将pg均匀的分布于osd之间。以某三副本pool有1024个pg，共1024*3=3072个pg在30个osd中的分布为例：</p>
<table>
<thead>
<tr>
<th>osd编号</th>
<th>28</th>
<th>22</th>
<th>3</th>
<th>12</th>
<th>7</th>
<th>23</th>
<th>20</th>
<th>13</th>
<th>16</th>
<th>4</th>
<th>2</th>
<th>14</th>
<th>9</th>
<th>8</th>
<th>24</th>
<th>18</th>
<th>17</th>
<th>11</th>
<th>6</th>
<th>21</th>
<th>0</th>
<th>27</th>
<th>10</th>
<th>1</th>
<th>25</th>
<th>29</th>
<th>19</th>
<th>26</th>
<th>15</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>pg数目</td>
<td>112</td>
<td>112</td>
<td>110</td>
<td>110</td>
<td>109</td>
<td>109</td>
<td>109</td>
<td>109</td>
<td>107</td>
<td>106</td>
<td>106</td>
<td>106</td>
<td>105</td>
<td>105</td>
<td>105</td>
<td>105</td>
<td>104</td>
<td>104</td>
<td>101</td>
<td>101</td>
<td>99</td>
<td>98</td>
<td>98</td>
<td>97</td>
<td>94</td>
<td>93</td>
<td>92</td>
<td>91</td>
<td>89</td>
<td>86</td>
</tr>
<tr>
<td>剩余比例(%)</td>
<td>5</td>
<td>5</td>
<td>6.7</td>
<td>6.7</td>
<td>7.6</td>
<td>7.6</td>
<td>7.6</td>
<td>7.6</td>
<td>9.4</td>
<td>10.3</td>
<td>10.3</td>
<td>10.3</td>
<td>11.2</td>
<td>11.2</td>
<td>11.2</td>
<td>11.2</td>
<td>12.1</td>
<td>12.1</td>
<td>14.8</td>
<td>14.8</td>
<td>16.6</td>
<td>17.5</td>
<td>17.5</td>
<td>18.3</td>
<td>21.1</td>
<td>22.0</td>
<td>22.9</td>
<td>23.8</td>
<td>25.5</td>
<td>28.2</td>
</tr>
</tbody>
</table>
<p>该pg数目分布的方差达到7，平均值是102.4。</p>
<p>这么分布的缺点有两个：</p>
<ul>
<li>无法充分利用空间。集群会更早的达到full报警，full之后，在full-osd上的pg将停止写入。full的警报在某个osd达到95%时报出，按照上面表格的数据，最早达到的是osd.28，osd.28写到95%时，按照pg分布的比例，各个osd此时的剩余比例如上，整个集群的剩余空间比例在13.3%。而如果pg数目的分布在[101, 105]之间，某osd达到95%时，整个集群的剩余比例在6%，可见，pg均匀分布会更充分利用空间。</li>
<li>pg分布多的osd将成为性能瓶颈。这个结论显而易见，当pg分布多时，iops就高，因此pg分布均匀能消除系统性能瓶颈。</li>
</ul>
<h2 id="什么时候调整权重？"><a href="#什么时候调整权重？" class="headerlink" title="什么时候调整权重？"></a>什么时候调整权重？</h2><p>一些公开的分享常常提及在集群空间报警时调整权重，实际上我更推荐在集群刚刚建立时即可调整权重，均衡pg分布。这样的好处有两个：</p>
<ul>
<li>新建立的集群没有数据，pg迁移时负担小。老集群迁移数据成本高，且会对应用产生性能影响。</li>
<li>更早的消除了性能瓶颈。</li>
</ul>
<h2 id="如何调整权重？"><a href="#如何调整权重？" class="headerlink" title="如何调整权重？"></a>如何调整权重？</h2><p>我们使用 <code>ceph osd crush reweight osd.N float_weight</code> 来调整某个pool的pg分布来实现均衡分布。我们建议ceph集群中一个ruleset只有一个主力pool，我们将调整这个主力pool的分布实现均衡。举个例子：</p>
<ul>
<li>对象存储。其主力使用的pool为data。如果把index pool放置在其他ruleset(该ruleset与data pool的ruleset不共享osd)上，则index pool也可以调整权重实现index pool pg均衡分布;</li>
<li>块存储。其主力使用的pool是rbd。</li>
<li>对象存储和块存储共享集群，此时建议分布于不同的osd集合，使用不同的ruleset。</li>
</ul>
<p>对于一个pool_id=10的pg分布调整，步骤如下：</p>
<ol>
<li>使用 <code>ceph pg dump|grep &#39;^10\.&#39; |awk &#39;{print $15}&#39; |python pg_stat.py|sort -k2 -rn</code> 得到分布统计</li>
<li>通过方差查看均衡效果：<code>ceph pg dump|grep &#39;^10\.&#39; |awk &#39;{print $15}&#39; | python pg_stat.py |sort -k2 -rn|awk &#39;{print $2}&#39;|python dispersion.py</code></li>
<li>通过 <code>python ceph-reweight.py {osd编号} {float权重}</code>来调整某个osd的权重。每次调整权重建议为osd权重的5%粒度。</li>
<li>等待所有pg进入active状态；</li>
<li>回到第2步查看方差，确认效果，效果不好可以撤销上次调整；继续调整则回到1，选择需要调整的节点。</li>
</ol>
<p>结束的时机选择在 <code>方差/avg_pg_num_per_osd &lt; 3</code> 时可以结束。</p>
<h2 id="有没有更好的办法？"><a href="#有没有更好的办法？" class="headerlink" title="有没有更好的办法？"></a>有没有更好的办法？</h2><p>ceph osd reweight-by-pg的方式早期可能有所效果，但是调整到一定程度时不够彻底，不如手动直接。</p>
<p>后续研究下crushtool，通过离线计算的方式直接得出权重，然后直接reweight osd一步到位。先提供手动方式凑合用。</p>
<p>脚本地址：<a href="https://github.com/xiaqunfeng/ceph-ansible/tree/master/tools/ceph-pg-reweight" target="_blank" rel="external">https://github.com/xiaqunfeng/ceph-ansible/tree/master/tools/ceph-pg-reweight</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> osd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph luminous最佳部署实践]]></title>
      <url>http://xiaqunfeng.cc/2018/03/04/ceph-luminous%E6%9C%80%E4%BD%B3%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>luminous版本ceph最佳部署实践，分别指定rocksdb、osd数据及元数据磁盘位置，最大化集群性能。<br><a id="more"></a></p>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>每个OSD对应需要4个磁盘分区（简单起见在一块磁盘上分的四个区）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  436K  0 rom</div><div class="line">vda    253:0    0   20G  0 disk</div><div class="line">├─vda1 253:1    0    2M  0 part</div><div class="line">├─vda2 253:2    0  500M  0 part /boot</div><div class="line">└─vda3 253:3    0 19.5G  0 part /</div><div class="line">vdd    253:48   0   50G  0 disk</div><div class="line">├─vdd1 253:49   0 1023M  0 part </div><div class="line">├─vdd2 253:50   0   10G  0 part</div><div class="line">├─vdd3 253:51   0   10G  0 part</div><div class="line">└─vdd4 253:52   0   29G  0 part</div></pre></td></tr></table></figure>
<p>四个分区分别用于：</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>功能</th>
<th>磁盘介质</th>
<th>推荐大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/vdd1</td>
<td>OSD元数据存放</td>
<td>SSD</td>
<td>1G</td>
</tr>
<tr>
<td>/dev/vdd2</td>
<td>rocksdb数据存放</td>
<td>SSD</td>
<td></td>
</tr>
<tr>
<td>/dev/vdd3</td>
<td>rocksdb wal</td>
<td>SSD</td>
<td>5G</td>
</tr>
<tr>
<td>/dev/vdd4</td>
<td>实际数据存放</td>
<td>SATA</td>
<td>单块SATA盘</td>
</tr>
</tbody>
</table>
<h2 id="安装ceph"><a href="#安装ceph" class="headerlink" title="安装ceph"></a>安装ceph</h2><p><strong>注意：先不要安装OSD</strong></p>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum blue0,blue1,blue2</div><div class="line">    mgr: blue0(active)</div><div class="line">    osd: 0 osds: 0 up, 0 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   0 pools, 0 pgs</div><div class="line">    objects: 0 objects, 0 bytes</div><div class="line">    usage:   0 kB used, 0 kB / 0 kB avail</div><div class="line">    pgs:</div></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>1、修改配置文件 ceph.conf 中关于 osd 的部分，为每个OSD的不同部分指定磁盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">[osd]</div><div class="line">osd mkfs type = xfs</div><div class="line">osd mkfs options xfs = -f -i size=2048</div><div class="line">osd mount options xfs = noatime,largeio,inode64,swalloc</div><div class="line">osd journal size = 5120</div><div class="line"></div><div class="line">osd objectstore = bluestore</div><div class="line">bluestore = true</div><div class="line">bluestore fsck on mount = true</div><div class="line">bluestore block create = true</div><div class="line">bluestore block db size = 67108864</div><div class="line">bluestore block db create = true</div><div class="line">bluestore block wal size = 134217728</div><div class="line">bluestore block wal create =true</div><div class="line"></div><div class="line">[osd.0]</div><div class="line">host = luminous0</div><div class="line">osd data = /var/lib/ceph/osd/ceph-0</div><div class="line">bluestore block db path = /dev/vdd2</div><div class="line">bluestore block wal path = /dev/vdd3</div><div class="line">bluestore block path = /dev/vdd4</div><div class="line"></div><div class="line">[osd.1]</div><div class="line">host = luminous1</div><div class="line">osd data = /var/lib/ceph/osd/ceph-1</div><div class="line">bluestore block db path = /dev/vdd2</div><div class="line">bluestore block wal path = /dev/vdd3</div><div class="line">bluestore block path = /dev/vdd4</div><div class="line"></div><div class="line">[osd.2]</div><div class="line">host = luminous2</div><div class="line">osd data = /var/lib/ceph/osd/ceph-2</div><div class="line">bluestore block db path = /dev/vdd2</div><div class="line">bluestore block wal path = /dev/vdd3</div><div class="line">bluestore block path = /dev/vdd4</div></pre></td></tr></table></figure>
<ul>
<li>db path为rocksdb 存放数据的位置</li>
<li>wal path 为rocksdb的原子操作位置</li>
<li>block path 为实际数据存放的位置</li>
<li>/dev/vdd1 作为osd的元数据存放位置</li>
</ul>
<p>2、重启 ceph-mon 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart ceph-mon.target</div></pre></td></tr></table></figure>
<h2 id="手动安装OSD"><a href="#手动安装OSD" class="headerlink" title="手动安装OSD"></a>手动安装OSD</h2><p>例如，手动安装 osd.1 步骤如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/ceph/osd/ceph-1</div><div class="line">mkfs -t xfs -d name=/dev/vdd1 -f</div><div class="line">mount -noatime /dev/vdd1 /var/lib/ceph/osd/ceph-1</div><div class="line">chown ceph:ceph /var/lib/ceph/osd/ceph-1</div><div class="line"></div><div class="line">ceph osd crush add-bucket luminous1 host</div><div class="line">ceph osd crush move luminous1 root=default</div><div class="line"></div><div class="line">ceph osd create</div><div class="line">ceph-osd -i 1 --mkfs --mkkey</div><div class="line">ceph auth add osd.1 osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-1/keyring</div><div class="line">ceph osd crush add osd.1 0.04 host=luminous1</div><div class="line">ceph osd in 1</div><div class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-1</div><div class="line">systemctl start ceph-osd@1</div></pre></td></tr></table></figure>
<p>安装完后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ll /var/lib/ceph/osd/ceph-0</div><div class="line">总用量 40</div><div class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block -&gt; /dev/vdd4</div><div class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block.db -&gt; /dev/vdd2</div><div class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block.wal -&gt; /dev/vdd3</div><div class="line">-rw-r--r--. 1 ceph ceph  2 7月  24 18:13 bluefs</div><div class="line">-rw-r--r--. 1 ceph ceph 37 7月  24 18:13 ceph_fsid</div><div class="line">-rw-r--r--. 1 ceph ceph 37 7月  24 18:13 fsid</div><div class="line">-rw-------. 1 ceph ceph 56 7月  24 18:13 keyring</div><div class="line">-rw-r--r--. 1 ceph ceph  8 7月  24 18:13 kv_backend</div><div class="line">-rw-r--r--. 1 ceph ceph 21 7月  24 18:13 magic</div><div class="line">-rw-r--r--. 1 ceph ceph  4 7月  24 18:13 mkfs_done</div><div class="line">-rw-r--r--. 1 ceph ceph  6 7月  24 18:13 ready</div><div class="line">-rw-r--r--. 1 ceph ceph 10 7月  24 18:13 type</div><div class="line">-rw-r--r--. 1 ceph ceph  2 7月  24 18:13 whoami</div></pre></td></tr></table></figure>
<p>如果不更改配置，为OSD分别指定磁盘，安装完后的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ll /var/lib/ceph/osd/ceph-0/</div><div class="line">总用量 484</div><div class="line">-rw-r--r--. 1 root root         429 7月  25 10:59 activate.monmap</div><div class="line">-rw-r--r--. 1 ceph ceph           3 7月  25 10:59 active</div><div class="line">-rw-r--r--. 1 ceph ceph 10737418240 7月  25 10:59 block</div><div class="line">-rw-r--r--. 1 ceph ceph           2 7月  25 10:59 bluefs</div><div class="line">-rw-r--r--. 1 ceph ceph          37 7月  25 10:59 ceph_fsid</div><div class="line">-rw-r--r--. 1 ceph ceph          37 7月  25 10:59 fsid</div><div class="line">-rw-------. 1 ceph ceph          56 7月  25 10:59 keyring</div><div class="line">-rw-r--r--. 1 ceph ceph           8 7月  25 10:59 kv_backend</div><div class="line">-rw-r--r--. 1 ceph ceph          21 7月  25 10:59 magic</div><div class="line">-rw-r--r--. 1 ceph ceph           4 7月  25 10:59 mkfs_done</div><div class="line">-rw-r--r--. 1 ceph ceph           6 7月  25 10:59 ready</div><div class="line">-rw-r--r--. 1 ceph ceph           0 7月  25 10:59 systemd</div><div class="line">-rw-r--r--. 1 ceph ceph          10 7月  25 10:59 type</div><div class="line">-rw-r--r--. 1 ceph ceph           2 7月  25 10:59 whoami</div></pre></td></tr></table></figure>
<p>部署完后磁盘情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  436K  0 rom</div><div class="line">vda    253:0    0   20G  0 disk</div><div class="line">├─vda1 253:1    0    2M  0 part</div><div class="line">├─vda2 253:2    0  500M  0 part /boot</div><div class="line">└─vda3 253:3    0 19.5G  0 part /</div><div class="line">vdd    253:48   0   50G  0 disk</div><div class="line">├─vdd1 253:49   0 1023M  0 part /var/lib/ceph/osd/ceph-0</div><div class="line">├─vdd2 253:50   0   10G  0 part</div><div class="line">├─vdd3 253:51   0   10G  0 part</div><div class="line">└─vdd4 253:52   0   29G  0 part</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> luminous </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph iscsi网关]]></title>
      <url>http://xiaqunfeng.cc/2018/02/28/ceph-iscsi%E7%BD%91%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>介绍三种iscsi target的选型：TGT、LIO、SCST。</p>
<a id="more"></a>
<p> Ceph iSCSI Gateway基本框架：<img src="http://oow6unnib.bkt.clouddn.com/ceph_iscsi_gateway.png" alt="ceph iscsi gateway"></p>
<h2 id="用户态（TGT）"><a href="#用户态（TGT）" class="headerlink" title="用户态（TGT）"></a>用户态（TGT）</h2><p>tgt是一个用户态的SCSI target框架。由于是基于用户态的框架，因此对集成同在用户态的RBD接口比较简单。</p>
<p>作为用户态框架，tgt在使用本地存储的情况下，性能相比SCST、LIO有一定差距的，如果从性能的角度考虑，tgt应该不推荐使用的，在新特性验证等方面是很合适的。</p>
<p>使用TGT的开源分布式存储项目：sheepdog 与 hlfs。</p>
<h2 id="内核态（LIO、SCST）"><a href="#内核态（LIO、SCST）" class="headerlink" title="内核态（LIO、SCST）"></a>内核态（LIO、SCST）</h2><h3 id="LIO"><a href="#LIO" class="headerlink" title="LIO"></a>LIO</h3><p>1）支持较多传输协议</p>
<p>2）代码并入linux内核，减少了手动编译内核的麻烦。</p>
<p>3）提供了python版本的编程接口rtslib。</p>
<p>4）LIO在不断backport SCST的功能到linux内核，社区的力量是强大的。</p>
<p>5）LIO也支持一些SCST没有的功能。如“会话多连接”（MC/S）。</p>
<blockquote>
<p>MC/S 让 initiator 可以和 target 在一条或多条物理路径上建立多条连接。这样，在一条路径发生错误的时候，已经建立好的会话可以不中断会话，直接使用其他的路径。MC/S 还可以用来进行所有连接之间的负载均衡。这种情况下，会在所有通信路径上保持会话命令的顺序性。</p>
</blockquote>
<p>MCS是一个比较鸡肋的feature，因为现在Linux内核已经有Device Mapper的支持。</p>
<p>6）LIO支持最高级别的ERL。</p>
<blockquote>
<p>iSCSI 连接的错误可能会发生在三个层面上：会话、校验或是连接层。错误恢复工作也可以在这三个层面开始进行，这样就可以在当前的层面开始进行恢复，不会让错误到达下一个层面。错误恢复首先是检查断开的连接。在这种情况下，iSCSI initiator 驱动会主动建立新的到 target 的 TCP 连接它会告诉 target，SCSI 指令路径已经变到新的连接上了。这样 target 就可以在新的连接上处理 SCSI 命令了。这时，上层的 SCSI 驱动对新的连接已经建立、控制信息已经通过新连接传输的事还是毫无知觉的。iSCSI 会话在这期间会保持正常，不会重新变换状态。LIO 支持的最大错误恢复级别（ERL）为2，这就是说，它可以在会话、校验或连接层进行错误恢复。而SCST 支持的 ERL 为 0，也就是说，它智能恢复会话级别的错误，所有连接层面的错误都会转到 SCSI 驱动层面来处理。</p>
</blockquote>
<h3 id="SCST"><a href="#SCST" class="headerlink" title="SCST"></a>SCST</h3><p>1）支持更多传输协议</p>
<p>2）针对性能做了特殊的优化</p>
<p>3）除了基本的SCSI协议支持外，还有一些高级支持：</p>
<p>SCST支持永久性预留（Persistent Reservation, PR）</p>
<blockquote>
<p>这是一个用于高可用集群中的存储设备的 I/O 隔离与存储设备故障切换、接管的特性。通过使用 PR 命令，initiator 可以在一个 target 上建立、抢占、查询、重置预留策略。在故障接管过程中，新的虚拟资源可以重置老的虚拟资源的预留策略，从而让故障切换更快、更容易地进行。</p>
</blockquote>
<p>SCST 可以使用异步事件通知（AEN）来通告会话状态的变更</p>
<blockquote>
<p>AEN 是一个 SCSI target 用来向 initiator 进行 target 端的事件告知的协议特性，即使在没有服务请求的时候也可以进行。于是 initiator 就可以在 target 端发生事件时，如设备插入、移除、调整尺寸或更换介质时，可以得到通知。这让 initiator 可以以即插即用的方式看到 target 的变化。</p>
</blockquote>
<p>4）SCST 的开发者声称，它们的设计在健壮性和安全性方面更加符合 SCSI 标准。</p>
<blockquote>
<p>SCSI 协议要求，如果一个 initiator 要清除另一个 initiator 的预留资源时，预留者必须要得到清除通知，否则，多个 initiator 都可能来改变预留数据，就可能会破坏数据。SCST 可以实现安全的预留、释放操作，避免类似事情发生。</p>
</blockquote>
<p>5）SCST 也支持非对称逻辑卷分配（ALUA）。</p>
<blockquote>
<p>ALUA 允许 target 管理员来管理 target 的访问状态和路径属性。这让多路径路由机制可以选择最好的路径，从而根据 target 的访问状态，优化带宽的使用。换句话说，在多路径环境下，target 管理员可以通过改变访问状态来调整 initiator 的路径。</p>
</blockquote>
<p>6）各大存储服务提供商都是基于SCST。</p>
<p>7）提供更细粒度的访问控制策略以及QoS保证机制（限制initiator连接的个数）。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>SCST和LIO，工作在内核态，缺点如下：</p>
<p>1、一旦出问题，会导致系统挂掉，直接影响跑在系统上的其他线上服务。</p>
<p>2、SCSI与LIO作为通用的SCSI Target实现，在处理完iSCSI协议后，会把SCSI的处理交给内核SCSI Driver去处理，这对支持分布式文件做二次开发来说，相对更加困难。</p>
<p>3、SCST 的kernel部分没有并入linux，需要手工编译。</p>
<p>4、LIO不支持AEN，所以target状态发生变化时，只能通过IO或者用户手动触发以检测处理变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>SCSI框架</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>TGT</td>
<td>用户态接口，可使用Ceph librbd</td>
<td>librbd 性能较差，FC驱动还不支持</td>
</tr>
<tr>
<td>LIO</td>
<td>性能好，支持用户态和内核态接口，加入linux内核</td>
<td>特性支持不如SCST</td>
</tr>
<tr>
<td>SCST</td>
<td>稳定，性能好，支持用户态和内核态接口</td>
<td>没有纳入linux内核，升级比较麻烦</td>
</tr>
</tbody>
</table>
<p>如果需求只是构建一个iSCSI target，并且规模不是很大，tgt是一个不错的选择。<br>如果要构建一个企业级的存储方案，即高性能、高稳定性的，并且围绕这个有长远计划的，SCST是正确的选择。<br>如果对性能、稳定性要求不是那么高，但又想支持FC、SRP等协议，可以选择LIO。</p>
<p><strong>参考资料</strong></p>
<p><a href="http://infinicloud.cn/blog/1/" target="_blank" rel="external">基于ceph RBD的iscsi target实现分析</a></p>
<p><a href="http://www.cnblogs.com/bodhitree/p/6016331.html" target="_blank" rel="external">iscsi与ceph</a></p>
<p><a href="http://chuansong.me/n/2297546" target="_blank" rel="external">ceph iscsi gateway demo 安装配置</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iscsi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph ansible使用手册]]></title>
      <url>http://xiaqunfeng.cc/2018/02/28/ceph-ansible%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<p>该文档介绍利用ansible来部署ceph集群<br>github：<a href="https://github.com/xiaqunfeng/ceph-ansible" target="_blank" rel="external">https://github.com/xiaqunfeng/ceph-ansible</a></p>
<a id="more"></a>
<p>新增role的使用方法详见github里的README.md</p>
<h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./install-ansible.sh</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，默认安装的是ansible的最新版，最好安装ansible版本为2.3.X.X。因为该改进的ceph-ansible是基于ansible 2.3版本的，为了避免版本不匹配带来的问题。</p>
</blockquote>
<h2 id="设置机器组"><a href="#设置机器组" class="headerlink" title="设置机器组"></a>设置机器组</h2><p>在文件 <code>/etc/ansible/hosts</code> 中添加如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># cat /etc/ansible/hosts</div><div class="line">...</div><div class="line">...</div><div class="line">[mons]</div><div class="line">ceph-0</div><div class="line">ceph-1</div><div class="line">ceph-2</div><div class="line"></div><div class="line">[osds]</div><div class="line">ceph-0</div><div class="line">ceph-1</div><div class="line">ceph-2</div><div class="line"></div><div class="line">[rgws]</div><div class="line">ceph-0</div></pre></td></tr></table></figure>
<p>mons表示将要安装mon的机器组，osds表示osd机器组，rgws表示要安装rgw网关的机器组。关于其他的机器组，可以在 <code>site.yml</code> 文件中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># cat site.yml</div><div class="line">...</div><div class="line">- hosts:</div><div class="line">  - mons</div><div class="line">  - agents</div><div class="line">  - osds</div><div class="line">  - mdss</div><div class="line">  - rgws</div><div class="line">  - nfss</div><div class="line">  - restapis</div><div class="line">  - rbdmirrors</div><div class="line">  - clients</div><div class="line">  - iscsigws</div><div class="line">  - mgrs</div><div class="line">...</div></pre></td></tr></table></figure>
<p>查看所有机器是否都能无密登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ansible -m ping all</div><div class="line">ceph-1 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">ceph-0 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">ceph-2 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>编辑配置文件：<code>group_vars/all.yml</code></p>
<p>主要修改一下几个配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"># or &apos;distro&apos; or &apos;local&apos;</div><div class="line">ceph_origin: &apos;upstream&apos;</div><div class="line">...</div><div class="line">ceph_stable: true</div><div class="line">ceph_mirror: http://mirrors.163.com/ceph</div><div class="line">ceph_stable_key: http://mirrors.163.com/ceph/keys/release.asc</div><div class="line">ceph_stable_release: kraken</div><div class="line">ceph_stable_repo: &quot;&#123;&#123; ceph_mirror &#125;&#125;/rpm-&#123;&#123; ceph_stable_release &#125;&#125;&quot;	# ubuntu系统的话记得把rpm改成debian</div><div class="line">...</div><div class="line">ceph_stable_redhat_distro: el7	# ubuntu系统不需要该选项</div><div class="line">...</div><div class="line">monitor_interface: eth0</div><div class="line">...</div><div class="line">public_network: 172.20.2.0/24</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="osd"><a href="#osd" class="headerlink" title="osd"></a>osd</h3><p>编辑配置文件：<code>group_vars/osds.yml</code></p>
<p>选择一种部署场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">journal_collocation</div><div class="line">raw_multi_journal</div><div class="line">dmcrypt_journal_collocation</div><div class="line">dmcrypt_dedicated_journal</div><div class="line">bluestore</div><div class="line">osd_directory</div></pre></td></tr></table></figure>
<p>根据不同的场景来编辑如下两个选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">devices:</div><div class="line">...</div><div class="line">raw_journal_devices:</div><div class="line">...</div></pre></td></tr></table></figure>
<p>最常用的场景解释：</p>
<p>journal_collocation：日志盘和数据盘共用一块磁盘，部署的时候不需要分区，只需要指定 devices磁盘就好。</p>
<p>raw_multi_journal：日志盘和数据盘分开指定，devices指定数据盘，raw_journal_devices指定日志盘，都是磁盘主分区。</p>
<p>bluestore：部署bluestore，只需要指定devices盘。当然最佳实践的话需要手动分4个区来部署。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>修改部署yml文件，注释掉不需要安装的选项，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># cat site.yml</div><div class="line">...</div><div class="line">- hosts: mons</div><div class="line">  gather_facts: false</div><div class="line">  become: True</div><div class="line">  roles:</div><div class="line">  - ceph-mon</div><div class="line"></div><div class="line">#- hosts: agents</div><div class="line">#  gather_facts: false</div><div class="line">#  become: True</div><div class="line">#  roles:</div><div class="line">#  - ceph-agent</div><div class="line"></div><div class="line">- hosts: osds</div><div class="line">  gather_facts: false</div><div class="line">  become: True</div><div class="line">  roles:</div><div class="line">  - ceph-osd</div><div class="line"></div><div class="line">- hosts: rgws</div><div class="line">  gather_facts: false</div><div class="line">  become: True</div><div class="line">  roles:</div><div class="line">  - ceph-rgw</div><div class="line">...</div></pre></td></tr></table></figure>
<p>通过ansible-playbook来运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ansible-playbook site.yml</div></pre></td></tr></table></figure>
<p>更多关于ansible的部署情况可以参见官方文档：<a href="https://github.com/ceph/ceph-ansible/wiki" target="_blank" rel="external">https://github.com/ceph/ceph-ansible/wiki</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Faster-R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/12/14/Faster-R-CNN/</url>
      <content type="html"><![CDATA[<p>Faster R-CNN论文阅读小笔记<br><a id="more"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>faster RCNN ~= RPN + fast RCNN</p>
<p>用RPN代替fast RCNN中的Selective Search方法</p>
<p><strong>架构图</strong></p>
<p><img src="http://img.blog.csdn.net/20170314163622365" alt="img"></p>
<p>从 Fast R-CNN 中可以发现，目标检测的时间减少了，这时候，发现生成候选框成了性能瓶颈，所以，下一个改进的两个要点就是：</p>
<ul>
<li>1、将候选框的选取也放到GPU中去实现</li>
<li>2、共享计算，共享已计算出的特征图</li>
</ul>
<p><strong>R-CNN系列的架构演变</strong></p>
<p><img src="http://img.blog.csdn.net/20160414164536029" alt="r-cnn架构对比"></p>
<p>目标检测的四个基本步骤被统一到一个大框架中，计算都在GPU中完成计算，提高了速度，同时消除了重复计算。</p>
<h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p><strong>网络结构</strong></p>
<p><img src="http://img.blog.csdn.net/20160415133947737" alt="arc"></p>
<p>用的是5层的ZF模型。</p>
<h3 id="anchor的生成"><a href="#anchor的生成" class="headerlink" title="anchor的生成"></a>anchor的生成</h3><p>遍历Conv layers计算获得的feature maps</p>
<p><img src="http://img.blog.csdn.net/20170322103903632" alt="img"></p>
<p>对于特征图中的每一个点，以该点为中心，考虑3种长宽比（1:1, 1:2, 2:1）和三种面积大小（128，256，512）共9种窗口，这些候选框即为anchors。示意图如下：</p>
<p><img src="http://img.blog.csdn.net/20170322103823615" alt="img"></p>
<p>关于anchors的生成代码如下：</p>
<p><strong><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="external">generate_anchors.py</a></strong></p>
<h3 id="Bounding-box-regression"><a href="#Bounding-box-regression" class="headerlink" title="Bounding-box regression"></a>Bounding-box regression</h3><p>如图，绿色框为飞机的Ground Truth(GT)，红色为提取的foreground anchors。这里得对红色的框进行微调，使得foreground anchors和GT更加接近。</p>
<p><img src="http://img.blog.csdn.net/20170321000420426" alt="img"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于窗口一般使用四维向量(x, y, w, h)表示，分别表示窗口的中心点坐标和宽高。</p>
<p>如下图所示，红色的框A代表原始的Foreground Anchors，绿色的框G代表目标的GT。这里要使得输入A经过映射得到一个跟真实窗口G更接近的回归窗口G’。</p>
<p><img src="http://img.blog.csdn.net/20170321221228658" alt="img"></p>
<p>给定：anchor A=(Ax, Ay, Aw, Ah)，GT=[Gx, Gy, Gw, Gh]</p>
<p>寻找变换<strong>F</strong>：<strong>F</strong>(Ax, Ay, Aw, Ah)=(G’x, G’y, G’w, G’h)</p>
<p>其中：(G’x, G’y, G’w, G’h)≈(Gx, Gy, Gw, Gh)</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、平移</p>
<p><img src="http://img.blog.csdn.net/20170322104630982" alt="img"></p>
<p>2、缩放</p>
<p><img src="http://img.blog.csdn.net/20170322104634390" alt="img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/fast_rcnn/bbox_transform.py" target="_blank" rel="external">bbox_transform.py</a></p>
<p>函数：bbox_transform_inv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">def bbox_transform_inv(boxes, deltas):</div><div class="line">    if boxes.shape[0] == 0:</div><div class="line">        return np.zeros((0, deltas.shape[1]), dtype=deltas.dtype)</div><div class="line"></div><div class="line">    boxes = boxes.astype(deltas.dtype, copy=False)</div><div class="line"></div><div class="line">    widths = boxes[:, 2] - boxes[:, 0] + 1.0</div><div class="line">    heights = boxes[:, 3] - boxes[:, 1] + 1.0</div><div class="line">    ctr_x = boxes[:, 0] + 0.5 * widths</div><div class="line">    ctr_y = boxes[:, 1] + 0.5 * heights</div><div class="line"></div><div class="line">    dx = deltas[:, 0::4]</div><div class="line">    dy = deltas[:, 1::4]</div><div class="line">    dw = deltas[:, 2::4]</div><div class="line">    dh = deltas[:, 3::4]</div><div class="line"></div><div class="line">    pred_ctr_x = dx * widths[:, np.newaxis] + ctr_x[:, np.newaxis]</div><div class="line">    pred_ctr_y = dy * heights[:, np.newaxis] + ctr_y[:, np.newaxis]</div><div class="line">    pred_w = np.exp(dw) * widths[:, np.newaxis]</div><div class="line">    pred_h = np.exp(dh) * heights[:, np.newaxis]</div><div class="line"></div><div class="line">    pred_boxes = np.zeros(deltas.shape, dtype=deltas.dtype)</div><div class="line">    # x1</div><div class="line">    pred_boxes[:, 0::4] = pred_ctr_x - 0.5 * pred_w</div><div class="line">    # y1</div><div class="line">    pred_boxes[:, 1::4] = pred_ctr_y - 0.5 * pred_h</div><div class="line">    # x2</div><div class="line">    pred_boxes[:, 2::4] = pred_ctr_x + 0.5 * pred_w</div><div class="line">    # y2</div><div class="line">    pred_boxes[:, 3::4] = pred_ctr_y + 0.5 * pred_h</div><div class="line"></div><div class="line">    return pred_boxes</div></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>RPN和Fast R-CNN都是独立训练的，要用不同方式修改它们的卷积层。因此需要开发一种允许两个网络间共享卷积层的技术，而不是分别学习两个网络。</p>
<p>论文中给出了三种训练具有共享特征的网络的解决方案：</p>
<p>1、交替训练</p>
<p>先训练RPN，并使用提案训练Fast R-CNN。然后，使用Fast R-CNN微调过后的网络初始化RPN，并重复此过程。这是论文中所有实验所使用的解决方案。</p>
<p>2、近似联合训练</p>
<p>RPN和Fast R-CNN网络在训练期间被合并到一个网络中。forward过程中，region proposal固定，训练Fast R-CNN。backward过程中，共享层包含RPN和Fast R-CNN两部分的损失。</p>
<p>忽略了衍生的w.r.t.提案框的坐标也是网络响应，所以产生的结果是近似。但与交替训练相比，训练时间减少了约25-50％。</p>
<p>3、非近似联合训练</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>源码地址：</p>
<p><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/tools/train_faster_rcnn_alt_opt.py" target="_blank" rel="external">train_faster_rcnn_alt_opt.py</a></p>
<p>根据代码，提取并总结的步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. Stage 1 RPN, init from ImageNet model (M0 -&gt; M1)</div><div class="line">2. Stage1 RPN, generate proposals (M1 -&gt; P1)</div><div class="line">3. Stage1 Fast R-CNN using RPN  proposals, init from ImageNet model (M0, P1 -&gt; M2)</div><div class="line">4. Stage2 RPN, init from stage 1 Fast R-CNN model (M2 -&gt; M3)</div><div class="line">5. Stage2 RPN, generate proposals (M3 -&gt; P2)</div><div class="line">6. Stage2 Fast R-CNN, init from stage 2 RPN R-CNN model (M3,P2 -&gt; M4)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【代码阅读】generate_anchors.py]]></title>
      <url>http://xiaqunfeng.cc/2017/12/05/faster-r-cnn-generate-anchors/</url>
      <content type="html"><![CDATA[<p>阅读Faster R-CNN里产生anchors的代码。<br><a id="more"></a></p>
<p>原代码地址：<a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="external">https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py</a></p>
<p>注释代码地址：<a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="external">https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py</a></p>
<h2 id="generate-anchors-py"><a href="#generate-anchors-py" class="headerlink" title="generate_anchors.py"></a>generate_anchors.py</h2><p>功能：生成多尺度多宽高比的anchors</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"># --------------------------------------------------------</div><div class="line"># Faster R-CNN</div><div class="line"># Copyright (c) 2015 Microsoft</div><div class="line"># Licensed under The MIT License [see LICENSE for details]</div><div class="line"># Written by Ross Girshick and Sean Bell</div><div class="line"># --------------------------------------------------------</div><div class="line"></div><div class="line">import numpy as np</div><div class="line"></div><div class="line"># Verify that we compute the same anchors as Shaoqing&apos;s matlab implementation:</div><div class="line">#</div><div class="line">#    &gt;&gt; load output/rpn_cachedir/faster_rcnn_VOC2007_ZF_stage1_rpn/anchors.mat</div><div class="line">#    &gt;&gt; anchors</div><div class="line">#</div><div class="line">#    anchors =</div><div class="line">#</div><div class="line">#       -83   -39   100    56</div><div class="line">#      -175   -87   192   104</div><div class="line">#      -359  -183   376   200</div><div class="line">#       -55   -55    72    72</div><div class="line">#      -119  -119   136   136</div><div class="line">#      -247  -247   264   264</div><div class="line">#       -35   -79    52    96</div><div class="line">#       -79  -167    96   184</div><div class="line">#      -167  -343   184   360</div><div class="line"></div><div class="line">#array([[ -83.,  -39.,  100.,   56.],</div><div class="line">#       [-175.,  -87.,  192.,  104.],</div><div class="line">#       [-359., -183.,  376.,  200.],</div><div class="line">#       [ -55.,  -55.,   72.,   72.],</div><div class="line">#       [-119., -119.,  136.,  136.],</div><div class="line">#       [-247., -247.,  264.,  264.],</div><div class="line">#       [ -35.,  -79.,   52.,   96.],</div><div class="line">#       [ -79., -167.,   96.,  184.],</div><div class="line">#       [-167., -343.,  184.,  360.]])</div><div class="line"></div><div class="line"># base_size =16 是因为从conv4层出来的最小的检测大小是16个像素</div><div class="line"># 在 fast_rcnn/config.py中有定义：__C.TRAIN.RPN_MIN_SIZE = 16</div><div class="line"># ratios 是宽高比，即 w:h = 1:2, 1:1, 2:1</div><div class="line"># scales = 8, 16, 32</div><div class="line"># [0，0，15，15]这四个数分别表示[x_l,y_l,x_r,y_r]，表示左上角和右下角的坐标</div><div class="line">def generate_anchors(base_size=16, ratios=[0.5, 1, 2],</div><div class="line">                     scales=2**np.arange(3, 6)):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Generate anchor (reference) windows by enumerating aspect ratios X</div><div class="line">    scales wrt a reference (0, 0, 15, 15) window.</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    base_anchor = np.array([1, 1, base_size, base_size]) - 1  #初始基准anchor[0，0，15，15]</div><div class="line">    ratio_anchors = _ratio_enum(base_anchor, ratios)  #枚举三种宽高比，得到3*4维anchor矩阵</div><div class="line">    #垂直方向上堆叠数组</div><div class="line">    anchors = np.vstack([_scale_enum(ratio_anchors[i, :], scales)</div><div class="line">                         for i in xrange(ratio_anchors.shape[0])]) #读取矩阵第一维大小，为3</div><div class="line">    return anchors</div><div class="line"></div><div class="line"># 根据输入的anchor[x,y,w,h]，返回宽、高、中心坐标：w,h,(x_ctr, y_ctr)</div><div class="line">def _whctrs(anchor):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Return width, height, x center, and y center for an anchor (window).</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    w = anchor[2] - anchor[0] + 1  #anchor里第三个值减去第一个值得到w</div><div class="line">    h = anchor[3] - anchor[1] + 1  #anchor里第四个值减去第二个值得到h</div><div class="line">    x_ctr = anchor[0] + 0.5 * (w - 1)  #通过左下角的点和w、h得到中心点</div><div class="line">    y_ctr = anchor[1] + 0.5 * (h - 1)</div><div class="line">    return w, h, x_ctr, y_ctr</div><div class="line"></div><div class="line"># 给定一组宽高向量，输出向量维度个数个anchor</div><div class="line">def _mkanchors(ws, hs, x_ctr, y_ctr):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Given a vector of widths (ws) and heights (hs) around a center</div><div class="line">    (x_ctr, y_ctr), output a set of anchors (windows).</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    ws = ws[:, np.newaxis]  #将数组转置成 X*1 维的矩阵，X为ws数组中元素的个数</div><div class="line">    hs = hs[:, np.newaxis]</div><div class="line">    anchors = np.hstack((x_ctr - 0.5 * (ws - 1),  #水平方向上将数组堆叠起来，得到一个X*4维的矩阵</div><div class="line">                         y_ctr - 0.5 * (hs - 1),  #[[-3.5,  2, 18.5, 13]</div><div class="line">                         x_ctr + 0.5 * (ws - 1),  # [   0,  0,   15, 15]</div><div class="line">                         y_ctr + 0.5 * (hs - 1))) # [ 2.5, -3, 12.5, 18]]</div><div class="line">    return anchors</div><div class="line"></div><div class="line"># 枚举一个anchor的三种宽高比，ratios[0.5，1，2]</div><div class="line">def _ratio_enum(anchor, ratios):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Enumerate a set of anchors for each aspect ratio wrt an anchor.</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor) #得到框、高、中心点</div><div class="line">    size = w * h  </div><div class="line">    size_ratios = size / ratios          #[512，256，128]</div><div class="line">    ws = np.round(np.sqrt(size_ratios))  #[23，16，11]</div><div class="line">    hs = np.round(ws * ratios)           #[12，16，22]</div><div class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr) #输出三个预测窗口</div><div class="line">    return anchors</div><div class="line"></div><div class="line"># 枚举输入anchor的三种尺度，scales[8，16，32]</div><div class="line">def _scale_enum(anchor, scales):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Enumerate a set of anchors for each scale wrt an anchor.</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</div><div class="line">    ws = w * scales  #同比例扩大宽高</div><div class="line">    hs = h * scales</div><div class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</div><div class="line">    return anchors</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import time</div><div class="line">    t = time.time()</div><div class="line">    a = generate_anchors()  #入口函数</div><div class="line">    print time.time() - t</div><div class="line">    print a</div><div class="line">    from IPython import embed; embed()</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Fast R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/11/25/Fast-R-CNN/</url>
      <content type="html"><![CDATA[<p>Fast R-CNN 是 RBG大神基于R-CNN的优化，论文阅读记录如下。<br><a id="more"></a></p>
<p>源码：<a href="https://github.com/rbgirshick/fast-rcnn" target="_blank" rel="external">https://github.com/rbgirshick/fast-rcnn</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简化了最先进的基于卷积网络的目标检测器的训练过程（R-CNN）。提出一个单阶段训练算法，联合学习候选框分类和修正他们的空间位置。</p>
<p>所得到的方法用来训练非常深的检测网络（例如VGG16） 比R-CNN快9倍，比SPPnet快3倍。在运行时，检测网络在PASCAL VOC 2012数据集上实现最高准确度，其中mAP为66％（R-CNN为62％），每张图像处理时间为0.3秒，不包括候选框的生成。测试时间比R-CNN快213倍。</p>
<h3 id="R-CNN缺点："><a href="#R-CNN缺点：" class="headerlink" title="R-CNN缺点："></a>R-CNN缺点：</h3><p>1、训练过程是多级流水线（multi-stage pipeline）</p>
<ul>
<li>R-CNN首先使用目标候选框对卷积神经网络使用log损失进行微调。</li>
<li>然后，它将卷积神经网络得到的特征送入SVM。 这些SVM作为目标检测器，替代通过微调学习的softmax分类器。 </li>
<li>在第三个训练阶段，学习检测框回归。</li>
</ul>
<p>2、训练时时间和空间开销大</p>
<p>对于SVM和检测框回归训练，从每个图像中的每个目标候选框提取特征，并写入磁盘。对于非常深的网络，如VGG16，这个过程在单个GPU上需要2.5天（VOC07 trainval上的5k个图像）。这些特征需要数百GB的存储空间。</p>
<p>3、目标检测速度慢</p>
<p>在测试时，从每个测试图像中的每个目标候选框提取特征。用VGG16网络检测目标每个图像需要47秒（在GPU上）。</p>
<p>R-CNN很慢是因为它为每个目标候选框进行卷积神经网络正向传递，而不共享计算。</p>
<p><strong>因为是分阶段训练，训练SVM和bbox回归时无法更新前面CNN的参数，模型精度上不去。</strong></p>
<h3 id="SPPnet"><a href="#SPPnet" class="headerlink" title="SPPnet"></a>SPPnet</h3><p>SPPnet通过共享计算加速R-CNN。SPPnet计算整个输入图像的卷积特征图，然后使用从共享特征图提取的特征向量来对每个候选框进行分类。通过最大池化将候选框内的特征图转化为固定大小的输出（例如，6X6）来提取针对候选框的特征。多个输出被池化，然后连接成空间金字塔池。SPPnet在测试时将R-CNN加速10到100倍。由于更快的候选框特征提取训练时间也减少3倍。</p>
<p>缺点：</p>
<ul>
<li>分阶段训练网络：选取候选区域、训练CNN、训练SVM、训练bbox回归器.</li>
<li>特征需要写入磁盘</li>
<li>训练SVM，bbox回归时算法不能更新卷积层的参数，这会影响网络的精度</li>
</ul>
<h3 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h3><p>针对上述问题，Fast R-CNN的想法是将整个模型分成两步：</p>
<ul>
<li>第一步是选取候选区域;</li>
<li>第二步就是提出一个RoI层，整合了整个模型，把CNN、变换层、SVM分类器、bbox回归这几个模块整一起，大家一起训练</li>
</ul>
<p>新的模型将多个训练阶段合并，训练后面阶段的同时可以更新前面阶段的参数，模型收敛的更好了。同时因为多个阶段合并，候选区域的特征不需要再写入磁盘，一直在显存中，训练的速度大大的提升。</p>
<h2 id="architecture-and-training"><a href="#architecture-and-training" class="headerlink" title="architecture and training"></a>architecture and training</h2><p>架构图：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/fastrcnn.jpg" alt="fastrcnn"></p>
<p>Fast R-CNN网络将整个图像和一组候选框作为输入。</p>
<p>1、网络首先使用几个卷积层（conv）和最大池化层来处理整个图像，以产生卷积特征图。</p>
<p>2、然后，对于每个候选框，RoI池化层从特征图中提取固定长度的特征向量。</p>
<p>把图片的候选区域映射到feature map得到对应的patch(这和SPPNet的处理类似)。然后把这个patch塞给ROI层(Region of interest)得到固定大小的的特征向量(feature vector).</p>
<p>3、每个特征向量被送入一系列全连接（fc）层中，其最终分支成两个同级输出层 ：</p>
<ul>
<li>一个输出K个类别加上1个背景类别的Softmax概率估计</li>
<li>另一个作为bbox回归，输出回归的选框数据。即为K个类别的每一个类别输出四个实数值。每组4个值表示K个类别的一个类别的检测框位置的修正。</li>
</ul>
<h3 id="ROI-pooling-layer"><a href="#ROI-pooling-layer" class="headerlink" title="ROI pooling layer"></a>ROI pooling layer</h3><p>作用：把不同尺寸的侯选区域提取特征变换成为固定大小的特征向量</p>
<p>每个RoI由指定其左上角(r,c)及其高度和宽度(h,w)的四元组(r,c,h,w)定义。</p>
<p>RoI最大池化通过将大小为 h×w 的RoI窗口分割成 H×W 个网格，子窗口大小约 h/H×w/W，然后对每个子窗口执行最大池化，并将输出合并到相应的输出网格单元中。其中 H 和 W 是层的超参数，独立于任何特定的RoI。</p>
<p>通过该层，可以将特征图上大小不一的候选区域转变为大小统一的数据，送入下一层。 </p>
<h3 id="fine-tuning-for-detection-检测微调"><a href="#fine-tuning-for-detection-检测微调" class="headerlink" title="fine-tuning for detection(检测微调)"></a>fine-tuning for detection(检测微调)</h3><p>用反向传播训练所有网络权重是Fast R-CNN的重要能力。</p>
<p>1、为什么SPPnet无法更新低于空间金字塔池化层的权重？</p>
<p>根本原因是当每个训练样本（即RoI）来自不同的图像时，通过SPP层的反向传播是非常低效的，这正是训练R-CNN和SPPnet网络的方法。低效的部分是因为每个RoI可能具有非常大的感受野，通常跨越整个输入图像。由于正向传播必须处理整个感受野，训练输入很大（通常是整个图像）。</p>
<p>2、提出了一种更有效的训练方法：利用训练期间的特征共享</p>
<p><strong>分层采样</strong></p>
<p>在Fast RCNN网络训练中，随机梯度下降（SGD）的小批量是被分层采样的，首先采样N个图像，然后从每个图像采样R/N个 RoI。</p>
<blockquote>
<p>关键的是，来自同一图像的RoI在向前和向后传播中共享计算和内存。减N，就减少了小批量的计算。例如，当N=2和R=128时，得到的训练方案比从128幅不同的图采样一个RoI（即R-CNN和SPPnet的策略）快64倍。</p>
</blockquote>
<p>这个策略的一个令人担心的问题是它可能导致训练收敛变慢，因为来自相同图像的RoI是相关的。然而在实际情况中该问题并不存在，当N=2和R=128时，我们使用比R-CNN更少的SGD迭代就获得了良好的结果。</p>
<p><strong>更加精细的训练过程</strong></p>
<p>在微调阶段联合优化Softmax分类器和检测框回归，而不是分别在三个独立的阶段训练softmax分类器，SVM和回归器。</p>
<h4 id="多任务损失（multi-task-loss）"><a href="#多任务损失（multi-task-loss）" class="headerlink" title="多任务损失（multi-task loss）"></a>多任务损失（multi-task loss）</h4><p>Fast R-CNN在FC层后有两个分支,一个是SVM分类器，一个是bbox回归。</p>
<p>结论就是：把两个分支的损失弄到一起</p>
<blockquote>
<p>具体没太看懂，后续再补</p>
</blockquote>
<h2 id="Fast-R-CNN检测"><a href="#Fast-R-CNN检测" class="headerlink" title="Fast R-CNN检测"></a>Fast R-CNN检测</h2><p>一旦Fast R-CNN网络被微调完毕，检测相当于运行前向传播（假设候选框是预先计算的）。网络将图像（或图像金字塔，编码为图像列表）和待计算概率的R个候选框的列表作为输入。在测试的时候，R通常在2000左右，虽然我们将考虑将它变大（约45k）的情况。当使用图像金字塔时，每个RoI被缩放，使其最接近 R-CNN 中的224个像素。</p>
<p>对于每个测试的RoI r，正向传播输出类别后验概率分布p和相对于r的预测的检测框框偏移集合（K个类别中的每一个获得其自己的精细检测框预测）。使用估计的概率Pr(class=k|r)≜pk为每个对象类别kk分配rr的检测置信度。然后，使用R-CNN算法的设置和对每个类别独立执行非最大抑制。</p>
<h3 id="使用截断的SVD来进行更快的检测"><a href="#使用截断的SVD来进行更快的检测" class="headerlink" title="使用截断的SVD来进行更快的检测"></a>使用截断的SVD来进行更快的检测</h3><p>对于整体图像分类，与卷积层相比，计算全连接层花费的时间较小。相反，为了检测，要处理的RoI的数量很大，并且接近一半的正向传递时间用于计算全连接层。大的全连接层容易通过用截短的SVD压缩来加速。</p>
<p>为了压缩网络，对应于W的单个全连接层由两个全连接层替代，中间以一个低纬数据相连。在它们之间没有非线性。当RoI的数量大时，这种简单的压缩方法给出良好的加速。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Fast RCNN方法修正了R-CNN和SPPnet的缺点，同时提高其速度和准确性，有以下几个优点：</p>
<ul>
<li>比R-CNN和SPPnet具有更高的目标检测精度（mAP）。</li>
<li>训练是使用多任务损失的单阶段训练。</li>
<li>训练可以更新所有网络层参数。</li>
<li>不需要磁盘空间缓存特征。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/11/24/R-CNN/</url>
      <content type="html"><![CDATA[<p>该论文是利用深度学习进行目标检测的开山之作<br><a id="more"></a></p>
<p>原文：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Girshick_Rich_Feature_Hierarchies_2014_CVPR_paper.pdf" target="_blank" rel="external">R-CNN</a>，</p>
<p>teach report v5：<a href="https://arxiv.org/pdf/1311.2524v5.pdf" target="_blank" rel="external">teach report v5</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要解决了两个问题：</p>
<p>1、如何确定物体位置，即建模</p>
<p>这个模型是Region proposal + CNN，所以叫R-CNN</p>
<p>本文通过传统的无监督的与类别无关的方法提取proposal，然后利用CNN对于这些矩形框进行特征提取；对于提取到的特征进行分类。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/1-1.jpg" alt="1-1"></p>
<ul>
<li>输入图片</li>
<li>提取约2000个 region proposals</li>
<li>使用一个大的CNN 为每个 proposal 计算出特征</li>
<li>使用类别特定的线性 SVM 对每个 region 进行分类</li>
</ul>
<p>2、如何训练一个复杂模型</p>
<p>传统的预训练方法是无监督的，每层自己训练训练一个权重出来（例如通过AutoEncoder）之后，再加上label信息进行整体微调。这个方法没有任何先验，需要大量数据进行训练。而R-CNN则采用了CNN在分类问题上已经训好的权重作为初始权重，再针对detection问题进行微调。这就使得小数据集可以使用大数据集上的先验知识，在分类问题上的研究成果可以轻松迁移到detection问题上了。</p>
<p>论文中使用大型辅助数据集(ILSVRC)上进行监督预训练，然后对小数据集(PASCAL)进行域特定的微调，这是在数据稀缺时训练高容量CNN模型的有效范例。最后在检测库上评测。</p>
<p>一个较大的<strong>识别库</strong>（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。<br>一个较小的<strong>检测库</strong>（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置。一万图像，20类。 </p>
<p>CNN的输入必须是固定大小的。论文中采用了最简单的warp图像变形方法。但是对变形的区域进行了限制，即不单单对proposal选中的矩形框进行变形，还将其扩大（引入背景息），使得变形后原proposal矩形框外围还有p个像素点(p=16)。原话是这样的</p>
<blockquote>
<p>对于这些转换中的每一个，我们还考虑在原始目标提案四周包括附加图像内容。内容填充的量(pp)被定义为在缩放后图像中，原始目标提案周围的边界大小。图7显示了每个示例的顶行中p=0p=0像素，底行中p=16p=16像素。在所有方法中，如果矩形框超出图像边缘，超出的部分将被填充为图像均值（然后在将图像输入到CNN之前减去）。一组实验表明，采用上下文填充（p=16p=16像素）的缩放可以明显提高mAP（提高3-5个点）。显然还有更多其它可行的方案，包括使用复制而不是平均填充。对这些方案的详尽评估将作为未来的工作。</p>
</blockquote>
<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><p>目标检测系统分为三个部分：1、生成类别无关的 region proposals（构成候选检测集）；2、从每个 region 提取固定长度特征向量的大型CNN；3、一组特定类别的线性 SVM。</p>
<p><strong>region proposals</strong></p>
<p>经典的目标检测算法使用滑动窗法依次判断所有可能的区域。</p>
<p>本文采用了 selective search （选择性搜索），论文中说便于与之前的一些工作进行比较。</p>
<p>从高层理解，Selective Search通过不同尺寸的窗口在图像中进行滑动，对于每个尺寸方法采用纹理、颜色或亮度对邻近的像素进行聚合，从而识别物体。</p>
<blockquote>
<p>关于 selective search，论文如下，后续有空深究：</p>
<p>J. Uijlings, K. van de Sande, T. Gevers, and A. Smeulders. Selective search for object recognition. IJCV, 2013.</p>
</blockquote>
<p><strong>feature extraction</strong></p>
<p>经典的目标检测算法在区域中提取人工设定的特征（Haar，HOG）。</p>
<p>从每个 region proposal 中提取4096维特征向量，将减去像素平均值的227×227227×227分辨率的RGB图像通过五个卷积层和两个全连接层向前传播来计算特征。</p>
<p>不管候选区域的大小或横纵比如何，我们将整个区域不保持横纵比缩放到所需的大小。</p>
<p>在测试时，先对测试图像进行选择性搜索，以提取大约2000个区域提案（我们在所有实验中使用选择性搜索的“快速模式”）。然后缩放每个区域，并通过CNN向前传播，以计算特征。最后，对于每个类，使用针对该类训练的SVM来对每个提取的特征向量进行评分。给定图像中的所有区域的得分，我们应用贪婪非极大值抑制（每个类别独立进行），在训练时学习一个阈值，如果其与得分较高的区域的重叠部分(IoU)高于这个阈值，则丢弃这个区域。</p>
<p><strong>两种性质使检测效率高</strong></p>
<p>首先，所有CNN参数都在<strong>所有类别</strong>中共享。</p>
<p>这种共享的结果是计算 region proposals 和 features（GPU上的13s/image 或 CPU上的53s/image）的时间在所有类别上进行摊销。唯一的类特定计算是特征、SVM权重和非极大值抑制之间的点积。</p>
<p>其次，与其他常见方法比较，由CNN计算出的特征向量是低维度的，例如具有空间金字塔（spatial pyramids）和视像单词（bag-of-visual-word）</p>
<h2 id="training"><a href="#training" class="headerlink" title="training"></a>training</h2><p><strong>supervised pre-training（监督预训练）</strong></p>
<p>通过使用图像级标记来区分性地对大型辅助数据集（ILSVRC2012分类）进行CNN预训练（此数据没有检测框标记）。使用开源的Caffe CNN库进行预训练。</p>
<p><strong>Domain-specific fine-tuning（特定域的微调）</strong></p>
<p>使用缩放后的 region proposals 继续进行CNN参数的随机梯度下降(SGD)训练。</p>
<p>所有 region proposals 与检测框真值（ground-truth）IoU ≥0.5的区域作为正样本，其余的作为负样本。</p>
<p>优化算法采用learning rate=0.001的SGD（这个小学习率可以使得模型既可以有明显的学习，又不至于过分的更改前几层连接的权重）；每个mini-batch由32个正样本（可以是任意类别的）和96个负样本（背景）组成（这样强制要求，对比于随机抽样，的原因是proposal中属于背景的占大多数）</p>
<p><strong>object category classifiers（目标类别分类器）</strong></p>
<p>一旦提取了特征并应用了训练标签，我们就可以优化每类线性SVM。由于训练数据太大内存不够，我们采用 standard hard negative mining method （标准的难分样本挖掘方法）。难分样本挖掘可以快速收敛，实际上所有图像遍历一边，mAP就停止增长了。</p>
<p>对每一类目标，使用一个线性SVM二类分类器进行判别。输入为CNN输出的4096维特征，输出是否属于此类。 </p>
<p>SVM的策略是对于所有IoU &lt; 0.3的proposal视为负样本，而只对ground truth视为正样本。</p>
<blockquote>
<p>IoU的threshold，对于最终结果影响很大。其交叉验证试验了{0,0.1,…,0.5}，发现差值可以达到5个mAP points。特别的，设其为0.5将会使得mAP掉5个点，而设为0则会掉4个点。</p>
</blockquote>
<p><strong>Bounding-box regression（检测框回归）</strong></p>
<blockquote>
<p>目标检测问题的衡量标准是重叠面积：许多看似准确的检测结果，往往因为候选框不够准确，重叠面积很小。故需要一个位置精修步骤。 </p>
</blockquote>
<p>受DPM中使用的检测框回归的启发，训练一个线性回归模型使用在 region proposals 上提取的 pool5 特征来预测一个新的检测框。</p>
<p>使用一个简单的检测框回归来提高定位性能。在使用类特定检测SVM对每个选择性搜索提案进行评分之后，使用类别特定的边界回归器预测新的检测框。</p>
<p><strong>回归器</strong><br>对每一类目标，使用一个线性回归器进行精修。这里转化为标准正则化最小二乘问题，基于验证集，设置正则项 λ=1000。<br>输入为CNN pool5层的4096维特征，输出为xy方向的缩放和平移。<br><strong>训练样本</strong><br>只有当提案P至少在一个检测框真值附近时，我们才执行学习任务。“附近”即，将P分配给具有最大IoU的检测框真值G（在重叠多于一个的情况下），并且仅当重叠大于阈值（基于验证集，我们使用的阈值为0.6）。所有未分配的提案都被丢弃。</p>
<p>为每个目标类别执行一次，以便学习一组特定于类别的检测框回归器。</p>
<p>在测试时，对每个提案进行评分，并预测其新的检测框一次。原则上，可以迭代这个过程（即重新评估新预测的检测框，然后从它预测一个新的检测框，等等）。但是，发现迭代不会改进结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>R-CNN的步骤如下：</p>
<ol>
<li>生成regions proposals集合作为Bounding Box；</li>
<li>采用预训练的AlexNet+SVM判断Bouding Box对应图像的物体类型；</li>
<li>对已分类物体的Bounding Box进行线性回归，输出Box对应的tighter bounding boxes。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>检测目标速度慢</li>
</ul>
<p>在测试阶段，特征来自于每张测试图片的每个候选区域。每个候选区域都需要经过CNN的前向传播计算出特征向量。因此速度很慢。</p>
<ul>
<li>多阶段训练（multi-stage pipeline）</li>
</ul>
<p>阶段一：从原始图片中使用selective search获取约2000个候选区域</p>
<p>阶段二：训练CNN,获取候选区域的特征向量</p>
<p>阶段三：训练SVM和bbox回归</p>
<blockquote>
<p>因为是分阶段训练，训练SVM和bbox回归时无法更新前面CNN的参数，模型精度上不去。</p>
</blockquote>
<ul>
<li>空间时间浪费（in space and time）</li>
</ul>
<p>候选区域经过CNN得到的特征向量要存在到disk内，然后在训练SVM和bbox回归再取出来，这需要大量的磁盘空间，并且很耗费时间。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> paper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph写流程分析]]></title>
      <url>http://xiaqunfeng.cc/2017/11/18/ceph%E5%86%99%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>之前总结的ceph写流程分析笔记，代码是基于jewel版本10.2.0，现分享出来，欢迎指点。<br><a id="more"></a></p>
<h2 id="一、rbd到OSD映射关系"><a href="#一、rbd到OSD映射关系" class="headerlink" title="一、rbd到OSD映射关系"></a>一、rbd到OSD映射关系</h2><p>​    客户端使用RBD设备，使用librbd、librados库进行访问管理块设备。</p>
<p>​    1、创建 一个pool，为这个pool指定pg的数量，同时在这个pool中指明保存数据的副本数（通常为3个副本）。</p>
<p>​    2、在这个pool中创建一个rbd设备rbd0，那么这个rbd0都会保存三份，在创建rbd0时必须指定rbd的size，对于这个rbd0的任何操作不能超过这个size。</p>
<p>​    3、将这个块设备进行切块，每个块的大小默认为4M，并且每个块都有一个名字，名字就是object+序号。</p>
<p>​    4、将每个object通过pg进行副本位置的分配，pg会寻找3个osd，把这个object分别保存在这三个osd上。最后对于object的存储就变成了存储一个文件 <code>rbd0.object1.file</code>。数据层次映射图如下： <img src="http://oow6unnib.bkt.clouddn.com/ceph_data_map.jpg" alt="ceph数据的映射层次">​</p>
<p>​    经过pool，rbd，object、pg的层层映射关系，在PG这一层中，已经知道存储数据的3个OSD所在位置及主从关系。</p>
<p>​    客户端与primay OSD建立SOCKET 通信，将要写入的数据传给primary OSD，由primary OSD再将数据发送给其他replica OSD数据节点。</p>
<p>​    读写框架图： <img src="http://oow6unnib.bkt.clouddn.com/ceph_rw_arc.jpg" alt="ceph读写框架"></p>
<h2 id="二、写请求流程"><a href="#二、写请求流程" class="headerlink" title="二、写请求流程"></a>二、写请求流程</h2><h3 id="1、rbd上的处理"><a href="#1、rbd上的处理" class="headerlink" title="1、rbd上的处理"></a>1、rbd上的处理</h3><p>​    在rbd中一个操作对象为一个image，这个请求经过处理拆分成object对象的请求，拆分后交给Objector进行处理，找到目标osd的集合及主osd。</p>
<p>​    将请求封装成MOSDOp消息，交由SimpleMessenger处理，SimpleMessager会尝试查找 / 创建一个OSDSession，并且为这个OSDSession创建一个数据通道pipe。消息从SimpleMessager收到后会保存到pipe的outq队列中。</p>
<p>​    pipe 与目标osd建立Socket通信通道，并有专门的写线程writer来负责socket通信。writer线程同时监视这个outq队列，当队列中存在消息等待发送时，会就将消息写入socket，发送给目标OSD。</p>
<p>​    OSD将数据消息处理完成之后，进行回调，反馈执行结果。</p>
<p>​    关键代码序列图如下： <img src="http://oow6unnib.bkt.clouddn.com/libRBD_write_Fotor.jpg" alt="libRBD write"></p>
<h3 id="2、osd上的处理"><a href="#2、osd上的处理" class="headerlink" title="2、osd上的处理"></a>2、osd上的处理</h3><p>​    OSD接收到message信息以后，解析并将消息转换成OpRequest，加入dispatch队列。同时从message中得到pool及PG的信息，将message交由PG进行相关处理。此时从OSD处理的message转化为了PG处理的op，添加到osd-&gt;op_wq队列中。PG中创建一个OpContext结构，接管message中的所有ops的操作。</p>
<p>​    解析出OpRequest中的所有op与data，用Transaction结构进行管理，即将ops与Transaction绑定，将操作和数据打包成事务，并发送给其他副本，同时管理自己和其他副本的数据处理统计，创建repop 所有的applied与commit的管理。</p>
<p>​    提交事务后，交由filestore进行处理。</p>
<p>​    如果数据处理完成了，使用eval_repop()进行收尾的工作，将结果回调给客户端。</p>
<p>​    关键代码序列图如下：  <img src="http://oow6unnib.bkt.clouddn.com/osd_write_Fotor.jpg" alt="osd write"></p>
<h3 id="3、filestore上的处理"><a href="#3、filestore上的处理" class="headerlink" title="3、filestore上的处理"></a>3、filestore上的处理</h3><p>​    当数据进行写入的时候需要写到journal中一份，当data数据失败的时候可以从journal中进行恢复。从_op_journal_transactions()开始激发写入日志的操作，回调函数C_JournaledAhead的会在日志完成之后进行回调处理，将data写入磁盘。</p>
<p>​    将日志保存完成的回调ondisk交给ondisk_finisher，ondisk注册回调为C_OSD_OnOpApplied，在后续finisher线程中处理。在该函数中，循环处理需要回调的请求，回复刚开始接收到请求的MOSDOp的操作，将请求发还给客户端。</p>
<p>​    写完data的回调函数注册的为C_OSD_OnOpCommit，该函数处理并回复OSD一些状态的逻辑。</p>
<p>​    关键代码序列图如下：<img src="http://oow6unnib.bkt.clouddn.com/file_write_Fotor.jpg" alt="file_write"></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上安装caffe并训练mnist]]></title>
      <url>http://xiaqunfeng.cc/2017/11/05/mac%E4%B8%8A%E5%AE%89%E8%A3%85caffe%E5%B9%B6%E8%AE%AD%E7%BB%83mnist/</url>
      <content type="html"><![CDATA[<p>在mac上安装caffe，然后训练一个mnist项目，熟悉流程。新增anaconda的使用介绍。<br><a id="more"></a></p>
<h2 id="安装caffe"><a href="#安装caffe" class="headerlink" title="安装caffe"></a>安装caffe</h2><p>官方的资料：<a href="http://caffe.berkeleyvision.org/install_osx.html" target="_blank" rel="external">http://caffe.berkeleyvision.org/install_osx.html</a></p>
<p>我这里并没有用 Anaconda Python，如果想要安装它的话，去<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">官网下载</a>并安装。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>1、安装必要的库和依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">brew install -vd snappy leveldb gflags glog szip lmdb</div><div class="line"># need the homebrew science source for OpenCV and hdf5</div><div class="line">brew tap homebrew/science</div><div class="line">brew install hdf5 opencv</div></pre></td></tr></table></figure>
<p>2、安装boost和protobuf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install protobuf boost</div></pre></td></tr></table></figure>
<p>3、安装BLAS</p>
<p>BLAS是Mac中自带的库，所以不需要安装。如果没有安装，推荐使用OpenBLAS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install openblas</div></pre></td></tr></table></figure>
<p>4、安装CUDA</p>
<p>要确定mac的显卡是否支持CUDA。我这里没有安装，为啥，因为不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Intel Iris Graphics 6100 1536 MB</div></pre></td></tr></table></figure>
<h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p>1、克隆代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/BVLC/caffe</div><div class="line">cd caffe</div></pre></td></tr></table></figure>
<blockquote>
<p>以下所有操作都在 caffe 目录下进行</p>
</blockquote>
<p>查看文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">~/AI/caffe  master ✔                                                                                                                                                           21d</div><div class="line">▶ ls</div><div class="line">CMakeLists.txt          LICENSE                 README.md               data                    examples                python</div><div class="line">CONTRIBUTING.md         Makefile                build                   distribute              include                 scripts</div><div class="line">CONTRIBUTORS.md         Makefile.config         caffe.cloc              docker                  matlab                  src</div><div class="line">INSTALL.md              Makefile.config.example cmake                   docs                    models                  tools</div></pre></td></tr></table></figure>
<p>2、修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp Makefile.config.example Makefile.config</div></pre></td></tr></table></figure>
<p>修改 Makefile.config 文件：</p>
<ul>
<li>去掉CPU_ONLY := 1的注释，使Caffe只运行在CPU上。</li>
<li>去掉OPENCV_VERSION := 3的注释，因为当前的OpenCV版本是3.1.0，如果版本是2.*就不需要。</li>
</ul>
<p>查看当前的opencv版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ pkg-config --modversion opencv</div><div class="line">3.3.1</div></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>pkg-config</code> 没安装：<code>brew install pkg-config</code></p>
</blockquote>
<p>修改anaconda的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Anaconda Python distribution is quite popular. Include path:</div><div class="line"># Verify anaconda location, sometimes it&apos;s in root.</div><div class="line"># ANACONDA_HOME := $(HOME)/anaconda</div><div class="line">ANACONDA_HOME := $/Users/xiaqunfeng/anaconda2</div><div class="line">PYTHON_INCLUDE := $(ANACONDA_HOME)/include \</div><div class="line">         $(ANACONDA_HOME)/include/python2.7 \</div><div class="line">         $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include</div></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>1、编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake -DCPU_ONLY=ON ..</div><div class="line">make all -j8</div></pre></td></tr></table></figure>
<p>忽略 warning，有error解决error的错误（正常没有error，有的话一般是依赖包没装成功）。</p>
<p>2、运行test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make runtest</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">[----------] 3 tests from MSRAFillerTest/0, where TypeParam = f</div><div class="line">[ RUN      ] MSRAFillerTest/0.TestFillAverage</div><div class="line">[       OK ] MSRAFillerTest/0.TestFillAverage (0 ms)</div><div class="line">[ RUN      ] MSRAFillerTest/0.TestFillFanIn</div><div class="line">[       OK ] MSRAFillerTest/0.TestFillFanIn (1 ms)</div><div class="line">[ RUN      ] MSRAFillerTest/0.TestFillFanOut</div><div class="line">[       OK ] MSRAFillerTest/0.TestFillFanOut (1 ms)</div><div class="line">[----------] 3 tests from MSRAFillerTest/0 (2 ms total)</div><div class="line"></div><div class="line">[----------] Global test environment tear-down</div><div class="line">[==========] 1110 tests from 152 test cases ran. (54652 ms total)</div><div class="line">[  PASSED  ] 1110 tests.</div></pre></td></tr></table></figure>
<p>此时，caffe安装成功，并通过了测试。</p>
<h2 id="pycaffe安装"><a href="#pycaffe安装" class="headerlink" title="pycaffe安装"></a>pycaffe安装</h2><p>1、在build目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make pycaffe</div><div class="line">make pytest</div></pre></td></tr></table></figure>
<p>2、设置pycaffe环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">▶ cat ~/.bash_profile</div><div class="line">...</div><div class="line"># caffe python</div><div class="line">export PYTHONPATH=&quot;/Users/xiaqunfeng/AI/caffe/python:$PYTHONPATH&quot;</div><div class="line">...</div><div class="line">▶ source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>3、在python中测试caffe接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">▶ python</div><div class="line">Python 2.7.14 |Anaconda, Inc.| (default, Dec  7 2017, 11:07:58)</div><div class="line">[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt; import caffe</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：python3和caffe不能很好的兼容，官方也说了不推荐，我试了一直会出错：“ImportError: dynamic module does not define module export function (PyInit__caffe)”</p>
</blockquote>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>Q1：<code>ImportError: No module named numpy</code></p>
<p>A1：<code>conda install numpy</code></p>
<p>Q2：<code>ImportError: No module named skimage.io</code></p>
<p>A2：<code>conda install scikit-image</code></p>
<p>Q3：<code>ImportError: No module named google.protobuf.internal</code></p>
<p>A3：<code>conda install protobuf</code></p>
<h2 id="训练mnist数据集"><a href="#训练mnist数据集" class="headerlink" title="训练mnist数据集"></a>训练mnist数据集</h2><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>1、下载mnist数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./data/mnist/get_mnist.sh</div></pre></td></tr></table></figure>
<p>下载的数据保存在 <code>./data/mnist/</code> 目录下。</p>
<p>2、建立训练数据和测试数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./examples/mnist/create_mnist.sh</div></pre></td></tr></table></figure>
<p>此时 <code>./examples/mnist/</code> 路径下出现 <code>mnist_test_lmdb</code> 和 <code>mnist_train_lmdb</code> 两个文件夹，分别是测试和训练数据。</p>
<p>3、训练</p>
<p>修改 <code>./examples/mnist/lenet_solver.prototxt</code> ，保证整个训练过程在CPU上进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"># solver mode: CPU or GPU</div><div class="line">solver_mode: CPU</div></pre></td></tr></table></figure>
<p>4、执行训练命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./examples/mnist/train_lenet.sh</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">I1102 17:31:49.379988 3124548544 solver.cpp:218] Iteration 9900 (25.582 iter/s, 3.909s/100 iters), loss = 0.00534126</div><div class="line">I1102 17:31:49.381337 3124548544 solver.cpp:237]     Train net output #0: loss = 0.00534115 (* 1 = 0.00534115 loss)</div><div class="line">I1102 17:31:49.381361 3124548544 sgd_solver.cpp:105] Iteration 9900, lr = 0.00596843</div><div class="line">I1102 17:31:54.009297 3124548544 solver.cpp:447] Snapshotting to binary proto file examples/mnist/lenet_iter_10000.caffemodel</div><div class="line">I1102 17:31:54.026062 3124548544 sgd_solver.cpp:273] Snapshotting solver state to binary proto file examples/mnist/lenet_iter_10000.solverstate</div><div class="line">I1102 17:31:54.059612 3124548544 solver.cpp:310] Iteration 10000, loss = 0.00328907</div><div class="line">I1102 17:31:54.059659 3124548544 solver.cpp:330] Iteration 10000, Testing net (#0)</div><div class="line">I1102 17:31:56.881471 148017152 data_layer.cpp:73] Restarting data prefetching from start.</div><div class="line">I1102 17:31:57.004863 3124548544 solver.cpp:397]     Test net output #0: accuracy = 0.9906</div><div class="line">I1102 17:31:57.004914 3124548544 solver.cpp:397]     Test net output #1: loss = 0.0292456 (* 1 = 0.0292456 loss)</div><div class="line">I1102 17:31:57.004932 3124548544 solver.cpp:315] Optimization Done.</div><div class="line">I1102 17:31:57.004940 3124548544 caffe.cpp:259] Optimization Done.</div></pre></td></tr></table></figure>
<p>可以看到，一共迭代10000次，准确率为 0.9906。训练出的模型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▶ ll examples/mnist</div><div class="line">...</div><div class="line">-rw-r--r--  1 xiaqunfeng  staff   1.6M 11  2 17:31 lenet_iter_10000.caffemodel</div><div class="line">...</div></pre></td></tr></table></figure>
<p>5、绘制网络图</p>
<p>用官方自带的python工具绘制网络图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ ./python/draw_net.py examples/mnist/lenet_train_test.prototxt examples/mnist/lenet_train_test.jpg</div><div class="line">Drawing net to examples/mnist/lenet_train_test.jpg</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>图如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/lenet_train_test.jpg" alt="lenet_train_test.jpg"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1、对训练的网络模型进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">格式：</div><div class="line">caffe 网络结构模型文件(.prototxt) 训练好的模型参数（.caffemodel） 迭代测试次数</div><div class="line"></div><div class="line">▶ ./build/tools/caffe test -model examples/mnist/lenet_train_test.prototxt -weights examples/mnist/lenet_iter_10000.caffemodel -iterations 100</div><div class="line">...</div><div class="line">I0108 11:41:02.459322 3449701312 caffe.cpp:330] accuracy = 0.9905</div><div class="line">I0108 11:41:02.459398 3449701312 caffe.cpp:330] loss = 0.0287398 (* 1 = 0.0287398 loss)</div></pre></td></tr></table></figure>
<p>2、用python接口调用训练好的模型识别数字</p>
<p>网络结构图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ ./python/draw_net.py examples/mnist/lenet.prototxt examples/mnist/lenet.jpg</div><div class="line">Drawing net to examples/mnist/lenet.jpg</div></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/lenet.jpg" alt="lenet.jpg"></p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import sys</div><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">import caffe</div><div class="line"></div><div class="line">caffe_root = &apos;/Users/xiaqunfeng/AI/caffe/&apos;</div><div class="line"></div><div class="line">#指定网络结构 与 lenet_train_test.prototxt不同 </div><div class="line">MODEL_FILE = caffe_root + &apos;examples/mnist/lenet.prototxt&apos;</div><div class="line">PRETRAINED = caffe_root + &apos;examples/mnist/lenet_iter_10000.caffemodel&apos;</div><div class="line"></div><div class="line">#图片已经处理成 lenet.prototxt的输入要求（尺寸28x28）且已经二值化为黑白色</div><div class="line">IMAGE_FILE = caffe_root + &apos;xqf/Learning-caffe/Lenet-mnist/test4.bmp&apos;</div><div class="line"></div><div class="line">input_image = caffe.io.load_image(IMAGE_FILE, color=False)</div><div class="line">net = caffe.Classifier(MODEL_FILE, PRETRAINED)</div><div class="line">prediction = net.predict([input_image], oversample=False)</div><div class="line">caffe.set_mode_cpu()</div><div class="line">print &apos;predicted class:&apos;, prediction[0].argmax()</div><div class="line"></div><div class="line">这个例子参考这里：https://zhuanlan.zhihu.com/p/24110318</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predicted class: 4</div></pre></td></tr></table></figure>
<h3 id="关于mnist"><a href="#关于mnist" class="headerlink" title="关于mnist"></a>关于mnist</h3><p>MNIST 数据集来自美国国家标准与技术研究所, <strong>National Institute of Standards and Technology (NIST)</strong>。训练集 (training set) 由来自 250 个不同人手写的数字构成，其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员。测试集(test set) 也是同样比例的手写数字数据。mnist最初备在美国被用与支票上手写数字识别，现在成了DeepLearning的入门练习示例，针对mnist识别的神经网络的专门模型是Lenet，算是最早的CNN模型了。</p>
<ul>
<li>mnist数据的—训练样本为60000张</li>
<li>测试样本为10000张</li>
<li>每个样本为28*28大小的黑白图片</li>
<li>手写数字为0-9,因此分为10类</li>
</ul>
<p>同时，Mnist数据库中的每张图片都进行了:</p>
<ul>
<li>尺寸的归一化处理(所有的图片均为28*28像素大小的图片)</li>
<li>数字进行了居中处理</li>
<li>通过脚本 <code>get_mnist.sh</code> 下载下来的数据不是图片数据，图片是以字节的形式进行存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">▶ ll data/mnist</div><div class="line">total 107352</div><div class="line">-rwxr-xr-x  1 xiaqunfeng  staff   408B 10 18 09:58 get_mnist.sh</div><div class="line">-rw-r--r--  1 xiaqunfeng  staff   7.5M  7 22  2000 t10k-images-idx3-ubyte</div><div class="line">-rw-r--r--  1 xiaqunfeng  staff   9.8K  7 22  2000 t10k-labels-idx1-ubyte</div><div class="line">-rw-r--r--  1 xiaqunfeng  staff    45M  7 22  2000 train-images-idx3-ubyte</div><div class="line">-rw-r--r--  1 xiaqunfeng  staff    59K  7 22  2000 train-labels-idx1-ubyte</div></pre></td></tr></table></figure>
<p>详解：</p>
<ul>
<li><strong>Training set images</strong>: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</li>
<li><strong>Training set labels</strong>: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</li>
<li><strong>Test set images</strong>: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</li>
<li><strong>Test set labels</strong>: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</li>
</ul>
<h2 id="使用模型进行分类"><a href="#使用模型进行分类" class="headerlink" title="使用模型进行分类"></a>使用模型进行分类</h2><p>用Caffe中已经训练好的模型（基于Alexnet的结构）对图像进行分类，并且可以显示不同层中训练得到的特征：</p>
<p><a href="http://nbviewer.jupyter.org/github/BVLC/caffe/blob/master/examples/00-classification.ipynb" target="_blank" rel="external">http://nbviewer.jupyter.org/github/BVLC/caffe/blob/master/examples/00-classification.ipynb</a></p>
<h2 id="ubuntu-16-04上安装遇到的问题"><a href="#ubuntu-16-04上安装遇到的问题" class="headerlink" title="ubuntu 16.04上安装遇到的问题"></a>ubuntu 16.04上安装遇到的问题</h2><h3 id="编译依赖问题"><a href="#编译依赖问题" class="headerlink" title="编译依赖问题"></a>编译依赖问题</h3><p><strong>问题1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./include/caffe/common.hpp:5:27: fatal error: gflags/gflags.h: No such file or directory</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libgflags-dev</div></pre></td></tr></table></figure>
<p><strong>问题2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./include/caffe/util/mkl_alternate.hpp:14:19: fatal error: cblas.h: No such file or directory</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libblas-dev</div></pre></td></tr></table></figure>
<p><strong>问题3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./include/caffe/util/hdf5.hpp:6:18: fatal error: hdf5.h: No such file or directory</div></pre></td></tr></table></figure>
<p>解决方法：在 <code>Makefile.config</code> 找到以下亮行并添加最后一部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial </div><div class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial</div></pre></td></tr></table></figure>
<p><strong>问题4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./include/caffe/util/db_lmdb.hpp:8:18: fatal error: lmdb.h: No such file or directory</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install liblmdb-dev</div></pre></td></tr></table></figure>
<p><strong>问题5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ld: cannot find -lcblas</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install libatlas-base-dev</div></pre></td></tr></table></figure>
<h3 id="python导入caffe"><a href="#python导入caffe" class="headerlink" title="python导入caffe"></a>python导入caffe</h3><p>编译安装完后，在python脚本中导入 caffe 时出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    import caffe</div><div class="line">ImportError: No module named caffe</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>1、先安装 pycaffe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make pycaffe</div></pre></td></tr></table></figure>
<p>会遇到如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python/caffe/_caffe.cpp:10:31: fatal error: numpy/arrayobject.h: No such file or directory</div></pre></td></tr></table></figure>
<p>原因是python-numpy没有安装到位，安装即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-numpy</div></pre></td></tr></table></figure>
<p>2、添加caffe路径</p>
<p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div></pre></td></tr></table></figure>
<p>添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PYTHONPATH=/workspace/caffe/python:$PYTHONPATH</div></pre></td></tr></table></figure>
<p>其中 <code>/workspace</code> 是clone caffe master代码的目录</p>
<p>然后执行 <code>source ~/.bashrc</code> 即可</p>
<p><strong>方法二：</strong></p>
<p>或者，在导入 caffe的时候在python 文件里手动添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import sys</div><div class="line">PYCAFFE_ROOT = &apos;/workspace/caffe/python/&apos;</div><div class="line">sys.path.append(PYCAFFE_ROOT)</div><div class="line">import caffe</div></pre></td></tr></table></figure>
<h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><blockquote>
<p>caffe不能和python3很好的支持，所以主要用Python2.7。因为我在mac上的使用习惯都是python3，各种安装包也都是通过 pip3 命令装的python3版本的，所以需要一个anaconda来创建一个python2.7的环境。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、官网<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">下载</a></p>
<p>推荐下载 .pkg 文件进行图形化安装，下载python2和python3版本的均可，只是默认环境不一样，不影响，我这里下载的 Anaconda2。</p>
<p>安装完后会在 <code>~/.bash_profile</code> 中自动添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># added by Anaconda2 5.0.1 installer</div><div class="line">export PATH=&quot;/Users/xiaqunfeng/anaconda2/bin:$PATH&quot;</div></pre></td></tr></table></figure>
<p>如果没有添加，手动添加之</p>
<p>运行 <code>source ~/.bash_profile</code></p>
<p>2、确认安装</p>
<p>进入选择的安装目录 <code>/Users/xiaqunfeng/anaconda2</code></p>
<p>查看conda命令是否可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># conda list</div></pre></td></tr></table></figure>
<p>可用，表示安装成功</p>
<h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>1、创建</p>
<p>创建名为python27的环境，指定python版本2.7（不用指定小版本 2.7.x，conda会自动寻找2.7.x中最新版）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ conda create --name python27 python=2.7</div></pre></td></tr></table></figure>
<p>2、激活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ source activate python27</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>这一步系统做的事情就是把默认2.7环境从PATH中去除，再把新的2.7对应的命令加入PATH</p>
<p>查看系统版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ python --version</div><div class="line">Python 2.7.14 :: Anaconda, Inc.</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>3、查看</p>
<p>用户安装的不同python环境都会被放在目录<code>~/anaconda/envs</code>下。运行<code>conda info -e</code>查看已安装的环境，当前被激活的环境会显示有一个星号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">▶ conda info -e</div><div class="line"># conda environments:</div><div class="line">#</div><div class="line">python27              *  /Users/xiaqunfeng/anaconda2/envs/python27</div><div class="line">root                     /Users/xiaqunfeng/anaconda2</div></pre></td></tr></table></figure>
<p>4、离开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ source deactivate python27</div></pre></td></tr></table></figure>
<p>此时系统环境回到了默认的 root 上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">▶ conda info -e</div><div class="line"># conda environments:</div><div class="line">#</div><div class="line">python27                 /Users/xiaqunfeng/anaconda2/envs/python27</div><div class="line">root                  *  /Users/xiaqunfeng/anaconda2</div></pre></td></tr></table></figure>
<p>5、删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ conda remove --name python27 --all</div></pre></td></tr></table></figure>
<p>6、共享</p>
<ul>
<li><strong>导出</strong></li>
</ul>
<p>将当前的环境保存到文件中包保存为YAML文件（包括Pyhton版本和所有包的名称）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ conda env export &gt; py27-env.yaml</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<blockquote>
<p>在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。</p>
</blockquote>
<ul>
<li><strong>使用</strong></li>
</ul>
<p>在conda中进入自己的环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ conda activate XXX</div></pre></td></tr></table></figure>
<p>然后更新环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ conda env update -f=/yourpath/py27-env.yaml</div></pre></td></tr></table></figure>
<blockquote>
<p>如果不使用 conda ，还可以使用 pip freeze，具体没实践过，可以查阅相关资料</p>
</blockquote>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>conda 的包管理功能可 pip 是一样的，当然你选择 pip 来安装包也是没问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 安装命令</div><div class="line">conda install package-name</div><div class="line"></div><div class="line"># 指定环境安装package</div><div class="line">conda install -n python34 package-name</div><div class="line"></div><div class="line"># 查看当前环境已经安装的packages</div><div class="line">conda list</div><div class="line"></div><div class="line"># 查看某个指定环境的已安装包</div><div class="line">conda list -n python34</div><div class="line"></div><div class="line"># 查找package信息</div><div class="line">conda search numpy</div><div class="line"></div><div class="line"># 更新package</div><div class="line">conda update -n python34 numpy</div><div class="line"></div><div class="line"># 删除package</div><div class="line">conda remove -n python34 numpy</div></pre></td></tr></table></figure>
<p>conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 更新conda，保持conda最新</div><div class="line">conda update conda</div><div class="line"># 更新anaconda</div><div class="line">conda update anaconda</div><div class="line"># 更新python</div><div class="line">conda update python</div></pre></td></tr></table></figure>
<h3 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><p>Anaconda.org的服务器在国外，下载速度有时会比较慢，设置国内清华TUNA镜像源，加入conda的配置。</p>
<p>1、原配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">▶ cat ~/.condarc</div><div class="line">channels:</div><div class="line">  - defaults</div><div class="line">ssl_verify: true</div></pre></td></tr></table></figure>
<p>2、添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class="line">▶ conda config --set show_channel_urls yes</div></pre></td></tr></table></figure>
<p>修改后配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">▶ cat ~/.condarc</div><div class="line">channels:</div><div class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class="line">  - defaults</div><div class="line">ssl_verify: true</div><div class="line">show_channel_urls: true</div></pre></td></tr></table></figure>
<p>3、查看配置是否生效，查看当前信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">▶ conda info</div><div class="line">Current conda install:</div><div class="line">...</div><div class="line">           channel URLs : https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/osx-64</div><div class="line">                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/noarch</div><div class="line">                          https://repo.continuum.io/pkgs/main/osx-64</div><div class="line">                          https://repo.continuum.io/pkgs/main/noarch</div><div class="line">                          https://repo.continuum.io/pkgs/free/osx-64</div><div class="line">                          https://repo.continuum.io/pkgs/free/noarch</div><div class="line">                          https://repo.continuum.io/pkgs/r/osx-64</div><div class="line">                          https://repo.continuum.io/pkgs/r/noarch</div><div class="line">                          https://repo.continuum.io/pkgs/pro/osx-64</div><div class="line">                          https://repo.continuum.io/pkgs/pro/noarch</div><div class="line">...</div><div class="line">(python27)</div></pre></td></tr></table></figure>
<p>在 channel URLs 中有新添加的镜像地址，表示已生效。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph指定版本安装]]></title>
      <url>http://xiaqunfeng.cc/2017/09/27/ceph%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>通过yum安装指定版本的ceph，避免因小版本不一致导致的一些问题。<br><a id="more"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>ceph集群现有的版本是 11.2.0，需要扩容一台机器，新机器上ceph版本保持一致。</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>添加ceph安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d/ceph.repo</div><div class="line">[ceph]</div><div class="line">name=Ceph packages for x86_64</div><div class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/x86_64</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">priority=1</div><div class="line">type=rpm-md</div><div class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</div><div class="line"></div><div class="line">[ceph-noarch]</div><div class="line">name=Ceph noarch packages</div><div class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/noarch</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">priority=1</div><div class="line">type=rpm-md</div><div class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</div><div class="line"></div><div class="line">[ceph-source]</div><div class="line">name=Ceph source packages</div><div class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/SRPMS</div><div class="line">enabled=0</div><div class="line">gpgcheck=1</div><div class="line">type=rpm-md</div><div class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</div><div class="line">priority=1</div></pre></td></tr></table></figure>
<p>然后执行yum安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install ceph</div></pre></td></tr></table></figure>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>通过 <code>yum install ceph --release kraken -y</code> 来安装，出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">错误：软件包：1:ceph-base-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：librados2 = 1:11.2.0-0.el7</div><div class="line">          可用: 1:librados2-0.94.5-2.el7.i686 (base)</div><div class="line">              librados2 = 1:0.94.5-2.el7</div><div class="line">          可用: 1:librados2-11.0.1-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.0.1-0.el7</div><div class="line">          可用: 1:librados2-11.0.2-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.0.2-0.el7</div><div class="line">          可用: 1:librados2-11.1.0-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.1.0-0.el7</div><div class="line">          可用: 1:librados2-11.1.1-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.1.1-0.el7</div><div class="line">          可用: 1:librados2-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.2.0-0.el7</div><div class="line">          正在安装: 1:librados2-11.2.1-0.el7.x86_64 (ceph)</div><div class="line">              librados2 = 1:11.2.1-0.el7</div><div class="line"> 您可以尝试添加 --skip-broken 选项来解决该问题</div><div class="line"> 您可以尝试执行：rpm -Va --nofiles --nodigest</div></pre></td></tr></table></figure>
<h3 id="方法一：指定版本"><a href="#方法一：指定版本" class="headerlink" title="方法一：指定版本"></a>方法一：指定版本</h3><p>因为kraken版本的ceph最新的release版本是 11.2.1，通过yum源来安装的话，会默认安装最新的release版本。</p>
<p>查看源里有哪些可安装的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># yum --showduplicates list ceph | expand</div><div class="line">已加载插件：fastestmirror, langpacks</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line"> * base: mirrors.btte.net</div><div class="line"> * epel: mirrors.ustc.edu.cn</div><div class="line"> * extras: mirrors.neusoft.edu.cn</div><div class="line"> * updates: mirrors.btte.net</div><div class="line">可安装的软件包</div><div class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</div><div class="line">ceph.x86_64                       1:11.0.1-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.0.2-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.1.0-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.1.1-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.2.1-0.el7                           ceph</div></pre></td></tr></table></figure>
<p>可以看到，最新的版本是 <code>11.2.1-0.el7</code>。可以通过指定安装包的形式来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install ceph-11.2.0-0.el7</div></pre></td></tr></table></figure>
<h3 id="方法二：限制版本"><a href="#方法二：限制版本" class="headerlink" title="方法二：限制版本"></a>方法二：限制版本</h3><p>通过在 <code>/etc/yum.conf</code> 文件中添加配置来限制版本，这里只需要限制住比 11.2.0 高的版本就好了。</p>
<p>1、新增 <code>exclude</code> 配置行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.con</div><div class="line">[main]</div><div class="line">...</div><div class="line">exclude=*11.2.1*</div></pre></td></tr></table></figure>
<p>2、再次查看可安装的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># yum --showduplicates list ceph | expand</div><div class="line">已加载插件：fastestmirror, langpacks</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line"> * base: mirrors.btte.net</div><div class="line"> * epel: mirrors.ustc.edu.cn</div><div class="line"> * extras: mirrors.neusoft.edu.cn</div><div class="line"> * updates: mirrors.btte.net</div><div class="line">可安装的软件包</div><div class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</div><div class="line">ceph.x86_64                       1:11.0.1-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.0.2-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.1.0-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.1.1-0.el7                           ceph</div><div class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</div></pre></td></tr></table></figure>
<p>发现版本 11.2.1 不见了，当前最高可安装的版本是 11.2.0。</p>
<p>3、然后就可以直接安装了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install ceph</div></pre></td></tr></table></figure>
<p><strong>如果要一次限制住多个版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exclude=*11.2.1* *11.1.0* *11.1.1* *11.0.1* *11.0.2*</div></pre></td></tr></table></figure>
<p>查看可安装版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># yum --showduplicates list ceph | expand</div><div class="line">已加载插件：fastestmirror, langpacks</div><div class="line">Loading mirror speeds from cached hostfile</div><div class="line"> * base: mirrors.btte.net</div><div class="line"> * epel: mirrors.ustc.edu.cn</div><div class="line"> * extras: mirrors.neusoft.edu.cn</div><div class="line"> * updates: mirrors.btte.net</div><div class="line">可安装的软件包</div><div class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</div><div class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</div></pre></td></tr></table></figure>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>解决了上面的问题，但是又有如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">错误：软件包：1:ceph-osd-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：libleveldb.so.1()(64bit)</div><div class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：libbabeltrace.so.1()(64bit)</div><div class="line">错误：软件包：1:librbd1-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：liblttng-ust.so.0()(64bit)</div><div class="line">错误：软件包：1:ceph-mon-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：libleveldb.so.1()(64bit)</div><div class="line">错误：软件包：1:librados2-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：liblttng-ust.so.0()(64bit)</div><div class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：libleveldb.so.1()(64bit)</div><div class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：libbabeltrace-ctf.so.1()(64bit)</div><div class="line">错误：软件包：1:ceph-base-11.2.0-0.el7.x86_64 (ceph)</div><div class="line">          需要：liblttng-ust.so.0()(64bit)</div><div class="line"> 您可以尝试添加 --skip-broken 选项来解决该问题</div><div class="line"> 您可以尝试执行：rpm -Va --nofiles --nodigest</div></pre></td></tr></table></figure>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>依赖软件包的下载版本不一致，修改epel yum源即可，如果没有epel源，创建它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d/epel.repo</div><div class="line">[epel]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line">[epel-debuginfo]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div><div class="line"></div><div class="line">[epel-source]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div></pre></td></tr></table></figure>
<p>以上！</p>
<p>此时，ceph指定的版本就可以顺利的安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph -v</div><div class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> install </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux command day day up]]></title>
      <url>http://xiaqunfeng.cc/2017/09/21/linux-command-day-day-up/</url>
      <content type="html"><![CDATA[<p>This article is aim to record some not commonly used linux command which used in the work.<br><a id="more"></a></p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>该命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<p><strong>1、文件测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e 文件名</td>
<td>如果文件存在则为真</td>
</tr>
<tr>
<td>-r 文件名</td>
<td>如果文件存在且可读则为真</td>
</tr>
<tr>
<td>-w 文件名</td>
<td>如果文件存在且可写则为真</td>
</tr>
<tr>
<td>-x 文件名</td>
<td>如果文件存在且可执行则为真</td>
</tr>
<tr>
<td>-s 文件名</td>
<td>如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td>-d 文件名</td>
<td>如果文件存在且为目录则为真</td>
</tr>
<tr>
<td>-f 文件名</td>
<td>如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td>-c 文件名</td>
<td>如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td>-b 文件名</td>
<td>如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<p>比如，测试该系统是否含有某一个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># cat test.sh</div><div class="line">if test -f /etc/redhat-release ; then</div><div class="line">    echo &quot;this system is centos&quot;</div><div class="line">else</div><div class="line">    echo &quot;this system is unbuntu&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>在centos系统上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># sh test.sh</div><div class="line">this system is centos</div></pre></td></tr></table></figure>
<p>centos上<code>test -f /etc/redhat-release</code> 返回真，ubuntu系统上返回假。</p>
<p><strong>2、字符串测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于则为真</td>
</tr>
<tr>
<td>!=</td>
<td>不相等则为真</td>
</tr>
<tr>
<td>-z 字符串</td>
<td>字符串的长度为零则为真</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>字符串的长度不为零则为真</td>
</tr>
</tbody>
</table>
<p><strong>3、数值测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>等于则为真</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于则为真</td>
</tr>
<tr>
<td>-gt</td>
<td>大于则为真</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于则为真</td>
</tr>
<tr>
<td>-lt</td>
<td>小于则为真</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于则为真</td>
</tr>
</tbody>
</table>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># type cd</div><div class="line">cd 是 shell 内嵌</div><div class="line"># type date</div><div class="line">date 是 /usr/bin/date</div><div class="line"># type if</div><div class="line">if 是 shell 关键字</div><div class="line"># type mysql</div><div class="line">-bash: type: mysql: 未找到</div><div class="line"># type ll</div><div class="line">ll 是 `ls -l --color=auto&apos; 的别名</div><div class="line"># type yum</div><div class="line">yum 是 /usr/bin/yum</div><div class="line"># type apt-get</div><div class="line">-bash: type: apt-get: 未找到</div></pre></td></tr></table></figure>
<p>一些选项：</p>
<ul>
<li>-t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”； </li>
<li>-p：如果给出的指令为外部指令，则显示其绝对路径； </li>
<li>-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># type -t cd</div><div class="line">builtin</div><div class="line"># type -t ll</div><div class="line">alias</div><div class="line"># type -t yum</div><div class="line">file</div><div class="line"># type -t if</div><div class="line">keyword</div><div class="line">#################</div><div class="line"># type -p yum</div><div class="line">/usr/bin/yum</div><div class="line">#################</div><div class="line"># type -a cd</div><div class="line">cd 是 shell 内嵌</div><div class="line">cd 是 /usr/bin/cd</div><div class="line"># type -a date</div><div class="line">date 是 /usr/bin/date</div><div class="line"># type -a yum</div><div class="line">yum 是 /usr/bin/yum</div></pre></td></tr></table></figure>
<h2 id="TO-BE-ADD"><a href="#TO-BE-ADD" class="headerlink" title="TO BE ADD"></a>TO BE ADD</h2><p>TODO</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[awk study notes]]></title>
      <url>http://xiaqunfeng.cc/2017/09/19/awk-study-notes/</url>
      <content type="html"><![CDATA[<p>The awk study notes from working.<br><a id="more"></a></p>
<p>先从计算每个osd中分别有多少个pg的脚本入手，解析awk用法。见实例一。</p>
<h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>用于以下测试的待处理的文件 <code>test.txt</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PG_STAT OBJECTS MISSING_ON_PRIMARY DEGRADED MISPLACED UNFOUND BYTES LOG  DISK_LOG STATE        STATE_STAMP                VERSION   REPORTED   UP      UP_PRIMARY ACTING  ACTING_PRIMARY LAST_SCRUB SCRUB_STAMP                LAST_DEEP_SCRUB DEEP_SCRUB_STAMP</div><div class="line">14.2          23                  0        0         0       0     0 3011     3011 active+clean 2017-09-18 17:03:38.392203 57&apos;639918  57:989384 [4,3,0]          4 [4,3,0]              4  56&apos;635514 2017-09-18 17:03:38.392149       56&apos;616858 2017-09-14 19:36:02.937121</div><div class="line">#1.7           2                  0        0         0       0    92    6        6 active+clean 2017-09-18 19:30:20.206806      29&apos;6  57:232942 [3,4,1]          3 [3,4,1]              3       29&apos;6 2017-09-18 19:30:20.206744            29&apos;6 2017-09-14 20:35:14.294297</div></pre></td></tr></table></figure>
<p>想要学习的awk代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk &apos;</div><div class="line"> /^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125;</div><div class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</div><div class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</div><div class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3><p>1、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># awk &apos;/^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125; END &#123; printf(&quot;col=%d\n&quot;, col) &#125;&apos; test.txt</div><div class="line">col=15</div></pre></td></tr></table></figure>
<p>从 <code>PG_STAT</code> 开始，直到遇到 <code>UP</code> 时结束，计算得到 <code>UP</code> 后的列号。</p>
<p>2、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># awk &apos;/^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0 &#125; END &#123; printf(&quot;pool=%s, RSTART=%s, RLENGTH=%s\n&quot;, pool, RSTART, RLENGTH) &#125;&apos; test.txt</div><div class="line">pool=14, RSTART=1, RLENGTH=2</div></pre></td></tr></table></figure>
<p>解释一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/^[0-9a-f]+\.[0-9a-f]+/  ——  这个表示匹配开头格式是 X.X 的字符串，X表示一个或多个[0-9a-f]的数字字符</div></pre></td></tr></table></figure>
<p>关于match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match($0,/^[0-9a-f]+/)  ——  从第一列中匹配开头为 [0-9a-f] 的一个或多个数字字符</div></pre></td></tr></table></figure>
<blockquote>
<p>RSTART，RLENGTH在match成功之后会自动被设置成第一个匹配部分的起始位置和长度，没匹配上就是0，-1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pool=substr($0, RSTART, RLENGTH)  ——  得到pool的值</div></pre></td></tr></table></figure>
<p>3、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># awk &apos;/^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125;</div><div class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</div><div class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; printf(&quot;up=%s, RSTART=%s, RLENGTH=%s\n&quot;, up, RSTART,RLENGTH); t=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH); printf(&quot;osd=%s\n&quot;,t) &#125; &#125;&apos; test.txt</div><div class="line">up=[4,3,0], RSTART=2, RLENGTH=1</div><div class="line">osd=4</div><div class="line">up=,3,0], RSTART=2, RLENGTH=1</div><div class="line">osd=3</div><div class="line">up=,0], RSTART=2, RLENGTH=1</div><div class="line">osd=0</div></pre></td></tr></table></figure>
<p>得到 <code>ACTING</code> 列的OSD列表，用于统计每个pool在每个osd上的pg数。</p>
<h2 id="AWK模块"><a href="#AWK模块" class="headerlink" title="AWK模块"></a>AWK模块</h2><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">substr( String, M, [ N ] )</div></pre></td></tr></table></figure>
<p>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">match( String, Ere )</div></pre></td></tr></table></figure>
<p>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</p>
]]></content>
      
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph PGs per Pool Calculator]]></title>
      <url>http://xiaqunfeng.cc/2017/09/18/ceph-PGs-per-Pool-Calculator/</url>
      <content type="html"><![CDATA[<p>根据集群相关信息计算每个pool的pg数量。<br><a id="more"></a></p>
<p>在前一篇文章<a href="http://xiaqunfeng.cc/2017/09/15/too-many-PGs-per-OSD/">too-many-PGs-per-OSD</a>中，简单讲了pg数目的设定，这里再深入介绍一下计算方法。</p>
<h2 id="计算PG-Count的公式"><a href="#计算PG-Count的公式" class="headerlink" title="计算PG Count的公式"></a>计算PG Count的公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PoolPGCount=(TargetPGsPerOSD ∗ OSDNumber ∗ DataPercent) / PoolReplicateSize</div></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数释义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PoolPGCount</td>
<td>该pool的PG数量</td>
<td></td>
</tr>
<tr>
<td>TargetPGsPerOSD</td>
<td>每个OSD的PG数量</td>
<td>该值根据如下规则来进行设置：<br>1. 如果未来集群的OSD数量基本不再增长，Target PGs per OSD =100 <br>2. 如果未来集群的OSD数量可能增长到目前规模的2倍以内，Target PGs per OSD =200<br>3. 如果未来集群的OSD数量增长规模大于当前2倍且小于3倍，Target PGs per OSD =300</td>
</tr>
<tr>
<td>OSDNumber</td>
<td>OSD数目</td>
<td>默认是所有的OSD, 具体看OSD所属的rule<br>一般会通过CRUSH rules划分SSD和SATA两个ruleset，此时单独填写pool所在的对应rule的OSD数量</td>
</tr>
<tr>
<td>DataPercent</td>
<td>该pool占用所在OSD集群容量百分比</td>
<td>需要预估</td>
</tr>
<tr>
<td>PoolReplicateSize</td>
<td>该pool的副本数</td>
<td>replicate size，默认是3<br>如果是EC pool，该值为 m+n</td>
</tr>
</tbody>
</table>
<h2 id="结果取值"><a href="#结果取值" class="headerlink" title="结果取值"></a>结果取值</h2><p>1、如果上述计算结果小于 <code>OSDNumber/PoolReplicateSize</code> ，那就使用值 <code>OSDNumber/PoolReplicateSize</code> 。这是为了确保每个Pool的每个OSD至少分配一个Primary或Secondary PG来确保均匀加载/数据。</p>
<p>2、计算的最终结果应该是与计算结果相邻的2的幂次方。</p>
<blockquote>
<p>采用2的幂次方是因为了提高CRUSH算法的效率</p>
</blockquote>
<p>3、如果结果超过较小2次幂数值的25%则选择较大的2次幂作为最终结果，反之则选择较小的那个2次幂数值。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>1、计算公式的目的是为了确保整个集群拥有足够多的PG从而实现数据均匀分布在各个OSD上，同时能够有效避免在Recovery 和Backfill 的时候因为PG/OSD比值过高所造成的问题。 </p>
<p>2、如果集群中存在空pool或者其他non-active的pool，这些pool并不影响现有集群的数据分布，但是这些pool仍然会消耗集群的内存和CPU资源。</p>
<p>官网参考信息：<a href="http://ceph.com/pgcalc/" target="_blank" rel="external">http://ceph.com/pgcalc/</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[too many PGs per OSD]]></title>
      <url>http://xiaqunfeng.cc/2017/09/15/too-many-PGs-per-OSD/</url>
      <content type="html"><![CDATA[<p>ceph告警问题：”too many PGs per OSD” 的解决方法，以及pg数量的合理设定<br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">     health HEALTH_WARN	</div><div class="line">            too many PGs per OSD (412 &gt; max 300)</div><div class="line">     monmap e2: 3 mons at &#123;ceph0=172.21.1.21:6789/0,ceph1=172.21.1.22:6789/0,ceph2=172.21.1.23:6789/0&#125;</div><div class="line">            election epoch 1780, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">        mgr active: ceph0 standbys: ceph1, ceph2</div><div class="line">     osdmap e94: 6 osds: 6 up, 6 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v161317: 824 pgs, 10 pools, 30201 MB data, 8642 objects</div><div class="line">            90831 MB used, 181 GB / 269 GB avail</div><div class="line">                 824 active+clean</div><div class="line">  client io 34800 B/s wr, 0 op/s rd, 9 op/s wr</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>集群osd 数量较少</li>
<li>搭建rgw网关、OpenStack、容器组件等，pool创建较多，每个pool默认需要占用一些pg，pool中pg数目设置不合理，导致集群 total pg 数过多</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>调整每个osd默认pg数，参数为 <code>mon_pg_warn_max_per_osd</code> ，当前默认参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --show-config  | grep mon_pg_warn_max_per_osd</div><div class="line">mon_pg_warn_max_per_osd = 300</div></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、修改ceph配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cd /etc/ceph</div><div class="line"># vim ceph.conf</div><div class="line">[global]</div><div class="line">.......</div><div class="line">mon_pg_warn_max_per_osd = 500</div></pre></td></tr></table></figure>
<p>2、将配置文件推到mon所在的其他节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ceph-deploy --overwrite-conf config push ceph1 ceph2</div></pre></td></tr></table></figure>
<p>3、重启mon进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl restart ceph-mon.target</div></pre></td></tr></table></figure>
<p>重启成功后，再次查看配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --show-config  | grep mon_pg_warn_max_per_osd</div><div class="line">mon_pg_warn_max_per_osd = 500</div></pre></td></tr></table></figure>
<p>此时集群状态ok</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;ceph0=172.21.1.21:6789/0,ceph1=172.21.1.22:6789/0,ceph2=172.21.1.23:6789/0&#125;</div><div class="line">            election epoch 1780, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">        mgr active: ceph0 standbys: ceph1, ceph2</div><div class="line">     osdmap e94: 6 osds: 6 up, 6 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v161317: 824 pgs, 10 pools, 30201 MB data, 8642 objects</div><div class="line">            90831 MB used, 181 GB / 269 GB avail</div><div class="line">                 824 active+clean</div><div class="line">  client io 34800 B/s wr, 0 op/s rd, 9 op/s wr</div></pre></td></tr></table></figure>
<h2 id="pg数目的设定"><a href="#pg数目的设定" class="headerlink" title="pg数目的设定"></a>pg数目的设定</h2><h3 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h3><p>1、查看当前osd数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd ls | wc -l</div><div class="line">6</div></pre></td></tr></table></figure>
<p>2、查看当前有多少个pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool ls | wc -l</div><div class="line">10</div></pre></td></tr></table></figure>
<p>3、查看 replication pool 的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd dump | grep repli</div><div class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 31 flags hashpspool stripe_width 0</div><div class="line">pool 1 &apos;.rgw.root&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 14 flags hashpspool stripe_width 0</div><div class="line">pool 2 &apos;default.rgw.control&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 16 flags hashpspool stripe_width 0</div><div class="line">pool 3 &apos;default.rgw.data.root&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 19 flags hashpspool stripe_width 0</div><div class="line">pool 4 &apos;default.rgw.gc&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 20 flags hashpspool stripe_width 0</div><div class="line">pool 5 &apos;default.rgw.lc&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 21 flags hashpspool stripe_width 0</div><div class="line">pool 6 &apos;default.rgw.log&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 23 flags hashpspool stripe_width 0</div><div class="line">pool 7 &apos;default.rgw.users.uid&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 26 flags hashpspool stripe_width 0</div><div class="line">pool 8 &apos;kube&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 36 flags hashpspool stripe_width 0</div><div class="line">pool 9 &apos;stage&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 54 flags hashpspool stripe_width 0</div></pre></td></tr></table></figure>
<p>可以看到，每个pool都是 3 副本（<code>replicated size 3</code>）</p>
<h3 id="total-pg-num"><a href="#total-pg-num" class="headerlink" title="total pg num"></a>total pg num</h3><p>公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Total PGs = (Total_number_of_OSD * 100) / max_replication_count</div></pre></td></tr></table></figure>
<p>结果必须取最接近该数的 2 的幂</p>
<p>比如，根据以上信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Total_number_of_OSD = 6</div><div class="line">max_replication_count = 3</div><div class="line">Total PGs = 200</div></pre></td></tr></table></figure>
<p>最接近 200 的 2 的幂是 256。所以推荐的集群最大 total PGs 数为 256。</p>
<h3 id="pool-pg-num"><a href="#pool-pg-num" class="headerlink" title="pool pg num"></a>pool pg num</h3><p>每个 pool 的 pg 数目计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Total PGs = ((Total_number_of_OSD * 100) / max_replication_count) / pool_count</div></pre></td></tr></table></figure>
<p>结果同样要取最接近的 2 的幂。</p>
<p>对应该例，每个 pool 的 pg num 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pool_count = 10</div><div class="line">Total PGs = 200 / 10 = 20</div></pre></td></tr></table></figure>
<p>所以每个 pool 的平均分配 pg num 为 16。</p>
<h3 id="pg-num-command"><a href="#pg-num-command" class="headerlink" title="pg num command"></a>pg num command</h3><p>得到和设置指定 pool 中的 pg_num 和 pgp_num</p>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ceph osd pool create &lt;pool-name&gt; &lt;pg-number&gt; &lt;pgp-number&gt;</code></td>
<td>To create a new pool</td>
</tr>
<tr>
<td><code>ceph osd pool get &lt;pool-name&gt; &lt;pg_num&gt;</code></td>
<td>To get number of PG in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool get &lt;pool-name&gt; &lt;pgp_num&gt;</code></td>
<td>To get number of PGP in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool set &lt;pool-name&gt; &lt;pg_num number&gt;</code></td>
<td>To increase number of PG in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool set &lt;pool-name&gt; &lt;pgp_num number&gt;</code></td>
<td>To increase number of PGP in a pool</td>
</tr>
</tbody>
</table>
<p>创建pool时如果不指定 pg_num，默认为8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --show-config  | grep osd_pool_default_pg_num</div><div class="line">osd_pool_default_pg_num = 8</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> osd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上安装python3]]></title>
      <url>http://xiaqunfeng.cc/2017/09/11/mac%E4%B8%8A%E5%AE%89%E8%A3%85python3/</url>
      <content type="html"><![CDATA[<p>简单介绍一下mac上如何安装和使用 python3<br><a id="more"></a></p>
<h2 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h2><p>官网地址：<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a></p>
<p>执行如下命令安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<p>安装完后查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ brew --version</div><div class="line">Homebrew 1.3.0</div><div class="line">Homebrew/homebrew-core (git revision 2f02; last commit 2017-07-31)</div></pre></td></tr></table></figure>
<p>表示安装成功。</p>
<h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>使用homebrew工具直接安装python3，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ brew install python3</div></pre></td></tr></table></figure>
<p>安装完后查看python3版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">▶ python3 --version</div><div class="line">Python 3.6.0</div></pre></td></tr></table></figure>
<p>安装成功。</p>
<h2 id="使用python3"><a href="#使用python3" class="headerlink" title="使用python3"></a>使用python3</h2><p>1、交互式命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">▶ python3</div><div class="line">Python 3.6.0 (default, Mar  4 2017, 12:32:34)</div><div class="line">[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>此时就可以输入python代码和运算了。</p>
<p>退出交互式命令有两种方法：ctrl + D，或者输入 <code>quit()</code> 然后回车。</p>
<p>2、执行python文件</p>
<p>如编写python代码 test.py，通过命令 python3 来运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ python3 test.py</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[lsblk命令]]></title>
      <url>http://xiaqunfeng.cc/2017/08/30/lsblk%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>介绍lsblk命令的详细用法。<br><a id="more"></a></p>
<h2 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h2><p>功能：列出块设备</p>
<p>描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lsblk lists information about all available or the specified block devices.  The lsblk command reads the sysfs filesystem to gather information.</div><div class="line"></div><div class="line">The command prints all block devices (except RAM disks) in a tree-like format by default.  Use lsblk --help to get a list of all available columns.</div><div class="line"></div><div class="line">The default output, as well as the default output from options like --fs and --topology, is subject to change.  So whenever possible, you should avoid using default out‐puts in your scripts.  Always explicitly define expected columns by using --output columns-list in environments where a stable output is required.</div></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsblk [选项] [&lt;设备&gt; ...]</div></pre></td></tr></table></figure>
<p>-a 是默认选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1  436K  0 rom</div><div class="line">vda    253:0    0   20G  0 disk</div><div class="line">├─vda1 253:1    0    2M  0 part</div><div class="line">├─vda2 253:2    0  500M  0 part /boot</div><div class="line">└─vda3 253:3    0 19.5G  0 part /</div><div class="line">vdb    253:16   0   20G  0 disk</div><div class="line">├─vdb1 253:17   0  9.3G  0 part</div><div class="line">└─vdb2 253:18   0  9.3G  0 part </div><div class="line">vdc    253:32   0   10G  0 disk</div><div class="line">└─vdc1 253:33   0  9.3G  0 part</div></pre></td></tr></table></figure>
<h3 id="head说明"><a href="#head说明" class="headerlink" title="head说明"></a>head说明</h3><table>
<thead>
<tr>
<th>HEAD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>块设备名</td>
</tr>
<tr>
<td>MAJ:MIN</td>
<td>主要和次要设备号</td>
</tr>
<tr>
<td>RM</td>
<td>设备是否可移动设备(1为可移动)</td>
</tr>
<tr>
<td>SIZE</td>
<td>设备的容量大小信息</td>
</tr>
<tr>
<td>RO</td>
<td>设备是否为只读(1表示只读)</td>
</tr>
<tr>
<td>TYPE</td>
<td>块设备是否是磁盘或磁盘上的一个分区(disk表示是磁盘，part表示是分区, rom表示只读存储)</td>
</tr>
<tr>
<td>MOUNTPOINT</td>
<td>设备挂载的挂载点</td>
</tr>
</tbody>
</table>
<h3 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">选项：</div><div class="line"> -a, --all            打印所有设备</div><div class="line"> -b, --bytes          以字节为单位而非易读的格式来打印 SIZE</div><div class="line"> -d, --nodeps         不打印从属设备(slave)或占位设备(holder)</div><div class="line"> -D, --discard        打印时丢弃能力</div><div class="line"> -e, --exclude &lt;列表&gt; 根据主设备号排除设备(默认：内存盘)</div><div class="line"> -I, --include &lt;列表&gt; 只显示有指定主设备号的设备</div><div class="line"> -f, --fs             输出文件系统信息</div><div class="line"> -h, --help           使用信息(此信息)</div><div class="line"> -i, --ascii          只使用 ascii 字符</div><div class="line"> -m, --perms          输出权限信息</div><div class="line"> -l, --list           使用列表格式的输出</div><div class="line"> -n, --noheadings     不打印标题</div><div class="line"> -o, --output &lt;列表&gt;  输出列</div><div class="line"> -p, --paths          打印完整设备路径</div><div class="line"> -P, --pairs          使用 key=“value” 输出格式</div><div class="line"> -r, --raw            使用原生输出格式</div><div class="line"> -s, --inverse        反向依赖</div><div class="line"> -t, --topology       输出拓扑信息</div><div class="line"> -S, --scsi           输出有关 SCSI 设备的信息</div><div class="line"></div><div class="line"> -h, --help     显示此帮助并退出</div><div class="line"> -V, --version  输出版本信息并退出</div></pre></td></tr></table></figure>
<h2 id="选项示例"><a href="#选项示例" class="headerlink" title="选项示例"></a>选项示例</h2><h3 id="b"><a href="#b" class="headerlink" title="-b"></a>-b</h3><p>以字节为单位而非易读的格式来打印 SIZE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk -b</div><div class="line">NAME   MAJ:MIN RM        SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1      446464  0 rom</div><div class="line">vda    253:0    0 21474836480  0 disk</div><div class="line">├─vda1 253:1    0     2097152  0 part</div><div class="line">├─vda2 253:2    0   524288000  0 part /boot</div><div class="line">└─vda3 253:3    0 20947402752  0 part /</div><div class="line">vdb    253:16   0 21474836480  0 disk</div><div class="line">├─vdb1 253:17   0  9999220736  0 part</div><div class="line">└─vdb2 253:18   0  9999220736  0 part </div><div class="line">vdc    253:32   0 10737418240  0 disk</div><div class="line">└─vdc1 253:33   0  9999220736  0 part</div></pre></td></tr></table></figure>
<h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>不打印从属设备(slave)或占位设备(holder)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># lsblk -d</div><div class="line">NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0   11:0    1  436K  0 rom</div><div class="line">vda  253:0    0   20G  0 disk</div><div class="line">vdb  253:16   0   20G  0 disk</div><div class="line">vdc  253:32   0   10G  0 disk</div></pre></td></tr></table></figure>
<h3 id="f"><a href="#f" class="headerlink" title="-f"></a>-f</h3><p>输出文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk -f</div><div class="line">NAME   FSTYPE  LABEL    UUID                                 MOUNTPOINT</div><div class="line">sr0    iso9660 config-2 2017-05-19-09-35-17-00</div><div class="line">vda</div><div class="line">├─vda1 vfat    BOOT     9485-0659</div><div class="line">├─vda2 xfs              4931e9cc-324d-43f1-9c77-c283add1d38d /boot</div><div class="line">└─vda3 xfs              8b9001aa-126c-489f-b23d-98ea539ee204 /</div><div class="line">vdb</div><div class="line">├─vdb1</div><div class="line">└─vdb2 xfs              824f74a5-0cd5-411a-a77f-8b42f398bb44 </div><div class="line">vdc</div><div class="line">└─vdc1 xfs              5389e17f-7613-48b1-a905-3115a43288e9</div></pre></td></tr></table></figure>
<h3 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h3><p>输出权限信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk -m</div><div class="line">NAME    SIZE OWNER GROUP MODE</div><div class="line">sr0     436K root  cdrom brw-rw----</div><div class="line">vda      20G root  disk  brw-rw----</div><div class="line">├─vda1    2M root  disk  brw-rw----</div><div class="line">├─vda2  500M root  disk  brw-rw----</div><div class="line">└─vda3 19.5G root  disk  brw-rw----</div><div class="line">vdb      20G root  disk  brw-rw----</div><div class="line">├─vdb1  9.3G root  disk  brw-rw----</div><div class="line">└─vdb2  9.3G ceph  ceph  brw-rw----</div><div class="line">vdc      10G root  disk  brw-rw----</div><div class="line">└─vdc1  9.3G ceph  ceph  brw-rw----</div></pre></td></tr></table></figure>
<h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p>使用列表格式的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk -l</div><div class="line">NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0   11:0    1  436K  0 rom</div><div class="line">vda  253:0    0   20G  0 disk</div><div class="line">vda1 253:1    0    2M  0 part</div><div class="line">vda2 253:2    0  500M  0 part /boot</div><div class="line">vda3 253:3    0 19.5G  0 part /</div><div class="line">vdb  253:16   0   20G  0 disk</div><div class="line">vdb1 253:17   0  9.3G  0 part</div><div class="line">vdb2 253:18   0  9.3G  0 part </div><div class="line">vdc  253:32   0   10G  0 disk</div><div class="line">vdc1 253:33   0  9.3G  0 part</div></pre></td></tr></table></figure>
<h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p>使用 key=“value” 输出格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># lsblk -P</div><div class="line">NAME=&quot;sr0&quot; MAJ:MIN=&quot;11:0&quot; RM=&quot;1&quot; SIZE=&quot;436K&quot; RO=&quot;0&quot; TYPE=&quot;rom&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vda&quot; MAJ:MIN=&quot;253:0&quot; RM=&quot;0&quot; SIZE=&quot;20G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vda1&quot; MAJ:MIN=&quot;253:1&quot; RM=&quot;0&quot; SIZE=&quot;2M&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vda2&quot; MAJ:MIN=&quot;253:2&quot; RM=&quot;0&quot; SIZE=&quot;500M&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/boot&quot;</div><div class="line">NAME=&quot;vda3&quot; MAJ:MIN=&quot;253:3&quot; RM=&quot;0&quot; SIZE=&quot;19.5G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/&quot;</div><div class="line">NAME=&quot;vdb&quot; MAJ:MIN=&quot;253:16&quot; RM=&quot;0&quot; SIZE=&quot;20G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vdb1&quot; MAJ:MIN=&quot;253:17&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vdb2&quot; MAJ:MIN=&quot;253:18&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/var/lib/ceph/osd/ceph-2&quot;</div><div class="line">NAME=&quot;vdc&quot; MAJ:MIN=&quot;253:32&quot; RM=&quot;0&quot; SIZE=&quot;10G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</div><div class="line">NAME=&quot;vdc1&quot; MAJ:MIN=&quot;253:33&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/var/lib/ceph/osd/ceph-4&quot;</div></pre></td></tr></table></figure>
<h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><p>输出拓扑信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk -t</div><div class="line">NAME   ALIGNMENT MIN-IO OPT-IO PHY-SEC LOG-SEC ROTA SCHED RQ-SIZE   RA WSAME</div><div class="line">sr0            0   2048      0    2048    2048    1 cfq       128  128    0B</div><div class="line">vda            0    512      0     512     512    1           128 4096    0B</div><div class="line">├─vda1         0    512      0     512     512    1           128 4096    0B</div><div class="line">├─vda2         0    512      0     512     512    1           128 4096    0B</div><div class="line">└─vda3         0    512      0     512     512    1           128 4096    0B</div><div class="line">vdb            0    512      0     512     512    1           128 4096    0B</div><div class="line">├─vdb1         0    512      0     512     512    1           128 4096    0B</div><div class="line">└─vdb2         0    512      0     512     512    1           128 4096    0B</div><div class="line">vdc            0    512      0     512     512    1           128 4096    0B</div><div class="line">└─vdc1         0    512      0     512     512    1           128 4096    0B</div></pre></td></tr></table></figure>
<p>其中 <code>SCHED</code> 是调度算法，有 cfq、deadline 等等。</p>
<h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>输出有关 SCSI 设备的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># lsblk -S</div><div class="line">NAME HCTL       TYPE VENDOR   MODEL             REV TRAN</div><div class="line">sr0  1:0:1:0    rom  QEMU     QEMU DVD-ROM     2.1. ata</div></pre></td></tr></table></figure>
<h3 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h3><p>输出列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># lsblk -o FSTYPE /dev/vdb2</div><div class="line">FSTYPE</div><div class="line">xfs</div></pre></td></tr></table></figure>
<h3 id="n"><a href="#n" class="headerlink" title="-n"></a>-n</h3><p>不打印标题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># lsblk -n -o FSTYPE /dev/vdb2</div><div class="line">xfs</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Syntax error: '(' unexpected]]></title>
      <url>http://xiaqunfeng.cc/2017/08/29/Syntax-error-unexpected/</url>
      <content type="html"><![CDATA[<p>一个shell脚本在centos和ubuntu上执行的问题。<br><a id="more"></a></p>
<p>今天发现一个奇怪的现象，原先在centos上写的可用的shell脚本，今天在ubuntu上突然运行就报错了。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>脚本部分内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cat test.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">array_osd=(2 3 4 5)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sh test.sh</div></pre></td></tr></table></figure>
<p>报的错误是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Syntax error: &quot;(&quot; unexpected</div></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过 <code>sh</code> 来执行脚本时，内核实际上执行的是 <code>/bin/sh</code></p>
<p>但是，在ubuntu上，<code>/bin/sh</code> 是 dash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 16.04.2 LTS</div><div class="line">Release:	16.04</div><div class="line">Codename:	xenial</div><div class="line"># ll /bin/sh</div><div class="line">lrwxrwxrwx 1 root root 4 Aug 22 16:24 /bin/sh -&gt; dash*</div></pre></td></tr></table></figure>
<p>而，在centos上，<code>/bin/sh</code> 是 bash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsb_release -a</div><div class="line">LSB Version:	:core-4.1-amd64:core-4.1-noarch</div><div class="line">Distributor ID:	CentOS</div><div class="line">Description:	CentOS Linux release 7.3.1611 (Core)</div><div class="line">Release:	7.3.1611</div><div class="line">Codename:	Core</div><div class="line"># ll /bin/sh</div><div class="line">lrwxrwxrwx. 1 root root 4 4月  20 11:52 /bin/sh -&gt; bash</div></pre></td></tr></table></figure>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>脚本中已经加了 <code>!/bin/bash</code> ，所以，直接执行的话，是用 bash 来执行，用 <code>sh</code> 会覆盖默认的bash。</p>
<p>所以，可以执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod +x test.sh</div><div class="line">$ ./test.sh</div></pre></td></tr></table></figure>
<p>OK，这时候就没有错误了</p>
]]></content>
      
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph osd相关操作]]></title>
      <url>http://xiaqunfeng.cc/2017/08/17/ceph-osd%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>ceph osd的相关操作，包括osd的部署（自动和手动部署）、OSD操作、journal软链、uuid等。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是之前笔记的一个整理，基于ceph jewel版本。</p>
<ul>
<li>自动部署osd可以采用 <code>ceph-deploy</code> ，也可以采用 <code>ceph-disk</code> 命令</li>
<li>luminous版本中，删除OSD可以直接使用 <code>ceph osd purge</code> 命令，比较省心</li>
<li>生产环节中磁盘的挂载尽量采用uuid/partuuid</li>
</ul>
<h2 id="添加OSD"><a href="#添加OSD" class="headerlink" title="添加OSD"></a>添加OSD</h2><p>查看当前挂载情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   200G  0 disk </div><div class="line">└─vdb1 253:17   0 186.3G  0 part /var/lib/ceph/osd/ceph-0</div><div class="line">vdc    253:32   0   200G  0 disk </div><div class="line">└─vdc1 253:33   0 186.3G  0 part /var/lib/ceph/osd/ceph-1</div></pre></td></tr></table></figure>
<p>在三个机器上：ceph-0, ceph-1, ceph-2 上每个机器挂两块盘，自动添加方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ceph-deploy osd prepare ceph-0:/dev/vdb1 ceph-0:/dev/vdc1</div><div class="line">chown ceph:ceph /dev/vdb1 /dev/vdc1</div><div class="line">ceph-deploy osd activate ceph-0:/dev/vdb1 ceph-0:/dev/vdc1</div><div class="line"></div><div class="line">ceph-deploy osd prepare ceph-1:/dev/vdb1 ceph-1:/dev/vdc1</div><div class="line">ssh ceph-1 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1&apos;</div><div class="line">ceph-deploy osd activate ceph-1:/dev/vdb1 ceph-1:/dev/vdc1</div><div class="line"></div><div class="line">ceph-deploy osd prepare ceph-2:/dev/vdb1 ceph-2:/dev/vdc1</div><div class="line">ssh ceph-2 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1&apos;</div><div class="line">ceph-deploy osd activate ceph-2:/dev/vdb1 ceph-2:/dev/vdc1</div></pre></td></tr></table></figure>
<p>这种方式添加完以后，OSD的状态就已经是 up 和 in 的状态了。</p>
<h2 id="手动部署OSD"><a href="#手动部署OSD" class="headerlink" title="手动部署OSD"></a>手动部署OSD</h2><h3 id="手动添加一个OSD过程"><a href="#手动添加一个OSD过程" class="headerlink" title="手动添加一个OSD过程"></a>手动添加一个OSD过程</h3><p>可以使用UUID来创建OSD，也可以不用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># uuidgen</div><div class="line">334d3f46-938c-41b7-9dc9-edc7e3036cbe</div><div class="line"># ceph osd create 334d3f46-938c-41b7-9dc9-edc7e3036cbe</div></pre></td></tr></table></figure>
<p>如果没有事先创建OSD的话，也可以在后面创建</p>
<p><strong>1、创建OSD目录，并把磁盘挂载到该目录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /var/lib/ceph/osd/ceph-0</div><div class="line">mkfs -t xfs -d name=/dev/sda1 -f</div><div class="line">mount -noatime /dev/sda1 /var/lib/ceph/osd/ceph-0/</div></pre></td></tr></table></figure>
<p>查看挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># mount | egrep sda</div><div class="line">/dev/sda1 on /var/lib/ceph/osd/ceph-0 type xfs (rw)</div></pre></td></tr></table></figure>
<p><strong>2、初始化OSD数据目录</strong></p>
<p>不带uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i 0 --mkfs --mkkey</div></pre></td></tr></table></figure>
<p>带uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i 0 --mkfs --mkkey --osd-uuid 334d3f46-938c-41b7-9dc9-edc7e3036cbe</div></pre></td></tr></table></figure>
<p><strong>3、注册OSD的key权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth add osd.0 osd &apos;allow *&apos; mon &apos;allow profile osd&apos; -i /var/lib/ceph/osd/ceph-0/keyring</div></pre></td></tr></table></figure>
<p><strong>4、添加OSD节点到 crush map中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd crush add-bucket ceph01 host</div><div class="line">ceph osd crush move ceph01 root=default</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph create osd		// 如果之前没有创建OSD，那在加入crush map前要调用该命令创建OSD</div><div class="line">ceph osd crush add osd.0 1.0 host=ceph01</div></pre></td></tr></table></figure>
<p><strong>5、启动OSD</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start ceph-osd id=0</div></pre></td></tr></table></figure>
<h3 id="shell脚本示例"><a href="#shell脚本示例" class="headerlink" title="shell脚本示例"></a>shell脚本示例</h3><p>在节点data01上部署osd 0，1，2，3（不包含目录的创建、磁盘格式化和挂载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">host_name=data01</div><div class="line"># 以下两条命令一个节点执行一次就好了，不需要每添加一个OSD执行一次</div><div class="line">ceph osd crush add-bucket $host_name host		</div><div class="line">ceph osd crush move $host_name root=default		</div><div class="line"></div><div class="line">for osd_num in $(seq 0 3)</div><div class="line">do</div><div class="line">    ceph-osd -i $osd_num --mkfs --mkkey</div><div class="line">    ceph auth add osd.$osd_num osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-$osd_num/keyring</div><div class="line">    ceph osd create</div><div class="line">    ceph osd crush add osd.$osd_num 1.0 host=$host_name</div><div class="line">    ceph osd in $osd_num</div><div class="line">    chown -R ceph:ceph /var/lib/ceph/osd/ceph-$osd_num</div><div class="line">    start ceph-osd id=$osd_num</div><div class="line">done</div></pre></td></tr></table></figure>
<p>注：手动添加方式还可以参考<a href="http://docs.ceph.org.cn/rados/operations/add-or-rm-osds/" target="_blank" rel="external">官方文档</a></p>
<h2 id="将挂载信息写入fstab"><a href="#将挂载信息写入fstab" class="headerlink" title="将挂载信息写入fstab"></a>将挂载信息写入fstab</h2><blockquote>
<p>好处是重启以后不需要再去手动mount。</p>
</blockquote>
<p>在 <code>/etc/fstab</code> 末尾添加如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/dev/vdb1	/var/lib/ceph/osd/ceph-0	xfs	defaults	0	2</div><div class="line">/dev/vdc1	/var/lib/ceph/osd/ceph-1	xfs	defaults	0	2</div></pre></td></tr></table></figure>
<p>然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -a</div></pre></td></tr></table></figure>
<p>没有任何输出，表示挂载成功。</p>
<p>查看挂载信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># df</div><div class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</div><div class="line">udev             2009636      12   2009624   1% /dev</div><div class="line">tmpfs             404696     552    404144   1% /run</div><div class="line">/dev/vda3       20027260 3009144  15977732  16% /</div><div class="line">none                   4       0         4   0% /sys/fs/cgroup</div><div class="line">none                5120       0      5120   0% /run/lock</div><div class="line">none             2023472      16   2023456   1% /run/shm</div><div class="line">none              102400       0    102400   0% /run/user</div><div class="line">/dev/vda2         463844   44634    390743  11% /boot</div><div class="line">/dev/vdb1      195216252 5282432 189933820   3% /var/lib/ceph/osd/ceph-0</div><div class="line">/dev/vdc1      195216252 5281204 189935048   3% /var/lib/ceph/osd/ceph-1</div></pre></td></tr></table></figure>
<h2 id="启动OSD"><a href="#启动OSD" class="headerlink" title="启动OSD"></a>启动OSD</h2><p>比如机器重启后，OSD处于 down 和 out 的状态，还没运行，必须先启动 OSD 它才能收数据。（前提是已经挂载好了）</p>
<p>在 Debian/Ubuntu 上用 Upstart。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo start ceph-osd id=&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>在 CentOS/RHEL 上用 sysvinit 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/ceph start osd.&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>一旦你启动了 OSD ，其状态就由 down 变成 up。</p>
<p>注：必须去OSD所在节点上执行该命令才可以成功。好像不是的</p>
<h2 id="踢出和加入集群"><a href="#踢出和加入集群" class="headerlink" title="踢出和加入集群"></a>踢出和加入集群</h2><p>把 OSD 踢出集群</p>
<p>删除 OSD 前，它通常是 up 且 in 的，要先把它踢出集群，以使 Ceph 启动重新均衡、把数据拷贝到其他 OSD 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd out &#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>同样的，把OSD加入集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd in &#123;osd-num&#125;</div></pre></td></tr></table></figure>
<h2 id="停止OSD"><a href="#停止OSD" class="headerlink" title="停止OSD"></a>停止OSD</h2><p>把 OSD 踢出集群后，它可能仍在运行，就是说其状态为 up 且 out 。删除前要先停止 OSD 进程。</p>
<p>CentOS下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh &#123;osd-host&#125;</div><div class="line">sudo /etc/init.d/ceph stop osd.&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>ubuntu下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop ceph-osd id=&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>停止 OSD 后，状态变为 down 。</p>
<h2 id="删除OSD"><a href="#删除OSD" class="headerlink" title="删除OSD"></a>删除OSD</h2><p>此步骤依次把一个 OSD 移出集群 CRUSH 图、删除认证密钥、删除 OSD 图条目、删除 ceph.conf 条目。如果主机有多个硬盘，每个硬盘对应的 OSD 都得重复此步骤。</p>
<p>1、删除 CRUSH 图的对应 OSD 条目，它就不再接收数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush remove &#123;name&#125;		// ex: name = osd.0</div></pre></td></tr></table></figure>
<p>2、删除 OSD 认证密钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth del osd.&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>3、ceph-{osd-num} 路径里的 ceph 值是 $cluster-$id ，如果集群名字不是 ceph ，这里要更改。</p>
<p>删除 OSD 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd rm &#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>如果将OSD相关的配置文件写到ceph配置文件中，那接下来还要删除配置文件中相关信息：</p>
<p>登录到保存 ceph.conf 主拷贝的主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh &#123;admin-host&#125;</div><div class="line">cd /etc/ceph</div><div class="line">vim ceph.conf</div></pre></td></tr></table></figure>
<p>从 ceph.conf 配置文件里删除对应条目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[osd.1]</div><div class="line">        host = &#123;hostname&#125;</div></pre></td></tr></table></figure>
<p>从保存 ceph.conf 主拷贝的主机，把更新过的 ceph.conf 拷贝到集群其他主机的 /etc/ceph 目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf config push &#123;hostname1&#125; &#123;hostname2&#125;</div></pre></td></tr></table></figure>
<p>完整的删除流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1）ceph osd crush reweight osd.x 0.0  </div><div class="line">... 等待平衡结束....  </div><div class="line">2）ceph osd out osd.x  </div><div class="line">3）service ceph stop osd.x</div><div class="line"></div><div class="line">4）ceph osd crush remove osd.x  </div><div class="line">5）ceph auth del osd.x  </div><div class="line">6）ceph osd rm X</div></pre></td></tr></table></figure>
<h2 id="调整osd的权重"><a href="#调整osd的权重" class="headerlink" title="调整osd的权重"></a>调整osd的权重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush reweight osd.&#123;osd-no&#125; 1.000</div></pre></td></tr></table></figure>
<p>一般 1T 盘的权重为1.0，按照这个基准来调整OSD的权重。</p>
<h2 id="清除ceph信息"><a href="#清除ceph信息" class="headerlink" title="清除ceph信息"></a>清除ceph信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">先停掉ceph相关进程</div><div class="line">rm /etc/ceph/*</div><div class="line">rm /var/lib/ceph/*</div></pre></td></tr></table></figure>
<p>格式化和挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">umount /var/lib/ceph/osd/ceph-26</div><div class="line">mkfs -t xfs -d name=/dev/sdf14 -f</div><div class="line">mount -noatime /dev/sdf14 /var/lib/ceph/osd/ceph-0</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题：运行osd启动命令后发现 osd还是down的状态</p>
<p>查看日志：<code>vim /var/log/ceph/ceph-osd.x.log</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2017-04-05 08:52:30.292249 7fe3789f1800  0 set uid:gid to 64045:64045 (ceph:ceph)</div><div class="line">2017-04-05 08:52:30.292263 7fe3789f1800  0 ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367), process ceph-osd, pid 27926</div><div class="line">2017-04-05 08:52:30.293056 7fe3789f1800  0 pidfile_write: ignore empty --pid-file</div><div class="line">2017-04-05 08:52:30.310394 7fe3789f1800 -1 filestore(/var/lib/ceph/osd/ceph-0) FileStore::mount: unable to access basedir &apos;/var/lib/ceph/osd/ceph-0&apos;: (13) Permission denied</div><div class="line">2017-04-05 08:52:30.310408 7fe3789f1800 -1 osd.0 0 OSD:init: unable to mount object store</div><div class="line">2017-04-05 08:52:30.310414 7fe3789f1800 -1  ** ERROR: osd init failed: (13) Permission denied</div></pre></td></tr></table></figure>
<p>权限的问题，修改osd目录权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown -R ceph:ceph /var/lib/ceph/osd</div></pre></td></tr></table></figure>
<h2 id="journal软链接"><a href="#journal软链接" class="headerlink" title="journal软链接"></a>journal软链接</h2><p>将ceph集群OSD对应的journal软链接到SSD的一个分区，提高journal速度。给每个OSD的journal配置独立的SSD分区有两种方式</p>
<h3 id="第一种是创建OSD的时候指定分区"><a href="#第一种是创建OSD的时候指定分区" class="headerlink" title="第一种是创建OSD的时候指定分区"></a>第一种是创建OSD的时候指定分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph-deploy osd prepare ceph-4:/dev/vdb1:/dev/vde1  //前面的是数据盘，后面的是日志盘</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="第二种就是软链接"><a href="#第二种就是软链接" class="headerlink" title="第二种就是软链接"></a>第二种就是软链接</h3><p>以下以 osd.0 为例，使用uuid</p>
<p>1、设置noout标志，防止集群进行数据恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd set noout</div></pre></td></tr></table></figure>
<p>2、停止OSD进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop ceph-osd id=0</div></pre></td></tr></table></figure>
<p>3、下刷journal到OSD中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i 0 --flush-journal</div></pre></td></tr></table></figure>
<p>4、移除旧的journal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal</div></pre></td></tr></table></figure>
<p>5、将新的journal链接到原来的位置</p>
<p>查看要链接的SSD分区uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ll /dev/disk/by-partuuid/ | grep sdb1</div><div class="line">lrwxrwxrwx 1 root root  10 Apr  5 11:26 bcb81c86-5c98-4f65-9102-a0da5d1e5241 -&gt; ../../sdb1</div></pre></td></tr></table></figure>
<p>链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /dev/disk/by-partuuid/bcb81c86-5c98-4f65-9102-a0da5d1e5241 /var/lib/ceph/osd/ceph-0/journal</div></pre></td></tr></table></figure>
<p>修改权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</div></pre></td></tr></table></figure>
<p>保存uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo bcb81c86-5c98-4f65-9102-a0da5d1e5241 &gt; /var/lib/ceph/osd/ceph-0/journal_uuid</div></pre></td></tr></table></figure>
<p>6、创建journal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-osd -i 0 --mkjournal</div></pre></td></tr></table></figure>
<p>7、启动osd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start ceph-osd id=0</div></pre></td></tr></table></figure>
<p>8、去除noout标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd unset noout</div></pre></td></tr></table></figure>
<blockquote>
<p>有时候为了图省事，不用uuid，直接使用分区名称，也可以，生产环境中必须用uuid，切记！！</p>
</blockquote>
<h3 id="脚本列表"><a href="#脚本列表" class="headerlink" title="脚本列表"></a>脚本列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ceph osd set noout</div><div class="line">stop ceph-osd id=0</div><div class="line">ceph-osd -i 0 --flush-journal </div><div class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal </div><div class="line">ln -s /dev/sdf1 /var/lib/ceph/osd/ceph-0/journal	</div><div class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-0/journal</div><div class="line">chown -R ceph:ceph /dev/sdf1</div><div class="line">ceph-osd --mkjournal -i 0</div><div class="line">start ceph-osd id=0</div><div class="line">ceph osd unset noout</div></pre></td></tr></table></figure>
<p>注意，在软链的时候 <code>ln -s</code> 前面的参数是设备名称 <code>/dev/sdf1</code> ，而不是其所挂载的目录 <code>/mnt/journal/ceph-0</code></p>
<blockquote>
<p>注意，也要修改软链设备的权限</p>
</blockquote>
<h2 id="persistent-block-device-naming"><a href="#persistent-block-device-naming" class="headerlink" title="persistent block device naming"></a>persistent block device naming</h2><p>如果你的机器上有不止一个 SATA, SCSI 或 IDE 磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如 <code>/dev/sda</code> 与 <code>/dev/sdb</code> 互换了，最终导致系统不可引导、kernel panic、或者设备不可见。持久化命名法可以解决这些问题。</p>
<p>有四种持久化命名方案：<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">by-label</a>#by-label)、<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">by-uuid</a>#by-uuid)、<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">by-id 和 by-path</a>#by-id_.E5.92.8C_by-path)。对于那些使用<a href="https://wiki.archlinux.org/index.php/GUID_Partition_Table" target="_blank" rel="external">GUID 分区表(GPT)</a>的磁盘，还有额外的两种方案，<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">by-partlabel</a>#by-partlabel) 和 <a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">by-partuuid</a>#by-partuuid)。你也可以<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">使用 Udev 静态设备名</a>#.E4.BD.BF.E7.94.A8<em>Udev</em>.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D)方案。</p>
<p>GPT分区表的系统应用应该用 <code>blkid</code> 命令查看，列出的uuid和使用 <code>ll /dev/disk/by-uuid</code> 得到的结果一样。</p>
<blockquote>
<p>注：by-uuid 和 by-partuuid 得到的结果不一样，使用其中一种命名方式即可</p>
</blockquote>
<h3 id="by-uuid"><a href="#by-uuid" class="headerlink" title="by-uuid"></a>by-uuid</h3><p>UUID是一种给每个文件系统唯一标识符的机制。 这些标识符由文件系统实用程序（例如，mkfs。*）生成，当分区被格式化并和设计时不太可能发生冲突。 所有GNU / Linux文件系统（包括原始加密设备的交换和LUKS头）都支持UUID。 FAT和NTFS文件系统（上面的fat和windows标签）不支持UUID，但仍然列在 <code>/dev/disk/by-uuid</code> 中，具有较短的UID（唯一标识符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /dev/disk/by-uuid/</div></pre></td></tr></table></figure>
<p>使用UUID方法的优点是名称冲突发生的可能性远远小于标签。 此外，它在文件系统的创建时自动生成。 例如，即使设备插入另一个系统（可能具有相同标签的设备），它将保持独特。<br>缺点是UUID使得很长的代码行难以读取和中断许多配置文件（例如fstab或crypttab）中的格式化。 每次分区<strong>重新调整大小</strong>或<strong>重新格式化</strong>时，都会生成一个新的UUID，并且必须调整配置（手动）。<br>提示：如果swap分区没有分配UUID，则需要使用mkswap实用程序重置交换分区。</p>
<h3 id="by-partuuid"><a href="#by-partuuid" class="headerlink" title="by-partuuid"></a>by-partuuid</h3><p>注意：此方法仅涉及具有GUID分区表（GPT）的磁盘。<br>像GPT分区标签一样，GPT分区UUID在GPT磁盘上的分区条目中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /dev/disk/by-partuuid/</div></pre></td></tr></table></figure>
<p>关于其他的使用方式详见<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">wiki</a>)</p>
<h2 id="关于UUID"><a href="#关于UUID" class="headerlink" title="关于UUID"></a>关于UUID</h2><p>UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。</p>
<p>使用UUID和使用/dev/sda5这种直接引用分区的方法的一个优点就是，当硬盘中增加了新的分区，或者分区的顺序改变后，仍然能够保证系统加载分区到正确的加载点。插拔盘并不会改变uuid。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls /dev/disk/by-</div><div class="line">by-id/           by-parttypeuuid/ by-path/         </div><div class="line">by-partlabel/    by-partuuid/     by-uuid/</div></pre></td></tr></table></figure>
<p>查看uuid的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># blkid</div><div class="line">/dev/vda1: SEC_TYPE=&quot;msdos&quot; LABEL=&quot;BOOT&quot; UUID=&quot;9485-0659&quot; TYPE=&quot;vfat&quot; </div><div class="line">/dev/vda2: UUID=&quot;30cb52e3-c54e-468c-944a-b27f2fe2dc4f&quot; TYPE=&quot;ext4&quot; </div><div class="line">/dev/vda3: UUID=&quot;012def77-c10e-47df-a669-85143d2e8073&quot; TYPE=&quot;ext4&quot; </div><div class="line">/dev/vdb1: UUID=&quot;cad11e23-e104-419d-9b61-3a1b6dc27fc9&quot; TYPE=&quot;xfs&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># blkid /dev/vdb1</div><div class="line">/dev/vdb1: UUID=&quot;cad11e23-e104-419d-9b61-3a1b6dc27fc9&quot; TYPE=&quot;xfs&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ll /dev/disk/by-uuid/ | grep vdb1</div><div class="line">lrwxrwxrwx 1 root root  10 Apr  1 16:13 cad11e23-e104-419d-9b61-3a1b6dc27fc9 -&gt; ../../vdb1</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> osd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令和功能]]></title>
      <url>http://xiaqunfeng.cc/2017/08/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>总结记录自己最常用的git命令，然后将一些命令分类，便于翻阅。<br><a id="more"></a></p>
<h2 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h2><p>1、下载一个项目和它的整个代码历史</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone [url]</div></pre></td></tr></table></figure>
<p>2、分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 切换到指定分支，并更新工作区</div><div class="line">git checkout [branch-name]	</div><div class="line"></div><div class="line">// 新建一个分支，并切换到该分支	</div><div class="line">git checkout -b [branch-name]	</div><div class="line"></div><div class="line">// 将名称为[branch-name]的分支合并到master</div><div class="line">git checkout master</div><div class="line">git merge [branch-name]</div></pre></td></tr></table></figure>
<p>3、显示有变更的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p>4、添加文件到暂存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add [file1] [file2] ...	// 添加指定文件到暂存区</div><div class="line">git add [dir]				// 添加指定目录到暂存区，包括子目录</div><div class="line">git add -A					// 添加所有git status显示有变更的文件</div></pre></td></tr></table></figure>
<p>5、提交暂存区到仓库区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m [message]</div></pre></td></tr></table></figure>
<p>6、恢复暂存区文件到工作区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout [file]		// 恢复暂存区的指定文件到工作区</div><div class="line">git checkout .			// 恢复暂存区的所有文件到工作区</div></pre></td></tr></table></figure>
<h2 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库 - repository"></a>仓库 - repository</h2><p>初始化目录为git仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<p>下载远程仓库的所有变动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch [remote]</div></pre></td></tr></table></figure>
<p>取回远程仓库的变化，并与本地分支合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull [remote] [branch]</div></pre></td></tr></table></figure>
<p>查看远程仓库地址和名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
<p>推送本地分支到远程仓库，首次提交需要加-u</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push –u origin branch</div></pre></td></tr></table></figure>
<p>创建远程分支(本地分支push到远程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git push origin &lt;local_branch&gt;	// 创建远程分支， origin是远程仓库名</div><div class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; // 提交本地分支作为远程的分支</div></pre></td></tr></table></figure>
<p>删除远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm &lt;repository&gt;</div></pre></td></tr></table></figure>
<h2 id="分支-branch"><a href="#分支-branch" class="headerlink" title="分支 - branch"></a>分支 - branch</h2><p>列出所有本地分支和远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure>
<p>查看远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -r</div></pre></td></tr></table></figure>
<p>查看本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<p>创建新分支并立即切换到新分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b [name]</div></pre></td></tr></table></figure>
<p>基于远程分支创建本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout   -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;</div></pre></td></tr></table></figure>
<p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d [name]</div></pre></td></tr></table></figure>
<p>删除远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin :heads/[name]</div></pre></td></tr></table></figure>
<p>先删除本地分支(<code>git br -d &lt;branch&gt;</code>)，然后再push删除远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin :&lt;remote_branch&gt;</div></pre></td></tr></table></figure>
<p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge [name] ----将名称为[name]的分支与当前分支合并</div></pre></td></tr></table></figure>
<h2 id="版本-tag"><a href="#版本-tag" class="headerlink" title="版本 - tag"></a>版本 - tag</h2><p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag</div></pre></td></tr></table></figure>
<p>创建版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag [name]</div></pre></td></tr></table></figure>
<p>删除版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d [name]</div></pre></td></tr></table></figure>
<p>查看远程版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -r</div></pre></td></tr></table></figure>
<p>创建远程版本(本地版本push到远程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin [name]</div></pre></td></tr></table></figure>
<p>删除远程版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin :refs/tags/[name]</div></pre></td></tr></table></figure>
<p>checkout远程tags到本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b &lt;new_branch_name&gt; &lt;tagname&gt;</div></pre></td></tr></table></figure>
<h2 id="日志-log"><a href="#日志-log" class="headerlink" title="日志 - log"></a>日志 - log</h2><p>查看历史版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure>
<p>查看提交统计信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --stat</div></pre></td></tr></table></figure>
<p>查看最近一次详细修改内容的diff</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -p -1		// -p 是显示详细信息的意思</div></pre></td></tr></table></figure>
<p>查看某个文件的提交记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log &lt;filename&gt;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>显示指定文件是什么人在什么时间修改过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame [file]</div></pre></td></tr></table></figure>
<p>显示今天你写了多少行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div></pre></td></tr></table></figure>
<p>比较当前文件和暂存区文件差异</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff &lt;filename&gt;</div></pre></td></tr></table></figure>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard [commit]</div></pre></td></tr></table></figure>
<p>暂时将未提交的变化移除，稍后再移入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line">git stash pop</div></pre></td></tr></table></figure>
<p>显示某次提交时，某个文件的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git show [commit]:[filename]</div></pre></td></tr></table></figure>
<p>删除所有untracked文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clean</div></pre></td></tr></table></figure>
<h2 id="同步fork"><a href="#同步fork" class="headerlink" title="同步fork"></a>同步fork</h2><p>fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？本文将给你解答。</p>
<h3 id="Configuring-a-remote-for-a-fork"><a href="#Configuring-a-remote-for-a-fork" class="headerlink" title="Configuring a remote for a fork"></a>Configuring a remote for a fork</h3><ul>
<li>给 fork 配置一个 remote</li>
<li>主要使用 <code>git remote -v</code> 查看远程状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line"># origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</div><div class="line"># origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</div></pre></td></tr></table></figure>
<ul>
<li>添加一个将被同步给 fork 远程的上游仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</div></pre></td></tr></table></figure>
<ul>
<li>再次查看状态确认是否配置成功。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line"># origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</div><div class="line"># origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</div><div class="line"># upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)</div><div class="line"># upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)</div></pre></td></tr></table></figure>
<h3 id="Syncing-a-fork"><a href="#Syncing-a-fork" class="headerlink" title="Syncing a fork"></a>Syncing a fork</h3><ul>
<li>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/master<br><code>git fetch upstream</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git fetch upstream</div><div class="line"># remote: Counting objects: 75, done.</div><div class="line"># remote: Compressing objects: 100% (53/53), done.</div><div class="line"># remote: Total 62 (delta 27), reused 44 (delta 9)</div><div class="line"># Unpacking objects: 100% (62/62), done.</div><div class="line"># From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</div><div class="line">#  * [new branch]      master     -&gt; upstream/master</div></pre></td></tr></table></figure>
<ul>
<li>切换到本地主分支(如果不在的话)<br><code>git checkout master</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line"># Switched to branch &apos;master&apos;</div></pre></td></tr></table></figure>
<ul>
<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br><code>git merge upstream/master</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git merge upstream/master</div><div class="line"># Updating a422352..5fdff0f</div><div class="line"># Fast-forward</div><div class="line">#  README                    |    9 -------</div><div class="line">#  README.md                 |    7 ++++++</div><div class="line">#  2 files changed, 7 insertions(+), 9 deletions(-)</div><div class="line">#  delete mode 100644 README</div><div class="line">#  create mode 100644 README.md</div></pre></td></tr></table></figure>
<ul>
<li>如果想更新到 GitHub 的 fork 上，直接 <code>git push origin master</code> 就好了。</li>
</ul>
<p>该部分参考：<a href="https://gaohaoyang.github.io/2015/04/12/Syncing-a-fork/" target="_blank" rel="external">syncing a fork</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>比如，配置全局用户名和邮箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.email &quot;email@example.com&quot;</div><div class="line">$ git config --global user.name &quot;yourname&quot;</div></pre></td></tr></table></figure>
<p>为某个仓库配置的话，在该仓库目录下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.email &quot;email@example.com&quot;</div><div class="line">$ git config user.name &quot;yourname&quot;</div></pre></td></tr></table></figure>
<h2 id="将已有项目添加到github"><a href="#将已有项目添加到github" class="headerlink" title="将已有项目添加到github"></a>将已有项目添加到github</h2><blockquote>
<p>已有本地项目，文件夹名为gitRepo</p>
</blockquote>
<p>1、初始化本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd gitRepo</div><div class="line">git init</div></pre></td></tr></table></figure>
<p>2、添加全部文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .      // git add -A</div></pre></td></tr></table></figure>
<blockquote>
<p>如果没有README.md，可以创建一个先</p>
</blockquote>
<p>3、提交说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &apos;xxxxx&apos;</div></pre></td></tr></table></figure>
<p>4、github上创建仓库</p>
<p>在github上新建仓库，名称为<code>gitRepo</code>，必须和文件夹同名！</p>
<p>5、添加远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:yourgithubID/gitRepo.git</div></pre></td></tr></table></figure>
<p>6、将本地仓库push到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>以上。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">▶ git checkout v12.1.4</div><div class="line">warning: refname &apos;v12.1.4&apos; is ambiguous.</div><div class="line">Switched to branch &apos;v12.1.4&apos;</div></pre></td></tr></table></figure>
<p>原因：这个branch的名称是危险的，因为这是可能是一个标识名、tag名等。所以，rename一下就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">▶ git branch -m v12.1.4 v12.1.4-local</div></pre></td></tr></table></figure>
<p><strong>Q2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: refusing to merge unrelated histories</div></pre></td></tr></table></figure>
<p>参考链接: <a href="https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories" target="_blank" rel="external">git refusing to merge unrelated histories</a></p>
<p>解决方法：在执行命令后加上选项 <code>--allow-unrelated-histories</code></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3 OS module]]></title>
      <url>http://xiaqunfeng.cc/2017/08/05/python3-OS-module/</url>
      <content type="html"><![CDATA[<p>python3 OS 模块学习笔记<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用的时候需要导入OS模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import os</div></pre></td></tr></table></figure>
<h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><p>1、<strong>os.path.split(path)  </strong></p>
<p>功能：将path分割成目录和文件名二元组返回</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.split(&apos;test/iostat.jpg&apos;)</div><div class="line">(&apos;test&apos;, &apos;iostat.jpg&apos;)</div></pre></td></tr></table></figure>
<p>2、<strong>os.path.dirname(path) </strong></p>
<p>功能：返回path的目录名。其实就是os.path.split(path)的第一个元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.dirname(&apos;test/iostat.jpg&apos;)</div><div class="line">&apos;test&apos;</div></pre></td></tr></table></figure>
<p>3、<strong>os.path.basename(path)</strong></p>
<p>功能：返回path最后的文件名。即os.path.split(path)的第二个元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.basename(&apos;test/iostat.jpg&apos;)</div><div class="line">&apos;iostat.jpg&apos;</div></pre></td></tr></table></figure>
<p>4、<strong>.os.path.splitext(path)</strong></p>
<p>功能：分离文件名与扩展名。默认返回(fname,fextension)元组，可做分片操作。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.splitext(&apos;test/iostat.jpg&apos;)</div><div class="line">(&apos;test/iostat&apos;, &apos;.jpg&apos;)</div></pre></td></tr></table></figure>
<p>5、<strong>os.path.join(path1[, path2[, …]])</strong></p>
<p>功能：将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.join(&apos;test/iostat.jpg&apos;)</div><div class="line">&apos;test/iostat.jpg&apos;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; os.path.join(&apos;test/iostat.jpg&apos;, &apos;hahaha&apos;)</div><div class="line">&apos;test/iostat.jpg/hahaha&apos;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; os.path.join(&apos;test&apos;, &apos;hello&apos;)</div><div class="line">&apos;test/hello&apos;</div></pre></td></tr></table></figure>
<p>6、<strong>os.path.isdir(path)</strong></p>
<p>功能：如果path是一个存在的目录，则返回True。否则返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.isdir(&apos;test&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; os.path.isdir(&apos;xqf&apos;)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>7、<strong>os.path.isfile(path)</strong></p>
<p>功能：如果path是一个存在的文件，返回True。否则返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.isfile(&apos;test/iostat.jpg&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; os.path.isfile(&apos;test/hello.jpg&apos;)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>8、<strong>os.path.abspath(path)</strong>   </p>
<p>功能：返回path规范化的绝对路径。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.abspath(&apos;test/hello.jpg&apos;)</div><div class="line">&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p>这一步其实已经包含 os.path.normpath(path) 的操作</p>
</blockquote>
<p>9、<strong>os.path.isabs(path) </strong></p>
<p>功能：如果path是绝对路径，返回True。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.isabs(&apos;test/hello.jpg&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; os.path.isabs(&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; os.path.isabs(&apos;/Users/xiaqunfeng/helloworld&apos;)		// helloworld并不存在</div><div class="line">True</div></pre></td></tr></table></figure>
<blockquote>
<p>该函数只返回是不是绝对路径，不判断路径是否存在</p>
</blockquote>
<p>10、<strong>os.path.exists(path) </strong></p>
<p>功能：如果path存在，返回True；如果path不存在，返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/helloworld&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; os.path.exists(&apos;test/hello.jpg&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; os.path.exists(&apos;test&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/python/show-me-the-code/&apos;)</div><div class="line">True</div></pre></td></tr></table></figure>
<blockquote>
<p>只判断路径是否存在，不能是具体的文件</p>
</blockquote>
<p>11、<strong>os.path.getsize(path) </strong></p>
<p>功能：返回path的文件的大小（字节）</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.getsize(&apos;test/iostat.jpg&apos;)</div><div class="line">237491</div></pre></td></tr></table></figure>
<p>12、<strong>os.path.getatime(path)</strong> &amp;&amp; <strong>os.path.getmtime(path)</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">os.path.getatime(path)          # 返回path所指向的文件或者目录的最后存取时间</div><div class="line">os.path.getmtime(path)          # 返回path所指向的文件或者目录的最后修改时间</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.getatime(&apos;test/iostat.jpg&apos;)</div><div class="line">1499659865.0</div><div class="line">&gt;&gt;&gt; os.path.getmtime(&apos;test/iostat.jpg&apos;)</div><div class="line">1499655924.0</div></pre></td></tr></table></figure>
<p>这里得到的是一个浮点数的timestamp，如果有小数位，小数位表示毫秒数。</p>
<p>可是看不懂哇。所以这里需要进行转换，将timestamp转换为datetime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; atime = 1499659865.0</div><div class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(atime))</div><div class="line">2017-07-10 12:11:05</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; mtime = 1499655924.0</div><div class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(mtime))</div><div class="line">2017-07-10 11:05:24</div></pre></td></tr></table></figure>
<p>13、<strong>os.path.normpath()</strong></p>
<p>功能：返回正常路径，可以解决双斜杆、对目录的多重引用的问题等。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; os.path.normpath(&apos;test//hello.jpg&apos;)</div><div class="line">&apos;test/hello.jpg&apos;</div><div class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/../test/hello.jpg&apos;)</div><div class="line">&apos;test/hello.jpg&apos;</div><div class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/test/hello.jpg&apos;)			// 该目录不存在</div><div class="line">&apos;test/test/hello.jpg&apos;</div><div class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/../test/../result/../test/hello.jpg&apos;)</div><div class="line">&apos;test/hello.jpg&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p>仅仅规范化目录，不能判断目录是否存在</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python3 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么对于企业NAS来说NFS-ganesha是一个更好的NFS server]]></title>
      <url>http://xiaqunfeng.cc/2017/08/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E4%BA%8E%E4%BC%81%E4%B8%9ANAS%E6%9D%A5%E8%AF%B4NFS-ganesha%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A5%BD%E7%9A%84NFS-server/</url>
      <content type="html"><![CDATA[<p>如题，介绍了ganesha，同时对比了用户态下的nfs server(ganesha)和内核态下传统nfs server。<br><a id="more"></a></p>
<h2 id="What-is-NFS-Ganesha"><a href="#What-is-NFS-Ganesha" class="headerlink" title="What is NFS-Ganesha?"></a>What is NFS-Ganesha?</h2><p>1、是NFS server用户态层面的实现</p>
<p>支持 NFS V2, V3, V4, V4.1, V4.2</p>
<p>2、可以管理庞大的元数据和数据缓存</p>
<p>3、能够访问不同的数据集</p>
<p>4、规定开发 FS 的具体特性</p>
<p>5、能够同时为多个不同类型的文件系统服务</p>
<p>6、能够同时服务多个协议</p>
<p>7、可以作为一个 Proxy server 并导出一个远端的 NFSv4 server</p>
<p>8、不感知集群管理</p>
<p>同时拥有一个小但是在成长中的社区</p>
<p>积极参与者有：IBM, Panasas, Redhat, LinuxBox, CES</p>
<h2 id="Enterprise-NAS"><a href="#Enterprise-NAS" class="headerlink" title="Enterprise NAS"></a>Enterprise NAS</h2><p>1、通过集群配置可靠、冗余和故障安全。</p>
<p>2、通过多个协议服务结构化和非机构化数据。</p>
<p>3、在容量和性能上可扩展</p>
<ul>
<li>灵活的 scale-up 和 scale-out</li>
<li>能够支持大量客户端</li>
</ul>
<p>4、企业级特性：tiering, de-dup, multi-tenancy, multi-protocol 等</p>
<p>5、灵活的运行在多个平台并服务于异构数据集</p>
<p>6、支持复杂的安全配置</p>
<p>7、QoS - 服务质量（Quality of Service）</p>
<h2 id="Kernel-vs-User-Space-Server"><a href="#Kernel-vs-User-Space-Server" class="headerlink" title="Kernel vs User Space Server"></a>Kernel vs User Space Server</h2><p>1、内核级服务需要提供更多的up-calls</p>
<ul>
<li>Mounted和exportfs信息</li>
<li>ID映射</li>
<li>GSS API</li>
<li>客户端ID跟踪</li>
<li>Statd 相互作用</li>
<li>集群相关的服务</li>
</ul>
<p>2、为什么用户空间更好</p>
<ul>
<li>用户空间比内核空间更灵活</li>
<li>实现 restarts, failover, failback 更容易</li>
<li>不需要实现系统调用</li>
<li>和用户空间的服务的交互没有 up-calls </li>
<li>clustering变得自然而简单</li>
<li>有针对性和侵略性的缓存功能</li>
<li>灵活和插件式的 FSAL（可以利用的 FS 的特定功能）</li>
<li>可以通过支持通用的 DLM 分布式锁管理来支持 multi-Protocol</li>
<li>易于实现的 multi-tenancy</li>
<li>易于监控和控制资源消耗，甚至扩展至强制执行QoS</li>
<li>可管理性和调试能力是重要的加分项</li>
</ul>
<p>3、内核服务没有优点吗？优点在这</p>
<ul>
<li>文件句柄：最近才有的主要优势，现在有了开放式的支持</li>
<li>性能：用户空间差一点，但可以通过集群FS，积极缓存，自定义RPC，以及积极的线程/并行执行来抵消</li>
<li>所有权/权限：每一个处理都通过 setfsuid。但是其他可能需要执行多个系统调用或特殊的 FS 接口来实现，如VFS，Luster，GPFS，但实CEPH，Gluster 可以接受lib库实现</li>
<li>多次系统调用由于WCC的原因需要 perform, write/getattr</li>
<li>没有重复的缓存和零拷贝读写，降低了复杂性</li>
</ul>
<h2 id="Clustering-with-NFS-Ganesha"><a href="#Clustering-with-NFS-Ganesha" class="headerlink" title="Clustering with NFS-Ganesha"></a>Clustering with NFS-Ganesha</h2><p>1、建议 Cluster Manager Abstraction Layer (CMAL) ，使集群不感知</p>
<p>2、故障转移和IP移动处理</p>
<p>3、集群感知DRC</p>
<p>4、跨集群的DLM</p>
<p>5、集群范围的宽限期管理</p>
<h2 id="Cluster-Manager-Abstraction-Layer-CMAL"><a href="#Cluster-Manager-Abstraction-Layer-CMAL" class="headerlink" title="Cluster Manager Abstraction Layer (CMAL)"></a>Cluster Manager Abstraction Layer (CMAL)</h2><p>1、为集群管理提供了一个抽象的支持</p>
<p>2、管理集群节点中节点内的通信</p>
<p>3、通用性足以实现 cDRC, DLM等特性的多个集群交互</p>
<p>4、集群管理不可知。容易插入任何集群管理中</p>
<p>5、模仿FSAL</p>
<p>6、CMAL层将具有基于集群管理的功能指针</p>
<p>7、能够提供pNFS配置文件中DS和MDS节点间的集群通信</p>
<h2 id="Cluster-DRC"><a href="#Cluster-DRC" class="headerlink" title="Cluster DRC"></a>Cluster DRC</h2><p>1、DRC帮助server识别非幂等操作的重复请求，并进行相应处理</p>
<p>2、识别back-up节点以备份DRC，或在集群/中心位置的所有节点上备份</p>
<p>3、通过CMAL存储和获取DRC entries</p>
<p>4、接口</p>
<ul>
<li>init_drc_cmal(server-ip)：初始化CMAL接口，设置server-ip的备份节点。</li>
<li>add_drc_entry(xid, entry, server-ip)：在集群中存储DRC entry。</li>
<li>retrieve_drc_entries(server-ip)：检索特定服务节点的所有entry</li>
<li>shutdown_drc_cmal(server-ip)：关闭指定 server-ip 的CMAL接口</li>
</ul>
<h2 id="Failover-IP-Move"><a href="#Failover-IP-Move" class="headerlink" title="Failover/IP Move"></a>Failover/IP Move</h2><p>1、NLM使其非常复杂，但NFS-Ganesha架构面临挑战。</p>
<p>2、在第一次加锁和最后一次解锁时，Ganesha调用集群管理提供的接口去register(monitor)/unregister(unmonitor) the client-ip, server-ip pair</p>
<p>3、当IP被移动（手动或者失败），CM发送 sm_notify 给影响 server-ip的客户端</p>
<p>4、CM为相应的服务器节点生成事件，release-ip，take-ip，所以状态应该从源节点释放，在目的节点获取</p>
<p>5、根据锁的粒度，相应的锁/文件系统，或者整个集群应该优雅的进入</p>
<h2 id="Distributed-Lock-manager"><a href="#Distributed-Lock-manager" class="headerlink" title="Distributed Lock manager"></a>Distributed Lock manager</h2><p>1、NFS-Ganesha的架构支持DLM</p>
<p>DLM可以用不同的方式实现</p>
<p>2、允许管理集群范围锁</p>
<p>3、通过 NFS, CIFS和其他协议共享状态管理</p>
<p>4、最小化失败带来影响的能力（Targeted Grace）</p>
<h2 id="FSAL-Enhancements-and-new-features"><a href="#FSAL-Enhancements-and-new-features" class="headerlink" title="FSAL Enhancements and new features"></a>FSAL Enhancements and new features</h2><p>1、动态exports</p>
<p>2、delegations</p>
<p>3、FSAL 增强</p>
<ul>
<li>支持ACL</li>
<li>开放升级支持</li>
<li>解决POSIX语义</li>
<li>用户libraries可以轻松插入（protecTIER, GlusterFS）</li>
<li>可堆叠的FSALs</li>
<li>PseudoFS作为FSAL的第一个类</li>
</ul>
<p>4、LTTng集成</p>
<p>5、通过libmooshika支持RDMA</p>
<h2 id="NFS-Ganesha-links"><a href="#NFS-Ganesha-links" class="headerlink" title="NFS-Ganesha links"></a>NFS-Ganesha links</h2><p>1、NFS-Ganesha is available under the terms of the LGPLv3 license.<br>2、NFS-Ganesha Project homepage on github<br> <a href="https://github.com/nfs-ganesha/nfs-ganesha/wiki" target="_blank" rel="external">https://github.com/nfs-ganesha/nfs-ganesha/wiki</a><br>3、Github:<br> <a href="https://github.com/nfs-ganesha/nfs-ganesh" target="_blank" rel="external">https://github.com/nfs-ganesha/nfs-ganesh</a><br>4、Download page<br> <a href="http://sourceforge.net/projects/nfs-ganesha/files" target="_blank" rel="external">http://sourceforge.net/projects/nfs-ganesha/files</a><br>5、Mailing lists</p>
<ul>
<li> nfs-ganesha-devel@lists.sourceforge.net</li>
<li> nfs-ganesha-support@lists.sourceforge.net</li>
<li> nfs-ganesha-announce@lists.sourceforge.net</li>
</ul>
<p>本文翻译自：<a href="http://events.linuxfoundation.org/sites/events/files/slides/Collab14_nfsGanesha.pdf" target="_blank" rel="external">Why is it a better NFS server for Enterprise NAS</a></p>
<blockquote>
<p>部分晦涩的地方直接引用英文原文</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> ganesha </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph peering过程分析]]></title>
      <url>http://xiaqunfeng.cc/2017/08/01/ceph-peering%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>总结分析peering过程中的一些笔记，介绍peering的各个阶段和状态转换。<br><a id="more"></a></p>
<p>peering过程使得一个PG内的OSD达成一个一致状态。当主从副本达成一个一致状态后，PG处于active状态，peering过程的状态就结束了。但此时该PG的三个OSD的数据副本上的数据并非完全一致。</p>
<p>互为副本的副本数个 PG 的元数据达到一致的过程。官方解释</p>
<blockquote>
<p>the process of bringing all of the OSDs that store a Placement Group (PG) into agreement about the state of all of the objects (and their metadata) in that PG. Note that agreeing on the state does not mean that they all have the latest contents.</p>
</blockquote>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>当系统初始化时，OSD重新启动导致PG重新加载，或者PG创建时，PG会发生一次peering过程。</p>
<p>当有OSD失效，OSD的增加或者删除等导致PG的acting set发生了变化，该PG就会重新发起一次peering过程。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>acting set 和 up set</p>
<p>临时 PG</p>
<p>权威日志olog</p>
<p>up_thru</p>
<h2 id="peering状态转换图"><a href="#peering状态转换图" class="headerlink" title="peering状态转换图"></a>peering状态转换图</h2><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img src="http://oow6unnib.bkt.clouddn.com/FullSizeRender%204.jpg" alt="FullSizeRender 4"></p>
<p>过程如下：</p>
<ul>
<li><p>当进入primary/peering状态后，就进入默认子状态getinfo中</p>
</li>
<li><p>状态getinfo接收事件gotinfo后，转移到getlog状态中</p>
</li>
<li><p>如果状态getlog接收到isIncomplete事件后，跳转到incomplete状态</p>
</li>
<li><p>如果getlog接收到事件gotlog后，就转入getmissing状态</p>
</li>
<li><p>状态getmissing接收到事件activate事件，转入状态active</p>
</li>
</ul>
<h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>由状态转换过程可知，peering过程基本分为以下三个步骤</p>
<ul>
<li><p><strong>步骤一：GetInfo</strong></p>
<p>​PG的主OSD通过发送消息获取所有从OSD的pg_info信息。</p>
</li>
<li><p><strong>步骤二：GetLog</strong></p>
<p>​根据各个副本获取的pg_info信息的比较，选择一个拥有权威日志的OSD。如果主OSD不是拥有权威日志的OSD，就从该OSD上拉取权威日志。主OSD完成拉取权威日志后也就拥有了权威日志。</p>
</li>
<li><p><strong>步骤三：GetMissing</strong></p>
<p>​主OSD拉取其他OSD的PG日志。通过与本地权威日志的比较，来计算该OSD上缺失的object信息，作为后续recover操作过程的依据。</p>
</li>
</ul>
<p>最后通过active操作激活主OSD，并发送notify通知消息，激活相应的从OSD。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p> <img src="http://oow6unnib.bkt.clouddn.com/peering.png" alt="peering"></p>
<h2 id="GetInfo"><a href="#GetInfo" class="headerlink" title="GetInfo"></a>GetInfo</h2><p>获取该PG在其他OSD上的 pg_info 信息。</p>
<p>其他OSD：当前PG的活跃OSD，以及past interval期间该PG所有处于up 状态的OSD。</p>
<p>Past_interval 是 epoch 的一个序列。在该序列内一个PG的 acting set 和 up set不会变化。current_interval 也是一个特殊的 past_interval，它是当前最新的一个没有变化的序列。</p>
<ul>
<li><p>1、调用函数 generate_past_intervals 计算 past intervals 的值</p>
<p>​选取一个epoch区间，对区间内的每个epoch计算其对应的acting set、acting primary、up set、up primary，将相同的结果作为一个interval（一个interval中 acting set 和up set 不会变化）；</p>
<p>​判断每个interval，将up状态的osd加入到prior set；同时将当前的（current interval）acting set和up set加入到prior set；</p>
</li>
<li><p>2、调用函数 build_prior 构造获取 pg_info_t 信息的OSD 列表</p>
<p>​向prior_set中的每个up状态的osd发送Query INFO请求，并等待接收应答，将接收到的请求保存到peer_info中；</p>
</li>
<li><p>3、调用函数 get_infos 给参与的OSD 发送获取请求</p>
<p>​收到最后一个应答后，状态机post event到GotInfo状态；如果在此期间有一个接收请求的osd down掉，这个PG的状态将持续等待，直到对应的osd恢复；</p>
</li>
</ul>
<h2 id="GetLog"><a href="#GetLog" class="headerlink" title="GetLog"></a>GetLog</h2><p>当PG的主OSD获取到所有从OSD，以及past interval期间的所有参与该PG且目前仍处于active状态的OSD的 pg_info 信息后，就跳转到 GetLog 状态。</p>
<ul>
<li>1、遍历peer_info，查找best info，将其作为authoritative log；将acting set/peer_info中将处于complete状态的pg以及up set的所有pg存入acting_backfill；</li>
<li>2、如果计算出的authoritative log对应的pg是自身，直接post event到GotLog；否则，向其所在的osd发送Query Log请求；</li>
<li>3、接收请求的osd应答，并将获取的log merge到本地，状态机post event到GetMissing；如果收不到应答，状态将持续等待；</li>
</ul>
<h3 id="olog的选择"><a href="#olog的选择" class="headerlink" title="olog的选择"></a>olog的选择</h3><p>函数 find_best_info 选取拥有权威日志的OSD：必须是非 incomplete 的OSD，必须拥有最大的 last_epoch_strated，其他选择优先顺序如下：</p>
<p>1、具有最新的 last_update 的OSD；</p>
<p>2、如果条件 1 相同，选择日志更长的；</p>
<p>3、如果 1、2条件都相同，选择当前的主OSD；</p>
<p>经过该阶段，PG的主OSD已经获取了权威日志，以及pg_info的权威信息。</p>
<h2 id="GetMissing"><a href="#GetMissing" class="headerlink" title="GetMissing"></a>GetMissing</h2><p>首先拉取各个从OSD上的有效日志</p>
<p>用主OSD上的权威日志与各个从OSD日志进行对比，计算出各个从OSD上不一致的对象并保存在对应的 pg_missing_t 结构中，作为后续数据修复的依据。</p>
<p>主OSD上不一致的对象信息，已经在合并权威日志的过程中计算过了。</p>
<ul>
<li>1、遍历acting_backfill，向与primary pg log有交集的pg所在的osd发送Query Log请求；将剩余没有交集的pg放入peer_missing，生成missing set用于后续recovery；</li>
<li>2、将收到的每一个应答merge到本地，如果在此期间有osd down掉，这个PG的状态将持续等待；收到所有的应答后，当前pg的状态机进入Activate状态，peering过程结束；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个peering过程主要分为三个阶段，GetInfo -&gt; GetLog -&gt; GetMissing</p>
<ul>
<li>首先向prior set、acting set、up set中的每个osd请求pg infos, 选出authoritative log对应的pg</li>
<li>其次向authoritative log所在的osd请求authoritative log</li>
<li>最后获取recovery过程需要的missing set</li>
</ul>
<p>peering时间的长短并不可控，主要是在于请求的osd是否能够及时响应；如果这个阶段某个osd down掉，很可能导致部分pg一直处在peering状态，即所有分布到这个pg上的IO都会阻塞。</p>
<h3 id="后续active操作"><a href="#后续active操作" class="headerlink" title="后续active操作"></a>后续active操作</h3><p>getmissing操作成功后，就跳转到activate状态。到本阶段为止，peering的主要工作已完成，这里是后续处理，激活各个副本。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了减少peering过程对client造成的影响，社区提出Faster Peering，该plan主要有以下两点：</p>
<p>1）向最近prior set interval中的osd请求log+missing，跳过GetLog阶段；</p>
<p>2）向acting set和up set中的osd请求log+missing，跳过GetMissing阶段；</p>
<p>部分参考资料：<a href="https://www.ustack.com/blog/ceph%EF%BC%8Dpg-peering/" target="_blank" rel="external">Ceph：pg peering过程分析</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph placement group]]></title>
      <url>http://xiaqunfeng.cc/2017/07/28/ceph-placement-group/</url>
      <content type="html"><![CDATA[<p>从PG的命名开始介绍，利用一个对象详细演练PG各个状态的变化，并介绍PG状态列表及意义。<br><a id="more"></a></p>
<h2 id="PG命名"><a href="#PG命名" class="headerlink" title="PG命名"></a>PG命名</h2><h3 id="PG唯一标识符"><a href="#PG唯一标识符" class="headerlink" title="PG唯一标识符"></a>PG唯一标识符</h3><p>归置组 ID 包含存储池号（不是存储池名字），后面跟一个点（ . ），然后是归置组 ID，一个十六进制数字。用 <code>ceph osd lspools</code> 可查看存储池号及其名字，默认存储池rbd 对应的存储池号是 0  。完整的归置组 ID 格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;pool-num&#125;.&#123;pg-id&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0.1f</div></pre></td></tr></table></figure>
<p>系统默认生成的<code>rbd</code>池的id号为<code>0</code>，所以 rbd 池内的所有PG都会以<code>0.</code>开头。</p>
<h3 id="查看osd目录里pg"><a href="#查看osd目录里pg" class="headerlink" title="查看osd目录里pg"></a>查看osd目录里pg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls /var/lib/ceph/osd/ceph-0/</div><div class="line">activate.monmap  ceph_fsid        fsid             journal_uuid     magic            store_version    systemd          whoami</div><div class="line">active           current/         journal          keyring          ready            superblock       type</div></pre></td></tr></table></figure>
<p><code>osd.0</code>下<code>current</code>目录的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ls /var/lib/ceph/osd/ceph-0/current/</div><div class="line">0.0_head   0.1d_head  0.34_head  0.45_head  0.4e_head</div></pre></td></tr></table></figure>
<p>每个OSD的<code>current</code>目录下都保存了部分的PG，而rbd池的PG以<code>0.xxx_head</code>的目录形式存在！</p>
<h2 id="PG状态"><a href="#PG状态" class="headerlink" title="PG状态"></a>PG状态</h2><p>查看所有归置组状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg stat</div><div class="line">v614916: 128 pgs: 128 active+clean; 27194 kB data, 185 MB used, 15141 MB / 15326 MB avail; 56023 B/s rd, 0 B/s wr, 89 op/s</div></pre></td></tr></table></figure>
<p>有一些问题的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg stat</div><div class="line">v2167: 120 pgs: 120 active+undersized+degraded; 1799 bytes data, 86476 kB used, 10133 MB / 10217 MB avail; 173/519 objects degraded (33.333%)</div></pre></td></tr></table></figure>
<p>或者这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg stat</div><div class="line">v1468117: 5440 pgs: 4 active+clean+scrubbing+deep, 77 active+remapped+backfilling, 5359 active+clean; 33452 GB data, 68799 GB used, 43742 GB / 109 TB avail; 134 kB/s rd, 154 op/s; 6668502/138960328 objects misplaced (4.799%); 40810 kB/s, 81 objects/s recovering</div></pre></td></tr></table></figure>
<h2 id="获取PG列表"><a href="#获取PG列表" class="headerlink" title="获取PG列表"></a>获取PG列表</h2><p>用下列命令获取归置组列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph pg dump</div></pre></td></tr></table></figure>
<p>你也可以让它输出到 JSON 格式，并保存到文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph pg dump -o &#123;filename&#125; --format=json</div></pre></td></tr></table></figure>
<p>要查询某个归置组，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph pg &#123;poolnum&#125;.&#123;pg-id&#125; query</div></pre></td></tr></table></figure>
<p>Ceph 会输出成 JSON 格式</p>
<h2 id="写一个object"><a href="#写一个object" class="headerlink" title="写一个object"></a>写一个object</h2><p>1、新建一个文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat xinfanyang.txt</div><div class="line">xin fan yang have delicious food</div></pre></td></tr></table></figure>
<p>2、查看数据在pool中默认保存的份数、最小保存份数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool get rbd size</div><div class="line">size: 3</div><div class="line"># ceph osd pool get rbd min_size</div><div class="line">min_size: 2</div></pre></td></tr></table></figure>
<p>3、写一个文件，在集群中保存对象名为 <code>xfy</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rados -p rbd put xfy xinfanyang.txt</div></pre></td></tr></table></figure>
<p>4、查看文件保存的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e47 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,2,0], p1) acting ([1,2,0], p1)</div></pre></td></tr></table></figure>
<p>文件保存在pg（0.2f）中，pg位于OSD的[1，2，0]中，其中OSD1是主，其他是从。</p>
<p>5、查看内容</p>
<p>在三台机器的三个OSD上，输出内容一致。举例 osd.2，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ll /var/lib/ceph/osd/ceph-2/current/0.2f*</div><div class="line">/var/lib/ceph/osd/ceph-2/current/0.2f_head:</div><div class="line">总用量 4</div><div class="line">-rw-r--r--. 1 ceph ceph  0 6月  21 15:45 __head_0000002F__0</div><div class="line">-rw-r--r--. 1 ceph ceph 33 7月  27 19:35 xfy__head_0C76C82F__0</div><div class="line"></div><div class="line">/var/lib/ceph/osd/ceph-2/current/0.2f_TEMP:</div><div class="line">总用量 0</div></pre></td></tr></table></figure>
<p>实际对象内容存在 <code>xfy__head_0C76C82F__0</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</div><div class="line">xin fan yang have delicious food</div></pre></td></tr></table></figure>
<p>osd分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY</div><div class="line">-1 0.05457 root default</div><div class="line">-2 0.01819     host ceph-1</div><div class="line"> 0 0.00909         osd.0        up  1.00000          1.00000</div><div class="line"> 3 0.00909         osd.3        up  1.00000          1.00000</div><div class="line">-3 0.01819     host ceph-0</div><div class="line"> 2 0.00909         osd.2        up  1.00000          1.00000</div><div class="line"> 4 0.00909         osd.4        up  1.00000          1.00000</div><div class="line">-4 0.01819     host ceph-2</div><div class="line"> 1 0.00909         osd.1        up  1.00000          1.00000</div><div class="line"> 5 0.00909         osd.5        up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h2 id="PG状态变化"><a href="#PG状态变化" class="headerlink" title="PG状态变化"></a>PG状态变化</h2><p><strong>1、查看 pg[0.2f] 的状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div></pre></td></tr></table></figure>
<p><strong>2、挂掉一台机器挂</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl stop ceph-osd@2</div></pre></td></tr></table></figure>
<p>这时降为两副本了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e54 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0], p1) acting ([1,0], p1)</div></pre></td></tr></table></figure>
<p>查看pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div><div class="line">0.0	active+undersized+degraded	[1,0]	1	[1,0]	1</div></pre></td></tr></table></figure>
<p>因为之前设置的最小副本数是2，所以没影响，可以正常读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rados -p rbd get xfy 111</div><div class="line"># cat 111</div><div class="line">xin fan yang have delicious food</div></pre></td></tr></table></figure>
<p><strong>3、osd out</strong></p>
<p>将 osd.2 out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd out 2</div><div class="line">marked out osd.2.</div></pre></td></tr></table></figure>
<p>如果osd out出集群了，那么 crush 算法就会重新分配一个osd进来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e103 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0,4], p1) acting ([1,0,4], p1)</div></pre></td></tr></table></figure>
<p>当然，也可以不out，默认 600s 后自动out，具体时间可调，默认配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph daemon osd.1 config show | grep mon_osd_down_out_interval</div><div class="line">    &quot;mon_osd_down_out_interval&quot;: &quot;600&quot;,</div></pre></td></tr></table></figure>
<p>重新将 osd.2 加入集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd in 2</div><div class="line">marked in osd.2.</div></pre></td></tr></table></figure>
<p>这时候该对象的分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e117 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0], p1) acting ([1,0,4], p1)</div></pre></td></tr></table></figure>
<p>可以看到，pg最终的分布是 [1,0]，当前的acting分布是 [1,0,4]</p>
<p><strong>4、挂掉两台机器</strong></p>
<p>down掉主副本所在的 osd.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl stop ceph-osd@1</div></pre></td></tr></table></figure>
<p>此时只有一个副本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e56 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([0], p0) acting ([0], p0)</div></pre></td></tr></table></figure>
<p>查看pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div><div class="line">0.2f    undersized+degraded+peered   [0]          0    [0]              0</div></pre></td></tr></table></figure>
<p>此时再去get这个对象的话，会一直得不到返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rados -p rbd get xfy 222</div><div class="line">...							// 一直在等待</div></pre></td></tr></table></figure>
<blockquote>
<p>原因：当对象的副本数小于设定的最小数（min_size）时，ceph不响应对应object的IO请求</p>
</blockquote>
<p><strong>5、启动 osd.1</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl start ceph-osd@1</div></pre></td></tr></table></figure>
<p>此时，会发现，上面卡着的那个命令返回了，并且得到的内容正确。</p>
<p>查看当前pg分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e76 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,4], p1) acting ([1,4], p1)</div></pre></td></tr></table></figure>
<p>pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div><div class="line">0.2f    active+undersized+degraded [1,4]          1   [1,4]              1</div></pre></td></tr></table></figure>
<p>注意，这里一个有意思的事情是，在第三步的时候只有一个副本在 osd.0 上，因为 osd.1 是主副本</p>
<p>启动的时候，4 作为临时pg加入，然后等 1 恢复完以后</p>
<p><strong>6、启动 osd.2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl start ceph-osd@2</div></pre></td></tr></table></figure>
<p>此时，pg 映射恢复正常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map rbd xfy</div><div class="line">osdmap e83 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,2,0], p1) acting ([1,2,0], p1)</div></pre></td></tr></table></figure>
<p>pg的状态开始变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div><div class="line">0.2f               active+remapped [1,2]          1 [1,2,4]              1</div></pre></td></tr></table></figure>
<p>直至OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg dump_stuck |egrep ^0.2f</div><div class="line">ok</div></pre></td></tr></table></figure>
<h2 id="PG修复"><a href="#PG修复" class="headerlink" title="PG修复"></a>PG修复</h2><p><strong>1、我修改一下 osd.1 中对象 xfy 主副本的内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</div><div class="line">xin fan yang have delicious food</div><div class="line">// 改为</div><div class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</div><div class="line">xin fan yang have food</div></pre></td></tr></table></figure>
<p>2、扫描这个PG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg scrub 0.2f</div><div class="line">instructing pg 0.2f on osd.1 to scrub</div></pre></td></tr></table></figure>
<p><strong>3、读这个对象</strong></p>
<p>这时候会不会发生读到改过的错误内容呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rados -p rbd get xfy 333</div><div class="line"># cat 333</div><div class="line">xin fan yang have delicious food</div></pre></td></tr></table></figure>
<p>并没有，读到的仍然是正确的内容</p>
<p><strong>4、查看ceph状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">     health HEALTH_ERR</div><div class="line">            1 pgs inconsistent</div><div class="line">            1 scrub errors</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>报的错误是：有一个pg inconsistent，就是内容不一致。那么具体是哪个pg scurb errors了呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph health detail</div><div class="line">HEALTH_ERR 1 pgs inconsistent; 1 scrub errors</div><div class="line">pg 0.2f is active+clean+inconsistent, acting [1,2,0]</div><div class="line">1 scrub errors</div></pre></td></tr></table></figure>
<p>可以看到，正是我们修改的那个pg</p>
<p><strong>5、修复PG</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph pg repair 0.2f</div><div class="line">instructing pg 0.2f on osd.1 to repair</div></pre></td></tr></table></figure>
<p><strong>6、此时内容已被纠正过来</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat  /var/lib/ceph/osd/ceph-1/current/0.2f_head/xfy__head_0C76C82F__0</div><div class="line">xin fan yang have delicious food</div></pre></td></tr></table></figure>
<p>此时，集群状态OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph health detail</div><div class="line">HEALTH_OK</div></pre></td></tr></table></figure>
<h2 id="PG状态列表"><a href="#PG状态列表" class="headerlink" title="PG状态列表"></a>PG状态列表</h2><p><strong>1、peering</strong></p>
<p>Ceph 为归置组建立互联时，会让存储归置组副本的 OSD 之间就其中的对象和元数据状态达成一致。 Ceph 完成了互联，也就意味着存储着归置组的 OSD 就其当前状态达成了一致。然而，互联过程的完成并不能表明各副本都有了数据的最新版本。</p>
<p><strong>2、active</strong></p>
<p>peering完成后，一归置组状态会变为 active 。 active 状态意味着数据已完好地保存到了主归置组和副本归置组。</p>
<p><strong>3、clean</strong></p>
<p>某一归置组处于 clean 状态时，主 OSD 和副本 OSD 已成功互联，并且没有偏离的归置组。 Ceph 已把归置组中的对象复制了规定次数。</p>
<p><strong>4、degraded</strong></p>
<p>当客户端向主 OSD 写入数据时，由主 OSD 负责把数据副本写入其余副本 OSD 。主 OSD 把对象写入存储器后，在副本 OSD 创建完对象副本并报告给主 OSD 之前，主 OSD 会一直停留在 degraded 状态。</p>
<ul>
<li>归置组状态可以处于 active+degraded 状态，原因在于一 OSD 即使尚未持有所有对象也可以处于 active 状态。如果一 OSD 挂了， Ceph 会把分配到此 OSD 的归置组都标记为 degraded ；那个 OSD 重生后，它们必须重新互联。然而，客户端仍可以向处于 degraded 状态的归置组写入新对象，只要它还在 active 状态。</li>
<li>如果一 OSD 挂了，且老是处于 degraded 状态， Ceph 会把 down 的 OSD 标记为在集群外（ out ）、并把那个 down 掉的 OSD 上的数据重映射到其它 OSD 。从标记为 down 到 out 的时间间隔由 mon osd down out interval 控制，默认是 300 秒。</li>
<li>归置组也会被降级（ degraded ），因为 Ceph 找不到本应存在于此归置组中的一或多个对象，这时，你不能读写找不到的对象，但仍能访问位于降级归置组中的其它对象。</li>
</ul>
<p><strong>5、recovering</strong></p>
<p>Ceph 被设计为可容错，可抵御一定规模的软、硬件问题。当某 OSD 挂了（ down ）时，其内的归置组会落后于别的归置组副本；此 OSD 重生（ up ）时，归置组内容必须更新到当前状态；在此期间， OSD 处于 recovering 状态。</p>
<blockquote>
<p>恢复并非总是这些小事，因为一次硬件失败可能牵连多个 OSD 。比如一个机柜或房间的网络交换机失败了，这会导致多个主机上的 OSD 落后于集群的当前状态，故障恢复后每一个 OSD 都必须恢复。</p>
</blockquote>
<p>Ceph 提供了几个选项来均衡资源竞争，如新服务请求、恢复数据对象和恢复归置组到当前状态。</p>
<ul>
<li><code>osd recovery delay start</code> 选项允许一 OSD 在开始恢复进程前，先重启、重建互联、甚至处理一些重放请求；</li>
<li><code>osd recovery threads</code> 选项限制恢复进程的线程数，默认为 1 线程； </li>
<li><code>osd recovery thread timeout</code> 设置线程超时，因为多个 OSD 可能交替失败、重启和重建互联； </li>
<li><code>osd recovery max active</code> 选项限制一 OSD 最多同时接受多少请求，以防它压力过大而不能正常服务； </li>
<li><code>osd recovery max chunk</code> 选项限制恢复数据块尺寸，以防网络拥塞。</li>
</ul>
<p><strong>6、backfilling</strong></p>
<p>有新 OSD 加入集群时， CRUSH 会把现有集群内的部分归置组重分配给它。强制新 OSD 立即接受重分配的归置组会使之过载，用归置组回填可使这个过程在后台开始。只要回填顺利完成，新 OSD 就可以对外服务了。</p>
<p>在回填运转期间，你可能见到以下几种状态之一： </p>
<ul>
<li>backfill_wait 表明一回填操作在等待时机，尚未开始； </li>
<li>backfill 表明一回填操作正在进行； </li>
<li>backfill_too_full 表明需要进行回填，但是因存储空间不足而不能完成。</li>
<li>incomplete 状态表明某归置组不能回填</li>
</ul>
<p>Ceph 提供了多个选项来解决重分配归置组给一 OSD （特别是新 OSD ）时相关的负载问题。</p>
<ul>
<li>默认，<code>osd_max_backfills</code> 把双向的回填并发量都设置为 10 ； </li>
<li><code>osd backfill full \ ratio</code> 可让一 OSD 在接近占满率（默认 85% ）时拒绝回填请求，如果一 OSD 拒绝了回填请求，在 <code>osd backfill retry interval</code> 间隔之后将重试（默认 10 秒）； </li>
<li>OSD 也能用 <code>osd backfill scan min</code> 和 <code>osd backfill scan max</code> 来管理扫描间隔（默认 64 和 512 ）。</li>
</ul>
<p><strong>7、remapped</strong></p>
<p>负责维护某一归置组的 Acting Set 变更时，数据要从旧集合迁移到新的。新的主 OSD 要花费一些时间才能提供服务，所以老的主 OSD 还要持续提供服务、直到归置组迁移完。数据迁移完后，运行图会包含新 acting set 里的主 OSD 。</p>
<p><strong>8、stale</strong></p>
<p>虽然 Ceph 用心跳来保证主机和守护进程在运行，但是 ceph-osd 仍有可能进入 stuck 状态，它们没有按时报告其状态（如网络瞬断）。默认， OSD 守护进程每半秒（ 0.5 ）会一次报告其归置组、出流量、引导和失败统计状态，此频率高于心跳阀值。如果一归置组的主 OSD 所在的 acting set 没能向监视器报告、或者其它监视器已经报告了那个主 OSD 已 down ，监视器们就会把此归置组标记为 stale 。</p>
<blockquote>
<p>启动集群时，会经常看到 stale 状态，直到互联完成。集群运行一阵后，如果还能看到有归置组位于 stale 状态，就说明那些归置组的主 OSD 挂了（ down ）、或没在向监视器报告统计信息。</p>
</blockquote>
<p><strong>9、undersized</strong></p>
<p>PG的副本数比pool的配置中副本数少。</p>
<p>可以通过如下命令查看指定pool的副本数，默认是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool get &#123;poolname&#125; size</div></pre></td></tr></table></figure>
<p><strong>10、peered</strong></p>
<p>PG已经peered，但是副本数少于pool配置中指定的最小副本数，不能向client提供IO操作。在这种状态下会出发 recovery 操作，所以 pg 最终会愈合到最小副本数。</p>
<p>可通过如下命令得到指定pool的最小副本数，默认是2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool get &#123;poolname&#125; min_size</div></pre></td></tr></table></figure>
<p><strong>11、incomplete</strong></p>
<p>ceph检测到一个PG缺少可能已经发生的写入信息，或没有任何健康的副本。如果看到此状态，请尝试启动任何可能包含所需信息的失败的OSD，或暂时调整min_size以允许恢复。</p>
<p><strong>其他：</strong></p>
<p>一个归置组状态不是 active+clean 时未必有问题。一般来说，归置组卡住时 Ceph 的自修复功能往往无能为力，卡住的状态细分为：</p>
<ul>
<li>Unclean: 归置组里有些对象的副本数未达到期望次数，它们应该在恢复中；</li>
<li>Inactive: 归置组不能处理读写请求，因为它们在等着一个持有最新数据的 OSD 回到 up 状态；</li>
<li>Stale: 归置组们处于一种未知状态，因为存储它们的 OSD 有一阵子没向监视器报告了（由 mon osd report timeout 配置）。</li>
</ul>
<p>找出卡住的归置组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph pg dump_stuck [unclean|inactive|stale|undersized|degraded]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Remove Big RBD Image]]></title>
      <url>http://xiaqunfeng.cc/2017/07/28/Remove-Big-RBD-Image/</url>
      <content type="html"><![CDATA[<p>对较大的RBD image采用两种方法进行移除实验，并给出结果对比。<br><a id="more"></a></p>
<p>创建一个容量疯狂大的磁盘很有趣，但是有一点难移除。</p>
<center><img src="http://cephnotes.ksperis.com/images/img012.png" alt="img"></center>

<p>这里有一个移除特别大image的小技巧（谨慎使用！），使用 <code>rm rbd</code> 命令（如果image没有初始化，或者没有填充满）。</p>
<h2 id="Image-format-1"><a href="#Image-format-1" class="headerlink" title="Image format 1 :"></a>Image format 1 :</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ rbd info rbdbigsize</div><div class="line">rbd image &apos;rbdbigsize&apos;:</div><div class="line">    size 1862 PB in 500000000000 objects</div><div class="line">    order 22 (4096 kB objects)</div><div class="line">    block_name_prefix: rb.0.47aa.74b0dc51</div><div class="line">    format: 1</div></pre></td></tr></table></figure>
<p>删除头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rados -p rbd rm rbdbigsize.rbd</div></pre></td></tr></table></figure>
<p>删除所有rbd数据：(这可能需要一些时间，取决于块设备上已经使用的空间)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rados -p rbd ls | grep &apos;^rb.0.47aa.74b0dc51&apos; | xargs -n 200  rados -p rbd rm</div></pre></td></tr></table></figure>
<p>最后，从rbd list中删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rbd rm rbdbigsize</div><div class="line">2014-06-12 16:27:20.838596 7fd86dff3760 -1 librbd::ImageCtx: error finding header: (2) No such file or directory</div><div class="line">Removing image: 100% complete...done.</div></pre></td></tr></table></figure>
<h2 id="Image-format-2"><a href="#Image-format-2" class="headerlink" title="Image format 2 :"></a>Image format 2 :</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$  rbd info rbdbigsize</div><div class="line">rbd image &apos;rbdbigsize&apos;:</div><div class="line">        size 1024 TB in 268435456 objects</div><div class="line">        order 22 (4096 kB objects)</div><div class="line">        block_name_prefix: rbd_data.81d12ae8944a</div><div class="line">        format: 2</div><div class="line">        features: layering</div></pre></td></tr></table></figure>
<p>删除头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rados -p rbd rm rbd_id.rbdbigsize </div><div class="line">$ rados -p rbd rm rbd_header.81d12ae8944a</div></pre></td></tr></table></figure>
<p>删除所有rbd 数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | xargs -n 200  rados -p rbd rm</div></pre></td></tr></table></figure>
<p>从 rbd list中删除 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rbd rm rbdbigsize</div><div class="line">2014-06-12 17:37:24.483587 7f413506c760 -1 librbd::ImageCtx: error finding header: (2) No such file or directory</div><div class="line">Removing image: 100% complete...done.</div></pre></td></tr></table></figure>
<h2 id="时间对比"><a href="#时间对比" class="headerlink" title="时间对比"></a>时间对比</h2><p>1PB 已格式化块设备删除时间示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ rbd create rbdbigsize --size=1073741824 --image-format=2</div><div class="line">$ rbd map rbdbigsize</div><div class="line">$ mkfs.xfs /dev/rbd0</div><div class="line">$ rbd unmap /dev/rbd0</div><div class="line"></div><div class="line">$ rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | wc -l</div><div class="line">1536</div></pre></td></tr></table></figure>
<p>块设备仅由 1536 个块组成，可以通过 <code>rados rm</code> 快速删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ time rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | xargs -n 200  rados -p rbd rm</div><div class="line">real    0m10.073s</div><div class="line">user    0m1.244s</div><div class="line">sys 0m0.228s</div></pre></td></tr></table></figure>
<p>对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ time rbd rm rbdbigsize</div><div class="line">Removing image: 100% complete...done.</div><div class="line"></div><div class="line">real    1123m5.409s</div><div class="line">user    686m19.924s</div><div class="line">sys     229m56.596s</div></pre></td></tr></table></figure>
<center><img src="http://cephnotes.ksperis.com/images/img010.png" alt="img"></center>

<h2 id="Fully-initialized-image"><a href="#Fully-initialized-image" class="headerlink" title="Fully initialized image :"></a>Fully initialized image :</h2><p>当然，删除一个完全初始化的 image 使用 <code>rbd rm</code> 更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ rbd create rbdbigsize --size 1048576</div><div class="line">$ rbd map rbdbigsize; dd if=/dev/zero of=/dev/rbd0; rbd unmap /dev/rbd0;</div><div class="line">$ time (rados -p rbd ls | grep `rbd info rbdbigsize | grep block_name_prefix | grep -o &apos;rb.*$&apos;` | xargs -n 200  rados -p rbd rm; rados -p rbd rm rbdbigsize.rbd; rbd rm rbdbigsize)</div><div class="line"></div><div class="line">real    143m6.373s</div><div class="line">user    2m49.100s</div><div class="line">sys     0m22.080s</div><div class="line"></div><div class="line"></div><div class="line">$ rbd create rbdbigsize --size 1048576</div><div class="line">$ rbd map rbdbigsize; dd if=/dev/zero of=/dev/rbd0; rbd unmap /dev/rbd0;</div><div class="line">$ time rbd rm rbdbigsize</div><div class="line"></div><div class="line">real   88m44.121s</div><div class="line">user    1m5.464s</div><div class="line">sys     0m25.244s</div></pre></td></tr></table></figure>
<center><img src="http://cephnotes.ksperis.com/images/img011.png" alt="img"></center>

<p>本文为译文，原文链接：<a href="http://cephnotes.ksperis.com/blog/2014/07/04/remove-big-rbd-image" target="_blank" rel="external">Remove Big RBD Image</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rbd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos下ceph部署]]></title>
      <url>http://xiaqunfeng.cc/2017/07/17/centos%E4%B8%8Bceph%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>前一篇文章讲了整个ceph的部署全过程，不过是基于ubuntu的，这里基于centos再分享一下部署过程。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系统环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/redhat-release</div><div class="line">CentOS Linux release 7.3.1611 (Core)</div><div class="line"># uname -r</div><div class="line">3.10.0-514.16.1.el7.x86_64</div></pre></td></tr></table></figure>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>1、关闭防火墙和selinux</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># systemctl stop firewalld </div><div class="line"># systemctl disable firewalld</div><div class="line"># sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config</div><div class="line"># setenforce 0</div></pre></td></tr></table></figure>
<p><strong>2、打开ceph需要的端口</strong></p>
<p>如果关闭了防火墙，这里就不需要打开端口了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># firewall-cmd --zone=public --add-port=6789/tcp --permanent</div><div class="line"># firewall-cmd --zone=public --add-port=6800-7100/tcp --permanent</div><div class="line"># firewall-cmd --reload</div></pre></td></tr></table></figure>
<p><strong>3、安装EPEL软件源</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line"># yum -y update</div><div class="line"># yum -y upgrade</div></pre></td></tr></table></figure>
<p><strong>4、安装 ntp 时间同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install ntp ntpdate ntp-doc</div></pre></td></tr></table></figure>
<p><strong>5、设置免密登录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen</div><div class="line">ssh-copy-id XXX</div></pre></td></tr></table></figure>
<p><strong>6、使用国内源安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rpm -Uvh http://mirrors.163.com/ceph/rpm-kraken/el7/noarch/ceph-release-1-1.el7.noarch.rpm</div><div class="line"># yum update -y</div></pre></td></tr></table></figure>
<p><strong>7、安装ceph-deploy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rpm -Uvh http://mirrors.163.com/ceph/rpm-kraken/el7/noarch/ceph-deploy-1.5.37-0.noarch.rpm </div><div class="line"># yum update -y</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum install ceph-deploy -y</div></pre></td></tr></table></figure>
<p><strong>8、让ceph-deploy使用国内源安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/rpm-kraken/el7</div><div class="line">export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc</div></pre></td></tr></table></figure>
<p><strong>9、安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install ceph0 ceph1 ceph2</div></pre></td></tr></table></figure>
<p><strong>10、mon安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy mon create-initial</div></pre></td></tr></table></figure>
<blockquote>
<p>OSD安装和ubuntu上一样</p>
</blockquote>
<h2 id="几个启动方式的不同"><a href="#几个启动方式的不同" class="headerlink" title="几个启动方式的不同"></a>几个启动方式的不同</h2><p>先列举两个：</p>
<p>1、启动mon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start ceph-mon@ceph0.service</div></pre></td></tr></table></figure>
<p>2、启动osd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start ceph-osd@&#123;osd-num&#125;</div></pre></td></tr></table></figure>
<p>更多cento 7 上操纵集群命令详见文章：<a href="http://xiaqunfeng.cc/2017/06/16/centos-7%E4%B8%8B%E6%93%8D%E7%BA%B5ceph%E8%BF%9B%E7%A8%8B/">centos 7下操纵ceph进程</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph部署完全手册]]></title>
      <url>http://xiaqunfeng.cc/2017/07/17/ceph%E9%83%A8%E7%BD%B2%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<p>从零开始，一步一步搭建一个ceph集群。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是以前的一个笔记，整理并分享出来，给有需要的人。</p>
<p><strong>环境：</strong></p>
<p>主机系统：ubuntu14.04</p>
<p>ceph版本：ceph jewel</p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><h3 id="1-1-硬件资源"><a href="#1-1-硬件资源" class="headerlink" title="1.1 硬件资源"></a>1.1 硬件资源</h3><p>​    <strong>硬件配置</strong>：5台云主机，4核4G内存，Ubuntu14系统，每台挂载1 块100G 的SSD 和3 块200G 的SATA 盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">vdc    253:32   0   200G  0 disk </div><div class="line">vdd    253:48   0   200G  0 disk </div><div class="line">vde    253:64   0   200G  0 disk</div></pre></td></tr></table></figure>
<p>​    <strong>磁盘分区</strong></p>
<p>​    ceph-mon可以和osd节点混布，但要物理隔离。单台机器可以由多个osd进程，每个osd的数据盘和journal盘分别处于独立分区，为了高性能，建议journal放在在ssd盘，分区大小10G即可(更精确的大小计算参见<a href="http://docs.ceph.com/docs/jewel/rados/configuration/osd-config-ref/#journal-settings" target="_blank" rel="external">这里</a>, 大致的计算原则是 磁盘的吞吐osd持久化间隔的两倍，默认的持久化间隔是5s，按照磁盘吞吐200M计算，2G空间就够了)。<br>​    以上述的推荐举个例子：<br>​    某机器上含有4T的sata盘/dev/sdb, /dev/sdc, /dev/sdc。ssd盘480G，/dev/sdd。使用lsscsi可以看到磁盘的类型(sata or ssd)，fdisk -l可以查看磁盘容量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># lsscsi</div><div class="line">[0:0:0:0]    disk    SEAGATE  ST300MM0006      0003  /dev/sda</div><div class="line">[0:0:1:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdb</div><div class="line">[0:0:2:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdc</div><div class="line">[0:0:3:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdd</div><div class="line">[0:0:4:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sde</div><div class="line">[0:0:5:0]    disk    ATA      INTEL SSDSC2BB48 0150  /dev/sdf</div><div class="line">[0:0:6:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdg</div><div class="line">[0:0:7:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdh</div><div class="line">[0:0:8:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdi</div><div class="line">[0:0:9:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdj</div><div class="line">[0:0:10:0]   disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdk</div><div class="line">[0:0:11:0]   disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdl</div><div class="line">[0:0:12:0]   disk    ATA      INTEL SSDSC2BB48 0150  /dev/sdm</div><div class="line">[0:0:13:0]   enclosu PMCSIERA SXP 24Sx12G      RevB  -</div></pre></td></tr></table></figure>
<p>可以使用parted工具进行分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parted  -s  /dev/sdb  mklabel gpt #对/dev/sdb分区</div><div class="line">parted /dev/sdb mkpart primary ext4 1 1000000 # 第一个分区占用1M到1000000M。</div></pre></td></tr></table></figure>
<p>对于ssd盘，可以创建多个分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parted  -s  /dev/sdd  mklabel gpt #对/dev/sdb分区</div><div class="line">parted /dev/sdb mkpart primary ext4 1 10000 # 第一个分区占用1M到10000M。</div><div class="line">parted /dev/sdb mkpart primary ext4 10000 20000# </div><div class="line">第二个分区占用10000M到20000M。</div><div class="line">parted /dev/sdb mkpart primary ext4 20000 30000 # </div><div class="line">第三个分区占用20000M到30000M，剩余的分区可以由你自由分配。</div></pre></td></tr></table></figure>
<p>​    <strong>实际分区部署操作</strong></p>
<p>​    分区的时候这里仅针对SSD分3个区，每个区给挂载在该主机上的3个SATA盘使用。</p>
<blockquote>
<p>为ceph准备好磁盘分区，仅作分区，不需要挂载和建立文件系统，部署osd节点时，ceph自己会做这个工作。</p>
</blockquote>
<p>​    将SSD分为3个主分区，SATA盘一个分区，独立挂载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# parted -s /dev/vdb mklabel gpt</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 0 40G</div><div class="line">Warning: The resulting partition is not properly aligned for best performance.</div><div class="line">Ignore/Cancel? Cancel </div><div class="line">#生成的分区没有正确地对齐以实现最佳性能。忽略/取消？</div></pre></td></tr></table></figure>
<blockquote>
<p>正确对齐分区的快速分步指南：</p>
<p>​    首先获得你阵列的alignment参数：</p>
<p>root@ceph0:~# cat /sys/block/vdb/queue/optimal_io_size<br>0<br>root@ceph0:~# cat /sys/block/vdb/queue/minimum_io_size<br>512<br>root@ceph0:~# cat /sys/block/vdb/alignment_offset<br>0<br>root@ceph0:~# cat /sys/block/vdb/queue/physical_block_size<br>512</p>
<p>​    其次，把optimal_io_size的值与alignment_offset的值相加，之后除以physical_block_size的值。在我的例子中是：(512 + 0) / 512 = 1。这个数值是分区起始的扇区。</p>
<p>​    最后，新的parted命令应该写成类似下面这样</p>
<p>mkpart primary 1s 100%</p>
<p>​    字母s是很有意义的：它告诉parted，你的输入是1个扇区，而不是1个字节，也不是1兆字节。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 1 40G</div><div class="line">Information: You may need to update /etc/fstab.  </div><div class="line"></div><div class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 40G 70G</div><div class="line">Information: You may need to update /etc/fstab.                           </div><div class="line"></div><div class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 70G 100G</div><div class="line">Information: You may need to update /etc/fstab.  </div><div class="line"></div><div class="line"># 不需要update。parted命令是实时生效的，分区命令完成后已经将分区表数据写入了硬盘。</div><div class="line"># /etc/fstab文件，是系统的自动挂载分区的配置。目的是让系统重启后，能够自动将某个分区挂载到指定挂载点，而不用再手动mount。</div></pre></td></tr></table></figure>
<p>​    SATA盘需要一个主分区，200G大小，分区过程同上。</p>
<p>​    分区后的磁盘挂载树状结构图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0  37.3G  0 part </div><div class="line">├─vdb2 253:18   0    28G  0 part </div><div class="line">└─vdb3 253:19   0    28G  0 part </div><div class="line">vdc    253:32   0   200G  0 disk </div><div class="line">└─vdc1 253:33   0 186.3G  0 part </div><div class="line">vdd    253:48   0   200G  0 disk </div><div class="line">└─vdd1 253:49   0 186.3G  0 part </div><div class="line">vde    253:64   0   200G  0 disk </div><div class="line">└─vde1 253:65   0 186.3G  0 part</div></pre></td></tr></table></figure>
<p>​    对其他主机上挂载的SSD和SATA盘操作同上。</p>
<h3 id="1-2-设置ssh免密登录-仅主控节点"><a href="#1-2-设置ssh免密登录-仅主控节点" class="headerlink" title="1.2 设置ssh免密登录(仅主控节点)"></a>1.2 设置ssh免密登录(仅主控节点)</h3><p>​    选定一个节点作为主控节点（这里选的ceph0主机），建立从主控节点到其他节点的免密登录。主控节点也可以安装ceph。</p>
<p><strong>1 生成秘钥：ssh-keygen</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# ssh-keygen</div></pre></td></tr></table></figure>
<p><strong>2 拷贝密钥：ssh-copy-id your_dst_node</strong></p>
<p>​    输入密码即可，如果不知道密码，则把~/.ssh/id_rsa.pub加入到目标机器的~/.ssh/authorized_keys中亦可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# ssh-copy-id root@172.20.0.197</div></pre></td></tr></table></figure>
<p>​    然后就可以免密登录了，直接 <strong>ssh + IP</strong> 就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# ssh 172.20.0.197</div></pre></td></tr></table></figure>
<p>​    对其他机台机器的操作同上。<strong>注意：也要对本机设置免密登录。</strong></p>
<p>​    有了免密登录，可以批量的执行命令。</p>
<p><strong>3 设置主控节点通过ssh访问其他节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">127.0.0.1       localhost       ceph0</div><div class="line">127.0.1.1       host-192-168-112-190.openstacklocal     host-192-168-112-190</div><div class="line"></div><div class="line">172.20.0.196    ceph0</div><div class="line">172.20.0.197    ceph1</div><div class="line">172.20.0.198    ceph2</div><div class="line">172.20.0.199    ceph3</div><div class="line">172.20.0.200    ceph4</div><div class="line"></div><div class="line"># The following lines are desirable for IPv6 capable hosts</div><div class="line">::1     localhost ip6-localhost ip6-loopback</div><div class="line">ff02::1 ip6-allnodes</div><div class="line">ff02::2 ip6-allrouters</div><div class="line">~                                                                                                                                                      </div><div class="line">~                                                                                                                                                   </div><div class="line">&quot;/etc/hosts&quot; 14L, 340C</div></pre></td></tr></table></figure>
<h3 id="1-3-防火墙及安全设置（所有节点）"><a href="#1-3-防火墙及安全设置（所有节点）" class="headerlink" title="1.3 防火墙及安全设置（所有节点）"></a>1.3 防火墙及安全设置（所有节点）</h3><p><strong>1 防火墙相关</strong></p>
<p>​    Ceph Monitors 之间默认使用 6789 端口通信， OSD 之间默认用 6800:7300 这个范围内的端口通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo firewall-cmd --zone=public --add-port=6789/tcp --permanent</div><div class="line">如果提示命令不存在，则可以批量安装</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# sudo firewall-cmd --zone=public --add-port=6789/tcp --permanent</div><div class="line">sudo: unable to resolve host ceph0</div><div class="line">sudo: firewall-cmd: command not found</div></pre></td></tr></table></figure>
<p><strong>2 selinux相关</strong><br>​    设置selinux，如果报命令不存在，可以忽略这一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# sudo setenforce 0</div><div class="line">sudo: setenforce: command not found</div></pre></td></tr></table></figure>
<p>​    如果命令存在，执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo setenforce 0</div></pre></td></tr></table></figure>
<p>​    如果希望永久生效，则修改 /etc/selinux/config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">This file controls the state of SELinux on the system.</div><div class="line">SELINUX= can take one of these three values:</div><div class="line">	enforcing - SELinux security policy is enforced.</div><div class="line">	permissive - SELinux prints warnings instead of enforcing.</div><div class="line">    disabled - No SELinux policy is loaded.</div><div class="line">SELINUX=disabled</div><div class="line">SELINUXTYPE= can take one of these two values:</div><div class="line">    targeted - Targeted processes are protected,</div><div class="line">    minimum - Modification of targeted policy. Only selected </div><div class="line">processes are protected.</div><div class="line">    mls - Multi Level Security protection.</div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
<h3 id="1-4-添加ceph用户，并设置权限（所有节点）"><a href="#1-4-添加ceph用户，并设置权限（所有节点）" class="headerlink" title="1.4 添加ceph用户，并设置权限（所有节点）"></a>1.4 添加ceph用户，并设置权限（所有节点）</h3><p>1、在各 Ceph 节点创建新用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# sudo useradd -d /home/ceph -m ceph</div><div class="line">sudo: unable to resolve host ceph0</div></pre></td></tr></table></figure>
<p>​    第一条命令执行后的告警没关系，如果想消除，可以参考<a href="http://blog.csdn.net/ichuzhen/article/details/8241847" target="_blank" rel="external">这里</a>。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/hosts</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#然后再localhost后面加上当前的主机名，这里是ceph0</div><div class="line">127.0.0.1       localhost       ceph0</div></pre></td></tr></table></figure>
<p>2、确保各 Ceph 节点上新创建的用户都有 sudo 权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# echo &quot;ceph ALL = (root) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/ceph</div><div class="line">ceph ALL = (root) NOPASSWD:ALL</div><div class="line">root@ceph0:~# sudo chmod 0440 /etc/sudoers.d/ceph</div></pre></td></tr></table></figure>
<h3 id="1-5-安装ntp服务（所有节点）"><a href="#1-5-安装ntp服务（所有节点）" class="headerlink" title="1.5 安装ntp服务（所有节点）"></a>1.5 安装ntp服务（所有节点）</h3><p>​    主要是用于ceph-mon之间的时间同步。在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障。确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ntp</div></pre></td></tr></table></figure>
<blockquote>
<p>可以暂时不设置，一般公司的服务器会校准时间，如果需要的话，时间服务器网上百度一下，自行设置即可。</p>
</blockquote>
<h3 id="1-6-添加ceph安装源（所有节点）"><a href="#1-6-添加ceph安装源（所有节点）" class="headerlink" title="1.6 添加ceph安装源（所有节点）"></a>1.6 添加ceph安装源（所有节点）</h3><p>​    顺序执行以下命令：</p>
<p>​    <strong>注</strong>：建议这里的源直接写国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; | sudo apt-key add -</div><div class="line">echo deb https://download.ceph.com/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div></pre></td></tr></table></figure>
<p>​    国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># wget -q -O- &apos;http://mirrors.163.com/ceph/keys/release.asc&apos; &gt; test.asc</div><div class="line"># vim test.asc </div><div class="line"># apt-key add test.asc </div><div class="line">OK</div><div class="line"># echo deb http://mirrors.163.com/ceph/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div><div class="line">deb https://mirrors.163.com/ceph/debian-jewel/ trusty main</div></pre></td></tr></table></figure>
<p>​    <strong>实际执行情况</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; | sudo apt-key add -</div><div class="line">apt-key add: command not found</div></pre></td></tr></table></figure>
<p>​    很诡异，不知道为啥不行，换一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; &gt; test.asc</div><div class="line">root@ceph0:~# apt-key add  test.asc </div><div class="line">OK</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# echo deb https://download.ceph.com/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div><div class="line">deb https://download.ceph.com/debian-jewel/ trusty main</div></pre></td></tr></table></figure>
<h3 id="1-7-安装ceph-deploy部署工具-仅主控节点"><a href="#1-7-安装ceph-deploy部署工具-仅主控节点" class="headerlink" title="1.7 安装ceph-deploy部署工具(仅主控节点)"></a>1.7 安装ceph-deploy部署工具(仅主控节点)</h3><p>​    更新你的仓库，并安装 ceph-deploy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</div></pre></td></tr></table></figure>
<p>​    <strong>实际执行情况</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</div><div class="line">E: Type &apos;deb https://download.ceph.com/debian-jewel/ trusty&apos; is not known on line 1 in source list /etc/apt/sources.list.d/ceph.list</div><div class="line">E: The list of sources could not be read.</div></pre></td></tr></table></figure>
<p>​    替换ceph国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# vi /etc/apt/sources.list.d/ceph.list</div><div class="line"></div><div class="line">修改内容如下：</div><div class="line">#deb http://download.ceph.com/debian-jewel/ trusty main </div><div class="line">deb http://mirrors.163.com/ceph/debian-jewel trusty main</div></pre></td></tr></table></figure>
<p>​    然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</div></pre></td></tr></table></figure>
<h2 id="2-启动ceph-mon"><a href="#2-启动ceph-mon" class="headerlink" title="2 启动ceph-mon"></a>2 启动ceph-mon</h2><h3 id="2-1-安装ceph"><a href="#2-1-安装ceph" class="headerlink" title="2.1 安装ceph"></a>2.1 安装ceph</h3><p>使用国内源加快安装速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-jewel </div><div class="line">export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc</div></pre></td></tr></table></figure>
<p>###2.2 创建部署的目录，目录内会生成ceph的配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir my-cluster &amp;&amp; cd my-cluster/</div></pre></td></tr></table></figure>
<h3 id="2-3-配置新节点"><a href="#2-3-配置新节点" class="headerlink" title="2.3 配置新节点"></a>2.3 配置新节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy new your-node-list</div></pre></td></tr></table></figure>
<p>例如：<code>ceph-deploy new ceph-0 ceph-1 ceph-2 [other node…]</code></p>
<p>此时会在my-cluster目录下生成几个文件，如ceph.conf;ceph.mon.keyring等</p>
<p>设置ceph.conf，增加一行<code>public network = xxx.xxx.xxx.0/24</code>[取决于实际的网络]</p>
<p><strong>实际配置操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph-deploy new ceph0 ceph1 ceph2</div><div class="line">root@ceph0:~/my-cluster# ls</div><div class="line">ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring  release.asc</div></pre></td></tr></table></figure>
<p>​    看一下网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ifconfig</div><div class="line">eth0      Link encap:Ethernet  HWaddr fa:16:3e:89:b2:7f  </div><div class="line">          inet addr:172.20.0.196  Bcast:172.20.255.255  Mask:255.255.0.0</div></pre></td></tr></table></figure>
<p>​    我这里新增加的一行为：public network = xxx.xxx.xxx.0/16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# vim ceph.conf</div><div class="line">[global]</div><div class="line">fsid = 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</div><div class="line">mon_initial_members = ceph0, ceph1, ceph2</div><div class="line">mon_host = 172.20.0.196,172.20.0.197,172.20.0.198</div><div class="line">auth_cluster_required = cephx</div><div class="line">auth_service_required = cephx</div><div class="line">auth_client_required = cephx</div><div class="line"></div><div class="line">public network = 172.20.0.0/16</div></pre></td></tr></table></figure>
<p>###2.4 安装该节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install ceph-0 ceph-2 ceph-2 [other node...]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph-deploy install ceph0 ceph1 ceph2</div><div class="line">……</div><div class="line">……</div><div class="line">[ceph2][INFO  ] Running command: ceph --version</div><div class="line">[ceph2][DEBUG ] ceph version 10.2.3 (ecc23778eb545d8dd55e2e4735b53cc93f92e65b)</div><div class="line"># ceph0,ceph1,ceph2都出现上面这两行输出表示安装完成</div></pre></td></tr></table></figure>
<p>###2.5 配置并启动ceph-mon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy mon create-initial</div></pre></td></tr></table></figure>
<p>​    然后运行 ceph -s可以看到当前集群的状态，3个mon，暂时没有osd，有个pool，pool的pg数目是64个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph -s</div><div class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</div><div class="line">     health HEALTH_ERR</div><div class="line">            no osds</div><div class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</div><div class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">     osdmap e1: 0 osds: 0 up, 0 in</div><div class="line">            flags sortbitwise</div><div class="line">      pgmap v2: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            0 kB used, 0 kB / 0 kB avail</div><div class="line">                  64 creating</div></pre></td></tr></table></figure>
<h2 id="3-添加ceph-osd节点"><a href="#3-添加ceph-osd节点" class="headerlink" title="3 添加ceph-osd节点"></a>3 添加ceph-osd节点</h2><h3 id="3-1-安装ceph到osd节点"><a href="#3-1-安装ceph到osd节点" class="headerlink" title="3.1 安装ceph到osd节点"></a>3.1 安装ceph到osd节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --release &#123;release-name&#125; node-list</div></pre></td></tr></table></figure>
<p>​    这里把之前装monitor前没装的主机装上，我这里还剩ceph3, ceph4没装，执行如下（其实命令里选择版本号这个可以去掉，因为默认的下载源已经指定了版本）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --release jewel ceph3 ceph4</div></pre></td></tr></table></figure>
<h3 id="3-2-设置并启动osd"><a href="#3-2-设置并启动osd" class="headerlink" title="3.2 设置并启动osd"></a>3.2 设置并启动osd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ceph-deploy osd prepare ceph-4:/dev/vdb1:/dev/vde1 ceph-4:/dev/vdc1:/dev/vde2 ceph-4:/dev/vdd1:/dev/vde3 #磁盘准备</div><div class="line">ssh ceph-4 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1 /dev/vdd1 /dev/vde1 /dev/vde2 /dev/vde3&apos; # 设置权限</div><div class="line">ceph-deploy osd activate ceph-4:/dev/vdb1:/dev/vde1 ceph-4:/dev/vdc1:/dev/vde2 ceph-4:/dev/vdd1:/dev/vde3 #启动osd</div></pre></td></tr></table></figure>
<p>​    上述代码会在ceph-4机器创建三个osd进程，磁盘组合/dev/vdb1:/dev/vde1的vdb1作为第一个osd的数据盘，vde1作为journal盘。然后运行ceph -s，可以看到osd节点已经加入。</p>
<p>具体执行如下：</p>
<p><strong>1 磁盘准备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph-deploy osd prepare ceph0:/dev/vdc1:/dev/vdb1 ceph0:/dev/vdd1:/dev/vdb2 ceph0:/dev/vde1:/dev/vdb3</div><div class="line">……</div><div class="line">……</div><div class="line">[ceph0][INFO  ] checking OSD status...</div><div class="line">[ceph0][DEBUG ] find the location of an executable</div><div class="line">[ceph0][INFO  ] Running command: /usr/bin/ceph --cluster=ceph osd stat --format=json</div><div class="line">[ceph_deploy.osd][DEBUG ] Host ceph0 is now ready for osd use.</div></pre></td></tr></table></figure>
<p><strong>2 设置权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ssh ceph0 &apos;chown ceph:ceph /dev/vdb1 /dev/vdb2 /dev/vdb3 /dev/vdc1 /dev/vdd1 /dev/vde1&apos;</div></pre></td></tr></table></figure>
<p><strong>3 启动OSD</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph-deploy osd activate ceph0:/dev/vdc1:/dev/vdb1 ceph0:/dev/vdd1:/dev/vdb2 ceph0:/dev/vde1:/dev/vdb3</div><div class="line">……</div><div class="line">……</div><div class="line">[ceph0][INFO  ] checking OSD status...</div><div class="line">[ceph0][DEBUG ] find the location of an executable</div><div class="line">[ceph0][INFO  ] Running command: /usr/bin/ceph --cluster=ceph osd stat --format=json</div></pre></td></tr></table></figure>
<p>​    其他四台主机上的OSD设置同上，注意SSD盘符和SATA盘符的不同。</p>
<p>​    所有五台机器设置完后，运行ceph -s，可以看到15个osd节点已经加入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~/my-cluster# ceph -s</div><div class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</div><div class="line">     health HEALTH_WARN</div><div class="line">            too few PGs per OSD (12 &lt; min 30)</div><div class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</div><div class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">     osdmap e80: 15 osds: 15 up, 15 in</div><div class="line">            flags sortbitwise</div><div class="line">      pgmap v181: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            525 MB used, 2792 GB / 2792 GB avail</div><div class="line">                  64 active+clean</div></pre></td></tr></table></figure>
<p><strong>4 设置使集群处于健康状态</strong></p>
<p><strong>注意上面的ceph 处于 HEALTH_WARN 状态</strong></p>
<p>查看副本数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph osd dump | grep &apos;replicated size&apos;</div><div class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</div></pre></td></tr></table></figure>
<p>查看已经存在的pools</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph osd lspools</div><div class="line">0 rbd,</div></pre></td></tr></table></figure>
<p>查看rbd pool中的 pg_num 和 pgp_num 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph osd pool get rbd pg_num</div><div class="line">pg_num: 64</div><div class="line">root@ceph0:/etc/ceph# ceph osd pool get rbd pgp_num</div><div class="line">pgp_num: 64</div></pre></td></tr></table></figure>
<p>健康的 pg_num 和 pgp_num 计算方法：</p>
<p>​    关于pgmap的数目，<strong>osd_num *100 / replica_num</strong>，<strong>向上取2的幂</strong>。比如15个osd，三备份，15 *100/3=500，得到pg_num = 512，线上重新设定这个数值时会引起数据迁移，请谨慎处理。</p>
<p>设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph osd pool set rbd pg_num 512</div><div class="line">set pool 0 pg_num to 512</div><div class="line">root@ceph0:/etc/ceph# ceph osd pool set rbd pgp_num 512</div><div class="line">set pool 0 pgp_num to 512</div><div class="line">root@ceph0:/etc/ceph#</div></pre></td></tr></table></figure>
<p>再次查看 ceph 集群状态，HEALTH_OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph -s</div><div class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</div><div class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">     osdmap e84: 15 osds: 15 up, 15 in</div><div class="line">            flags sortbitwise</div><div class="line">      pgmap v226: 512 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            561 MB used, 2792 GB / 2792 GB avail</div><div class="line">                 512 active+clean</div><div class="line">root@ceph0:/etc/ceph#</div></pre></td></tr></table></figure>
<h2 id="4-设置ceph的rbd块存储设备"><a href="#4-设置ceph的rbd块存储设备" class="headerlink" title="4 设置ceph的rbd块存储设备"></a>4 设置ceph的rbd块存储设备</h2><p>​    确保ceph存储集群处于 active + clean 的状态，这样才能使用块设备。</p>
<h3 id="4-1-建立主控机器到rbd所在设备的ssh免密登录关系"><a href="#4-1-建立主控机器到rbd所在设备的ssh免密登录关系" class="headerlink" title="4.1 建立主控机器到rbd所在设备的ssh免密登录关系"></a>4.1 建立主控机器到rbd所在设备的ssh免密登录关系</h3><p>​    参见上文：章节1.2。</p>
<h3 id="4-2-安装ceph环境，并授予权限"><a href="#4-2-安装ceph环境，并授予权限" class="headerlink" title="4.2 安装ceph环境，并授予权限"></a>4.2 安装ceph环境，并授予权限</h3><p>​    假设rbd所在机器的hostname为 ceph-cli（这里新建一台主机，名为ceph-cli）。在<strong>主控节点上</strong>的 /etc/ceph 目录下执行操作。</p>
<p>​    1 在ceph0上使用ceph-deploy 工具ceph二进制程序安装到ceph-cli上面</p>
<p>​    注意：在 ceph-cli 主机上将ceph 源改为国内源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/ceph/ # 主控节点</div><div class="line">ceph-deploy install ceph-cli</div></pre></td></tr></table></figure>
<p>​    2 将ceph配置文件（ceph.conf）复制到ceph-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy config push ceph-cli</div></pre></td></tr></table></figure>
<p>​    3 客户机需要ceph密钥去访问ceph集群。ceph创建了一个默认用户 client.admin，它有足够的权限去访问ceph集群。不建议把client.admin共享到所有其他客户端节点。更好的做法是用分开的密钥创建一个新的ceph用户去访问特定的存储池。</p>
<p>​    这里，创建了一个ceph用户 client.rbd，它拥有访问rbd存储池的权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph auth get-or-create client.rbd mon &apos;allow r&apos; osd &apos;allow class-read object_prefix rbd_children, allow rwx pool=rbd&apos;</div><div class="line">[client.rbd]</div><div class="line">	key = AQAmVzVYzXDjBhAAWlcdtEnQ6XBscmU58ZljAw==</div></pre></td></tr></table></figure>
<p>​    4 为ceph-cli上的client.rbd用户添加密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ceph auth get-or-create client.rbd | ssh ceph-cli &apos;sudo tee /etc/ceph/ceph.client.rbd.keyring&apos;</div><div class="line">sudo: unable to resolve host ceph-cli</div><div class="line">[client.rbd]</div><div class="line">	key = AQAmVzVYzXDjBhAAWlcdtEnQ6XBscmU58ZljAw==</div></pre></td></tr></table></figure>
<p>​    5 至此，ceph-cli 应该准备好充当ceph客户端了。通过提供用户名和密钥在 ceph-cli 上检查集群的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@ceph0:/etc/ceph# ssh ceph-cli &apos;cat /etc/ceph/ceph.client.rbd.keyring &gt;&gt; /etc/ceph/keyring&apos;</div><div class="line"></div><div class="line">root@ceph0:/etc/ceph# ssh ceph-cli &apos;ceph -s --name client.rbd&apos;</div><div class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</div><div class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</div><div class="line">     osdmap e84: 15 osds: 15 up, 15 in</div><div class="line">            flags sortbitwise</div><div class="line">      pgmap v232: 512 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            547 MB used, 2792 GB / 2792 GB avail</div><div class="line">                 512 active+clean</div></pre></td></tr></table></figure>
<p>​    至此，ceph客户端已经配置完毕。接下来在客户端上创建块设备。</p>
<h3 id="4-3-创建ceph块设备"><a href="#4-3-创建ceph块设备" class="headerlink" title="4.3 创建ceph块设备"></a>4.3 创建ceph块设备</h3><p>​    1 创建一个102400M 大小的RADOS 块设备，取名 rbd1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# rbd create rbd1 --size 102400 --name client.rbd --image-feature layering</div><div class="line"># 14.04的内核只支持layering，增加不支持的特性会导致后续的map失败。</div></pre></td></tr></table></figure>
<p>​    2 列出RBD 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# rbd ls --name client.rbd</div><div class="line">rbd1</div></pre></td></tr></table></figure>
<p>​    3 检查rbd 镜像的细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# rbd --image rbd1 info --name client.rbd</div><div class="line">rbd image &apos;rbd1&apos;:</div><div class="line">	size 102400 MB in 25600 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.10912ae8944a</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<h3 id="4-4-映射块设备并初始化"><a href="#4-4-映射块设备并初始化" class="headerlink" title="4.4 映射块设备并初始化"></a>4.4 映射块设备并初始化</h3><p>​    1 映射块设备到 ceph-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# rbd map --image rbd1 --name client.rbd</div><div class="line">/dev/rbd0</div></pre></td></tr></table></figure>
<p>​    2 检查被映射的块设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# rbd showmapped --name client.rbd</div><div class="line">id pool image snap device    </div><div class="line">0  rbd  rbd1  -    /dev/rbd0</div></pre></td></tr></table></figure>
<p>​    3 要使用这个块设备，我们需要创建并挂载一个文件系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# fdisk -l /dev/rbd0</div><div class="line"></div><div class="line">#创建文件系统</div><div class="line">root@ceph-cli:~# mkfs.ext4 /dev/rbd0</div><div class="line"></div><div class="line">#创建文件夹 ceph-disk1，并将块设备 rbd0 挂载在该目录下</div><div class="line">root@ceph-cli:~# mkdir /mnt/ceph-disk1 &amp;&amp; mount /dev/rbd0 /mnt/ceph-disk1</div><div class="line"></div><div class="line">root@ceph-cli:~# df -h /mnt/ceph-disk1</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/rbd0        99G   60M   94G   1% /mnt/ceph-disk1</div></pre></td></tr></table></figure>
<h3 id="4-5-测试块设备"><a href="#4-5-测试块设备" class="headerlink" title="4.5 测试块设备"></a>4.5 测试块设备</h3><p>​    接下来就可以开始对这个块存储进行任意读写了。可以使用dd或者fio进行性能测试，注意fio是破坏性测试，会毁坏数据甚至文件系统。不过破坏了也没关系，删除rbd设备后，重新添加rbd设备，格式化即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@ceph-cli:~# dd if=/dev/zero of=/mnt/ceph-disk1/file1 count=100 bs=1M</div><div class="line">100+0 records in</div><div class="line">100+0 records out</div><div class="line">104857600 bytes (105 MB) copied, 0.12931 s, 811 MB/s</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> install </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fio测试ceph]]></title>
      <url>http://xiaqunfeng.cc/2017/07/12/fio%E6%B5%8B%E8%AF%95ceph/</url>
      <content type="html"><![CDATA[<p>包含三块内容：fio测试RBD，fio测试ceph filestore，fio测试ceph bluestore。<br><a id="more"></a></p>
<h2 id="fio测试RBD"><a href="#fio测试RBD" class="headerlink" title="fio测试RBD"></a>fio测试RBD</h2><p>fio测试工具扩展了一个对 <code>librbd</code> 的支持模块，并使用您选择的IO模式测试Ceph RBD集群。安装librbd开发包（例如librbd-dev或librbd-dev和依赖关系），或者将库及其头放在指定位置即可。</p>
<h3 id="安装fio及依赖包"><a href="#安装fio及依赖包" class="headerlink" title="安装fio及依赖包"></a>安装fio及依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># git clone git://git.kernel.dk/fio.git</div><div class="line"># cd fio/</div><div class="line"># ./configure</div><div class="line">...</div><div class="line">Rados Block Device engine     no</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里显示不支持RBD engine，configure检查编译环境缺少依赖导致的，安装 <code>ceph-devel</code> 包即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install ceph-devel -y</div></pre></td></tr></table></figure>
<p>重新编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ./configure</div><div class="line">...</div><div class="line">Rados Block Device engine     yes</div><div class="line">...</div></pre></td></tr></table></figure>
<p>查看当前 fio 已支持的 IO 引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># fio --enghelp</div><div class="line">Available IO engines:</div><div class="line">	cpuio</div><div class="line">	mmap</div><div class="line">	sync</div><div class="line">	psync</div><div class="line">	vsync</div><div class="line">	pvsync</div><div class="line">	null</div><div class="line">	net</div><div class="line">	netsplice</div><div class="line">	libaio</div><div class="line">	rdma</div><div class="line">	posixaio</div><div class="line">	falloc</div><div class="line">	e4defrag</div><div class="line">	splice</div><div class="line">	rbd</div><div class="line">	mtd</div><div class="line">	sg</div><div class="line">	binject</div></pre></td></tr></table></figure>
<p>此时，已支持 RBD engine。</p>
<h3 id="测试librbd"><a href="#测试librbd" class="headerlink" title="测试librbd"></a>测试librbd</h3><p>1、创建一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd -p rbd create --size 2048 fio_test</div></pre></td></tr></table></figure>
<p>2、撰写 job file：<code>rbd.fio</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">######################################################################</div><div class="line"># Example test for the RBD engine.</div><div class="line">#</div><div class="line"># Runs a 4k random write test agains a RBD via librbd</div><div class="line">#</div><div class="line"># NOTE: Make sure you have either a RBD named &apos;fio_test&apos; or change</div><div class="line">#       the rbdname parameter.</div><div class="line">######################################################################</div><div class="line">[global]</div><div class="line">#logging</div><div class="line">#write_iops_log=write_iops_log</div><div class="line">#write_bw_log=write_bw_log</div><div class="line">#write_lat_log=write_lat_log</div><div class="line">ioengine=rbd</div><div class="line">clientname=admin</div><div class="line">pool=rbd</div><div class="line">rbdname=fio_test</div><div class="line">invalidate=0    # mandatory</div><div class="line">rw=randwrite</div><div class="line">bs=4k</div><div class="line"></div><div class="line">[rbd_iodepth32]</div><div class="line">iodepth=32</div></pre></td></tr></table></figure>
<p>以上 job file 将执行整个RBD大小的100％随机写入测试（将通过librbd确定），Ceph用户 <code>admin</code> 使用Ceph 默认 pool <code>rbd</code>和刚刚创建的空的 RBD fio_test，写的 blocksize 为 4k 和 iodepth 为32 。 引擎正在使用异步IO。</p>
<p>当前实施限制：</p>
<ul>
<li>invalidate = 0 现在是强制需要的，engine 现在没有这个会返回失败。 </li>
<li>测试完成后 <code>rbd</code> 引擎不会被清除。完成测试运行后，给定的RBD将被填充。（我们现在使用它进行预填充测试，并在需要时重新创建RBD。）</li>
</ul>
<p>部分参考：<a href="http://telekomcloud.github.io/ceph/2014/02/26/ceph-performance-analysis_fio_rbd.html" target="_blank" rel="external">Ceph Performance Analysis: fio and RBD</a></p>
<p>3、测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fio rbd.fio</div></pre></td></tr></table></figure>
<h3 id="测试kernel-RBD"><a href="#测试kernel-RBD" class="headerlink" title="测试kernel RBD"></a>测试kernel RBD</h3><p>1、创建一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd -p rbd create --size 2048 fio_test</div></pre></td></tr></table></figure>
<p>2、将image map到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/fio_test</div><div class="line">/dev/rbd0</div><div class="line"># mkfs.xfs /dev/rbd0 -f</div></pre></td></tr></table></figure>
<p>3、撰写 job file：<code>rbd.fio</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">ioengine=libaio</div><div class="line">direct=1</div><div class="line">thread=1</div><div class="line">runtime=100</div><div class="line">size=100G</div><div class="line">group_reporting</div><div class="line">ramp_time=6</div><div class="line">userspace_reap</div><div class="line">numjobs=1</div><div class="line">iodepth=128</div><div class="line">time_based</div><div class="line"></div><div class="line">[randwrite-4k]</div><div class="line">filename=/dev/rbd0</div><div class="line">bs=4k</div><div class="line">rw=randwrite</div><div class="line">rwmixwrite=20</div><div class="line">stonewall</div></pre></td></tr></table></figure>
<h2 id="fio测试filestore"><a href="#fio测试filestore" class="headerlink" title="fio测试filestore"></a>fio测试filestore</h2><p>TODO</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7上安装python3]]></title>
      <url>http://xiaqunfeng.cc/2017/07/07/centos7%E4%B8%8A%E5%AE%89%E8%A3%85python3/</url>
      <content type="html"><![CDATA[<p>之前一直使用python2，现在转python3，安装了一下，记录之。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>python所有版本的下载地址: <a href="https://www.python.org/ftp/python/" target="_blank" rel="external">https://www.python.org/ftp/python/</a></p>
<p>最新的已经到3.6.2版本了，不过还是RC，这里安装3.6.1<br>有两个文件可以选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Python-3.6.1.tar.xz</div><div class="line">Python-3.6.1.tgz</div></pre></td></tr></table></figure></p>
<p>两种都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz</div><div class="line">tar -zxvf Python-3.6.1.tar.xz</div><div class="line">cd Python-3.6.1</div><div class="line">./configure --prefix=/usr/local/python3</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>此时两个版本共存，默认是2.7.5版本，可以通过 <code>python3</code> 命令来使用Python 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># python --version</div><div class="line">Python 2.7.5</div></pre></td></tr></table></figure>
<h2 id="修改默认为python-3"><a href="#修改默认为python-3" class="headerlink" title="修改默认为python 3"></a>修改默认为python 3</h2><blockquote>
<p>不推荐这么做，直接使用命令 python3 来调用挺好的</p>
</blockquote>
<p>1、首先备份原先的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv /usr/bin/python /usr/bin/python.bak</div></pre></td></tr></table></figure></p>
<p>2、创建python3的软链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python</div></pre></td></tr></table></figure></p>
<p>此时python3为默认版本了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># python --version</div><div class="line">Python 3.6.1</div></pre></td></tr></table></figure>
<h3 id="yum-问题"><a href="#yum-问题" class="headerlink" title="yum 问题"></a>yum 问题</h3><p>yum使用Python 2，默认 <code>python</code> 替换Python 3后无法正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># yum</div><div class="line">  File &quot;/usr/bin/yum&quot;, line 30</div><div class="line">    except KeyboardInterrupt, e:</div><div class="line">                            ^</div><div class="line">SyntaxError: invalid syntax</div></pre></td></tr></table></figure>
<p>修改配置文件：<code>/usr/bin/yum</code></p>
<p>将默认的python替换为python2.7，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">替换为</div><div class="line">#!/usr/bin/python2.7</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XFS vs EXT4]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/XFS-vs-EXT4/</url>
      <content type="html"><![CDATA[<p>ceph默认的文件系统是XFS，centos7之前的版本默认文件系统是EXT4，现在是XFS，这里对比了一下，然后针对4k大小的随机读写进行了小小的测试。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux操作系统有很多不同的文件系统选择，所有现有的默认文件系统都是ext4。 通常文件系统被用来处理当程序不再使用信息之后如何保存信息，如何管理信息的可访问性，其他信息（元数据）与数据本身如何相关联等。</p>
<h2 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h2><p>Ext4是第四代扩展文件系统的缩写，它是2008年推出的。它是一个真正可靠的文件系统，它几乎在过去几年的大部分发行版中一直是默认选项，它是由比较老的代码生成的。它是一个日志文件系统，意味着它会对文件在磁盘中的位置以及任何其它对磁盘的更改做记录。如果系统崩溃，得益于journal技术，文件系统很少会损坏。</p>
<p>最大单个文件大小可以从16 GB到16 TB<br>最大文件系统大小为1EB（exabyte）<br>最大值包含64,000个子目录（ext3中的32,000个）</p>
<h2 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h2><p>XFS是由SGI为其IRIX平台设计的高性能64位日志文件系统。 XFS具有各种改进，使其能够在文件系统群体列表中脱颖而出，例如用于元数据操作的日志记录，可扩展/并行I / O，挂起/恢复I / O，在线碎片整理，延迟性能分配，等等</p>
<p>大概在2002年，XFS被合入Linux内核，2009年RHEL Linux版本5.4使用了XFS文件系统。 由于其高性能，架构可扩展性和鲁棒性，XFS一直是很多企业系统的首选，特别是拥有大量数据的企业系统。 现在，RHEL / CentOS 7和Oracle Linux使用XFS作为其默认文件系统。</p>
<p>最大单个文件大小可以是16 TB到16 Exabytes<br>最大文件系统大小为8EB（exabyte）<br>缺点：XFS文件系统不能缩小，当删除大量文件时会性能下降。</p>
<h2 id="更多对比"><a href="#更多对比" class="headerlink" title="更多对比"></a>更多对比</h2><ul>
<li>ext4不支持透明压缩、重复数据删除或者透明加密。技术上支持了快照，但该功能还处于实验性阶段。xfs也不能压缩，XFS 是基于B+ Ttree 管理元数据，即将支持reflink, dedupe等高级特性。</li>
<li>Ext4受限制于磁盘结构和兼容问题，可扩展性和scalability不如XFS。</li>
<li>虽然Ext4 目录索引采用了Hash Index Tree, 但是依然限制高度为2。</li>
<li>由于历史磁盘结构原因Ext4 的inode 个数限制(32位数)最多只能有大概40多亿文件。而且Ext4的单个文件大小最大只能支持到16T(4K block size) ，目前来说已经是瓶颈。XFS使用64位管理空间，文件系统规模可以达到EB级别。</li>
</ul>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>测试了一下4k随机读写的性能，direct=1，numjobs=20，iodepth=128</p>
<p>磁盘信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Disk /dev/sdc1: 4000.8 GB, 4000785104896 bytes, 7814033408 sectors</div><div class="line">Units = sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div></pre></td></tr></table></figure>
<p>测试数据</p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>4k-randread</th>
<th>4k-read</th>
<th>4k-randwrite</th>
<th>4k-write</th>
</tr>
</thead>
<tbody>
<tr>
<td>XFS</td>
<td>iops=426</td>
<td>iops=42773</td>
<td>iops=313</td>
<td>iops=24732</td>
</tr>
<tr>
<td>EXT4</td>
<td>iops=430</td>
<td>iops=41636</td>
<td>iops=315</td>
<td>iops=19095</td>
</tr>
</tbody>
</table>
<p>在4k这个量级上IOPS基本没啥区别，4k随机写XFS略好于EXT4。</p>
<p>性能方面的对比：<a href="http://www.cnblogs.com/tommyli/p/3201047.html" target="_blank" rel="external">ext3，ext4，xfs和btrfs文件系统性能对比</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext3/4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Create a file system</td>
<td>mkfs.ext4 or mkfs.ext3</td>
<td>mkfs.xfs</td>
</tr>
<tr>
<td>File system check</td>
<td>e2fsck</td>
<td>xfs_repair</td>
</tr>
<tr>
<td>Resizing a file system</td>
<td>resize2fs</td>
<td>xfs_growfs</td>
</tr>
<tr>
<td>Save an image of a file system</td>
<td>e2image</td>
<td>xfs_metadump and xfs_mdrestore</td>
</tr>
<tr>
<td>Label or tune a file system</td>
<td>tune2fs</td>
<td>xfs_admin</td>
</tr>
<tr>
<td>Backup a file system</td>
<td>dump and restore</td>
<td>xfsdump and xfsrestore</td>
</tr>
</tbody>
</table>
<h2 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quota</td>
<td>quota</td>
<td>xfs_quota</td>
</tr>
<tr>
<td>File mapping</td>
<td>filefrag</td>
<td>xfs_bmap</td>
</tr>
</tbody>
</table>
<p>文件系统之间更多的参数和功能的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems" target="_blank" rel="external">Comparison of file systems</a></p>
]]></content>
      
        
        <tags>
            
            <tag> filesystem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph luminous新命令探索]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/ceph-luminous%E6%96%B0%E5%91%BD%E4%BB%A4%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>在luminous版本中有好多新命令，来逐一探索一下。<br><a id="more"></a></p>
<h2 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h2><p>这个命令之前就说过了，这个来个对比吧。</p>
<p>luminous版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   10 pools, 192 pgs</div><div class="line">    objects: 251 objects, 10685 bytes</div><div class="line">    usage:   9156 MB used, 41538 MB / 50694 MB avail</div><div class="line">    pgs:     192 active+clean</div></pre></td></tr></table></figure></p>
<p>kraken版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;test0=172.20.2.235:6789/0,test1=172.20.2.236:6789/0,test2=172.20.2.237:6789/0&#125;</div><div class="line">            election epoch 8, quorum 0,1,2 test0,test1,test2</div><div class="line">        mgr active: test2 standbys: test1, test0</div><div class="line">     osdmap e28: 6 osds: 6 up, 6 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v11414: 320 pgs, 2 pools, 149 MB data, 68 objects</div><div class="line">            609 MB used, 30044 MB / 30653 MB avail</div><div class="line">                 320 active+clean</div></pre></td></tr></table></figure></p>
<h2 id="CEPH-OSD"><a href="#CEPH-OSD" class="headerlink" title="CEPH OSD"></a>CEPH OSD</h2><h3 id="ceph-osd-ls-tree"><a href="#ceph-osd-ls-tree" class="headerlink" title="ceph osd ls-tree"></a>ceph osd ls-tree</h3><p>功能：</p>
<p>将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd ls-tree &lt;name&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ceph osd ls-tree default</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd ls-tree default~ssd</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-add-rm-noout-noin-nodown-noup"><a href="#ceph-osd-add-rm-noout-noin-nodown-noup" class="headerlink" title="ceph osd {add, rm} - {noout, noin, nodown, noup}"></a>ceph osd {add, rm} - {noout, noin, nodown, noup}</h3><p>功能：</p>
<p>允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd &#123;add, rm&#125;-&#123;noout, noin, nodown, noup&#125; &lt;ids&gt; [&lt;ids&gt;...]</div></pre></td></tr></table></figure>
<p>意义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mark osd(s) &lt;id&gt; [&lt;id&gt;...] as &#123;noout, noin, nodown, noup&#125;, or use &lt;all|any|*&gt; to mark all osds as &#123;noout, noin, nodown, noup&#125;</div><div class="line">allow osd(s) &lt;id&gt; [&lt;id&gt;...] to be marked &#123;out, in, down, up&#125; (if they are currently marked as noout, noin, nodown, noup),can use &lt;all|any|*&gt; to automatically filter out all nodown osds</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd add-noout 1 4</div><div class="line"># ceph osd rm-noout 1 4</div><div class="line"># ceph osd add-noout all</div><div class="line"># ceph osd rm-noout any</div></pre></td></tr></table></figure>
<p>查看某一个osd的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># ceph osd dump 1</div><div class="line">epoch 1</div><div class="line">fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">created 2017-06-29 15:34:07.310885</div><div class="line">modified 2017-06-29 15:34:07.310885</div><div class="line">flags sortbitwise</div><div class="line">crush_version 1</div><div class="line">full_ratio 0.95</div><div class="line">backfillfull_ratio 0.9</div><div class="line">nearfull_ratio 0.85</div><div class="line">require_min_compat_client jewel</div><div class="line">min_compat_client jewel</div><div class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</div><div class="line">max_osd 0</div></pre></td></tr></table></figure>
<blockquote>
<p>这里其实并不会显示标记</p>
</blockquote>
<p><strong>原先的标记命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd &#123;set, unset&#125; &#123;noout, noin, nodown, noup&#125;</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-crush-swap-bucket"><a href="#ceph-osd-crush-swap-bucket" class="headerlink" title="ceph osd crush swap-bucket"></a>ceph osd crush swap-bucket</h3><p>功能：</p>
<p>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush swap-bucket &lt;source&gt; &lt;dest&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swap existing bucket contents from (orphan) bucket &lt;source&gt; and &lt;target&gt;</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-destroy"><a href="#ceph-osd-destroy" class="headerlink" title="ceph osd destroy"></a>ceph osd destroy</h3><p>功能：</p>
<p>将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。简单来说</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd destroy &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mark osd as being destroyed. Keeps the ID intact (allowing reuse), but removes cephx keys,config-key data and lockbox keys, rendering data permanently unreadable.</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ceph osd destroy 1</div><div class="line">Error EPERM: Are you SURE? This will mean real, permanent data loss, as well as cephx and lockbox keys. Pass --yes-i-really-mean-it if you really do.</div><div class="line"></div><div class="line"># ceph osd destroy 1 --yes-i-really-mean-it</div><div class="line">Error EBUSY: osd.1 is not `down`.</div><div class="line"></div><div class="line"># ceph osd down 1</div><div class="line">marked down osd.1.</div></pre></td></tr></table></figure>
<blockquote>
<p>这里有个奇怪的现象，执行 ceph osd down 发现osd 还是 up的状态，一直无果，最终还是停掉进程使其 down</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl stop ceph-osd@1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd destroy 1 --yes-i-really-mean-it</div><div class="line">destroyed osd.1</div></pre></td></tr></table></figure>
<p>此时，osd.1 还在集群中，只不过已经清理了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd stat</div><div class="line">6 osds: 5 up, 5 in</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line"> -1 0.05699 root default</div><div class="line"> -2 0.01900     host luminous0</div><div class="line">  1 0.00999         osd.1             down        0          1.00000</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-purge"><a href="#ceph-osd-purge" class="headerlink" title="ceph osd purge"></a>ceph osd purge</h3><p>功能：</p>
<p>将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd purge &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">purge all osd data from the monitors. Combines `osd destroy`, `osd rm`, and `osd crush rm`</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd purge 1 --yes-i-really-mean-it</div><div class="line">purged osd.1</div></pre></td></tr></table></figure>
<p>此时发现osd已经不再集群中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd stat</div><div class="line">5 osds: 5 up, 5 in</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">-1 0.04799 root default</div><div class="line"> -2 0.00999     host luminous0</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-rewightn"><a href="#ceph-osd-rewightn" class="headerlink" title="ceph osd rewightn"></a>ceph osd rewightn</h3><blockquote>
<p>该命令没试验成功！！</p>
</blockquote>
<p>功能：</p>
<p>在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code>命令。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd reweightn &lt;weights&gt;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div></pre></td></tr></table></figure>
<p>单个osd的rewight命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd reweight &lt;osdname (id|osd.id)&gt; &lt;float[0.0-1.0]&gt;</div><div class="line">explain: reweight osd to 0.0 &lt; &lt;weight&gt; &lt; 1.0</div></pre></td></tr></table></figure>
<p>我当前osd状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line"> -1 0.05699 root default</div><div class="line"> -2 0.01900     host luminous0</div><div class="line">  1 0.00999         osd.1               up  1.00000          1.00000</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph osd reweightn &#123;5:0.02, 4:0.03, 2:0.01&#125;</div><div class="line">Invalid command:  unused arguments: [u&apos;4:0.03,&apos;, u&apos;2:0.01&#125;&apos;]</div><div class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div><div class="line">Error EINVAL: invalid command</div><div class="line"></div><div class="line"># ceph osd reweightn 5:0.02</div><div class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;5:0.02&apos;</div><div class="line"></div><div class="line"># ceph osd reweightn &#123;5:0.02&#125;</div><div class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;&#123;5:0.02&#125;&apos;</div><div class="line"></div><div class="line"># ceph osd reweightn osd.5  0.02</div><div class="line">Invalid command:  unused arguments: [u&apos;0.02&apos;]</div><div class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div><div class="line">Error EINVAL: invalid command</div></pre></td></tr></table></figure>
<blockquote>
<p>该命令好像有问题，没有get到正确的姿势，有知道的请指正</p>
</blockquote>
<h2 id="ceph-log-last-n"><a href="#ceph-log-last-n" class="headerlink" title="ceph log last [n]"></a>ceph log last [n]</h2><p>输出集群日志的最后 n 行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph log last 10</div><div class="line">2017-06-30 17:13:14.216738 osd.3 osd.3 172.20.2.244:6804/38283 4 : cluster [INF] 0.d scrub ok</div><div class="line">2017-06-30 17:14:32.906853 osd.1 osd.1 172.20.2.243:6801/43997 5 : cluster [INF] 0.f scrub starts</div><div class="line">2017-06-30 17:14:32.908231 osd.1 osd.1 172.20.2.243:6801/43997 6 : cluster [INF] 0.f scrub ok</div><div class="line">2017-06-30 17:26:28.012607 osd.4 osd.4 172.20.2.245:6804/38814 5 : cluster [INF] 6.6 scrub starts</div><div class="line">2017-06-30 17:26:28.017546 osd.4 osd.4 172.20.2.245:6804/38814 6 : cluster [INF] 6.6 scrub ok</div><div class="line">2017-06-30 17:28:13.016525 osd.5 osd.5 172.20.2.243:6805/45058 3 : cluster [INF] 0.28 scrub starts</div><div class="line">2017-06-30 17:28:13.017914 osd.5 osd.5 172.20.2.243:6805/45058 4 : cluster [INF] 0.28 scrub ok</div><div class="line">2017-06-30 17:28:13.026468 osd.4 osd.4 172.20.2.245:6804/38814 7 : cluster [INF] 0.33 deep-scrub starts</div><div class="line">2017-06-30 17:28:13.027690 osd.4 osd.4 172.20.2.245:6804/38814 8 : cluster [INF] 0.33 deep-scrub ok</div><div class="line">2017-06-30 17:32:53.687436 mon.luminous0 mon.0 172.20.2.243:6789/0 357 : audit [INF] from=&apos;client.? 172.20.2.243:0/3812708038&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;log last&quot;, &quot;num&quot;: 5&#125;]: dispatch</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是显示集群的最近 n 条日志，不是某一个日志文件里的，比如 <code>/var/log/ceph/ceph.log</code> 等。</p>
</blockquote>
<p>这对调试比较有用，不用去打开日志查看了</p>
<h2 id="ceph-features"><a href="#ceph-features" class="headerlink" title="ceph features"></a>ceph features</h2><p>查询所有连接的守护进程和客户端的支持特性和版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># ceph features</div><div class="line">&#123;</div><div class="line">    &quot;mon&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 14</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;mds&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 1</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;osd&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 6</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;client&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 2</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ceph-mgr-dump"><a href="#ceph-mgr-dump" class="headerlink" title="ceph mgr dump"></a>ceph mgr dump</h2><p>dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ceph mgr dump</div><div class="line">&#123;</div><div class="line">    &quot;epoch&quot;: 15,</div><div class="line">    &quot;active_gid&quot;: 34310,</div><div class="line">    &quot;active_name&quot;: &quot;luminous0&quot;,</div><div class="line">    &quot;active_addr&quot;: &quot;172.20.2.243:6800/71321&quot;,</div><div class="line">    &quot;available&quot;: true,</div><div class="line">    &quot;standbys&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ceph-config-key"><a href="#ceph-config-key" class="headerlink" title="ceph config-key"></a>ceph config-key</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config-key del &lt;key&gt;						delete &lt;key&gt;</div><div class="line">config-key dump 							dump keys and values</div><div class="line">config-key exists &lt;key&gt;						check for &lt;key&gt;&apos;s existence</div><div class="line">config-key get &lt;key&gt; 						get &lt;key&gt;</div><div class="line">config-key list 							list keys</div><div class="line">config-key put &lt;key&gt; &#123;&lt;val&gt;&#125;				put &lt;key&gt;, value &lt;val&gt;</div><div class="line">config-key rm &lt;key&gt; 						rm &lt;key&gt;</div></pre></td></tr></table></figure>
<p>比如，dump出config-key entries及其内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph config-key dump</div><div class="line">&#123;</div><div class="line">    &quot;initial_mon_keyring&quot;: &quot;AQDfMxVZAAAAABAAA1za9TC3Z2kmEdlVZL6gGQ==&quot;,</div><div class="line">    &quot;mgr/dashboard/server_addr&quot;: &quot;172.20.2.243&quot;,</div><div class="line">    &quot;mgr/dashboard/server_port&quot;: &quot;7000&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>list，只dump出key，不包含value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph config-key list</div><div class="line">[</div><div class="line">    &quot;initial_mon_keyring&quot;,</div><div class="line">    &quot;mgr/dashboard/server_addr&quot;,</div><div class="line">    &quot;mgr/dashboard/server_port&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="ceph-mon-feature-list"><a href="#ceph-mon-feature-list" class="headerlink" title="ceph mon feature list"></a>ceph mon feature list</h2><p>列出MonMap中记录的monitor功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ceph mon feature list</div><div class="line">all features</div><div class="line">	supported: [kraken,luminous]</div><div class="line">	persistent: [kraken,luminous]</div><div class="line">on current monmap (epoch 1)</div><div class="line">	persistent: [kraken,luminous]</div><div class="line">	required: [kraken,luminous]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> luminous </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous新功能之crush class]]></title>
      <url>http://xiaqunfeng.cc/2017/07/04/ceph-Luminous%E6%96%B0%E5%8A%9F%E8%83%BD%E4%B9%8Bcrush-class/</url>
      <content type="html"><![CDATA[<p>cursh class为新增的管理设备类的功能，可以将特定一组设备指定为类，创建rule的时候直接指定class即可，以前也可以实现该功能，只不过需要编辑crushmap，手动添加class。该功能只需要命令行就可以实现。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集群情况和上一篇文章一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   7 pools, 112 pgs</div><div class="line">    objects: 240 objects, 3359 bytes</div><div class="line">    usage:   9245 MB used, 51587 MB / 60833 MB avail</div><div class="line">    pgs:     112 active+clean</div></pre></td></tr></table></figure>
<h2 id="关于之前的crush"><a href="#关于之前的crush" class="headerlink" title="关于之前的crush"></a>关于之前的crush</h2><h3 id="完全手动管理crush"><a href="#完全手动管理crush" class="headerlink" title="完全手动管理crush"></a>完全手动管理crush</h3><p>1、在 <code>ceph.conf</code> 配置中将挂钩关掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osd_crush_update_on_start = false</div></pre></td></tr></table></figure>
<p>2、部署OSD</p>
<p>3、手动创建所有的 CRUSH buckets</p>
<p>4、手动在每个 buckets 中放置 OSD</p>
<p>每当新加入、移除一个节点，或者将OSD从一个 host 移到另一个 host 时，也必须手动更改 CRUSH map。</p>
<h3 id="CEPH-CRUSH-LOCATION-挂钩"><a href="#CEPH-CRUSH-LOCATION-挂钩" class="headerlink" title="CEPH-CRUSH-LOCATION 挂钩"></a>CEPH-CRUSH-LOCATION 挂钩</h3><p>定义 osd_crush_location_hook，它可以让你定义一个路径去执行脚本，允许你自动处理以上过程。</p>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myhook --cluster &lt;cluster_name&gt; --id &lt;id&gt; --type osd</div></pre></td></tr></table></figure>
<p>集群名通常是 ceph ， id 是守护进程标识符（ OSD 号）。</p>
<h2 id="CRUSH-devices-class"><a href="#CRUSH-devices-class" class="headerlink" title="CRUSH devices class"></a>CRUSH devices class</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这么做的目的是为ceph不同类型的设备（HDD,SSD,NVMe）提供一个合理的默认，以便用户不必自己手动编辑指定。这相当于给磁盘组一个统一的class标签，根据class创建rule，然后根据role创建pool，整个操作不需要手动修改crushmap。</p>
<h3 id="创建两个-class"><a href="#创建两个-class" class="headerlink" title="创建两个 class"></a>创建两个 class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush class ls</div><div class="line">[]</div><div class="line"># ceph osd crush class create hdd</div><div class="line">created class hdd with id 0 to crush map</div><div class="line"># ceph osd crush class create ssd</div><div class="line">created class ssd with id 1 to crush map</div><div class="line"># ceph osd crush class ls</div><div class="line">[</div><div class="line">    &quot;hdd&quot;,</div><div class="line">    &quot;ssd&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>根据class，可以对osd进行以下两种操作：</p>
<p>1、部署OSD时指定 class，比如，指定部署磁盘所在的 OSD 到指定 class 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-disk prepare --crush-device-class &lt;class&gt; /dev/XXX</div></pre></td></tr></table></figure>
<p>2、将现有 osd 加入到指定 class 中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush set-device-class osd.&lt;id&gt; &lt;class&gt;</div></pre></td></tr></table></figure>
<p><strong> 以下对第二种操作进行实验，也是使用最多的。</strong></p>
<h3 id="当前OSD-分布"><a href="#当前OSD-分布" class="headerlink" title="当前OSD 分布"></a>当前OSD 分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME          UP/DOWN REWEIGHT PRIMARY-AFFINITY</div><div class="line">-1 0.05814 root default</div><div class="line">-2 0.01938     host luminous0</div><div class="line"> 1 0.00969         osd.1           up  1.00000          1.00000</div><div class="line"> 5 0.00969         osd.5           up  1.00000          1.00000</div><div class="line">-3 0.01938     host luminous2</div><div class="line"> 0 0.00969         osd.0           up  1.00000          1.00000</div><div class="line"> 4 0.00969         osd.4           up  1.00000          1.00000</div><div class="line">-4 0.01938     host luminous1</div><div class="line"> 2 0.00969         osd.2           up  1.00000          1.00000</div><div class="line"> 3 0.00969         osd.3           up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="为class添加osd"><a href="#为class添加osd" class="headerlink" title="为class添加osd"></a>为class添加osd</h3><p>将0、1、2分到hdd class，3、4、5分到ssd class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># for i in 0 1 2; do ceph osd crush set-device-class osd.$i hdd; done</div><div class="line">set-device-class item id 3 name &apos;osd.0&apos; device_class hdd</div><div class="line">set-device-class item id 4 name &apos;osd.1&apos; device_class hdd</div><div class="line">set-device-class item id 5 name &apos;osd.2&apos; device_class hdd</div><div class="line"># for i in 3 4 5; do ceph osd crush set-device-class osd.$i ssd; done</div><div class="line">set-device-class item id 3 name &apos;osd.3&apos; device_class ssd</div><div class="line">set-device-class item id 4 name &apos;osd.4&apos; device_class ssd</div><div class="line">set-device-class item id 5 name &apos;osd.5&apos; device_class ssd</div></pre></td></tr></table></figure>
<h3 id="再查看osd分布"><a href="#再查看osd分布" class="headerlink" title="再查看osd分布"></a>再查看osd分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID  WEIGHT  TYPE NAME              UP/DOWN REWEIGHT PRIMARY-AFFINITY</div><div class="line">-12 0.02907 root default~ssd</div><div class="line"> -9 0.00969     host luminous0~ssd</div><div class="line">  5 0.00969         osd.5               up  1.00000          1.00000</div><div class="line">-10 0.00969     host luminous2~ssd</div><div class="line">  4 0.00969         osd.4               up  1.00000          1.00000</div><div class="line">-11 0.00969     host luminous1~ssd</div><div class="line">  3 0.00969         osd.3               up  1.00000          1.00000</div><div class="line"> -8 0.02907 root default~hdd</div><div class="line"> -5 0.00969     host luminous0~hdd</div><div class="line">  1 0.00969         osd.1               up  1.00000          1.00000</div><div class="line"> -6 0.00969     host luminous2~hdd</div><div class="line">  0 0.00969         osd.0               up  1.00000          1.00000</div><div class="line"> -7 0.00969     host luminous1~hdd</div><div class="line">  2 0.00969         osd.2               up  1.00000          1.00000</div><div class="line"> -1 0.05814 root default</div><div class="line"> -2 0.01938     host luminous0</div><div class="line">  1 0.00969         osd.1               up  1.00000          1.00000</div><div class="line">  5 0.00969         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01938     host luminous2</div><div class="line">  0 0.00969         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00969         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01938     host luminous1</div><div class="line">  2 0.00969         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00969         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="创建rule"><a href="#创建rule" class="headerlink" title="创建rule"></a>创建rule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule create-simple hdd-rule default~ssd host firstn</div><div class="line">Invalid command:  invalid chars ~ in default~ssd</div><div class="line">osd crush rule create-simple &lt;name&gt; &lt;root&gt; &lt;type&gt; &#123;firstn|indep&#125; :  create crush rule &lt;name&gt; to start from &lt;root&gt;, replicate across buckets of type &lt;type&gt;, using a choose mode of &lt;firstn|indep&gt; (default firstn; indep best for erasure pools)</div><div class="line">Error EINVAL: invalid command</div></pre></td></tr></table></figure>
<p>这里出现错误，我在想，是不是 class name 不用带上 <code>default~</code> 这个符号，于是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule create-simple hdd-rule ssd host firstn</div><div class="line">Error ENOENT: root item ssd does not exist</div></pre></td></tr></table></figure>
<p>依然出错，这是个<a href="http://tracker.ceph.com/issues/20446" target="_blank" rel="external">bug</a>，还在 <a href="https://github.com/ceph/ceph/pull/16027" target="_blank" rel="external">merge 中</a></p>
<blockquote>
<p>先跳过这个直接创建rule关联class的命令，后续BUG修复了再来实验</p>
</blockquote>
<h3 id="手动来创建rule"><a href="#手动来创建rule" class="headerlink" title="手动来创建rule"></a>手动来创建rule</h3><p>首先查看当前rule的状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule ls</div><div class="line">[</div><div class="line">    &quot;replicated_rule&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>只有一个默认的rule</p>
<p><strong> 第一步：获取crushmap </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd getcrushmap -o c1</div><div class="line">11</div></pre></td></tr></table></figure>
<p><strong>第二步：反编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># crushtool -d c1 -o c2.txt</div></pre></td></tr></table></figure>
<p>编辑crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim c2.txt</div></pre></td></tr></table></figure>
<p>在 <code># rule</code> 那一栏 <code>replicated_rule</code> 的后面添加 <code>hdd_rule</code> 和 <code>ssd_rule</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># rules</div><div class="line">rule replicated_rule &#123;</div><div class="line">        ruleset 0</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default</div><div class="line">        step chooseleaf firstn 0 type host</div><div class="line">        step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line">rule hdd_rule &#123;</div><div class="line">        ruleset 1</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default class hdd</div><div class="line">        step chooseleaf firstn 0 type osd</div><div class="line">        step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line">rule ssd_rule &#123;</div><div class="line">        ruleset 2</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default class ssd</div><div class="line">        step chooseleaf firstn 0 type osd</div><div class="line">        step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>第三步：编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># crushtool -c c2.txt -o c1.new</div></pre></td></tr></table></figure>
<p><strong>第四步：注入crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd setcrushmap -i c1.new</div><div class="line">12</div></pre></td></tr></table></figure>
<p>此时，查看rule</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule ls</div><div class="line">[</div><div class="line">    &quot;replicated_rule&quot;,</div><div class="line">    &quot;hdd_rule&quot;,</div><div class="line">    &quot;ssd_rule&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>有了新创建的两个rule</p>
<h2 id="测试一下，rule-绑定-class是否成功"><a href="#测试一下，rule-绑定-class是否成功" class="headerlink" title="测试一下，rule 绑定 class是否成功"></a>测试一下，rule 绑定 class是否成功</h2><p>1、在 ssd_rule 上创建一个 pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool create testpool 64 64 ssd_rule</div><div class="line">pool &apos;testpool&apos; created</div></pre></td></tr></table></figure>
<p>2、写一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rados -p testpool put object1 c2.txt</div></pre></td></tr></table></figure>
<p>3、查看对象的osdmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map testpool object1</div><div class="line">osdmap e46 pool &apos;testpool&apos; (7) object &apos;object1&apos; -&gt; pg 7.bac5debc (7.3c) -&gt; up ([5,3,4], p5) acting ([5,3,4], p5)</div></pre></td></tr></table></figure>
<p>发现对象确实只写在 ssd class 所对应的 3个OSD（osd.3 osd.4 osd.5）上，rule绑定成功。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> luminous </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous dashboard初探]]></title>
      <url>http://xiaqunfeng.cc/2017/06/29/ceph-Luminous%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>体验ceph luminous，并初步探测ceph luminous的相关功能，这里先来看看官方标配的仪表盘长啥样。<br><a id="more"></a></p>
<p>就冲这句话：Ceph now has a simple, built-in web-based dashboard for monitoring<br>cluster status，来一探究竟。</p>
<h2 id="Luminous集群"><a href="#Luminous集群" class="headerlink" title="Luminous集群"></a>Luminous集群</h2><p><strong>物理环境</strong></p>
<p>3个 host ，每个 host 含有 2 个OSD</p>
<p><strong>查看ceph版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph -v</div><div class="line">ceph version 12.1.0 (262617c9f16c55e863693258061c5b25dea5b086) luminous (dev)</div></pre></td></tr></table></figure>
<h3 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h3><p>查看集群状态，这里发现 <code>ceph -s</code> 信息和之前的不一样。（更多新的命令后续探索后奉上）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   7 pools, 112 pgs</div><div class="line">    objects: 208 objects, 3359 bytes</div><div class="line">    usage:   6341 MB used, 54492 MB / 60833 MB avail</div><div class="line">    pgs:     112 active+clean</div></pre></td></tr></table></figure>
<p>这里我在机器 luminous0 上还部署了 mgr 和 mds。</p>
<blockquote>
<p>注意：mgr是高可用的，如果配置多个的话，会有standbys。我这里只配了一个 mgr，所以就只有active，没有standby。访问的时候，务必使用 active 进程所在节点的 IP ！！</p>
</blockquote>
<h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><h3 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h3><p>在所有运行了 ceph-mgr 守护进程的机器上编辑ceph配置文件 <code>/etc/ceph/ceph.conf</code> ，以启用 dashboard。</p>
<p>添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mgr]</div><div class="line">mgr_modules = dashboard</div></pre></td></tr></table></figure>
<p>注意：不要重启 ceph-mgr 进程，还有其他的配置要做。</p>
<h3 id="配置IP和端口"><a href="#配置IP和端口" class="headerlink" title="配置IP和端口"></a>配置IP和端口</h3><p>服务器地址和可选端口必须配置为 config-key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph config-key put mgr/dashboard/server_addr 172.20.2.243</div><div class="line">set mgr/dashboard/server_addr</div></pre></td></tr></table></figure>
<p>查看，发现<strong>默认端口是 7000</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># netstat -antpl | grep ceph-mgr | grep LISTEN</div><div class="line">tcp        0      0 0.0.0.0:6800            0.0.0.0:*               LISTEN      57645/ceph-mgr</div><div class="line">tcp        0      0 172.20.2.243:7000       0.0.0.0:*               LISTEN      57645/ceph-mgr</div></pre></td></tr></table></figure>
<p>当然，可以改为指定端口号，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph config-key put mgr/dashboard/server_port 8888</div></pre></td></tr></table></figure>
<h3 id="重启ceph-mgr"><a href="#重启ceph-mgr" class="headerlink" title="重启ceph-mgr"></a>重启ceph-mgr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl restart ceph-mgr@luminous0</div></pre></td></tr></table></figure>
<p>这时候就可以访问了。</p>
<h3 id="访问界面"><a href="#访问界面" class="headerlink" title="访问界面"></a>访问界面</h3><p><strong>1、主界面</strong>（Cluster health）</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-0.jpg" alt="dashboard"></p>
<p><strong>2、Servers界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-2.jpg" alt="servers"></p>
<p><strong>3、cephfs界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-1.jpg" alt="ceph-fs"></p>
<h2 id="使用后感想"><a href="#使用后感想" class="headerlink" title="使用后感想"></a>使用后感想</h2><p>1、这仅仅只是一个展示的界面，不能进行相关操作</p>
<p>2、关于 MONITORS 和 OSDS 的信息不能详细展开，更不能看到每台机器的情况</p>
<p>3、比起ceph周边的监控软件：calamari、VSM、inkscope、grafana等，相去甚远，当然，可以简单展示基本信息，还是不错的。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> luminous </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph v12.1.0 Luminous RC released]]></title>
      <url>http://xiaqunfeng.cc/2017/06/28/Ceph-v12-1-0-Luminous-RC-released/</url>
      <content type="html"><![CDATA[<p>ceph L 版本终于出了一个候选release版本。来看看都有哪些新功能吧。<br><a id="more"></a></p>
<p>本文翻译自官网：<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/" target="_blank" rel="external">v12.1.0 Luminous RC released</a></p>
<p>Github：<a href="https://github.com/ceph/ceph/tree/luminous" target="_blank" rel="external">https://github.com/ceph/ceph/tree/luminous</a></p>
<h2 id="v12-1-0-Luminous-RC-released"><a href="#v12-1-0-Luminous-RC-released" class="headerlink" title="v12.1.0 Luminous RC released"></a>v12.1.0 Luminous RC released</h2><p>这是Luminous的第一个候选版本，下一个长期的稳定release。</p>
<p>Ceph Luminous将是下一个长期的稳定release系列的基础。 自Kraken（v11.2.z）和jewel（v10.2.z）以来，发生了重大的变化。</p>
<h2 id="Major-Changes-from-Kraken"><a href="#Major-Changes-from-Kraken" class="headerlink" title="Major Changes from Kraken"></a>Major Changes from Kraken</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>Ceph目前拥有一个简单的、内置的基于Web的仪表板，用于监控群集状态。</p>
<h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><p><strong>BlueStore</strong></p>
<ul>
<li>ceph-osd的新后端存储BlueStore已经稳定，并且是新建OSD的默认设置。 BlueStore通过直接管理物理磁盘（HDD或SSD）而不使用XFS之类的中间文件系统来管理存储在每个OSD上的数据，这提供了更好的性能和特性。</li>
<li>BlueStore对于通过ceph存储的数据支持完整数据和元数据校验。</li>
<li>BlueStore支持zlib、snappy或LZ4的在线压缩。（Ceph还支持zstd进行RGW压缩，但由于性能原因，不推荐BlueStore使用zstd）。<br>EC pools现在完全支持覆盖写，允许它们与RBD和CephFS一起使用。<a href="http://ceph.com/releases/rados/operations/erasure-code/#erasure-coding-with-overwrites" target="_blank" rel="external">Read more about EC overwrites**</a></li>
</ul>
<p><strong>ceph-mgr</strong></p>
<ul>
<li>ceph-mgr是一个新的进程，它是任何Ceph部署所必须的一部分。虽然当ceph-mgr停止时，可以继续下发IO，但是度量不会刷新，并且某些与度量相关的请求（如：ceph df）可能会阻塞。为了可靠性，我们建议部署ceph-mgr的多个实例。查看这里的注释<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/#id1" target="_blank" rel="external"><code>Upgrading</code>_</a> </li>
<li>ceph-mgr进程包括一个基于REST的管理API。 API仍然处于实验阶段，并有一定的限制，但未来将成为Ceph基于API管理的基础。</li>
</ul>
<p>集群的总体可扩展性有所提高。我们已经成功测试了多达10,000个OSD节点的集群。</p>
<ul>
<li>目前，每个OSD都具有与其相关联的设备类（例如，hdd或ssd），允许CRUSH规则将数据简单地映射到系统中的设备的子集。通常不需要手动编写CRUSH规则或手动编辑CRUSH。</li>
<li>现在可以优化CRUSH权重，以保持OSD之间数据的近乎完美的分布。</li>
<li>还有一个新的upmap异常处理机制，允许单个PG移动以实现完美的分布（这需要luminous的客户端）。</li>
<li>目前每个OSD可以根据后端设备是HDD还是SSD来调整其默认配置。一般不需要手动调整。</li>
<li>mclock QoS排队算法原型现在是可用的；</li>
<li>现在有一种 backoff 机制，可以防止OSD出现对当前不能处理IO的对象或PG的请求出现过载。</li>
<li>简化了OSD更换过程，并且更加鲁棒。</li>
<li>您可以使用 <code>ceph features</code> 来查询所有连接的守护进程和客户端的支持特性和版本。</li>
<li>您可以配置你想要最旧的Ceph客户端版本，并通过 <code>ceph osd set-require-min-compat-client</code> 命令连接到集群，Ceph将阻止您启用会破坏与这些客户端兼容性的特性。</li>
<li>一些 <code>sleep</code> 的设置，包括 <code>osd_recovery_sleep</code>，<code>osd_snap_trim_sleep</code> 和 <code>osd_scrub_sleep</code> 已经被重新实现，并且可以有效地工作。（这些在某些情况下用于解决问题，限制后台工作。）</li>
</ul>
<p><strong>RGW:</strong></p>
<ul>
<li>ElasticSearch支持的RGW元数据搜索现在通过RGW本身支持最终用户请求服务，并且还支持自定义元数据字段。查询语言是一组RESTful API，用户可以通过其元数据来搜索对象。还添加了允许自定义元数据字段控制的新API。</li>
<li>RGW支持动态存储桶索引分片（bucket index sharding）。随着桶中的对象数量的增加，RGW将自动重新构建桶索引。不需要用户干预或桶大小容量规划。</li>
<li>RGW引入了上传对象的服务器端加密，用于管理加密密钥的三个选项有：自动加密（仅推荐用于测试设置），客户提供的类似于Amazon SSE-C规范的密钥，以及通过使用外部密钥管理服务 （OpenstackBarbician）类似于Amazon SSE-KMS规范。</li>
<li>RGW具有初步的类似AWS的存储桶策略API支持。现在，策略是一种表达一系列新授权概念的方式。未来，这将成为附加身份验证功能的基础，例如STS和组策略等。</li>
<li>RGW通过使用rados命名空间合并了几个元数据索引池。</li>
</ul>
<p><strong>RBD:</strong></p>
<ul>
<li>RBD目前通过<code>rbd create</code>新的<code>--data-pool</code>选项，对EC pools有全面稳定的支持。</li>
<li>RBD镜像的rbd-mirror守护进程现在是高可用的。我们建议部署rbd-mirror的多个实例来实现可靠性。</li>
<li>在创建集群期间，不再自动创建默认的 <code>rbd</code> 存储池。另外，当没有指定池时，rbd CLI 使用的默认池的名称可以通过新的 <code>rbd default pool = &lt;pool name&gt;</code> 配置选项来覆盖。</li>
<li>通过新的 <code>rbd trash</code>  CLI命令初步支持延迟 image 删除。images，即使是由克隆主动使用的镜像，也可以移动到垃圾桶，并在以后删除。</li>
<li>新的管理池级别的命令 <code>rbd mirror pool promote</code> 和 <code>rbd mirror pool demote</code>可以批量提升/降级一个pool内所有的mirrored images。</li>
<li>mirroring 现在可以通过 <code>rbd mirroring replay delay = &lt;seconds&gt;</code> 配置选项支持可选择的配置复制延迟。</li>
<li>当对象map 特性启用时，可以提升丢弃处理功能。</li>
<li>rbd CLI <code>import</code> 和 <code>copy</code> 命令现在可以检测稀疏并保留稀疏区域。</li>
<li>snapshots现在将包含创建时间戳。</li>
</ul>
<p><strong>CephFS:</strong></p>
<ul>
<li>现在，多个活动的MDS守护进程是稳定的。活动的MDS服务器的数量可以基于活动的CephFS文件系统进行上下调整。</li>
<li>CephFS目录分片现在是稳定的，并且在新的文件系统上默认启用。要使其在现有的文件系统上启动，使用命令 <code>ceph fs set&lt;fs_name&gt; allow_dirfrags</code>。大的或非常繁忙的目录被分割并（可能）自动分布在多个MDS守护进程中。</li>
<li>在自动负载均衡不需要和无效的情况下，目录子树可以明确固定到特定的MDS守护进程。</li>
</ul>
<p><strong>Miscellaneous:</strong> </p>
<p>Debian Stretch现在正在构建版本包。我们现在构建的发行版包括： </p>
<ul>
<li>CentOS 7 (x86_64and aarch64)</li>
<li>Debian 8 Jessie(x86_64)</li>
<li>Debian 9 Stretch(x86_64)</li>
<li>Ubuntu 16.04 Xenial(x86_64 and aarch64)</li>
<li>Ubuntu 14.04Trusty (x86_64)</li>
</ul>
<p>注意 QA 仅限于 CentOS 和 Ubuntu (xenialand trusty).</p>
<p><strong>CLI 变化</strong></p>
<ul>
<li><code>ceph -s</code> 或者 <code>ceph status</code> 命令焕然一新。</li>
<li><code>ceph {osd，mds，mon} versions</code> 总结了运行中守护进程的版本。</li>
<li><code>ceph {osd，mds，mon} count-metadata &lt;property&gt;</code> 类似地列出通过 <code>ceph {osd，mds，mon} metadata</code> 命令可见的任何其他守护进程元数据。</li>
<li><code>ceph features</code> 总结了连接的客户端和守护进程的特性和版本。</li>
<li><code>ceph osd require-osd-release &lt;release&gt;</code> 替换旧的<code>require_RELEASE_osds</code> flags。</li>
<li><code>ceph osd pg-upmap</code>，<code>ceph osdrm-pg-upmap</code>，<code>ceph osd pg-upmap-items</code>，<code>ceph osdrm-pg-upmap-items</code>可以明确地管理upmap项目。</li>
<li><code>ceph osd getcrushmap</code>在stderr上返回一个crush map版本号，如果版本匹配，<code>ceph osd setcrushmap [version]</code> 将只会注入更新的crush map。这允许crush map进行离线更新，然后重新注入到群集中，而不用担心颠覆性的变化（例如，通过其他管理员新添加和修改osds）。</li>
<li><code>ceph osd create</code> 已被 <code>ceph osd new</code> 所替换。大多数用户应该使用像 <code>ceph-disk</code> 这样面向用户的工具来隐藏这个。</li>
<li><code>ceph osd destroy</code> 将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。</li>
<li><code>ceph osd purge</code> 将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</li>
<li><code>ceph osd ls-tree &lt;name&gt;</code> 将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。例如，<code>ceph osd down</code> ，<code>ceph osd ls-tree rack1</code>。</li>
<li><code>ceph osd {add，rm} - {noout，noin，nodown，noup}</code> 允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</li>
<li><code>ceph log last [n]</code> 将输出集群日志的最后n行。</li>
<li><code>ceph mgr dump</code> 将dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程。</li>
<li><code>ceph osd crush swap-bucket &lt;src&gt; &lt;dest&gt;</code>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</li>
<li><code>ceph osd set-require-min-compat-client &lt;release&gt;</code> 可以配置支持群集的最旧的客户端版本。其他更改，如CRUSH可调参数，如果违反此设置，将会失败并显示错误。如果当前连接到集群的客户端版本比指定版本还老旧，则更改此设置也将失败。</li>
<li><code>ceph config-key dump</code> dump出config-key entries及其内容。（已有的 <code>ceph config-key ls</code> 仅dump密钥名称，而不是值。）</li>
<li><code>ceph osd set-{full，nearfull，backfillfull}-ratio</code> 将集群范围的比例设置为各种全阈值（例如：当集群拒绝IO时，当集群警告接近满时，当OSD延迟PG重新平衡到本身时）。</li>
<li><code>ceph osd reweightn</code> 将在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code> 命令。</li>
<li><code>ceph crush class {create,rm,ls}</code> 管理新的CRUSH设备类功能。 <code>ceph crush set-device-class &lt;osd&gt; &lt;class&gt;</code> 将为特定设备设置class。</li>
<li><code>ceph mon feature list</code> 将列出MonMap中记录的monitor功能。<code>ceph mon feature set</code> 将设置一个可选功能（这些功能尚未存在）。</li>
</ul>
<h2 id="Major-Changes-from-Jewel"><a href="#Major-Changes-from-Jewel" class="headerlink" title="Major Changes from Jewel"></a>Major Changes from Jewel</h2><p><strong>RADOS</strong></p>
<ul>
<li>我们现在默认使用AsyncMessenger（ms type = async），而不是传统的SimpleMessenger。 最明显的区别是，我们现在使用固定大小的线程池进行网络连接（而不是使用SimpleMessenger每个socket两个线程）。</li>
<li>现在几乎可以马上检测到一些OSD故障，而之前的心跳超时（默认为20秒）必须过期。 当host保持up状态，但ceph-osd进程不再运行的故障出现时，可以防止IO长时间阻塞。</li>
<li>编码OSDMaps的大小已经减少了。</li>
<li>当recovery或rebalancing进行时，OSD现在会静止scrubbing。</li>
</ul>
<p><strong>RGW</strong></p>
<ul>
<li>RGW现在支持 S3 多部分对象部分复制（multipart object copy-part）API。</li>
<li>现在离线resharding一个现有的bucket是可能的。离线resharding bucket当前需要所有到这个指定bucket的IO（特别是writes）是静止的。（为了自动在线resharding，看上面Luminous的新特性）</li>
<li>RGW现在支持对对象的数据压缩。</li>
<li>Civetweb版本已经更新到1.8。</li>
<li>支持Swift静态网站API（之前的版本就已经支持S3）</li>
<li>S3 bucket生命周期 API 已添加。注意当前只支持对象到期。</li>
<li>支持用户自定义搜索过滤器已添加到 LDAP 认证实现中。</li>
<li>对NFS版本3的支持已添加到RGW NFS网关</li>
<li>已经为librgw创建了一个Python绑定</li>
</ul>
<p><strong>RBD</strong></p>
<ul>
<li>rbd-mirror守护进程现在支持从主image到非主image复制动态image特征更新和image元数据密钥/值对。</li>
<li>Image快照的数量可以可选地限制在可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<p><strong>CephFS</strong></p>
<ul>
<li>libcephfs函数定义已更改，以启用适当的uid / gid控件。library版本已经增加，以反映界面的变化。</li>
<li>standby replay MDS守护程序现在在执行删除的工作负载上消耗更少的内存。</li>
<li>Scrub 现在修复回溯，通常使用 <code>damage ls</code> 发现错误。</li>
<li>新 <code>pg_files</code> 子命令<code>cephfs-data-scan</code>可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性警告 <code>failing to respond to cache pressure</code> 已被修复。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> luminous </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wget批量下载http目录及文件]]></title>
      <url>http://xiaqunfeng.cc/2017/06/23/wget%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDhttp%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>有时候看到好的镜像，想保存下来，不可能一个个通过url手动来下载，这时候就需要批量下载了。<br><a id="more"></a></p>
<p>举个例子，我要下载的地址和内容如下：<br><img src="http://oow6unnib.bkt.clouddn.com/wget-http.jpg" alt="wget-http"></p>
<h2 id="得到页面的index-html"><a href="#得到页面的index-html" class="headerlink" title="得到页面的index.html"></a>得到页面的index.html</h2><p>我就在 <code>/root</code> 目录下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -m http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/</div></pre></td></tr></table></figure>
<p>得到<code>index.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># cat /root/mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/index.html</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;&lt;title&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/title&gt;&lt;/head&gt;</div><div class="line">&lt;body bgcolor=&quot;white&quot;&gt;</div><div class="line">&lt;h1&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a href=&quot;../&quot;&gt;../&lt;/a&gt;</div><div class="line">&lt;a href=&quot;repodata/&quot;&gt;repodata/&lt;/a&gt;                                          11-Apr-2017 03:06       -</div><div class="line">&lt;a href=&quot;ceph-10.1.0-0.el7.src.rpm&quot;&gt;ceph-10.1.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</div><div class="line">&lt;a href=&quot;ceph-10.1.1-0.el7.src.rpm&quot;&gt;ceph-10.1.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.1.2-0.el7.src.rpm&quot;&gt;ceph-10.1.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.0-0.el7.src.rpm&quot;&gt;ceph-10.2.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.1-0.el7.src.rpm&quot;&gt;ceph-10.2.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.2-0.el7.src.rpm&quot;&gt;ceph-10.2.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</div><div class="line">&lt;a href=&quot;ceph-10.2.3-0.el7.src.rpm&quot;&gt;ceph-10.2.3-0.el7.src.rpm&lt;/a&gt;                          17-Oct-2016 20:29      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.4-0.el7.src.rpm&quot;&gt;ceph-10.2.4-0.el7.src.rpm&lt;/a&gt;                          07-Dec-2016 05:39     10M</div><div class="line">&lt;a href=&quot;ceph-10.2.5-0.el7.src.rpm&quot;&gt;ceph-10.2.5-0.el7.src.rpm&lt;/a&gt;                          05-Jan-2017 02:49     10M</div><div class="line">&lt;a href=&quot;ceph-10.2.6-0.el7.src.rpm&quot;&gt;ceph-10.2.6-0.el7.src.rpm&lt;/a&gt;                          08-Mar-2017 21:55     11M</div><div class="line">&lt;a href=&quot;ceph-10.2.7-0.el7.src.rpm&quot;&gt;ceph-10.2.7-0.el7.src.rpm&lt;/a&gt;                          11-Apr-2017 02:53     11M</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.29-0.src.rpm&quot;&gt;ceph-deploy-1.5.29-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.30-0.src.rpm&quot;&gt;ceph-deploy-1.5.30-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.31-0.src.rpm&quot;&gt;ceph-deploy-1.5.31-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.32-0.src.rpm&quot;&gt;ceph-deploy-1.5.32-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.33-0.src.rpm&quot;&gt;ceph-deploy-1.5.33-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.34-0.src.rpm&quot;&gt;ceph-deploy-1.5.34-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     94K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.35-0.src.rpm&quot;&gt;ceph-deploy-1.5.35-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.36-0.src.rpm&quot;&gt;ceph-deploy-1.5.36-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.37-0.src.rpm&quot;&gt;ceph-deploy-1.5.37-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-release-1-1.el7.src.rpm&quot;&gt;ceph-release-1-1.el7.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53    4186</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.5-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.5-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.6-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.6-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.7-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.7-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h2><p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -nc -B http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/ -F -nH --cut-dirs=3 -i index.html</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nc</td>
<td>下载时跳过已经存在的文件</td>
</tr>
<tr>
<td>-B</td>
<td>使用 -F -i 文件选项时，在相对链接前添加指定的 URL</td>
</tr>
<tr>
<td>-nH</td>
<td>不创建主机名目录</td>
</tr>
<tr>
<td>-i</td>
<td>下载从指定文件中找到的 URL</td>
</tr>
<tr>
<td>-v</td>
<td>显示信息</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
<tr>
<td>-l</td>
<td>最大递归深度(inf 或 0 表示无限)</td>
</tr>
<tr>
<td>-F</td>
<td>以 HTML 方式处理输入文件</td>
</tr>
<tr>
<td>–cut-dir=num</td>
<td>忽略远程目录中指定数目的目录层</td>
</tr>
<tr>
<td>-E</td>
<td>将所有 MIME 类型为 text/html 的文件都加上 .html 扩展文件名</td>
</tr>
</tbody>
</table>
<p>更多关于参数的问题详见：<a href="http://jiaxl.blog.51cto.com/3064605/1191196" target="_blank" rel="external">wget参数介绍</a></p>
<p>然后就开始下载，直至完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">FINISHED --2017-06-23 18:11:54--</div><div class="line">Total wall clock time: 7m 31s</div><div class="line">Downloaded: 24 files, 103M in 7m 29s (234 KB/s)</div></pre></td></tr></table></figure></p>
<p>下载完成后列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># ll</div><div class="line">总用量 105264</div><div class="line">-rw-r--r--. 1 root root  8894228 6月  15 2016 ceph-10.1.0-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8942739 6月  15 2016 ceph-10.1.1-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8961123 6月  15 2016 ceph-10.1.2-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8967492 6月  15 2016 ceph-10.2.0-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8996472 6月  15 2016 ceph-10.2.1-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8876099 6月  15 2016 ceph-10.2.2-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  9044336 10月 17 2016 ceph-10.2.3-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 10849625 12月  7 2016 ceph-10.2.4-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 10795514 1月   5 02:49 ceph-10.2.5-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 11215646 3月   8 21:55 ceph-10.2.6-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 11245006 4月  11 02:53 ceph-10.2.7-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92710 4月  11 02:53 ceph-deploy-1.5.29-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92915 4月  11 02:53 ceph-deploy-1.5.30-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92953 4月  11 02:53 ceph-deploy-1.5.31-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    93493 4月  11 02:53 ceph-deploy-1.5.32-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    93323 4月  11 02:53 ceph-deploy-1.5.33-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    96664 4月  11 02:53 ceph-deploy-1.5.34-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    97010 4月  11 02:53 ceph-deploy-1.5.35-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    96998 4月  11 02:53 ceph-deploy-1.5.36-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    97146 4月  11 02:53 ceph-deploy-1.5.37-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root     4186 4月  11 02:53 ceph-release-1-1.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root     3189 6月  23 18:01 index.html</div><div class="line">-rw-r--r--. 1 root root    30175 4月  11 02:53 radosgw-agent-1.2.5-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    29980 4月  11 02:53 radosgw-agent-1.2.6-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    30044 4月  11 02:53 radosgw-agent-1.2.7-0.el7.src.rpm</div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[公有云和私有云的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/%E5%85%AC%E6%9C%89%E4%BA%91%E5%92%8C%E7%A7%81%E6%9C%89%E4%BA%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>介绍了一下公有云和私有云的区别，以及该如何选择。<br><a id="more"></a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/public-private-cloud.jpg" alt="public-private-cloud"></p>
<h2 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h2><p>这是一个可以存在于公司的托管数据中心的云主机解决方案，所有信息都在专用防火墙后面。一般来说，公司已经选择为其数据中心付出了相当大的代价，并仍然希望使用其已建立的基础设施。这是一个主要的优势，也是私有云与公共云的辩论在这个特定主题上如此激烈的一个重要原因。</p>
<p>然而，私有云的一个重大问题是维护、更新和整体管理数据中心所需的资源属于公司本身。这是在选择私有云时通常不能正确计算的费用。维护包括：一旦旧的服务器被不堪重负或过期，必须购买新的服务器，并通过公司本身来整合最新的技术。</p>
<p>当然，由于私有云的资源基本上与系统外的任何人都不共享，因此维护安全性要容易得多，这可能是选择公有云与私有云时的决定因素。</p>
<h2 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h2><p>公有云是在其网站上托管大量企业、个人和组织的公共云。公有云管理系统提供的最大优势是，企业或组织无需负责，由主办公司接管。你的所有数据都由提供商存储在他们的数据中心，并负责管理和更新。</p>
<p>这样做的优势是相当大的，因为这显著的降低了存储信息的成本。这对于没有广泛且已到位的基础设施的公司也是有利的。此外，降低了测试和推出新产品的交付时间。</p>
<p>然而，与私有云系统相比最大的缺点是缺乏安全性。这就是为什么许多企业正在讨论对公有、私有云计算的倾向，即使意味着更大的费用，也会倾向于安全。虽然公共云系统确实具有广泛的安全性，事实上，由于增加的公司数量是相当大的担忧，所以系统的任何攻击，违规或崩溃都会更大。</p>
<p>应该注意的是，每个公司的数据都是分开的，尽管过去几年的头条新闻中，公有云系统的安全漏洞也比较少见。这就是为什么在公有云 vs 私有云的辩论中，答案往往会归结为公司的需求和预算。</p>
]]></content>
      
        
        <tags>
            
            <tag> cloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 7下操纵ceph进程]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/centos-7%E4%B8%8B%E6%93%8D%E7%BA%B5ceph%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>分享一个以前的笔记。官网给的通过<code>/etc/init.d/ceph</code>stop、start等命令在centos7下不行，service命令也是不行的。现在都使用原生的 systemd 来管理ceph进程。<br><a id="more"></a></p>
<h2 id="操作集群"><a href="#操作集群" class="headerlink" title="操作集群"></a>操作集群</h2><p>在<a href="http://docs.ceph.org.cn/rados/operations/operating/" target="_blank" rel="external">官方文档</a>中给出了几种操作方法：</p>
<p><strong>1、用 UPSTART 控制 CEPH</strong></p>
<p>用 ceph-deploy 把 Ceph Cuttlefish 及更高版部署到 Ubuntu 之后，你可以用基于事件的 Upstart来启动、关闭 Ceph 节点上的守护进程。 Upstart 不要求你在配置文件里定义守护进程例程。</p>
<p><strong>2、通过 SYSVINIT 机制运行 CEPH</strong></p>
<p>在 CentOS 、 Redhat 、 Fedora 和 SLES 发行版上可以通过传统的 sysvinit 运行 Ceph ， Debian/Ubuntu 的较老的版本也可以用此方法。</p>
<p><strong>3、把 CEPH 当服务运行</strong></p>
<p>如果你是用 ceph-deploy 部署 Argonaut 或 Bobtail 的，那么 Ceph 可以作为服务运行（还可以用 sysvinit ）。</p>
<h2 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h2><p>但是，现在所有支持 systemd 的发行版（ CentOS 7 、 Fedora 、 Debian Jessie 8.x 、 SUSE ）都用原生的 systemd 文件来管理 ceph 守护进程，不再使用原来的 sysvinit 脚本了。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph.target       # start all daemons</div><div class="line">sudo systemctl status ceph-osd@12      # check status of osd.12</div></pre></td></tr></table></figure>
<p>罗列节点上 Ceph 的 systemd unit 用此命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl status ceph\*.service ceph\*.target</div></pre></td></tr></table></figure>
<h3 id="启动所有守护进程"><a href="#启动所有守护进程" class="headerlink" title="启动所有守护进程"></a>启动所有守护进程</h3><p>要启动一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph.target</div></pre></td></tr></table></figure>
<h3 id="停止所有守护进程"><a href="#停止所有守护进程" class="headerlink" title="停止所有守护进程"></a>停止所有守护进程</h3><p>要停止一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph\*.service ceph\*.target</div></pre></td></tr></table></figure>
<h3 id="按类型启动所有守护进程"><a href="#按类型启动所有守护进程" class="headerlink" title="按类型启动所有守护进程"></a>按类型启动所有守护进程</h3><p>要启动一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd.target</div><div class="line">sudo systemctl start ceph-mon.target</div><div class="line">sudo systemctl start ceph-mds.target</div></pre></td></tr></table></figure>
<h3 id="按类型停止所有守护进程"><a href="#按类型停止所有守护进程" class="headerlink" title="按类型停止所有守护进程"></a>按类型停止所有守护进程</h3><p>要停止一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-mon\*.service ceph-mon.target</div><div class="line">sudo systemctl stop ceph-osd\*.service ceph-osd.target</div><div class="line">sudo systemctl stop ceph-mds\*.service ceph-mds.target</div></pre></td></tr></table></figure>
<h3 id="启动单个进程"><a href="#启动单个进程" class="headerlink" title="启动单个进程"></a>启动单个进程</h3><p>要启动某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd@&#123;id&#125;</div><div class="line">sudo systemctl start ceph-mon@&#123;hostname&#125;</div><div class="line">sudo systemctl start ceph-mds@&#123;hostname&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd@1</div><div class="line">sudo systemctl start ceph-mon@ceph-server</div><div class="line">sudo systemctl start ceph-mds@ceph-server</div></pre></td></tr></table></figure>
<h3 id="停止单个进程"><a href="#停止单个进程" class="headerlink" title="停止单个进程"></a>停止单个进程</h3><p>要停止某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-osd@&#123;id&#125;</div><div class="line">sudo systemctl stop ceph-mon@&#123;hostname&#125;</div><div class="line">sudo systemctl stop ceph-mds@&#123;hostname&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-osd@1</div><div class="line">sudo systemctl stop ceph-mon@ceph-server</div><div class="line">sudo systemctl stop ceph-mds@ceph-server</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim移动光标]]></title>
      <url>http://xiaqunfeng.cc/2017/06/15/vim%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>平常的基本编辑环境都是vim，因此总结了一些光标移动的命令，可以提高效率，使vim用起来不显得那么笨重。<br><a id="more"></a></p>
<h2 id="光标方向"><a href="#光标方向" class="headerlink" title="光标方向"></a>光标方向</h2><p>上下左右：<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code></p>
<p>支持数字前缀，比如<code>10j</code>可以向下移动10行</p>
<p><code>ctrl + o</code>返回上一个光标位置</p>
<p><code>ctrl + i</code>跳到下一个光标位置</p>
<h2 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h2><p><code>w</code>移动光标到下一个单词的词首</p>
<p><code>b</code>移动光标到上一个单词的词首</p>
<p><code>e</code>移动光标到光标所在单词的结尾</p>
<p><code>ge</code>移动光标到上一个单词的结尾</p>
<p>支持数字前缀，比如<code>4w</code>可以向后移动4个单词</p>
<p>以上单词的分割标准是：空格、特殊符号</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raw: sudo apt-get -y install ceph</div></pre></td></tr></table></figure>
<p>这里 <code>:</code>  <code>-</code> 以及空格，都是分割符号</p>
<p><code>W</code>, <code>B</code>, <code>E</code> 功能同上，只不过它分隔单词的标准是空格，所以可以跳的更远，更方便，用的比较多。</p>
<h2 id="屏幕移动"><a href="#屏幕移动" class="headerlink" title="屏幕移动"></a>屏幕移动</h2><p><code>H</code>移动到屏幕的首行</p>
<p><code>L</code>到屏幕尾行</p>
<p><code>M</code>到屏幕中间</p>
<p><code>ctrl + f</code>向下翻页</p>
<p><code>ctrl + b</code>向上翻页</p>
<p><code>ctrl + e</code>逐行下滚</p>
<p><code>ctrl + y</code>逐行上滚</p>
<h2 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h2><p><code>^</code>到行首</p>
<p><code>$</code>到行尾</p>
<p><code>gg</code>移到文件首行</p>
<p><code>G</code>移到文件尾行</p>
<p><code>zt</code>置顶当前行</p>
<p><code>zz</code>将当前行移到屏幕中部</p>
<p><code>zb</code>将当前行移到底部</p>
<p>拷贝一行：<code>^y$</code>，也可以直接 <code>yy</code></p>
<p>拷贝整个文件：<code>ggyG</code></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Map RBD Devices on NBD]]></title>
      <url>http://xiaqunfeng.cc/2017/06/07/Map-RBD-Devices-on-NBD/</url>
      <content type="html"><![CDATA[<p>jewel及以后的版本支持rbd-nbd的特性，在需要map支持较多特性的rbd image时，可以使用此方法。<br><a id="more"></a></p>
<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>前一篇文章中说到在map特性比较丰富的rbd设备时，内核不支持，所以出现如如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># rbd nbd map rbd/image-1</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div></pre></td></tr></table></figure>
<p>所以行不通，于是寻求其他解决方案。</p>
<p>幸运的是，jewel及以后版本中，RBD支持将RBD image map为本地nbd设备，通过<code>rbd nbd map</code>命令即可映射为本地nbd设备。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>安装 rbd-nbd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rbd-nbd -y</div></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd nbd map rbd/image-1</div><div class="line">/dev/nbd0</div></pre></td></tr></table></figure>
<p>成功！</p>
<p>这时就可以格式化并挂载来使用该设备了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mkfs.xfs -f /dev/nbd0</div><div class="line"># mkdir /mnt/nbd0</div><div class="line"># mount -noatime /dev/nbd0 /mnt/nbd0</div><div class="line"># lsblk</div><div class="line">...</div><div class="line">nbd0    43:0    0    1G  0 disk /mnt/nbd0</div></pre></td></tr></table></figure>
<p>查看已映射的nbd设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd-nbd list-mapped</div><div class="line">/dev/nbd0</div></pre></td></tr></table></figure>
<blockquote>
<p>查看已挂载的rbd设备的命令是：rbd showmapped</p>
</blockquote>
<p>那么，什么是nbd设备？</p>
<h2 id="NBD"><a href="#NBD" class="headerlink" title="NBD"></a>NBD</h2><p><strong>NBD</strong>(Network Block Device)让你可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。NBD是一个内核模块，大部分Linux发行版都包含它。</p>
<h3 id="和RBD比较"><a href="#和RBD比较" class="headerlink" title="和RBD比较"></a>和RBD比较</h3><p>ceph jewel版本中有一个特性，RBD的NBD驱动，它允许librbd对外提供一个内核级别的RBD。</p>
<p>与RBD内核驱动程序相比，NBD有许多优点：</p>
<ul>
<li>RBD-KO开发和特性的添加必须要经过稳定的内核</li>
<li>RBD-KO开发慢于librbd，如果要与librbd开发保持同步，需要时间和努力</li>
<li>NBD已经很好地集成到内核多年，是大多数现今的内核的一部分</li>
</ul>
<p>RBD-NBD依靠librbd的用户空间实现，该实现通过使用强大和完善的NBD（网络块设备）内核模块已经非常稳定。</p>
<p>参考：<a href="http://www.sebastien-han.fr/blog/2016/04/04/ceph-jewel-preview-map-rbd-devices-on-nbd/" target="_blank" rel="external">Ceph Jewel Preview: map RBD devices on NBD</a></p>
<h3 id="和NFS的区别"><a href="#和NFS的区别" class="headerlink" title="和NFS的区别"></a>和NFS的区别</h3><ul>
<li>NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式</li>
<li>NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用</li>
</ul>
<h2 id="RBD-NBD"><a href="#RBD-NBD" class="headerlink" title="RBD-NBD"></a>RBD-NBD</h2><p><strong>rbd-nbd</strong> 是个 RADOS 块设备（ rbd ）映像的客户端，与 rbd 内核模块类似。它可以把一个 rbd 映像映射为 nbd （ Network Block Device，网络块设备）设备，这样就可以当常规的本地块设备使用了。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rbd-nbd [-c conf] [–nbds_max limit] [–read-only] [–device nbd device] map image-spec | snap-spec</div><div class="line">rbd-nbd unmap nbd device</div><div class="line">rbd-nbd list-mapped</div></pre></td></tr></table></figure>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p>-c ceph.conf</p>
<p>指定 ceph.conf 配置文件，而不是用默认的 /etc/ceph/ceph.conf 来确定启动时需要的 monitor 地址。</p>
</li>
</ul>
<ul>
<li><p>–nbds_max <em>limit</em></p>
<p>载入 NBD 内核模块时覆盖其参数，用于限制 nbd 设备的数量。</p>
</li>
</ul>
<h3 id="映像名和快照名规则"><a href="#映像名和快照名规则" class="headerlink" title="映像名和快照名规则"></a>映像名和快照名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">image-spec is [pool-name]/image-name</div><div class="line">snap-spec is [pool-name]/image-name@snap-name</div></pre></td></tr></table></figure>
<h2 id="ceph-rbd"><a href="#ceph-rbd" class="headerlink" title="ceph rbd"></a>ceph rbd</h2><p>使用Ceph的块存储有两种路径：</p>
<p>一种是利用QEMU走librbd路径，另一种是使用kernel module，走kernel的路径，两种途径的接口实现不完全相同。就目前来说，前者是目前更稳定的途径，也是Ceph所有应用场景中最广泛使用的。</p>
<ul>
<li>librbd是用户态的，主要为虚拟机提供块存储设备，kvm对接的就是librbd</li>
<li>kernel rbd是内核态的，主要为Host提供块设备支持，内核直接与osd交互，性能优于用户态</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rbd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph rbd map failed]]></title>
      <url>http://xiaqunfeng.cc/2017/06/06/ceph-rbd-map-failed/</url>
      <content type="html"><![CDATA[<p>探索 kernel RBD map 失败的问题。<br><a id="more"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>搭完 rbd mirror后，想通过client往image里写一些数据，所以在client端map rbd设备，结果失败了。</p>
<blockquote>
<p>rbd mirror的image 需要两个属性：exclusive-lock, journaling</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="查看rbd-image-info"><a href="#查看rbd-image-info" class="headerlink" title="查看rbd image info"></a>查看rbd image info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd/image-1</div><div class="line">rbd image &apos;image-1&apos;:</div><div class="line">	size 1024 MB in 256 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.108b238e1f29</div><div class="line">	format: 2</div><div class="line">	features: exclusive-lock, journaling</div><div class="line">	flags:</div><div class="line">	journal: 108b238e1f29</div><div class="line">	mirroring state: enabled</div><div class="line">	mirroring global id: c603d9dc-6f8d-49e0-ab68-5944d348e527</div><div class="line">	mirroring primary: true</div></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/image-1</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div><div class="line">rbd: map failed: (6) No such device or address</div></pre></td></tr></table></figure>
<p>然后dmesg看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># dmesg | tail</div><div class="line">[   64.808315] rbd: loaded (major 251)</div><div class="line">[   64.818369] libceph: mon2 172.20.2.160:6789 session established</div><div class="line">[   64.819187] libceph: client14167 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">[   64.836328] rbd: image image-1: image uses unsupported features: 0x40</div><div class="line">[  443.658569] libceph: mon1 172.20.2.161:6789 session established</div><div class="line">[  443.659143] libceph: client4313 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">[  443.683178] rbd: rbd0: capacity 10737418240 features 0x1</div><div class="line">[  978.502132] rbd: image image-1: image uses unsupported features: 0x40</div></pre></td></tr></table></figure>
<h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p><strong>image uses unsupported features: 0x40</strong></p>
<p>不支持特性 0x40 = 64，也就是不支持特性 <strong>journaling</strong></p>
<h2 id="关于内核支持的特性分析"><a href="#关于内核支持的特性分析" class="headerlink" title="关于内核支持的特性分析"></a>关于内核支持的特性分析</h2><p>查看内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">3.10.0-327.el7.x86_64</div></pre></td></tr></table></figure>
<p>根据查阅资料和实践，发现：</p>
<ul>
<li>CentOS的3.10内核仅支持其中的layering 和 exclusive-lock，其他feature概不支持</li>
<li>内核4.6仍然只支持：layering、exclusive-lock和 striping 属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd/test-map</div><div class="line">rbd image &apos;test-map&apos;:</div><div class="line">	size 512 MB in 128 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.10ca238e1f29</div><div class="line">	format: 2</div><div class="line">	features: layering, exclusive-lock</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/test-map</div><div class="line">/dev/rbd1</div></pre></td></tr></table></figure>
<p>此时可以map成功。</p>
<h2 id="RBD特性解析"><a href="#RBD特性解析" class="headerlink" title="RBD特性解析"></a>RBD特性解析</h2><h3 id="特性一览表"><a href="#特性一览表" class="headerlink" title="特性一览表"></a>特性一览表</h3><p>RBD支持的特性，及具体BIT值的计算如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
<th>BIT码</th>
</tr>
</thead>
<tbody>
<tr>
<td>layering</td>
<td>支持分层</td>
<td>1</td>
</tr>
<tr>
<td>striping</td>
<td>支持条带化 v2</td>
<td>2</td>
</tr>
<tr>
<td>exclusive-lock</td>
<td>支持独占锁</td>
<td>4</td>
</tr>
<tr>
<td>object-map</td>
<td>支持对象映射（依赖 exclusive-lock ）</td>
<td>8</td>
</tr>
<tr>
<td>fast-diff</td>
<td>快速计算差异（依赖 object-map ）</td>
<td>16</td>
</tr>
<tr>
<td>deep-flatten</td>
<td>支持快照扁平化操作</td>
<td>32</td>
</tr>
<tr>
<td>journaling</td>
<td>支持记录 IO 操作（依赖独占锁）</td>
<td>64</td>
</tr>
</tbody>
</table>
<h3 id="ceph-kraken版本默认属性值"><a href="#ceph-kraken版本默认属性值" class="headerlink" title="ceph kraken版本默认属性值"></a>ceph kraken版本默认属性值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --show-config|grep rbd|grep features</div><div class="line">rbd_default_features = 61</div></pre></td></tr></table></figure>
<p>为啥是61？我们创建一个默认配置的rbd看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># rbd create test-feature --size 64</div><div class="line"># rbd info rbd/test-feature</div><div class="line">rbd image &apos;test-feature&apos;:</div><div class="line">	size 65536 kB in 16 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.107d238e1f29</div><div class="line">	format: 2</div><div class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<p><strong>1+4+8+16+32 = 61</strong></p>
<p>就是说除了特性：striping 和 journaling 外都开启了。</p>
<h3 id="控制属性"><a href="#控制属性" class="headerlink" title="控制属性"></a>控制属性</h3><p>有三种方法来开启需要的特性</p>
<p>1、在创建image时，通过 <code>--image-feature</code> 来指定需要开启的特性</p>
<p>2、对已存在的image可以通过如下命令开启和关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd feature enable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</div><div class="line">rbd feature disable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</div></pre></td></tr></table></figure>
<p>3、当然，每次通过enable和disable来不是很便捷，可以通过修改配置文件来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/ceph/ceph.conf</div><div class="line">...</div><div class="line">rbd_default_features = 1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>具体该设为多少可以通过上面BIT值查表计算得出。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rbd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph mon时钟偏移问题]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/ceph-mon%E6%97%B6%E9%92%9F%E5%81%8F%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>之前记录的关于时钟漂移的解决过程和心得，这里分享一下。<br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>查看集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_WARN</div><div class="line">            clock skew detected on mon.xs734</div><div class="line">            Monitor clock skew detected</div><div class="line">...</div></pre></td></tr></table></figure>
<p>根据提示，发现这是一个明显的时钟漂移的问题</p>
<h2 id="配置NTP"><a href="#配置NTP" class="headerlink" title="配置NTP"></a>配置NTP</h2><p>第一反应就是ntp同步，配置ntp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install ntp ntpdate -y</div><div class="line">ntpdate pool.ntp.org</div><div class="line">systemctl restart ntpdate.service</div><div class="line">systemctl restart ntpd.service</div><div class="line">systemctl enable ntpdate.service</div><div class="line">systemctl enable ntpd.service</div></pre></td></tr></table></figure>
<blockquote>
<p>每台机器上重复如上过程</p>
</blockquote>
<p>此时，查看集群的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># for x in xs732 xs733 xs734; do ssh $x &apos;date&apos;; done</div><div class="line">Thu May 05 17:51:26 CST 2017</div><div class="line">Thu May 05 17:51:27 CST 2017</div><div class="line">Thu May 05 17:51:27 CST 2017</div></pre></td></tr></table></figure>
<p>说明时间基本已经同步了。<strong>一般情况下问题就已经解决了，但这里还有问题。</strong></p>
<h2 id="进一步跟踪集群状态"><a href="#进一步跟踪集群状态" class="headerlink" title="进一步跟踪集群状态"></a>进一步跟踪集群状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_WARN</div><div class="line">            clock skew detected on mon.xs734</div><div class="line">            Monitor clock skew detected</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这时候问题来了，发现集群还是处于 WARN 的状态，进一步看问题出在哪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph -w</div><div class="line">...</div><div class="line">2017-05-26 10:27:14.325856 mon.0 [WRN] mon.2 10.34.57.27:6789/0 clock skew 0.0556591s &gt; max 0.05s</div><div class="line">2017-05-26 10:27:44.292273 mon.0 [INF] HEALTH_WARN; clock skew detected on mon.xs733, mon.xs734; Monitor clock skew detected</div></pre></td></tr></table></figure>
<p><strong>问题所在：0.0556591s &gt; max 0.05s 漂移的时间略大于默认的0.05秒</strong></p>
<blockquote>
<p>很少出现这种大于0.05秒的情况</p>
</blockquote>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><p>在 <code>/etc/ceph/ceph.conf</code> 中添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mon]</div><div class="line">mon_clock_drift_allowed = 0.10</div><div class="line">mon clock drift warn backoff = 10</div></pre></td></tr></table></figure>
<blockquote>
<p>亲测，参数名称要不要下划线都可以</p>
</blockquote>
<p>改完后将配置推到集群所有的机器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf config push xs732 xs733 xs734</div></pre></td></tr></table></figure>
<h3 id="关于这两个参数"><a href="#关于这两个参数" class="headerlink" title="关于这两个参数"></a>关于这两个参数</h3><p>mon clock drift allowed</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>监视器间允许的时钟漂移量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>.050</td>
</tr>
</tbody>
</table>
<p>mon clock drift warn backoff</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>时钟偏移警告的退避指数。</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>链接：<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/" target="_blank" rel="external">http://docs.ceph.org.cn/rados/configuration/mon-config-ref/</a></p>
<h3 id="查看此时运行的ceph配置"><a href="#查看此时运行的ceph配置" class="headerlink" title="查看此时运行的ceph配置"></a>查看此时运行的ceph配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</div><div class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.05&quot;,</div><div class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;5&quot;,</div><div class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</div></pre></td></tr></table></figure>
<p>发现还是默认的 0.05 和 5，说明更改的配置根本没生效。</p>
<h3 id="重启monitor"><a href="#重启monitor" class="headerlink" title="重启monitor"></a>重启monitor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart ceph-mon@xs732.service</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，每台机器上都重启一下</p>
</blockquote>
<p>然后再查看，发现生效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</div><div class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.10&quot;,</div><div class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;10&quot;,</div><div class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</div></pre></td></tr></table></figure>
<p>再次查看ceph集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;xs732=10.34.57.25:6789/0,xs733=10.34.57.26:6789/0,xs734=10.34.57.27:6789/0&#125;</div><div class="line">            election epoch 12, quorum 0,1,2 xs732,xs733,xs734</div><div class="line">        mgr active: xs733 standbys: xs734, xs732</div><div class="line">     osdmap e50: 9 osds: 9 up, 9 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v113: 256 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            46397 MB used, 4423 GB / 4469 GB avail</div><div class="line">                 256 active+clean</div></pre></td></tr></table></figure>
<p>OK，问题解决！</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPG key retrieval failure]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/GPG-key-retrieval-failure/</url>
      <content type="html"><![CDATA[<p>在centos 7.31611上遇到的问题，记录一下解决方法，并附下载链接。<br><a id="more"></a></p>
<h2 id="我的epel源"><a href="#我的epel源" class="headerlink" title="我的epel源"></a>我的epel源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d</div><div class="line">[epel]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line">[epel-debuginfo]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div><div class="line"></div><div class="line">[epel-source]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>更新yum源的时候出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line"></div><div class="line">GPG key retrieval failed: [Errno 14] curl#37 - &quot;Couldn&apos;t open file /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7&quot;</div></pre></td></tr></table></figure>
<p>查看一下，确实没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# ls /etc/pki/rpm-gpg/</div><div class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-ZABBIX</div></pre></td></tr></table></figure>
<h2 id="网上解决方案"><a href="#网上解决方案" class="headerlink" title="网上解决方案"></a>网上解决方案</h2><p>这是个bug，没啥好的办法</p>
<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1237057" target="_blank" rel="external">https://bugzilla.redhat.com/show_bug.cgi?id=1237057</a></p>
<h2 id="原因-amp-解决尝试"><a href="#原因-amp-解决尝试" class="headerlink" title="原因&amp;解决尝试"></a>原因&amp;解决尝试</h2><p>看了下输出，就是缺少 <code>RPM-GPG-KEY-EPEL-7</code> 嘛，补上是不是就可以了呢？</p>
<p>带着这个疑问，实践一下：</p>
<p>1、在原先成功的机器上，查看是否有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@ceph3 yum.repos.d]# ls /etc/pki/rpm-gpg/</div><div class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-SIG-Virtualization  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-EPEL-7</div></pre></td></tr></table></figure>
<p>发现果然有</p>
<p>2、将 <code>RPM-GPG-KEY-EPEL-7</code> 拷贝到现在的机器上</p>
<p>3、这时再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install epel-release -y</div></pre></td></tr></table></figure>
<p>可以成功，问题解决！</p>
<p align="center"><strong>附上<code>RPM-GPG-KEY-EPEL-7</code>下载链接，给有需要的人</strong></p>

<p align="center"><a href="http://oow6unnib.bkt.clouddn.com/RPM-GPG-KEY-EPEL-7" target="_blank" rel="external">点此下载</a></p>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># sudo rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line">Retrieving https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line">curl: (7) Failed connect to dl.fedoraproject.org:443; Connection refused</div><div class="line">error: skipping https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm - transfer failed</div><div class="line">You have new mail in /var/spool/mail/root</div></pre></td></tr></table></figure>
<p>这个问题的原因是网站无法访问</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上实现vim的markdown预览]]></title>
      <url>http://xiaqunfeng.cc/2017/05/25/mac%E4%B8%8A%E5%AE%9E%E7%8E%B0vim%E7%9A%84markdown%E9%A2%84%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>有时候在vim下创建了一个markdown文件，比如 <code>README.md</code> ，因为不能实时预览，所以要离开vim，用编辑器去编辑，比较麻烦。所以这里配置使能在vim编辑器上预览markdown文件。<br><a id="more"></a></p>
<p>这里分享两个插件</p>
<h2 id="vim-instant-markdown"><a href="#vim-instant-markdown" class="headerlink" title="vim-instant-markdown"></a><strong>vim-instant-markdown</strong></h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>github：<a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="external">https://github.com/suan/vim-instant-markdown</a></p>
<p>下载zip文件，解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls vim-instant-markdown-master/</div><div class="line">CHANGELOG.md README.md    after</div></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>注意：需要依赖 node.js 和 npm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install npm</div><div class="line">sudo npm -g install instant-markdown-d</div></pre></td></tr></table></figure>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -pv ~/.vim/after/ftplugin/markdown/</div><div class="line">sudo cp after/ftplugin/markdown/instant-markdown.vim ~/.vim/after/ftplugin/markdown/</div></pre></td></tr></table></figure>
<p>注意：保证在 <code>~/.vimrc</code> 中 <code>filetype plugin on</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filetype plugin indent on     &quot; required!</div></pre></td></tr></table></figure>
<blockquote>
<p>一般是on的，特别是之前配置过vim插件的时候，已经打开了。</p>
</blockquote>
<h2 id="markdown-preview-vim"><a href="#markdown-preview-vim" class="headerlink" title="markdown-preview.vim"></a><strong>markdown-preview.vim</strong></h2><p>Github：<a href="https://github.com/iamcco/markdown-preview.vim" target="_blank" rel="external">https://github.com/iamcco/markdown-preview.vim</a></p>
<p>相比较上面一种方法，这种比较轻量级，推荐此方法。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>第一步：在 <code>~/.vimrc</code> 中的插件部分添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug &apos;iamcco/markdown-preview.vim&apos;</div></pre></td></tr></table></figure>
<p>第二步：安装插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo vim		# 或者：sudo mvim</div><div class="line">:BundleInstall</div></pre></td></tr></table></figure>
<h3 id="设置chrome为预览浏览器"><a href="#设置chrome为预览浏览器" class="headerlink" title="设置chrome为预览浏览器"></a>设置chrome为预览浏览器</h3><p>在 <code>~/.vimrc</code> 的末尾添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let g:mkdp_path_to_chrome = &quot;open -a Google\\ Chrome&quot;</div></pre></td></tr></table></figure>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>在编辑markdown的vim界面上敲如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:MarkdownPreview</div></pre></td></tr></table></figure>
<p>这时候就会在浏览器中出现markdown的预览界面</p>
<h3 id="退出预览"><a href="#退出预览" class="headerlink" title="退出预览"></a>退出预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:MarkdownPreviewStop</div></pre></td></tr></table></figure>
<p>文件退出vim编辑的时候也会自动关闭和退出预览。</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>如果不是用mac自带的bash，而是自己装的zsh，需要注意以下两点：</p>
<p>1、保证在安装 instant-markdown-d 的时候添加了选项 <code>npm -g install</code></p>
<p>2、在 <code>~/.vimrc</code> 的末尾添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set shell=bash\ -i</div></pre></td></tr></table></figure>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>第二种方法较第一种比较轻量级，而且不需要依赖node.js，不需要下载外部依赖，只需要支持python2/3就可以了，同时支持滚动。</p>
<p>这种配置在配合 mvim + hexo + markdown 的时候特别爽，可以实时显示，都省了先执行<code>hexo s</code>，然后登陆<code>localhost:4000</code> 去查看了。</p>
<p>本篇博客的实时预览截图如下：（可以看到，端口为9183）<br><img src="http://oow6unnib.bkt.clouddn.com/markdown-preview.png" alt="markdown-preview"></p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph日志迁移]]></title>
      <url>http://xiaqunfeng.cc/2017/05/23/ceph%E6%97%A5%E5%BF%97%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>将ceph日志从默认的位置移动到SSD的一个分区，比较常用。<br><a id="more"></a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、停止osd</p>
<p>2、将该osd的日志下盘</p>
<p>3、移除原有日志</p>
<p>4、将osd的日志软链到SSD的分区</p>
<p>5、创建新的journal</p>
<p>6、启动osd</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>系统：centos 7.3</p>
<p>以 osd 0 、/dev/sdb1 为例，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># stop osd</div><div class="line">systemctl stop ceph-osd@0</div><div class="line"></div><div class="line"># flush journal</div><div class="line">ceph-osd --flush-journal -i 0</div><div class="line"></div><div class="line"># remove old journal</div><div class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal</div><div class="line"></div><div class="line"># create symlink to partition</div><div class="line">ln -s /dev/sdb1 /var/lib/ceph/osd/ceph-0/journal</div><div class="line"></div><div class="line"># create new journal</div><div class="line">ceph-osd --mkjournal -i 0</div><div class="line"></div><div class="line"># start osd</div><div class="line">systemctl start ceph-osd@0</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>确认日志和磁盘分区的权限，如果不是ceph，会出现访问失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-0/journal</div><div class="line">chown -R ceph:ceph /dev/sdb1</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[cpu拓扑及ceph使用时的优化]]></title>
      <url>http://xiaqunfeng.cc/2017/05/11/cpu%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>先将在ceph层面的调优，再介绍cpu的拓扑结构。<br><a id="more"></a></p>
<h2 id="ceph优化之CPU"><a href="#ceph优化之CPU" class="headerlink" title="ceph优化之CPU"></a>ceph优化之CPU</h2><p>NUMA的思路就是讲内存和CPU分割成多个区域，每个区域叫node，然后将node高速互联。node内CPU与内存的访问速度快于访问其他node的内存，NUMA可能会在某些情况下影响ceph-osd。</p>
<p>ceph目前未对NUMA架构的内存做过多优化，在日常使用过程中，通常为 2~4 颗CPU，这时候选择SMP架构的内存在效率上会高一些，如果条件允许，可以通过进程绑定的方法，在保证CPU能尽可能访问自身内存的前提下，使用NUMA架构。</p>
<h3 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h3><p><strong>通过BIOS关闭NUMA。</strong></p>
<ul>
<li>在os层numa关闭时，打开bios层的numa会影响性能，QPS会下降15-30%。</li>
<li>在bios层面numa关闭时，无论os层面的numa是否打开，都不会影响性能。</li>
</ul>
<p>通过命令判断bios层是否开启numa：</p>
<p>1、开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># grep -i numa /var/log/dmesg</div><div class="line">[    0.000000] NUMA: Initialized distance table, cnt=2</div><div class="line">[    0.000000] NUMA: Node 0 [mem 0x00000000-0x7fffffff] + [mem 0x100000000-0x47fffffff] -&gt; [mem 0x00000000-0x47fffffff]</div><div class="line">[    0.000000] Enabling automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl</div><div class="line">[    0.593086] pci_bus 0000:00: on NUMA node 0</div><div class="line">[    0.598672] pci_bus 0000:80: on NUMA node 1</div></pre></td></tr></table></figure>
<p>2、未开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep -i numa /var/log/dmesg</div><div class="line">[    0.000000] No NUMA configuration found</div></pre></td></tr></table></figure>
<p>查看机器的NUMA拓扑结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># numastat</div><div class="line">                           node0           node1</div><div class="line">numa_hit             83549806562     18182486371</div><div class="line">numa_miss               54084897     15540366583</div><div class="line">numa_foreign         15540366583        54084897</div><div class="line">interleave_hit             14109           14168</div><div class="line">local_node           83549670098     18182734455</div><div class="line">other_node              54221361     15540118499</div></pre></td></tr></table></figure>
<p>当发现numa_miss数值比较高时，说明需要对分配策略进行调整。例如将指定进程关联绑定到指定的CPU上，从而提高内存命中率。</p>
<p>在运行程序的时候使用<code>numactl</code> <code>-m</code>和<code>-physcpubind</code>就能制定将这个程序运行在哪个cpu和哪个memory中。</p>
<p>numa的陷阱：当你的服务器还有内存的时候，发现它已经在开始使用swap了，甚至已经导致机器出现停滞的现象。这个就有可能是由于numa的限制，如果一个进程限制它只能使用自己的numa节点的内存，那么当自身numa node内存使用光之后，就不会去使用其他numa node的内存了，会开始使用swap，甚至更糟的情况，机器没有设置swap的时候，可能会直接死机。所以可以使用<code>numactl --interleave=all</code>来取消numa node的限制。</p>
<p>根据具体业务决定NUMA的使用：</p>
<ul>
<li>如果你的程序是会占用大规模内存的，你大多应该选择关闭numa node的限制（或从硬件关闭numa）。因为这个时候你的程序很有几率会碰到numa陷阱。</li>
<li>如果你的程序并不占用大内存，而是要求更快的程序运行时间。你大多应该选择限制只访问本numa node的方法来进行处理。</li>
</ul>
<h3 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h3><p>通过cgroup将ceph-osd进程与某一个 CPU core 以及同一个 node下的内存进行绑定。</p>
<p>绑定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mkdir -p /dys/fs/cgroup/cpuset/ceph</div><div class="line"># cup number : 0,1,2,3 = 0-3</div><div class="line">echo 0,4 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.cpus</div><div class="line"># NUMA node</div><div class="line">echo 0 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.mems</div><div class="line">osd-pid-list=$(ps aux | grep osd | grep -v grep | awk &apos;&#123;print $2&#125;&apos;)</div><div class="line">for osd-pid in $(osd-pid-list)</div><div class="line">do</div><div class="line">    echo $(osd-pid) &gt; /sys/fs/cgroup/cpuset/ceph/cgroup.procs</div><div class="line">done</div></pre></td></tr></table></figure>
<p>注意的问题：</p>
<p>· 防止进程跨CPU核心迁移，以更好的利用缓存；</p>
<p>· 防止进程跨物理CPU迁移，以更好的利用内存和缓存；</p>
<p>· Ceph进程和其他进程会互相抢占资源，使用Cgroups做好隔离措施；</p>
<p>· 为Ceph进程预留足够多的CPU和内存资源，防止影响性能或产生OOM。尤其是高性能环境中并不能完全满足Ceph进程的开销，在高性能场景（全SSD）下，每个OSD进程可能需要高达6GHz的CPU和4GB以上的内存。</p>
<h2 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h2><p>cpu相关的信息都在 <code>/proc/cpuinfo</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># lscpu</div><div class="line">Architecture:          x86_64</div><div class="line">CPU op-mode(s):        32-bit, 64-bit</div><div class="line">Byte Order:            Little Endian</div><div class="line">CPU(s):                32</div><div class="line">On-line CPU(s) list:   0-31</div><div class="line">Thread(s) per core:    2</div><div class="line">Core(s) per socket:    8</div><div class="line">座：                 2</div><div class="line">NUMA 节点：         2</div><div class="line">厂商 ID：           GenuineIntel</div><div class="line">CPU 系列：          6</div><div class="line">型号：              63</div><div class="line">型号名称：        Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz</div><div class="line">步进：              2</div><div class="line">CPU MHz：             1200.585</div><div class="line">BogoMIPS：            4800.30</div><div class="line">虚拟化：           VT-x</div><div class="line">L1d 缓存：          32K</div><div class="line">L1i 缓存：          32K</div><div class="line">L2 缓存：           256K</div><div class="line">L3 缓存：           20480K</div><div class="line">NUMA 节点0 CPU：    0-7,16-23</div><div class="line">NUMA 节点1 CPU：    8-15,24-31</div></pre></td></tr></table></figure>
<p>两种不同的CPU硬件体系架构：</p>
<ul>
<li>NUMA（Non-Uniform Memory Access，非一致性内存访问）</li>
<li>SMP（Symmetric Multi-Processor，对称多处理器系统）</li>
</ul>
<p>SMP的主要特征是共享，所有的CPU共享使用全部资源，例如内存、总线和I/O，多个CPU对称工作，彼此之间没有主次之分，平等地访问共享的资源，这样势必引入资源的竞争问题，且如果内存访问达到瓶颈的时候，性能就不能随之增加。每个CPU通过总线访问内存，当CPU数量不断增加以后，总线的压力不断增加，导致CPU的处理能力大大降低。</p>
<p>NUMA技术将CPU划分成不同的组（Node)，每个Node由多个CPU组成，并且有独立的本地内存、I/O等资源。Node之间通过互联模块连接和沟通，因此除了本地内存外，每个CPU仍可以访问远端Node的内存，不过效率会比访问本地内存差一些，我们用Node之间的距离（Distance，抽象的概念）来定义各个Node之间互访资源的开销。</p>
<p>NUMA架构旨在超越SMP架构的可扩展性限制。 使用代表对称多处理的SMP，所有存储器访问都被发布到相同的共享存储器总线。 这对于相对较少数量的CPU来说可行，但是当您有数十个甚至数百个CPU竞争访问共享内存总线时，会出现共享总线的问题。 NUMA通过限制任何一个存储器总线上的CPU数量以及通过高速互连连接各个节点来减轻这些瓶颈。</p>
<p>在NUMA盒上，访问非本地内存的成本很高。 如果您运行的是不支持NUMA的软件，那么它不会小心节点正在托管刚刚分配的内存，并没有利用NUMA架构的优势。 根据实施情况和平台，这种处罚可以忽略不计，压倒一切。</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>如果你只知道CPU这么一个概念，那么是无法理解CPU的拓扑的。事实上，在NUMA架构下，CPU的概念从大到小依次是：Node、Socket、Core、Processor。</p>
<p>随着多核技术的发展，我们将多个CPU封装在一起，这个封装一般被称为Socket（插槽的意思，也有人称之为Packet），而Socket中的每个核心被称为Core。为了进一步提升CPU的处理能力，Intel又引入了HT（Hyper-Threading，超线程)的技术，一个Core打开HT之后，在OS看来就是两个核，当然这个核是逻辑上的概念，所以也被称为Logical Processor，本文简称为Processor。</p>
<p>综上所述，一个NUMA Node可以有一个或者多个Socket，一个多核Socket显然包含多个Core，一个Core如果打开HT则变成两个Logical Processor。Logical processor只是OS内部看到的，实际上两个Processor还是位于同一个Core上，所以频繁的调度仍可能导致资源竞争，影响性能。</p>
<p>NUMA相关的策略</p>
<p>1、每个进程（或线程）都会从父进程继承NUMA策略，并分配有一个优先node。如果NUMA策略允许的话，进程可以调用其他node上的资源。</p>
<p>2、NUMA的CPU分配策略有cpunodebind、physcpubind。cpunodebind规定进程运行在某几个node之上，而physcpubind可以更加精细地规定运行在哪些核上。</p>
<p>3、NUMA的内存分配策略有localalloc、preferred、membind、interleave。</p>
<p>localalloc规定进程从当前node上请求分配内存；</p>
<p>而preferred比较宽松地指定了一个推荐的node来获取内存，如果被推荐的node上没有足够内存，进程可以尝试别的node。</p>
<p>membind可以指定若干个node，进程只能从这些指定的node上请求分配内存。</p>
<p>interleave规定进程从指定的若干个node上以RR（Round Robin 轮询调度）算法交织地请求分配内存。</p>
<p>因为NUMA默认的内存分配策略是优先在进程所在CPU的本地内存中分配，会导致CPU节点之间内存分配不均衡，当某个CPU节点的内存不足时，会导致swap产生，而不是从远程节点分配内存。这就是所谓的swap insanity 现象。</p>
<h2 id="查看CPU拓扑"><a href="#查看CPU拓扑" class="headerlink" title="查看CPU拓扑"></a>查看CPU拓扑</h2><p><strong>Node -&gt; Socket -&gt; Core -&gt; Processor</strong></p>
<h3 id="查看Numa-Node"><a href="#查看Numa-Node" class="headerlink" title="查看Numa Node"></a>查看Numa Node</h3><p>安装numactl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install numactl -y</div></pre></td></tr></table></figure>
<p>numactl是设定进程NUMA策略的命令行工具，也可以用来查看当前的Nuwa node：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># numactl --hardware</div><div class="line">available: 2 nodes (0-1)</div><div class="line">node 0 cpus: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">node 0 size: 16263 MB</div><div class="line">node 0 free: 168 MB</div><div class="line">node 1 cpus: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div><div class="line">node 1 size: 16384 MB</div><div class="line">node 1 free: 263 MB</div><div class="line">node distances:</div><div class="line">node   0   1</div><div class="line">  0:  10  21</div><div class="line">  1:  21  10</div></pre></td></tr></table></figure>
<h3 id="查看socket"><a href="#查看socket" class="headerlink" title="查看socket"></a>查看socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line"> 0</div><div class="line"> 1</div><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</div><div class="line">2</div></pre></td></tr></table></figure>
<p>查看每个socket对应几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2&#125;&apos; | sort | uniq -c</div><div class="line">     16  0</div><div class="line">     16  1</div></pre></td></tr></table></figure>
<p>查看socket对应哪几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># awk -F: &apos;&#123;</div><div class="line">&gt;     if ($1 ~ /processor/) &#123;</div><div class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</div><div class="line">&gt;         p_id=$2;</div><div class="line">&gt;     &#125; else if ($1 ~ /physical id/)&#123;</div><div class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</div><div class="line">&gt;         s_id=$2;</div><div class="line">&gt;         arr[s_id]=arr[s_id] &quot; &quot; p_id</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; END&#123;</div><div class="line">&gt;     for (i in arr)</div><div class="line">&gt;         print arr[i];</div><div class="line">&gt; &#125;&apos; /proc/cpuinfo | cut -c2-</div><div class="line">0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div></pre></td></tr></table></figure>
<h3 id="查看core"><a href="#查看core" class="headerlink" title="查看core"></a>查看core</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># cat /proc/cpuinfo | grep &apos;core&apos;  | sort -u</div><div class="line">core id		: 0</div><div class="line">core id		: 1</div><div class="line">core id		: 2</div><div class="line">core id		: 3</div><div class="line">core id		: 4</div><div class="line">core id		: 5</div><div class="line">core id		: 6</div><div class="line">core id		: 7</div><div class="line">cpu cores	: 8</div></pre></td></tr></table></figure>
<h3 id="查看processor"><a href="#查看processor" class="headerlink" title="查看processor"></a>查看processor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep &apos;processor&apos; /proc/cpuinfo | wc -l</div><div class="line">32</div></pre></td></tr></table></figure>
<p>每个socket中有几个processor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep &apos;siblings&apos; /proc/cpuinfo | sort -u</div><div class="line">siblings	: 16</div></pre></td></tr></table></figure>
<h2 id="所有CPU拓扑信息"><a href="#所有CPU拓扑信息" class="headerlink" title="所有CPU拓扑信息"></a>所有CPU拓扑信息</h2><p>shell脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"># cat cpu-topology.sh</div><div class="line">#!/bin/bash</div><div class="line"># Simple print cpu topology</div><div class="line"></div><div class="line">function get_nr_processor()</div><div class="line">&#123;</div><div class="line">    grep &apos;^processor&apos; /proc/cpuinfo | wc -l</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_socket()</div><div class="line">&#123;</div><div class="line">    grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_siblings()</div><div class="line">&#123;</div><div class="line">    grep &apos;siblings&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_cores_of_socket()</div><div class="line">&#123;</div><div class="line">    grep &apos;cpu cores&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &apos;===== CPU Topology Table =====&apos;</div><div class="line">echo</div><div class="line"></div><div class="line">echo &apos;+--------------+---------+-----------+&apos;</div><div class="line">echo &apos;| Processor ID | Core ID | Socket ID |&apos;</div><div class="line">echo &apos;+--------------+---------+-----------+&apos;</div><div class="line"></div><div class="line">while read line; do</div><div class="line">    if [ -z &quot;$line&quot; ]; then</div><div class="line">        printf &apos;| %-12s | %-7s | %-9s |\n&apos; $p_id $c_id $s_id</div><div class="line">        echo &apos;+--------------+---------+-----------+&apos;</div><div class="line">        continue</div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^processor&quot;; then</div><div class="line">        p_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^core id&quot;; then</div><div class="line">        c_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^physical id&quot;; then</div><div class="line">        s_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line">done &lt; /proc/cpuinfo</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">awk -F: &apos;&#123; </div><div class="line">    if ($1 ~ /processor/) &#123;</div><div class="line">        gsub(/ /,&quot;&quot;,$2);</div><div class="line">        p_id=$2;</div><div class="line">    &#125; else if ($1 ~ /physical id/)&#123;</div><div class="line">        gsub(/ /,&quot;&quot;,$2);</div><div class="line">        s_id=$2;</div><div class="line">        arr[s_id]=arr[s_id] &quot; &quot; p_id</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">END&#123;</div><div class="line">    for (i in arr) </div><div class="line">        printf &quot;Socket %s:%s\n&quot;, i, arr[i];</div><div class="line">&#125;&apos; /proc/cpuinfo</div><div class="line"></div><div class="line">echo</div><div class="line">echo &apos;===== CPU Info Summary =====&apos;</div><div class="line">echo</div><div class="line"></div><div class="line">nr_processor=`get_nr_processor`</div><div class="line">echo &quot;Logical processors: $nr_processor&quot;</div><div class="line"></div><div class="line">nr_socket=`get_nr_socket`</div><div class="line">echo &quot;Physical socket: $nr_socket&quot;</div><div class="line"></div><div class="line">nr_siblings=`get_nr_siblings`</div><div class="line">echo &quot;Siblings in one socket: $nr_siblings&quot;</div><div class="line"></div><div class="line">nr_cores=`get_nr_cores_of_socket`</div><div class="line">echo &quot;Cores in one socket: $nr_cores&quot;</div><div class="line"></div><div class="line">let nr_cores*=nr_socket</div><div class="line">echo &quot;Cores in total: $nr_cores&quot;</div><div class="line"></div><div class="line">if [ &quot;$nr_cores&quot; = &quot;$nr_processor&quot; ]; then</div><div class="line">    echo &quot;Hyper-Threading: off&quot;</div><div class="line">else</div><div class="line">    echo &quot;Hyper-Threading: on&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">echo</div><div class="line">echo &apos;===== END =====&apos;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"># sh cpu-topology.sh</div><div class="line">===== CPU Topology Table =====</div><div class="line"></div><div class="line">+--------------+---------+-----------+</div><div class="line">| Processor ID | Core ID | Socket ID |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 0            | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 1            | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 2            | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 3            | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 4            | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 5            | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 6            | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 7            | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 8            | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 9            | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 10           | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 11           | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 12           | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 13           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 14           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 15           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 16           | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 17           | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 18           | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 19           | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 20           | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 21           | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 22           | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 23           | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 24           | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 25           | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 26           | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 27           | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 28           | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 29           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 30           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 31           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line"></div><div class="line">Socket 0: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">Socket 1: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div><div class="line"></div><div class="line">===== CPU Info Summary =====</div><div class="line"></div><div class="line">Logical processors: 32</div><div class="line">Physical socket: 2</div><div class="line">Siblings in one socket:  16</div><div class="line">Cores in one socket:  8</div><div class="line">Cores in total: 16</div><div class="line">Hyper-Threading: on</div><div class="line"></div><div class="line">===== END =====</div></pre></td></tr></table></figure>
<h2 id="工具hwloc"><a href="#工具hwloc" class="headerlink" title="工具hwloc"></a>工具hwloc</h2><p>hwloc可以显示CPU拓扑，比较方面地查看CPU各级缓存以及各个核、物理CPU之间，可以共享哪一级别的CPU cache。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"># hwloc-ls</div><div class="line">Machine (94GB total)</div><div class="line">  NUMANode L#0 (P#0 47GB)</div><div class="line">    Package L#0 + L3 L#0 (20MB)</div><div class="line">      L2 L#0 (256KB) + L1d L#0 (32KB) + L1i L#0 (32KB) + Core L#0</div><div class="line">        PU L#0 (P#0)</div><div class="line">        PU L#1 (P#16)</div><div class="line">      L2 L#1 (256KB) + L1d L#1 (32KB) + L1i L#1 (32KB) + Core L#1</div><div class="line">        PU L#2 (P#1)</div><div class="line">        PU L#3 (P#17)</div><div class="line">      L2 L#2 (256KB) + L1d L#2 (32KB) + L1i L#2 (32KB) + Core L#2</div><div class="line">        PU L#4 (P#2)</div><div class="line">        PU L#5 (P#18)</div><div class="line">      L2 L#3 (256KB) + L1d L#3 (32KB) + L1i L#3 (32KB) + Core L#3</div><div class="line">        PU L#6 (P#3)</div><div class="line">        PU L#7 (P#19)</div><div class="line">      L2 L#4 (256KB) + L1d L#4 (32KB) + L1i L#4 (32KB) + Core L#4</div><div class="line">        PU L#8 (P#4)</div><div class="line">        PU L#9 (P#20)</div><div class="line">      L2 L#5 (256KB) + L1d L#5 (32KB) + L1i L#5 (32KB) + Core L#5</div><div class="line">        PU L#10 (P#5)</div><div class="line">        PU L#11 (P#21)</div><div class="line">      L2 L#6 (256KB) + L1d L#6 (32KB) + L1i L#6 (32KB) + Core L#6</div><div class="line">        PU L#12 (P#6)</div><div class="line">        PU L#13 (P#22)</div><div class="line">      L2 L#7 (256KB) + L1d L#7 (32KB) + L1i L#7 (32KB) + Core L#7</div><div class="line">        PU L#14 (P#7)</div><div class="line">        PU L#15 (P#23)</div><div class="line">    HostBridge L#0</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#0 &quot;enp1s0f0&quot;</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#1 &quot;enp1s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#2 &quot;enp4s0f0&quot;</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#3 &quot;enp4s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 1000:0097</div><div class="line">          Block(Disk) L#4 &quot;sda&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#5 &quot;enp8s0f0&quot;</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#6 &quot;enp8s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCIBridge</div><div class="line">          PCI 1a03:2000</div><div class="line">            GPU L#7 &quot;card0&quot;</div><div class="line">            GPU L#8 &quot;controlD64&quot;</div><div class="line">  NUMANode L#1 (P#1 47GB)</div><div class="line">    Package L#1 + L3 L#1 (20MB)</div><div class="line">      L2 L#8 (256KB) + L1d L#8 (32KB) + L1i L#8 (32KB) + Core L#8</div><div class="line">        PU L#16 (P#8)</div><div class="line">        PU L#17 (P#24)</div><div class="line">      L2 L#9 (256KB) + L1d L#9 (32KB) + L1i L#9 (32KB) + Core L#9</div><div class="line">        PU L#18 (P#9)</div><div class="line">        PU L#19 (P#25)</div><div class="line">      L2 L#10 (256KB) + L1d L#10 (32KB) + L1i L#10 (32KB) + Core L#10</div><div class="line">        PU L#20 (P#10)</div><div class="line">        PU L#21 (P#26)</div><div class="line">      L2 L#11 (256KB) + L1d L#11 (32KB) + L1i L#11 (32KB) + Core L#11</div><div class="line">        PU L#22 (P#11)</div><div class="line">        PU L#23 (P#27)</div><div class="line">      L2 L#12 (256KB) + L1d L#12 (32KB) + L1i L#12 (32KB) + Core L#12</div><div class="line">        PU L#24 (P#12)</div><div class="line">        PU L#25 (P#28)</div><div class="line">      L2 L#13 (256KB) + L1d L#13 (32KB) + L1i L#13 (32KB) + Core L#13</div><div class="line">        PU L#26 (P#13)</div><div class="line">        PU L#27 (P#29)</div><div class="line">      L2 L#14 (256KB) + L1d L#14 (32KB) + L1i L#14 (32KB) + Core L#14</div><div class="line">        PU L#28 (P#14)</div><div class="line">        PU L#29 (P#30)</div><div class="line">      L2 L#15 (256KB) + L1d L#15 (32KB) + L1i L#15 (32KB) + Core L#15</div><div class="line">        PU L#30 (P#15)</div><div class="line">        PU L#31 (P#31)</div><div class="line">    HostBridge L#7</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#9 &quot;enp132s0f0&quot;</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#10 &quot;enp132s0f1&quot;</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div></pre></td></tr></table></figure>
<p>如果是桌面环境，则会弹窗一个窗口：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hwloc.png" alt="hwloc"></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[firewalld和iptables]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/firewalld%E5%92%8Ciptables/</url>
      <content type="html"><![CDATA[<p>centos7上关于打开和关闭防火墙及端口略有区别，记录之~<br><a id="more"></a><br>Centos升级到7之后，使用firewalld代替了原来的iptables，控制Linuxs的端口。firewalld是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。</p>
<h2 id="防火墙的设置"><a href="#防火墙的设置" class="headerlink" title="防火墙的设置"></a>防火墙的设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl stop firewalld 		# 停止firewall</div><div class="line">systemctl disable firewalld 	# 禁止firewall开机启动</div><div class="line">systemctl start firewalld 		# 开启防火墙</div></pre></td></tr></table></figure>
<h2 id="端口操作"><a href="#端口操作" class="headerlink" title="端口操作"></a>端口操作</h2><p>查看已开放的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># firewall-cmd --list-ports</div><div class="line">6789/tcp 6800-7100/tcp</div></pre></td></tr></table></figure>
<p>开启端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</div></pre></td></tr></table></figure>
<p>命令含义：<br>–zone #作用域<br>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent   #永久生效，没有此参数重启后失效</p>
<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure>
<p>查询9200端口是否打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --query-port=9200/tcp</div></pre></td></tr></table></figure>
<h2 id="使用iptables"><a href="#使用iptables" class="headerlink" title="使用iptables"></a>使用iptables</h2><p>如果你要改用iptables的话，需要安装iptables服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install iptables-services</div><div class="line">sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables</div><div class="line">sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[S.M.A.R.T--磁盘健康状态监测工具]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/S-M-A-R-T-%E7%A3%81%E7%9B%98%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>介绍磁盘状态监测工具：S.M.A.R.T。<br><a id="more"></a></p>
<h2 id="S-M-A-R-T"><a href="#S-M-A-R-T" class="headerlink" title="S.M.A.R.T."></a>S.M.A.R.T.</h2><p><strong>S.M.A.R.T.</strong>，全称为“Self-Monitoring Analysis and Reporting Technology”，即“自我监测、分析及报告技术”，是一种自动的硬盘状态检测与预警系统和规范。通过在硬盘硬件内的检测指令对硬盘的硬件如磁头、盘片、马达、电路的运行情况进行监控、记录并与厂商所设定的预设安全值进行比较，若监控情况将或已超出预设安全值的安全范围，就可以通过主机的监控硬件或软件自动向用户作出警告并进行轻微的自动修复，以提前保障硬盘数据的安全。</p>
<p>软件包 <strong>smartmontools</strong> 它通过使用自我监控(Self-Monitoring)、分析(Analysis)和报告(Reporting)三种技术（缩写为S.M.A.R.T或SMART）来管理和监控存储硬件。如今大部分的ATA/SATA、SCSI/SAS和固态硬盘都搭载内置的SMART系统。SMART的目的是监控硬盘的可靠性、预测磁盘故障和执行各种类型的磁盘自检。smartmontools由smartctl和smartd两部分工具程序组成，它们一起为Linux平台提供对磁盘退化和故障的高级警告。</p>
<blockquote>
<p>文章内容大部分为转载，硬盘信息和配置部分为自己实验所得。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install smartmontools</div></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">smartctl -a  &lt;device&gt;    		显示硬盘所有SMART信息。</div><div class="line">smartctl -i &lt;device&gt;   			显示硬盘model number, serial number,是否开启SMART等信息。</div><div class="line">smartctl -s on &lt;device&gt;    		如果没有打开SMART技术，使用该命令打开SMART技术。</div><div class="line">smartctl -t short &lt;device&gt;    	后台检测硬盘，消耗时间短</div><div class="line">smartctl -t long &lt;device&gt;      	后台检测硬盘，消耗时间长</div><div class="line">smartctl -C -t short &lt;device&gt; 	前台检测硬盘，消耗时间短</div><div class="line">smartctl -C -t long &lt;device&gt;  	前台检测硬盘，消耗时间长</div><div class="line">smartctl -X &lt;device&gt;  			中断后台检测硬盘。</div><div class="line">smartctl -l selftest &lt;device&gt;  	显示硬盘检测日志。</div><div class="line">smartctl -l error &lt;device&gt; 		显示硬盘错误汇总。</div></pre></td></tr></table></figure>
<p>列出和系统相连的硬盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /dev | grep -E &apos;sd|hd&apos;</div></pre></td></tr></table></figure>
<h2 id="显示出某个指定硬盘的信息"><a href="#显示出某个指定硬盘的信息" class="headerlink" title="显示出某个指定硬盘的信息"></a>显示出某个指定硬盘的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># smartctl --info /dev/sdc</div><div class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</div><div class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</div><div class="line"></div><div class="line">=== START OF INFORMATION SECTION ===</div><div class="line">Device Model:     TOSHIBA MG03ACA400</div><div class="line">Serial Number:    565BK4CXF</div><div class="line">LU WWN Device Id: 5 000039 70bc0043a</div><div class="line">Firmware Version: FL1A</div><div class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</div><div class="line">Sector Size:      512 bytes logical/physical</div><div class="line">Rotation Rate:    7200 rpm</div><div class="line">Device is:        Not in smartctl database [for details use: -P showall]</div><div class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</div><div class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</div><div class="line">Local Time is:    Sun May  7 15:10:58 2017 CST</div><div class="line">SMART support is: Available - device has SMART capability.</div><div class="line">SMART support is: Enabled</div></pre></td></tr></table></figure>
<h2 id="检测某个硬盘的健康状况"><a href="#检测某个硬盘的健康状况" class="headerlink" title="检测某个硬盘的健康状况"></a>检测某个硬盘的健康状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"># smartctl -s on -a /dev/sdc</div><div class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</div><div class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</div><div class="line"></div><div class="line">=== START OF INFORMATION SECTION ===</div><div class="line">Device Model:     TOSHIBA MG03ACA400</div><div class="line">Serial Number:    565BK4CXF</div><div class="line">LU WWN Device Id: 5 000039 70bc0043a</div><div class="line">Firmware Version: FL1A</div><div class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</div><div class="line">Sector Size:      512 bytes logical/physical</div><div class="line">Rotation Rate:    7200 rpm</div><div class="line">Device is:        Not in smartctl database [for details use: -P showall]</div><div class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</div><div class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</div><div class="line">Local Time is:    Sun May  7 15:12:44 2017 CST</div><div class="line">SMART support is: Available - device has SMART capability.</div><div class="line">SMART support is: Enabled</div><div class="line"></div><div class="line">=== START OF ENABLE/DISABLE COMMANDS SECTION ===</div><div class="line">SMART Enabled.</div><div class="line"></div><div class="line">=== START OF READ SMART DATA SECTION ===</div><div class="line">SMART overall-health self-assessment test result: PASSED</div><div class="line"></div><div class="line">General SMART Values:</div><div class="line">Offline data collection status:  (0x82)	Offline data collection activity</div><div class="line">					was completed without error.</div><div class="line">					Auto Offline Data Collection: Enabled.</div><div class="line">Self-test execution status:      (   0)	The previous self-test routine completed</div><div class="line">					without error or no self-test has ever</div><div class="line">					been run.</div><div class="line">Total time to complete Offline</div><div class="line">data collection: 		(  120) seconds.</div><div class="line">Offline data collection</div><div class="line">capabilities: 			 (0x5b) SMART execute Offline immediate.</div><div class="line">					Auto Offline data collection on/off support.</div><div class="line">					Suspend Offline collection upon new</div><div class="line">					command.</div><div class="line">					Offline surface scan supported.</div><div class="line">					Self-test supported.</div><div class="line">					No Conveyance Self-test supported.</div><div class="line">					Selective Self-test supported.</div><div class="line">SMART capabilities:            (0x0003)	Saves SMART data before entering</div><div class="line">					power-saving mode.</div><div class="line">					Supports SMART auto save timer.</div><div class="line">Error logging capability:        (0x01)	Error logging supported.</div><div class="line">					General Purpose Logging supported.</div><div class="line">Short self-test routine</div><div class="line">recommended polling time: 	 (   2) minutes.</div><div class="line">Extended self-test routine</div><div class="line">recommended polling time: 	 ( 616) minutes.</div><div class="line">SCT capabilities: 	       (0x003d)	SCT Status supported.</div><div class="line">					SCT Error Recovery Control supported.</div><div class="line">					SCT Feature Control supported.</div><div class="line">					SCT Data Table supported.</div><div class="line"></div><div class="line">SMART Attributes Data Structure revision number: 16</div><div class="line">Vendor Specific SMART Attributes with Thresholds:</div><div class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</div><div class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</div><div class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</div><div class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</div><div class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</div><div class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</div><div class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</div><div class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</div><div class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</div><div class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</div><div class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</div><div class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</div><div class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</div><div class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</div><div class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</div><div class="line"></div><div class="line">SMART Error Log Version: 1</div><div class="line">No Errors Logged</div><div class="line"></div><div class="line">SMART Self-test log structure revision number 1</div><div class="line">No self-tests have been logged.  [To run self-tests, use: smartctl -t]</div><div class="line"></div><div class="line"></div><div class="line">SMART Selective self-test log data structure revision number 1</div><div class="line"> SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS</div><div class="line">    1        0        0  Not_testing</div><div class="line">    2        0        0  Not_testing</div><div class="line">    3        0        0  Not_testing</div><div class="line">    4        0        0  Not_testing</div><div class="line">    5        0        0  Not_testing</div><div class="line">Selective self-test flags (0x0):</div><div class="line">  After scanning selected spans, do NOT read-scan remainder of disk.</div><div class="line">If Selective self-test is pending on power-up, resume after 0 minute delay.</div></pre></td></tr></table></figure>
<p>其中，”READ SMART DATA”部分显示出硬盘的整体健康状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">=== START OF READ SMART DATA SECTION ===</div><div class="line">SMART overall-health self-assessment test result: PASSED</div></pre></td></tr></table></figure>
<h2 id="SMART属性表"><a href="#SMART属性表" class="headerlink" title="SMART属性表"></a>SMART属性表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</div><div class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</div><div class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</div><div class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</div><div class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</div><div class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</div><div class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</div><div class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</div><div class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</div><div class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</div><div class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</div><div class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</div><div class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</div><div class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</div><div class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</div></pre></td></tr></table></figure>
<p>SMART属性表列出了制造商在硬盘中定义好的属性值，以及这些属性相关的故障阈值。这个表由驱动固件自动生成和更新。</p>
<ul>
<li><strong>ID</strong>：属性ID，通常是一个1到255之间的十进制或十六进制的数字。</li>
<li><strong>ATTRIBUTE_NAME</strong>：硬盘制造商定义的属性名。</li>
<li><strong>FLAG</strong>：属性操作标志（可以忽略）。</li>
<li><strong>VALUE</strong>：这是表格中最重要的信息之一，代表给定属性的标准化值，在1到253之间。253意味着最好情况，1意味着最坏情况。取决于属性和制造商，初始化VALUE可以被设置成100或200.</li>
<li><strong>WORST</strong>：所记录的最小VALUE。</li>
<li><strong>THRESH</strong>：在报告硬盘FAILED状态前，WORST可以允许的最小值。</li>
<li><strong>TYPE</strong>：属性的类型（Pre-fail或Old<em>age）。Pre-fail类型的属性可被看成一个关键属性，表示参与磁盘的整体SMART健康评估（PASSED/FAILED）。如果任何Pre-fail类型的属性故障，那么可视为磁盘将要发生故障。另一方面，Old</em>age类型的属性可被看成一个非关键的属性（如正常的磁盘磨损），表示不会使磁盘本身发生故障。</li>
<li><strong>UPDATED</strong>：表示属性的更新频率。Offline代表磁盘上执行离线测试的时间。</li>
<li><strong>WHEN_FAILED</strong>：如果VALUE小于等于THRESH，会被设置成“FAILING_NOW”；如果WORST小于等于THRESH会被设置成“In_the_past”；如果都不是，会被设置成“-”。在“FAILING_NOW”情况下，需要尽快备份重要文件，特别是属性是Pre-fail类型时。“In_the_past”代表属性已经故障了，但在运行测试的时候没问题。“-”代表这个属性从没故障过。</li>
<li><strong>RAW_VALUE</strong>：制造商定义的原始值，从VALUE派生。</li>
</ul>
<h2 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h2><p>编辑smartctl的配置文件(/etc/default/smartmontools)以便在系统启动时启动smartd，并以秒为单位指定间隔时间（如7200 = 2小时）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start_smartd=yes</div><div class="line">smartd_opts=&quot;--interval=7200&quot;</div></pre></td></tr></table></figure>
<p>编辑smartd的配置文件，添加以下行内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># vim /etc/smartmontools/smartd</div><div class="line">smartd.conf        smartd_warning.d/  smartd_warning.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda -m myemail@mydomain.com -M test</div></pre></td></tr></table></figure>
<p><strong>-m </strong>：指定发送测试报告到某个电子邮件地址。这里可以是系统用户比如root，或者如果服务器已经配置成发送电子邮件到系统外部，则是类似于<a href="mailto:myemail@mydomain.com" target="_blank" rel="external">myemail@mydomain.com</a>的邮件地址。</p>
<p><strong>-M </strong>：指定发送邮件报告的期望类型。</p>
<ul>
<li><strong>once</strong>：为检测到的每种磁盘问题只发送一封警告邮件。</li>
<li><strong>daily</strong>：为检测到的每种磁盘问题每隔一天发送一封额外的警告提醒邮件。</li>
<li><strong>diminishing</strong>：为检测到的每种问题发送一封额外的警告提醒邮件，开始是每隔一天，然后每隔两天，每隔四天，以此类推。每个间隔是前一次间隔的2倍。</li>
<li><strong>test</strong>：只要smartd一启动，立即发送一封测试邮件。</li>
<li><strong>exec PATH</strong>：取代默认的邮件命令，运行PATH路径下的可执行文件。PATH必须指向一个可执行的二进制文件或脚本。当检测到一个问题时，可以指定执行一个期望的动作（闪烁控制台、关闭系统等等）。</li>
</ul>
<p>保存改动并重启smartd。</p>
<p>可以使用“-s”标志和形如“T/MM/DD/d/HH”的正则表达式按照想要的调度方案执行测试，其中：</p>
<p>正则表达式中的T代表测试的类型：</p>
<ul>
<li>L：长测试</li>
<li>S：短测试</li>
<li>C：传输测试（仅限ATA）</li>
<li>O：离线测试（仅限ATA）</li>
</ul>
<p>其它的字符代表测试执行的日期和时间：</p>
<ul>
<li>MM是一年中的月份。</li>
<li>DD是一月中的天份。</li>
<li>HH是一天中的小时。</li>
<li>d是一个星期中的某天（从1=周一到7=周日）。</li>
<li>MM、DD和HH使用两位十进制数字表示。</li>
</ul>
<p>在上述表达中的小圆点表示所有可能的值。形如’(A|B|C)’在圆括号里的表达式表示三个可能值A、B和C中的任意一个。形如[1-5]在方括号中的表达式表示1到5的范围（包含5）.</p>
<p>例如，想要在每个工作日的下午一点为所有的磁盘执行一次长测试，在/etc/smartd.conf中添加如下行内容。确保编辑完重启smartd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEVICESCAN -s (L/../../[1-5]/13)</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/S.M.A.R.T" target="_blank" rel="external">https://zh.wikipedia.org/wiki/S.M.A.R.T</a>.</p>
<p><a href="https://linux.cn/article-4461-1.html" target="_blank" rel="external">使用 smartmontools 查看硬盘的健康状态</a></p>
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2配色--zsh & oh-my-zsh]]></title>
      <url>http://xiaqunfeng.cc/2017/05/04/iterm2%E9%85%8D%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>给iterm2进行配色，炫酷一点。<br><a id="more"></a></p>
<h3 id="Solarized"><a href="#Solarized" class="headerlink" title="Solarized"></a>Solarized</h3><p>目前网络上最流行的配色解决方案：<a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">Solarized</a></p>
<p>Solarized Dark 官方网站: <a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">http://ethanschoonover.com/solarized</a></p>
<p>Solarized Dark github 地址: <a href="https://github.com/altercation/solarized" target="_blank" rel="external">https://github.com/altercation/solarized</a></p>
<p>下载下来后会看到琳琅满目的配色解决方案，其中有一个目录 <code>iterm2-colors-solarized</code> 是为 iterm2 准备的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ls iterm2-colors-solarized/</div><div class="line">.md</div><div class="line">Solarized Dark.itermcolors</div><div class="line">Solarized Light.itermcolors</div></pre></td></tr></table></figure>
<p>进入目录能看到 3个文件 (1个 md说明文件,2个配色文件) </p>
<p>我们使用其中一个 Solarized Dark.itermcolors</p>
<p>然后 preferences -&gt; colors -&gt; import 即可。</p>
<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>众所周知在Unix/Linux系统下是存在很多不同的shell，常见的就有bash, csh，ksh，zsh等等。在Linux和MAC OS系统中，默认使用的是bash。这里介绍功能更加强大的 <strong>zsh</strong>。</p>
<p>1、通过homebrew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install zsh</div></pre></td></tr></table></figure>
<p>2、将zsh设置成系统默认shell，以代替bash</p>
<p>用编辑器打开<code>/etc/shells</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/zsh</div></pre></td></tr></table></figure>
<p> 在终端中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /usr/local/bin/zsh</div></pre></td></tr></table></figure>
<p>然后重新启动iTerm2，zsh就已经被配置成默认的shell了。</p>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p>github：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh</a></p>
<p>1、安装</p>
<p> <strong>on-my-zsh</strong>的安装支持自动和手动，为了省去麻烦，我建议优先使用自动，如果要使用手动安装，请查看安装说明。这里只说一下自动安装。 在终端里，如果你有<code>curl</code>，则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L http://install.ohmyz.sh | sh</div></pre></td></tr></table></figure>
<p>如果你使用<code>wget</code>,则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div></pre></td></tr></table></figure>
<p>这样oh-my-zsh就安装完成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">~/.oh-my-zsh  master ✔                                                              1d</div><div class="line">▶ ls</div><div class="line">CONTRIBUTING.md cache           log             templates</div><div class="line">LICENSE.txt     custom          oh-my-zsh.sh    themes</div><div class="line">README.md       lib             plugins         tools</div></pre></td></tr></table></figure>
<p>2、配置</p>
<p>zsh的配置在<code>~/.zshrc</code>下面这</p>
<p>主题的配置</p>
<p>在<code>~/.oh-my-zsh/themes</code>存在各式各样的主题文件，每个主题可以通过：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a> 进行查看。选好样式后，</p>
<p>在<code>.zshrc</code>中的 <code>ZSH_THEME</code>设置成你所选用的主题，重启iTerm2，就可以看到相应的效果。我这里用的 <strong>avit</strong>。上面哪个oh-my-zsh 文件夹目录的列表就是用的这个主题。</p>
<p>如果使用agnoster主题的话还需要装字体包，如下：</p>
<p><a href="https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher" target="_blank" rel="external">https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher</a></p>
<p><a href="https://github.com/powerline/fonts" target="_blank" rel="external">https://github.com/powerline/fonts</a></p>
<h3 id="更多的配色方案"><a href="#更多的配色方案" class="headerlink" title="更多的配色方案"></a>更多的配色方案</h3><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="external">https://github.com/mbadolato/iTerm2-Color-Schemes</a></p>
<p>可以根据自己的喜好来选择主题了。</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</div><div class="line">echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc</div><div class="line">source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</div></pre></td></tr></table></figure>
<p>在 .zshrc 尾部添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(zsh-syntax-highlighting)</div></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.zshrc</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iterm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx使用和配置]]></title>
      <url>http://xiaqunfeng.cc/2017/05/03/nginx%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>简单介绍nginx，特别是反向代理和负载均衡部分，并用通过实战加深理解。<br><a id="more"></a></p>
<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<p>架设服务器均衡负载方式有多种，Nginx、LVS、HAProxy+Keepalived是目前使用最广泛的三种方案。其中Keepalived+HAProxy是一个高可用性方案。</p>
<p>nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。</p>
<ul>
<li>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</li>
<li>多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。基本的网络事件，在worker进程中处理。</li>
</ul>
<p>nginx模块一般被分成三大类：handler、filter和upstream。</p>
<p>使用<code>Nginx</code>的方法就是写配置文件，配置文件能完全控制<code>Nginx</code>，使<code>Nginx</code>按照我们的需求进行运行。</p>
<blockquote>
<p>关于nginx的配置文件，需要深入了解和使用的可以去学习一下。</p>
</blockquote>
<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>OS: CentOS 7.3</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nginx -y</div></pre></td></tr></table></figure>
<p>关闭防火墙和selinux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># systemctl stop firewalld</div><div class="line"># systemctl disable firewalld</div><div class="line"></div><div class="line"># setenforce 0</div><div class="line">setenforce: SELinux is disabled</div><div class="line"># getenforce</div><div class="line">Disabled</div></pre></td></tr></table></figure>
<p>添加至服务列表，开机自动启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># chkconfig --add nginx</div><div class="line"># chkconfig nginx on </div><div class="line"># chkconfig nginx --list</div></pre></td></tr></table></figure>
<p>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service nginx start</div><div class="line">Redirecting to /bin/systemctl start  nginx.service</div></pre></td></tr></table></figure>
<p>查看端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># netstat -ntlp | grep :80</div><div class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      16858/nginx: master</div><div class="line">tcp6       0      0 :::80                   :::*                    LISTEN      16858/nginx: master</div></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost" target="_blank" rel="external">http://localhost</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-welcome.png" alt="nginx-welcome"></p>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx -s reload</div><div class="line">或者</div><div class="line">service nginx restart</div></pre></td></tr></table></figure>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>1、代理</p>
<p>所谓代理，就是在客户端和服务端之间强行添加了一层，用来实现流量转发的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+----------------+         +---------------+        +--------------+</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |  http   |               | http   |              |</div><div class="line">|    client      &lt;---------&gt;    proxy      &lt;--------&gt;   server     |</div><div class="line">|                |  https  |               | https  |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">+----------------+         +---------------+        +--------------+</div></pre></td></tr></table></figure>
<p>2、正向代理</p>
<p>用于代理客户端。</p>
<p>比如：我是一个用户，我访问不了某网站（例如google），但是我能访问一个代理服务器，这个代理服务器能访问google，于是我先连上代理服务器，告诉他我需要访问google的内容，代理服务器去取回来，然后返回给我。自此，一次正向代理顺利完成。</p>
<p>3、反向代理</p>
<p>用来代理服务端。</p>
<p>依然拿google举例，网站每秒钟要处理很多请求，如果仅仅让一台单一的服务器处理，肯定应付不过来。所以采用多台服务器来处理这些请求，减少每台服务器的压力。但是多个服务器那就产生了多个Server，我的一个<code>google.com</code>就不能解析到这些服务器上，而且用多个二级域名比如<code>server1.google.com</code>，<code>server2.google.com</code>等等也给用户造成了使用上的不便，通过反向代理可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+-------------+                                             |      |                   |</div><div class="line">|             +----------+                                  |      |                   |</div><div class="line">|  client 1   |          |                                  |      +-------------------+</div><div class="line">|             |          |                                  |</div><div class="line">+-------------+          |                                  |</div><div class="line">                         |         +------------------+     |      +-------------------+</div><div class="line">                         |         |                  |     |      |                   |</div><div class="line">+-------------+          |         |                  |     |      |   server 2        |</div><div class="line">|             |          |         |                  +------------&gt;                   |</div><div class="line">|  clent 2    +--------------------&gt;  reverse proxy   |     |      |                   |</div><div class="line">|             |          |         |                  |     |      +-------------------+</div><div class="line">+-------------+          |         |                  |     |</div><div class="line">                         |         |                  |     |               .</div><div class="line">      .                  |         |                  |     |               .</div><div class="line">      .                  |         +------------------+     |               .</div><div class="line">      .                  |                                  |</div><div class="line">                         |                                  |      +--------------------+</div><div class="line">+-------------+          |                                  |      |                    |</div><div class="line">|             |          |                                  |      |   server m         |</div><div class="line">|  client n   +----------+                                  +------&gt;                    |</div><div class="line">|             |                                                    |                    |</div><div class="line">+-------------+                                                    +--------------------+</div></pre></td></tr></table></figure>
<p> 结论就是，客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>
<p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>
<p>代理模块的指令有很多我这里只讲解重要的proxy_pass，这个模块可以转发请求到其他的服务器。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>一台机器装有Nginx，两台测试机装httpd</p>
<h4 id="测试机httpd配置"><a href="#测试机httpd配置" class="headerlink" title="测试机httpd配置"></a>测试机httpd配置</h4><p>1、安装httpd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install httpd -y</div></pre></td></tr></table></figure>
<p>2、提供页面测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph0机器</div><div class="line">echo &quot;&lt;h1&gt;ceph0.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</div><div class="line"># ceph1机器</div><div class="line">echo &quot;&lt;h1&gt;ceph1.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</div></pre></td></tr></table></figure>
<p>3、启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service httpd start</div></pre></td></tr></table></figure>
<p>如果启动失败的话注意查看是否80端口被占用</p>
<p>4、web上登录ceph0和ceph1机器IP查看</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph0.png" alt="ceph0"></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph1.png" alt="ceph1"></p>
<p>注意：Nginx和httpd都监听在80端口，https监听在443端口</p>
<p>如果要修改httpd的监听端口的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf/httpd.conf</div><div class="line">...</div><div class="line">Listen 80		# 修改这一行</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="nginx配置和测试"><a href="#nginx配置和测试" class="headerlink" title="nginx配置和测试"></a>nginx配置和测试</h4><p>设置配置文件，设置完后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># cat /etc/nginx/conf.d/test.conf</div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://123.59.204.185:80;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx -t</div><div class="line">nginx -s reload</div><div class="line">service nginx restart</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>去ceph0机器上查看日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@ceph0 ~]# tail /var/log/httpd/access_log</div><div class="line">180.168.57.238 - - [03/May/2017:10:27:17 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">123.59.185.23 - - [03/May/2017:11:25:30 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</div><div class="line">123.59.185.23 - - [03/May/2017:11:29:40 +0800] &quot;GET / HTTP/1.0&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</div></pre></td></tr></table></figure>
<p>注意这里 HTTP/1.1和HTTP/1.0的区别</p>
<p>proxy_pass模块可以转发请求到其他的服务器。nginx为浏览器发送HTTP/1.1，为后端服务器发送HTTP/1.0。</p>
<p>HTTP/1.0无法使用keepalive（后端服务器将为每个请求创建并且删除连接），这样浏览器就可以为浏览器处理keepalive。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>upstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>Nginx的负载均衡模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方调度算法。  </p>
<ul>
<li>轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight 指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。（一般电子商务网站用的比较多）</li>
<li>fair。这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li>url_hash。此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li>
</ul>
<blockquote>
<p>在 ip_hash 策略中，用于进行 hash 运算的 key，是 client 的 C 类 IP 地址（C 类 IP 地址就是范围在 192.0.0.0 到 223.255.255.255 之间，前三段号码表示子网，第四段号码为本地主机的 IP 地址类别）。这样的方式保证一个 client 每次请求都将到达同一个 backend。当然，如果所 hash 到的 backend 当前不可用，则请求会被转移到其他 backend。</p>
</blockquote>
<h3 id="upstream-支持的状态参数"><a href="#upstream-支持的状态参数" class="headerlink" title="upstream 支持的状态参数"></a>upstream 支持的状态参数</h3><p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：      </p>
<ul>
<li>down，表示当前的server暂时不参与负载均衡。</li>
<li>weight 默认为1。weight越大，负载的权重就越大。</li>
<li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li>
<li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li>
<li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<blockquote>
<p>注，当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>
<p>如果负载均衡把请求分配到backup服务器上，就不能能访问到期望的页面了。</p>
<p>weight和 ip_hash是不同的策略。</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80 weight=1 max_fails=2 fial_timeout=2;</div><div class="line">    server 123.59.204.193:80 down;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>server 185的权重为1，当请求失败的次数为2时，返回错误，并暂停服务2秒。</p>
<p>Server 193 down了，不会被访问到。</p>
<h3 id="配置负载均衡服务器"><a href="#配置负载均衡服务器" class="headerlink" title="配置负载均衡服务器"></a>配置负载均衡服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat conf.d/test.conf</div><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80;</div><div class="line">    server 123.59.204.193:80;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    server_name itest.com;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://itest;</div><div class="line">#        proxy_set_header  X-Real-IP  $remote_addr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@nginx]# curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</div><div class="line">[root@nginx]# curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph1.test.com&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>百分之50的概率读取到一台机器</p>
<p>注，upstream是定义在server{ }之外的，不能定义在server{ }内部。定义好upstream之后，用proxy_pass引用一下即可。</p>
<h2 id="备份服务器"><a href="#备份服务器" class="headerlink" title="备份服务器"></a>备份服务器</h2><p>配置nginx文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># cat /etc/nginx/conf.d/test.conf</div><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80;</div><div class="line">    server 123.59.204.193:80;</div><div class="line">    server 127.0.0.1:8000 backup;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    server_name itest.com;</div><div class="line">    root /root/errorpage;</div><div class="line">    index index.html;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://itest;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件夹和index文件的建立</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mkdir /root/errorpage</div><div class="line"># cat index.html</div><div class="line">&lt;h1&gt;Sorry, all ceph node is down! Please try again later!&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>另外两台机器上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service httpd stop</div></pre></td></tr></table></figure>
<p>然后再访问的话就会访问到备份服务器，输出index.html的内容。</p>
<p>附一个关于nginx的好系列文章：<a href="http://blog.csdn.net/poechant/article/details/7213546" target="_blank" rel="external">高性能Web服务器Nginx的配置与部署研究</a></p>
<p>有空学习，mark之。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2快捷键的使用]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>mac下终端神器iterm2，非常的好用，极大提高了效率，这里将自己使用过的快捷键总结如下。<br><a id="more"></a></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>新建tab：⌘ + t</p>
<p>切换 tab：    ⌘+←, ⌘+→</p>
<p>​            ⌘+{, ⌘+}</p>
<p>​            ⌘ + Num</p>
<p>切换全屏：⌘ + enter</p>
<p>关闭tab：⌘ + w</p>
<h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p>
<p>切换Tab中的pane：⌘ + [ / ]</p>
<p>按方向切换 pane：⌘+Option+方向键</p>
<p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p>
<p>关闭panel：⌘ + w</p>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>智能查找，支持正则查找：⌘+f</p>
<p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p>
<p>自动填充：⌘ + ； 命令补全提示 </p>
<p>打开最近目录： ⌘ + alt + /</p>
<p>窗口太多，快速定位到光标所在位置：⌘ + / </p>
<p>鼠标所在行高亮显示： ⌘ + alt + ； </p>
<p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p>
<p>⌘+Shift+h弹出历史记录窗口</p>
<p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p>
<p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p>
<h2 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h2><p>可以拖拽选中的字符串</p>
<p>可以点击 url：调用默认浏览器访问该网址</p>
<p>可以点击文件：调用默认程序打开文件</p>
<p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p>
<p>点击文件夹：在 finder 中打开该文件夹</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>设置标记：⌘ + shift + m </p>
<p>跳转到上个标记：⌘ + shift + j</p>
<p>多个标记切换：⌘ + shift + arrow(上下)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>置空屏幕: clear </p>
<p>​        ctrl + l </p>
<p>​        ⌘ + k</p>
<p>清空屏幕: command + k/r</p>
<p>字体调大:  command + +</p>
<p>字体调小:  command + -</p>
<p>清除当前行：ctrl + u</p>
<p>到行首：ctrl + a</p>
<p>到行尾：ctrl + e</p>
<p>从光标处删至字首/尾：ctrl + w / k</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iterm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VSM部署]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/VSM%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>本文介在已有ceph集群机器上部署VSM的过程，涵盖centos和ubuntu两种系统。<br><a id="more"></a></p>
<h2 id="VSM-Virtual-Storage-Manager"><a href="#VSM-Virtual-Storage-Manager" class="headerlink" title="VSM - Virtual Storage Manager"></a>VSM - Virtual Storage Manager</h2><p>最新发布的release版本为2.1，pre-release版本为2.2，已不再更新和维护（因为负责人<a href="mailto:yaguang.wang@intel.com" target="_blank" rel="external">yaguang.wang@intel.com</a> or <a href="mailto:ferber.dan@intel.com" target="_blank" rel="external">ferber.dan@intel.com</a>已经从intel离职了）。</p>
<p>从2.1版本开始，VSM支持在已有ceph集群上部署，正是因为这个原因，才开始尝试部署VSM。</p>
<p>VSM 2.1的代码组件分为四个：</p>
<ul>
<li>vsm-dashboard：VSM的管理与监控web界面</li>
<li>python-vsmclient：调用restapi的client</li>
<li>vsm：VSM的核心组件（包括api、scheduler、conductor、agent等）</li>
<li>vsm-deploy：ceph部署工具</li>
</ul>
<p>代码基于Python语言，使用了wsgi、django等技术框架。</p>
<p>Git主页：<br><a href="https://github.com/01org/virtual-storage-manager" target="_blank" rel="external">https://github.com/01org/virtual-storage-manager</a></p>
<p>vsm-dependencies：<br><a href="https://github.com/01org/vsm-dependencies" target="_blank" rel="external">https://github.com/01org/vsm-dependencies</a></p>
<p>VSM系统有两个角色，一个是vsm-controller，另外一个是vsm-agent：</p>
<ul>
<li>vsm-agent部署在ceph节点上</li>
<li>vsm-controller部署在单独的任意节点（也可以部署在ceph节点上）</li>
</ul>
<p>架构图如下：<img src="http://oow6unnib.bkt.clouddn.com/vsm-architecture.png" alt="vsm-architecture"></p>
<h2 id="centos上部署"><a href="#centos上部署" class="headerlink" title="centos上部署"></a>centos上部署</h2><p>OS：CentOS 7.2</p>
<p>VSM：v2.1 released</p>
<p>4台机器，一个作为controller，三台ceph集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">172.20.2.76     ceph0</div><div class="line">172.20.2.77     ceph1</div><div class="line">172.20.2.79     ceph2</div><div class="line">172.20.2.81     controller</div></pre></td></tr></table></figure>
<p>1、从controller机器上设置到ceph集群机器和自己的免密登录</p>
<p>2、关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># systemctl disable firewalld</div><div class="line"># systemctl stop firewalld</div></pre></td></tr></table></figure>
<p>3、关闭selinux</p>
<p>临时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setenforce 0</div></pre></td></tr></table></figure>
<p>永久</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/selinux/config | grep -v &quot;#&quot;</div><div class="line"></div><div class="line">SELINUX=disabled</div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
<h3 id="下载VSM："><a href="#下载VSM：" class="headerlink" title="下载VSM："></a>下载VSM：</h3><p>在controller机器上执行如下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336_centos7.tar.gz</div><div class="line"># tar -zxvf 2.1.0-336_centos7.tar.gz</div><div class="line"># cd 2.1.0-336</div><div class="line"># ls</div><div class="line">CHANGELOG.md   INSTALL.pdf  manifest      RELEASE       vsm-dep-repo</div><div class="line">CHANGELOG.pdf  installrc    NOTICE        rpms.lst      vsm-dep.repo</div><div class="line">get_pass.sh    install.sh   prov_node.sh  uninstall.sh  vsmrepo</div><div class="line">INSTALL.md     LICENSE      README.md     VERSION       vsm.repo</div></pre></td></tr></table></figure>
<h3 id="配置文件installrc"><a href="#配置文件installrc" class="headerlink" title="配置文件installrc"></a>配置文件installrc</h3><p>设置控制节点和代理节点的地址，设置完如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cat installrc | egrep -v &quot;#|^$&quot;</div><div class="line">AGENT_ADDRESS_LIST=&quot;172.20.2.76 172.20.2.77 172.20.2.79&quot;</div><div class="line">CONTROLLER_ADDRESS=&quot;172.20.2.81&quot;</div></pre></td></tr></table></figure>
<h3 id="配置manifest"><a href="#配置manifest" class="headerlink" title="配置manifest"></a>配置manifest</h3><p>在文件夹manifest中，分别创建以管理IP地址命名的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls manifest/</div><div class="line">172.20.2.76  172.20.2.79  cluster.manifest.sample</div><div class="line">172.20.2.77  172.20.2.81  server.manifest.sample</div></pre></td></tr></table></figure>
<p>将cluster.manifest.sample 文件复制到 172.20.2.81/cluster.manifest，编辑改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[management_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[100.64.0.22ceph_public_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[ceph_cluster_addr]</div><div class="line">172.20.2.0/24</div></pre></td></tr></table></figure>
<p>将server.manifest.sample 文件复制到 76、77、79文件夹下，重命名为server.manifest，改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vsm_controller_ip]</div><div class="line">172.20.2.81</div></pre></td></tr></table></figure>
<p>注：这里添加磁盘部分不用处理，因为是在已有ceph的集群上安装的。</p>
<p>manifest文件夹目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># tree</div><div class="line">.</div><div class="line">├── 172.20.2.76</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.77</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.79</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.81</div><div class="line">│   └── cluster.manifest</div><div class="line">├── cluster.manifest.sample</div><div class="line">└── server.manifest.sample</div></pre></td></tr></table></figure>
<h3 id="添加epel源"><a href="#添加epel源" class="headerlink" title="添加epel源"></a>添加epel源</h3><p>在ceph集群机器上添加epel源，一般在安装ceph集群的时候就应该已经添加了，如果没有添加的话这里加一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./install.sh -u cephuser -v 2.1 --check-dependence-package</div></pre></td></tr></table></figure>
<p>安装完成后，调用get_pass.sh提取管理密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ./get_pass.sh</div><div class="line">24195bcbce558aa7bd2c</div></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录VSM仪表盘，地址：<a href="https://172.20.2.81:dashboard/vsm" target="_blank" rel="external">https://172.20.2.81:dashboard/vsm</a></p>
<p>用户名：admin</p>
<p>密码：24195bcbce558aa7bd2c</p>
<p>进入后界面如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/vsm-start.png" alt="vsm"></p>
<blockquote>
<p>注意：是https，不是http</p>
</blockquote>
<h2 id="ubuntu上部署"><a href="#ubuntu上部署" class="headerlink" title="ubuntu上部署"></a>ubuntu上部署</h2><p>OS：ubuntu 14.04</p>
<p>安装方法和centos上基本类似，不一样的地方有：</p>
<p>1、下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336-ubuntu14.tar.gz</div></pre></td></tr></table></figure>
<p>2、不需要添加epel源</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于在非ceph集群集群上安装并创建ceph集群后续有空补充。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> monitor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令清单]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<p>转载的文章，里面git命令应有尽有，包含所有常用命令，mark之。<br><a id="more"></a></p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; # 在当前目录新建一个Git代码库</div><div class="line">&gt; $ git init</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个目录，将其初始化为Git代码库</div><div class="line">&gt; $ git init [project-name]</div><div class="line">&gt;</div><div class="line">&gt; # 下载一个项目和它的整个代码历史</div><div class="line">&gt; $ git clone [url]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示当前的Git配置</div><div class="line">&gt; $ git config --list</div><div class="line">&gt;</div><div class="line">&gt; # 编辑Git配置文件</div><div class="line">&gt; $ git config -e [--global]</div><div class="line">&gt;</div><div class="line">&gt; # 设置提交代码时的用户信息</div><div class="line">&gt; $ git config [--global] user.name &quot;[name]&quot;</div><div class="line">&gt; $ git config [--global] user.email &quot;[email address]&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; # 添加指定文件到暂存区</div><div class="line">&gt; $ git add [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 添加指定目录到暂存区，包括子目录</div><div class="line">&gt; $ git add [dir]</div><div class="line">&gt;</div><div class="line">&gt; # 添加当前目录的所有文件到暂存区</div><div class="line">&gt; $ git add .</div><div class="line">&gt;</div><div class="line">&gt; # 添加每个变化前，都会要求确认</div><div class="line">&gt; # 对于同一个文件的多处变化，可以实现分次提交</div><div class="line">&gt; $ git add -p</div><div class="line">&gt;</div><div class="line">&gt; # 删除工作区文件，并且将这次删除放入暂存区</div><div class="line">&gt; $ git rm [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 停止追踪指定文件，但该文件会保留在工作区</div><div class="line">&gt; $ git rm --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 改名文件，并且将这个改名放入暂存区</div><div class="line">&gt; $ git mv [file-original] [file-renamed]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; # 提交暂存区到仓库区</div><div class="line">&gt; $ git commit -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交暂存区的指定文件到仓库区</div><div class="line">&gt; $ git commit [file1] [file2] ... -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交工作区自上次commit之后的变化，直接到仓库区</div><div class="line">&gt; $ git commit -a</div><div class="line">&gt;</div><div class="line">&gt; # 提交时显示所有diff信息</div><div class="line">&gt; $ git commit -v</div><div class="line">&gt;</div><div class="line">&gt; # 使用一次新的commit，替代上一次提交</div><div class="line">&gt; # 如果代码没有任何新变化，则用来改写上一次commit的提交信息</div><div class="line">&gt; $ git commit --amend -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 重做上一次commit，并包括指定文件的新变化</div><div class="line">&gt; $ git commit --amend [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有本地分支</div><div class="line">&gt; $ git branch</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有远程分支</div><div class="line">&gt; $ git branch -r</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有本地分支和远程分支</div><div class="line">&gt; $ git branch -a</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，但依然停留在当前分支</div><div class="line">&gt; $ git branch [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，并切换到该分支</div><div class="line">&gt; $ git checkout -b [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向指定commit</div><div class="line">&gt; $ git branch [branch] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，与指定的远程分支建立追踪关系</div><div class="line">&gt; $ git branch --track [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到指定分支，并更新工作区</div><div class="line">&gt; $ git checkout [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到上一个分支</div><div class="line">&gt; $ git checkout -</div><div class="line">&gt;</div><div class="line">&gt; # 建立追踪关系，在现有分支与指定的远程分支之间</div><div class="line">&gt; $ git branch --set-upstream [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 合并指定分支到当前分支</div><div class="line">&gt; $ git merge [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 选择一个commit，合并进当前分支</div><div class="line">&gt; $ git cherry-pick [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除分支</div><div class="line">&gt; $ git branch -d [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程分支</div><div class="line">&gt; $ git push origin --delete [branch-name]</div><div class="line">&gt; $ git branch -dr [remote/branch]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有tag</div><div class="line">&gt; $ git tag</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在当前commit</div><div class="line">&gt; $ git tag [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在指定commit</div><div class="line">&gt; $ git tag [tag] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除本地tag</div><div class="line">&gt; $ git tag -d [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程tag</div><div class="line">&gt; $ git push origin :refs/tags/[tagName]</div><div class="line">&gt;</div><div class="line">&gt; # 查看tag信息</div><div class="line">&gt; $ git show [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交指定tag</div><div class="line">&gt; $ git push [remote] [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交所有tag</div><div class="line">&gt; $ git push [remote] --tags</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向某个tag</div><div class="line">&gt; $ git checkout -b [branch] [tag]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示有变更的文件</div><div class="line">&gt; $ git status</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的版本历史</div><div class="line">&gt; $ git log</div><div class="line">&gt;</div><div class="line">&gt; # 显示commit历史，以及每次commit发生变更的文件</div><div class="line">&gt; $ git log --stat</div><div class="line">&gt;</div><div class="line">&gt; # 搜索提交历史，根据关键词</div><div class="line">&gt; $ git log -S [keyword]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，每个commit占据一行</div><div class="line">&gt; $ git log [tag] HEAD --pretty=format:%s</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</div><div class="line">&gt; $ git log [tag] HEAD --grep feature</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个文件的版本历史，包括文件改名</div><div class="line">&gt; $ git log --follow [file]</div><div class="line">&gt; $ git whatchanged [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件相关的每一次diff</div><div class="line">&gt; $ git log -p [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示过去5次提交</div><div class="line">&gt; $ git log -5 --pretty --oneline</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有提交过的用户，按提交次数排序</div><div class="line">&gt; $ git shortlog -sn</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件是什么人在什么时间修改过</div><div class="line">&gt; $ git blame [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和工作区的差异</div><div class="line">&gt; $ git diff</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和上一个commit的差异</div><div class="line">&gt; $ git diff --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示工作区与当前分支最新commit之间的差异</div><div class="line">&gt; $ git diff HEAD</div><div class="line">&gt;</div><div class="line">&gt; # 显示两次提交之间的差异</div><div class="line">&gt; $ git diff [first-branch]...[second-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 显示今天你写了多少行代码</div><div class="line">&gt; $ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交的元数据和内容变化</div><div class="line">&gt; $ git show [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交发生变化的文件</div><div class="line">&gt; $ git show --name-only [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交时，某个文件的内容</div><div class="line">&gt; $ git show [commit]:[filename]</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的最近几次提交</div><div class="line">&gt; $ git reflog</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; # 下载远程仓库的所有变动</div><div class="line">&gt; $ git fetch [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有远程仓库</div><div class="line">&gt; $ git remote -v</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个远程仓库的信息</div><div class="line">&gt; $ git remote show [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 增加一个新的远程仓库，并命名</div><div class="line">&gt; $ git remote add [shortname] [url]</div><div class="line">&gt;</div><div class="line">&gt; # 取回远程仓库的变化，并与本地分支合并</div><div class="line">&gt; $ git pull [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 上传本地指定分支到远程仓库</div><div class="line">&gt; $ git push [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 强行推送当前分支到远程仓库，即使有冲突</div><div class="line">&gt; $ git push [remote] --force</div><div class="line">&gt;</div><div class="line">&gt; # 推送所有分支到远程仓库</div><div class="line">&gt; $ git push [remote] --all</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、保持fork分支更新"><a href="#九、保持fork分支更新" class="headerlink" title="九、保持fork分支更新"></a>九、保持fork分支更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1. Clone your fork</div><div class="line">git clone git@github.com:YOUR-USERNAME/YOUR-FORKED-REPO.git</div><div class="line"></div><div class="line">2. Add remote from original repository in your forked repository</div><div class="line">cd into/cloned/fork-repo</div><div class="line">git remote add upstream git://github.com/ORIGINAL-DEV-USERNAME/REPO-YOU-FORKED-FROM.git</div><div class="line">git fetch upstream</div><div class="line"></div><div class="line">3. Updating your fork from original repo to keep up with their changes</div><div class="line">git pull upstream master</div></pre></td></tr></table></figure>
<h2 id="十、撤销"><a href="#十、撤销" class="headerlink" title="十、撤销"></a>十、撤销</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt; # 恢复暂存区的指定文件到工作区</div><div class="line">&gt; $ git checkout [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复某个commit的指定文件到暂存区和工作区</div><div class="line">&gt; $ git checkout [commit] [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复暂存区的所有文件到工作区</div><div class="line">&gt; $ git checkout .</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</div><div class="line">&gt; $ git reset [file]</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区与工作区，与上一次commit保持一致</div><div class="line">&gt; $ git reset --hard</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</div><div class="line">&gt; $ git reset [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">&gt; $ git reset --hard [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class="line">&gt; $ git reset --keep [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个commit，用来撤销指定commit</div><div class="line">&gt; # 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class="line">&gt; $ git revert [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 暂时将未提交的变化移除，稍后再移入</div><div class="line">&gt; $ git stash</div><div class="line">&gt; $ git stash pop</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; # 生成一个可供发布的压缩包</div><div class="line">&gt; $ git archive</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>（完）</p>
<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解socket编程]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/%E7%90%86%E8%A7%A3socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>理解socket编程的思想，介绍各个函数及其作用，文末有一个server和client的代码，可直接运行。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本地进程通信</strong></p>
<p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p><strong>网络进程通信</strong></p>
<p>但是网络中进程之间如何通信？</p>
<p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p>
<p>TCP/IP协议族已经帮我们解决了这个问题：</p>
<ul>
<li>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机</li>
<li>传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</li>
</ul>
<p>这样利用三元组<strong>（ip地址，协议，端口）</strong>就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<h2 id="socket基本操作"><a href="#socket基本操作" class="headerlink" title="socket基本操作"></a>socket基本操作</h2><h3 id="1、socket-函数"><a href="#1、socket-函数" class="headerlink" title="1、socket()函数"></a>1、socket()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的<strong>打开</strong>操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符</strong>（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，<strong>AF_INET</strong>、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，<strong>SOCK_STREAM</strong>、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，<strong>IPPROTO_TCP</strong>、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li>
</ul>
<p>当我们调用<strong>socket()</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h3 id="2、bind-函数"><a href="#2、bind-函数" class="headerlink" title="2、bind()函数"></a>2、bind()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># ipv4</div><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div><div class="line"># ipv6对应的是： </div><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line"># Unix域对应的是： </div><div class="line">#define UNIX_PATH_MAX    108</div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
</blockquote>
<h3 id="3、listen-函数"><a href="#3、listen-函数" class="headerlink" title="3、listen()函数"></a>3、listen()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int listen(int sockfd, int backlog);</div></pre></td></tr></table></figure>
<p>两个参数</p>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>backlog：相应socket可以排队的最大连接个数</li>
</ul>
<p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<h3 id="4、connect-函数"><a href="#4、connect-函数" class="headerlink" title="4、connect()函数"></a>4、connect()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>addr：服务器的socket地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<p>客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h3 id="5、accept-函数"><a href="#5、accept-函数" class="headerlink" title="5、accept()函数"></a>5、accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p>
<p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p>
<p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：服务器的socket描述字</li>
<li>addr：指向struct sockaddr *的指针，用于返回客户端的协议地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<blockquote>
<p>服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
</blockquote>
<h3 id="6、网络I-O"><a href="#6、网络I-O" class="headerlink" title="6、网络I/O"></a>6、网络I/O</h3><p>服务端：socket、bind、listen、accept</p>
<p>客户端：socket、connect</p>
<p>至此服务器与客户已经建立好连接，可以调用网络I/O进行读写操作，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure>
<p>recvmsg()/sendmsg()这两个函数是最通用的I/O函数。各函数需要对应的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">                      const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
<h3 id="7、close-函数"><a href="#7、close-函数" class="headerlink" title="7、close()函数"></a>7、close()函数</h3><p>服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int close(int fd);</div></pre></td></tr></table></figure>
<blockquote>
<p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
</blockquote>
<p>以上参考了这篇文章：<a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="external">Linux Socket编程（不限Linux）</a>，写的很不错。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// server.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"></div><div class="line">#define SERVER_PORT    	6666 </div><div class="line">#define BUFFER_SIZE 	1024</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    // server的socket地址结构server_addr,三元组(地址,协议,端口)</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr)); //把一段内存区的内容全部设置为0</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line"></div><div class="line">    // socket描述符</div><div class="line">    int server_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( server_socket &lt; 0)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Create Socket Failed!&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 给socket 描述符绑定一个地址，地址是我们上面定义好的</div><div class="line">    if( bind(server_socket,(struct sockaddr*)&amp;server_addr,sizeof(server_addr)))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Server Bind Port : %d Failed!&quot;, SERVER_PORT); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    // 监听这个socket, 第二个参数是排队的最大连接数</div><div class="line">    if ( listen(server_socket, 10) )</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server Listen Failed!&quot;); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    while (1) </div><div class="line">    &#123;   </div><div class="line">        // 定义客户端的socket地址结构client_addr</div><div class="line">        struct sockaddr_in client_addr;</div><div class="line">        socklen_t len = sizeof(client_addr);</div><div class="line"></div><div class="line">        // 如果没有连接请求,就等待到有连接请求--这是accept函数的特性</div><div class="line">        // accept函数返回一个新的socket,这个socket(new_server_socket)用于同连接到的客户的通信，代表了服务器和客户端之间的一个通信通道</div><div class="line">        // accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中</div><div class="line">        int new_server_socket = accept(server_socket,(struct sockaddr*)&amp;client_addr,&amp;len);</div><div class="line">        if ( new_server_socket &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Accept Failed!\n&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        char buffer[BUFFER_SIZE];</div><div class="line">        bzero(buffer, BUFFER_SIZE);</div><div class="line">        // 接收从客户端来的请求</div><div class="line">        len = recv(new_server_socket,buffer,BUFFER_SIZE,0);</div><div class="line">        if (len &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Recieve Data Failed!\n&quot;);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        buffer[len] = &apos;\0&apos;;</div><div class="line">        printf(&quot;recv msg from client: %s\n&quot;, buffer);</div><div class="line">        close(new_server_socket);</div><div class="line">    &#125;</div><div class="line">    close(server_socket);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端：socket() -&gt; connect() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// client.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"> </div><div class="line">#define SERVER_PORT 6666 </div><div class="line">#define BUFFER_SIZE 1024</div><div class="line"> </div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    if (argc != 2)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Usage: ./%s ServerIPAddress\n&quot;,argv[0]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //创建socket描述符</div><div class="line">    int client_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( client_socket &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Create Socket Failed!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //设置server的地址，三元组</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr));</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line">    if(inet_aton(argv[1],&amp;server_addr.sin_addr) == 0) //服务器的IP地址来自程序的参数</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server IP Address Error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    //向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接</div><div class="line">    if(connect(client_socket,(struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Can Not Connect To %s!\n&quot;,argv[1]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line">    printf(&quot;send msg to server!\n&quot;);</div><div class="line">    char sendline[BUFFER_SIZE];</div><div class="line">    fgets(sendline, BUFFER_SIZE, stdin);</div><div class="line"></div><div class="line">	// 向服务器发送数据</div><div class="line">    if (send(client_socket, sendline, strlen(sendline), 0) &lt; 0)&#123;</div><div class="line">        printf(&quot;send msg error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(client_socket);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gcc server.c -o s</div><div class="line">gcc client.c -o c</div><div class="line"></div><div class="line"># ./s</div><div class="line">recv msg from client: hello socket</div><div class="line"></div><div class="line"># ./c 127.0.0.1</div><div class="line">send msg to server!</div><div class="line">hello socket     		// 交互输入</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cow和row快照机制的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/cow%E5%92%8Crow%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>很清晰的讲解快照两种模式cow和row的区别。<br><a id="more"></a></p>
<p>所谓快照，是指某数据集在某一时刻一个完全可用的拷贝。也叫即时拷贝。注意是一个完全可用的。如果是在window环境下，则要结合VSS 机制，把应用程序的buffer,文件系统的buffer,操作系统的buffer全部刷向磁盘后，再做快照。﻿</p>
<p>当前快照有两种实现，分别是COW（Copy on first write） 和ROW(Redirect on first write).﻿﻿﻿</p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、读取第8个物理块﻿</li>
<li>3、新读取的第8个物理块数据写入到第9个物理块。﻿</li>
<li>4、更新快照卷map,指向第9个物理块﻿</li>
<li>5、更新第8个物理块﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/cow.jpg" alt="COW"></p>
<p>从上面可以看出，本来写一个物理块，变成了1读3写。﻿</p>
<p>COW 优点：﻿</p>
<p>1、原始卷物理块连续。没有碎片。﻿</p>
<p>COW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成1读3写。﻿﻿﻿</p>
<h2 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h2><p>对ROW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、数据写入到第9个物理块。﻿</li>
<li>3、更新原始卷map,指向第9个物理块﻿﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/row.jpg" alt="ROW"></p>
<p>从上面可以看出，本来写一个物理块，变成了2写。﻿</p>
<p>ROW 优点：﻿</p>
<p>1、性能比COW 好。﻿</p>
<p>ROW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成2写。﻿</p>
<p>2、原始卷物理块不连续。没、有碎片。</p>
<blockquote>
<p>本文为转载，原始链接未找到</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(5、6、7)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/Machine-Learning-Yearning-5%E3%80%816/</url>
      <content type="html"><![CDATA[<p>第5、6、7三章，主要讲开发集和测试集，包括选型、大小、比例等。<br><a id="more"></a></p>
<p>共14篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新" target="_blank" rel="external">https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新</a></p>
<p>Setting up development and test sets</p>
<p>设置开发和测试集</p>
<h2 id="Chapter-5、Your-development-and-test-sets"><a href="#Chapter-5、Your-development-and-test-sets" class="headerlink" title="Chapter 5、Your development and test sets"></a>Chapter 5、Your development and test sets</h2><p><strong>您的开发和测试集</strong><br>​    让我们回到我们早期猫图片的那个例子：你运行一个移动app，用户正在上传很多不同事物的图片到该app中。你想自动找到猫的图片。<br>​    您的团队通过从不同网站上下载猫（positive examples，正样本）和非猫（negative examples，负样本）的图获得一个大的训练集。 他们将数据集按照比例70％/ 30％分成训练集/测试集。 使用这些数据，他们构建了一个在训练集和测试集上都表现很好的的猫检测器。<br>​    但是当你将这个分类器部署到移动app时，你发现表现真的很糟糕！</p>
<p><img src="http://img.blog.csdn.net/20161209012152300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<p>​    发生了什么？<br>​    您发现用户上传的图片与您构建训练集的网站图片有所不同：用户上传的照片使用手机拍摄，这些照片往往分辨率较低，比较模糊，并且采光不好。 由于您的训练集/测试集是由网站图片构建的，您的算法没有很好的兼顾到你所关心的智能手机图片的实际分布。<br>​    在大数据的时代之前，在机器学习中使用随机的70％/ 30％来分割训练集和测试集是常见的规则。 这种做法可以工作，但在越来越多的应用程序，如训练集的分布（上面例子中的网站图像）不同于你最终关心的分布（手机图像），这是一个坏主意。</p>
<p>​    我们通常定义：</p>
<ul>
<li>训练集 - 学习算法运行在这上面。</li>
<li>Dev（开发）集 - 用于调整参数，选择特征，以及对学习算法做出其他决定。 有时也称为维持交叉验证集(hold-out cross validation set)。</li>
<li><p>测试集 - 用于评估算法的性能，但不要做出关于使用什么学习算法或参数的任何决定。</p>
<p>​你定义一个开发集和测试集，你的团队会尝试很多想法，如不同的学习算法参数，看看什么是最好的。 开发集和测试集能够使你的团队快速看到你的算法做得有多好。</p>
<p>​换句话说，开发和测试集的目的是指导你的团队对机器学习系统进行最重要的更改。<br>​所以，你应该做如下事情：</p>
</li>
<li><p>选择开发和测试集，以反映您期望在未来获得的数据，并希望做好。</p>
<p>​换句话说，您的测试集不应该只是可用数据的30％这么简单，特别是如果您期望您的未来数据（移动app图片）在性质上与您的训练集（网站图像）不同时。</p>
<p>​如果您尚未启动移动app，可能还没有任何用户，因此可能无法获取准确反映您未来需要做的更好的数据。 但你可能仍然尝试去靠近它。 例如，请你的朋友拍一些手机图片，并发送给你。 一旦app启动后，您可以使用实际的用户数据更新您的开发集/测试集。<br>​如果你真的没有任何方法来获得接近你期望的未来数据，也许你可以从使用网站图像开始。 但是你应该意识到这将导致系统不能一般化的很好的风险。<br>​我们需要判断去决定多少投资开发好的开发集和测试集。 但是不要假定你的训练分布与你的测试分布是一样的。 尝试选择反映您最终想要表现良好的测试样本，而不是训练遇到的任何数据。</p>
</li>
</ul>
<h2 id="Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution"><a href="#Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution" class="headerlink" title="Chapter 6、Your dev and test sets should come from the same distribution"></a>Chapter 6、Your dev and test sets should come from the same distribution</h2><p><strong>你的开发集和测试集应该来自相同的分布</strong></p>
<p>根据您最大的市场，将猫应用图片数据分为四个区域：（i）美国，（ii）中国，（iii）印度和（iv）其他。要想出一个开发集和一个测试集，我们可以随机分配这两个区域到开发集，另外两个到测试集，对吧？ 比如美国和印度在开发集; 中国和其他在测试集。</p>
<p><img src="http://img.blog.csdn.net/20161209022552344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>​    一旦定义了开发集和测试集，您的团队将专注于提高开发集的性能。 因此，开发集应该反映你最想提高的任务：在所有四个地区都要做得很好，而不只是两个。<br>​    开发集和测试集的不同分布带来的第二个问题：有一个机会，你的团队将构建一些在开发集件上工作得很好，只是发现它在测试集上做得不好。 我曾经在很多失望和白费的努力中看到这个结果。 避免让这些发生在你身上。<br>​    例如，假设您的团队开发的系统在开发集上工作的很好，但在测试集上并不如意。 如果你的开发集和测试集合来自相同的分布，那么你会有一个非常明确的诊断哪里出错了：你在开发集上过拟合(overfit)了。显而易见的方法是去获得更多的开发集数据。</p>
<p>​    但是如果开发集和测试集来自不同的分布，那么你的选择是不清晰的。几方面可能会出错：</p>
<ul>
<li>1、在开发集上过拟合。</li>
<li>2、测试集比开发集更难。所以你的算法可能做的和预期一样好，因此没有进一步的重大改进的可能了。</li>
<li><p>3、测试集不一定更难，但只是和开发集不同。所以在开发集上表现很好但并不能在测试集上表现一样。这种情况下，之前很多提高开发集性能的努力可能都白费了。</p>
<p>​在机器学习应用程序上工作是很艰难的。具有不匹配的开发和测试集引入了关于是否改进开发集分布也提高测试集性能额外的不确定性。具有不匹配的开发和测试集，使得更难找出什么是有效和无效的努力，因此使得更难以确定工作的优先级。<br>​如果你面临的是第三方基准测试 问题，他们的创建者可能会指定开发集和测试集来自不同的分布。相比开发和测试集来自同一分布，此时运气，而不是技术，将对这样的基准的性能有更大的影响。开发一个在一个分布上训练的很好同时能够很好的推广到另一个分布中的学习算法是一个重要的研究问题。但是如果你的目标是在一个特定的机器学习应用中取得进展，而不是研究进展，我建议尝试选择开发集和测试集从相同的分布。这将使您的团队更有效率。</p>
</li>
</ul>
<h2 id="Chapter-7、How-large-do-the-dev-test-sets-need-to-be"><a href="#Chapter-7、How-large-do-the-dev-test-sets-need-to-be" class="headerlink" title="Chapter 7、How large do the dev/test sets need to be?"></a>Chapter 7、How large do the dev/test sets need to be?</h2><p><strong>开发集/测试集需要多大？</strong></p>
<p>​    开发集应该足够大，以检测您尝试的算法之间的差异。例如，如果分类器A具有90.0％的准确度，分类器B具有90.1％的准确度，那么100个样本的开发集将不能检测出这0.1％的差异。与我看到的其他机器学习问题相比，100个样本的开发集太小了。常见的开发集的大小在1,000到10,000个样本之间。有10,000个样本，你将有很好的机会检测到这0.1％的提升。[2]<br>​    对于成熟和重要的应用，例如广告，网络搜索和产品建议 - 我也看到了很多团队，甚至为提升0.01％积极努力，因为它对公司的利润有直接影响。在这种情况下，开发集可以远大于10,000，以便检测出更小的提升。<br>​    测试集的大小应该多大？它应该足够大，使得对系统的整体性能有一个高的信心。一个流行的启发式方法是将30％的数据用于测试集。当你有适量的样本，比如100到10,000的样本，它会工作的很好。但在大数据的时代，我们现在有机器学习问题，有时会超过十亿个样本，分配给开发集/测试集的比例一直在缩小，即使开发集 /测试集中的样本绝对数量一直在增长。除了需要评估算法的性能之外，没有必要提供过大的开发集/测试集。</p>
<p>——————————</p>
<p>[2]. 在理论上，我们可以测试算法的变化是否对开发集产生统计上显着的差异。 在实践中，大多数团队不会为此困扰（除非他们出版学术研究论文），我通常没法发现统计意义的测试对测量临时进展是有用的。</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(3、4)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/03/Machine-Learning-Yearning-3%E3%80%814/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，第三章：预备知识和注释；第四章：规模驱使机器学习前进。<br><a id="more"></a></p>
<p>共14篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新" target="_blank" rel="external">https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新</a></p>
<h2 id="Chapter-3、Prerequisites-and-Notation"><a href="#Chapter-3、Prerequisites-and-Notation" class="headerlink" title="Chapter 3、Prerequisites and Notation"></a>Chapter 3、Prerequisites and Notation</h2><p><strong>预备知识和注释</strong><br>​    如果你有学习过机器学习课程，比如我在Coursera上的的机器学习MOOC，或者如果你有应用监督学习的经验，你也将能够理解这段文字。<br>​    我假设你熟悉监督学习（supervised learning）：使用标记的训练样本（x，y）去学习一个从x映射到y的函数。 监督学习算法包括线性回归（linear regression），逻辑回归（logistic regression）和神经网络（neural networks）。 机器学习的形式有很多，但是现如今大部分机器学习的实用价值来自于监督学习。<br>​    我将经常提到神经网络（也称为“deep learning”）。你只需要遵循本问对它是什么有一个基本的理解就可以了。<br>​    如果您不熟悉这里提到的概念，请观看在Coursera上前三周 机器学习视频课程<a href="http://ml-class.org" target="_blank" rel="external">http://ml-class.org</a></p>
<p><img src="http://img.blog.csdn.net/20161208234928384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Chapter-4、Scale-drives-machine-learning-progress"><a href="#Chapter-4、Scale-drives-machine-learning-progress" class="headerlink" title="Chapter 4、Scale drives machine learning progress"></a>Chapter 4、Scale drives machine learning progress</h2><p><strong>规模驱使机器学习前进</strong></p>
<p>深度学习（神经网络）的许多想法已经存在几十年了。 为什么这些想法现在才火起来？<br>最近得以进步的最大驱动因素有两个：</p>
<ul>
<li>数据可用性。 人们现在在数字设备（笔记本电脑，移动设备）上花费更多的时间。这些活动产生大量的数据，我们可以使用这些数据来训练和反馈我们的学习算法。</li>
<li>计算尺度。 我们几年前才开始能够训练足够大的神经网络，以利用我们现在拥有的巨大的数据集。</li>
</ul>
<p>具体来说，即使你积累了更多的数据，通常传统学习算法（如逻辑回归）的性能表现“平稳”。这意味着它的学习曲线“平坦”，即使你给它更多的数据，算法也不会再有提升效果。</p>
<p><img src="http://img.blog.csdn.net/20161209001935676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这就好像传统的算法不知道如何处理我们现在拥有的所有数据。<br>如果你在同一个监督学习任务上训练一个小的神经网络（NN），你可能会获得略好一点的性能：</p>
<p><img src="http://img.blog.csdn.net/20161209002633511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里，“小的神经网络”是指仅具有少量隐藏单位/层/参数的神经网络。 最后，如果你训练越来越大的神经网络，你可以获得更好的性能：[1]</p>
<p><img src="http://img.blog.csdn.net/20161209003804359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>因此，当你做到下面两点的时候你会获得最佳的性能（i）训练一个非常大的神经网络，使其在上面的绿色曲线上; （ii）有大量的数据。<br>许多其他细节，如神经网络架构也很重要，这里已经有很多创新。 但是现在提高算法性能的更可靠的方法之一仍然是（i）训练更大的网络和（ii）获得更多的数据。<br>如何完成（i）和（ii）的方法是极其复杂的。 这本书将详细讨论细节。 我们将从对传统学习算法和神经网络都有用的一般策略开始，并建立构建深度学习系统所需的最先进策略。</p>
<p>[1]这个图表展示了NN在小数据集下做得更好。这种效果不如NNs在大数据集中表现良好的效果一致。 在小数据系统中，取决于特征是如何手工设计的，传统算法可能做的很好，也可能做得并不好。 例如，如果你有20个训练样本，那么使用逻辑回归还是神经网络可能并不重要; 手工特征的选择将比算法的选择产生更大的影响。 但如果你有100万的样本，我更倾向于神经网络。</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(开篇、1、2)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/02/Machine-Learning-Yearning-%E5%BC%80%E7%AF%87%E3%80%811%E3%80%812/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，翻译过来，这里是开篇、第一章和第二章的内容。<br><a id="more"></a></p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>网上搜了一下，发现已经有一些翻译后的资料了，我这里就是边学习边翻译记录，主要作为给自己的学习笔记吧，并不冲突。</p>
<p>官网：<a href="http://www.mlyearning.org/" target="_blank" rel="external">http://www.mlyearning.org/</a></p>
<p>这里可以留下你的邮箱，当有更新的时候会发到你的邮箱（好像我关注后就没发过）。</p>
<p>共14篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新" target="_blank" rel="external">https://github.com/xiaqunfeng/machine-learning-yearning，博客上就不再更新</a></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这本书的目的是教你如何做组织一个机器学习项目所需的大量的决定。 你将学习：</p>
<ul>
<li>如何建立你的开发和测试集</li>
<li>基本错误分析</li>
<li>如何使用偏差和方差来决定该做什么</li>
<li>学习曲线</li>
<li>将学习算法与人类水平的表现进行比较</li>
<li>调试推理算法</li>
<li>什么时候应该和不应该使用端到端的深度学习</li>
<li>按部进行错误分析</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>当前更新了14章，下载如下：</p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_01.pdf" target="_blank" rel="external">1-12章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_02.pdf" target="_blank" rel="external">13章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_03.pdf" target="_blank" rel="external">14章</a></p>
<h3 id="章节名称"><a href="#章节名称" class="headerlink" title="章节名称"></a>章节名称</h3><p>Chapter 1、Why Machine Learning Strategy<br>Chapter 2、How to use this book to help your team<br>Chapter 4、Prerequisites and Notation<br>Chapter 5、Scale drives machine learning progress<br>Chapter 6、Your development and test sets<br>Chapter 7、Your dev and test sets should come from the same distribution<br>Chapter 8、How large do the dev/test sets need to be?<br>Chapter 9、Establish a single-number evaluation metric for your team to optimize<br>Chapter 10、Optimizingandsatisficingmetrics<br>Chapter 11、Having a dev set and metric speeds up iterations<br>Chapter 12、When to change dev/test sets and metrics<br>Chapter 13、Takeaways: Setting up development and test sets<br>Chapter 14、Build your first system quickly, then iterate<br>Chapter 15、Error analysis: Look at dev set examples to evaluate ideas<br>Chapter 16、Evaluate multiple ideas in parallel during error analysis </p>
<p>（待添加）                </p>
<h2 id="Chapter-1、Why-Machine-Learning-Strategy"><a href="#Chapter-1、Why-Machine-Learning-Strategy" class="headerlink" title="Chapter 1、Why Machine Learning Strategy"></a>Chapter 1、Why Machine Learning Strategy</h2><p>为什么是机器学习策略</p>
<p>机器学习是无数重要应用程序的基础，包括网页搜索，电子邮件反垃圾邮件，语音识别，产品推荐等。我假设你或你的团队正在一个机器学习应用程序，并且你想要快速进步。那么这本书将帮助到你。</p>
<p>示例：构建一个cat图片启动</p>
<p>假设你正在建立一个创业公司，将为猫爱好者提供一个无尽的猫图片流。并使用神经网络建立一个计算机视觉系统，以检测图片中的猫。</p>
<p><img src="http://img.blog.csdn.net/20161208213001211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但悲剧的是，你的学习算法的准确性还不够好。你面临着提高猫检测算法的巨大压力。你该怎么做？</p>
<p>您的团队有很多想法，例如：</p>
<p>•获取更多的数据：收集更多的猫的照片</p>
<p>•收集更多样化的培训集。例如，猫在不寻常的位置的图片;猫不寻常的着色;各种相机设置下拍摄出的猫图; ….</p>
<p>•通过运行更多的梯度下降迭代来增加算法的训练时间</p>
<p>•尝试更大的神经网络，具有更多的层/隐藏单位/参数</p>
<p>•尝试更小的神经网络。</p>
<p>•尝试添加正则化（例如L2正则化）</p>
<p>•改变神经网络架构（激活功能，隐藏单位数等）</p>
<p>•…</p>
<p>在这些可能的方向中，如果选择的好，你将会建立领先的猫图片平台，并带领公司走向成功。如果选择 不好，可能会浪费几个月的时间。你该怎么做？</p>
<p>这本书会告诉你怎么做。大多数机器学习问题留下的线索告诉你什么是有用的的尝试，什么是没用的尝试。学会阅读这些线索会节省你几个月甚至几年的开发时间。</p>
<h2 id="Chapter-2、How-to-use-this-book-to-help-your-team"><a href="#Chapter-2、How-to-use-this-book-to-help-your-team" class="headerlink" title="Chapter 2、How to use this book to help your team"></a>Chapter 2、How to use this book to help your team</h2><p>如何使用这本书来帮助你的团队<br>阅读完本书后，您将对如何设置机器学习项目的技术方向有深入的了解。<br>但是你的队友可能不明白你为什么要推荐一个特定的方向。 也许你希望你的团队定义一个单数评估指标，但他们不相信。 你如何说服他们？<br>这就是为什么我把章节短：所以，你可以打印出来，让你的队友只读你需要他们知道的那一两页。<br>优先级上的一些改变会对您的团队的生产力产生巨大的影响。 通过帮助您的团队进行一些这样的改变，我希望您可以成为您的团队的超级英雄！</p>
<p><img src="http://img.blog.csdn.net/20161208232515575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[异步IO]]></title>
      <url>http://xiaqunfeng.cc/2017/03/01/%E5%BC%82%E6%AD%A5IO/</url>
      <content type="html"><![CDATA[<p>介绍了AIO，以及四种IO模型。<br><a id="more"></a></p>
<p>Linux® 中最常用的输入/输出（I/O）模型是同步 I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是很好的一种解决方案，因为调用应用程序在等待 I/O 请求完成时不需要使用任何中央处理单元（CPU）。但是在某些情况中，I/O 请求可能需要与其他进程产生交叠。可移植操作系统接口（POSIX）异步 I/O（AIO）应用程序接口（API）就提供了这种功能。在本文中，我们将对这个 API 概要进行介绍，并来了解一下如何使用它。</p>
<h2 id="AIO-简介"><a href="#AIO-简介" class="headerlink" title="AIO 简介"></a>AIO 简介</h2><p>Linux 异步 I/O 是 Linux 内核中提供的一个相当新的增强。它是 2.6 版本内核的一个标准特性，但是我们在 2.4 版本内核的补丁中也可以找到它。AIO 背后的基本思想是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。</p>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>在深入介绍 AIO API 之前，让我们先来探索一下 Linux 上可以使用的不同 I/O 模型。这并不是一个详尽的介绍，但是我们将试图介绍最常用的一些模型来解释它们与异步 I/O 之间的区别。图 1 给出了同步和异步模型，以及阻塞和非阻塞的模型。</p>
<p align="center">图 1. 基本 Linux I/O 模型的简单矩阵</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure1.gif" alt="基本 Linux I/O 模型的简单矩阵"></p>
<p>每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。</p>
<h3 id="同步阻塞-I-O"><a href="#同步阻塞-I-O" class="headerlink" title="同步阻塞 I/O"></a>同步阻塞 I/O</h3><h2 id="I-O-密集型与-CPU-密集型进程的比较"><a href="#I-O-密集型与-CPU-密集型进程的比较" class="headerlink" title="I/O 密集型与 CPU 密集型进程的比较"></a>I/O 密集型与 CPU 密集型进程的比较</h2><p>I/O 密集型进程所执行的 I/O 操作比执行的处理操作更多。CPU 密集型的进程所执行的处理操作比 I/O 操作更多。Linux 2.6 的调度器实际上更加偏爱 I/O 密集型的进程，因为它们通常会发起一个 I/O 操作，然后进行阻塞，这就意味着其他工作都可以在两者之间有效地交错进行。</p>
<p>最常用的一个模型是同步阻塞 I/O 模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>图 2 给出了传统的阻塞 I/O 模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用 <code>read</code> 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（<code>read</code> 调用返回）。</p>
<p align="center">图 2. 同步阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure2.gif" alt="同步阻塞 I/O 模型的典型流程"></p>
<p>从应用程序的角度来说，<code>read</code> 调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。</p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I/O"></a>同步非阻塞 I/O</h3><p>同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，<code>read</code>操作可能会返回一个错误代码，说明这个命令不能立即满足（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>），如图 3 所示。</p>
<p align="center">图 3. 同步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure3.gif" alt="同步非阻塞 I/O 模型的典型流程"></p>
<p>非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图 3 所示的一样，这个方法可以引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 <code>read</code> 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。</p>
<h3 id="异步阻塞-I-O"><a href="#异步阻塞-I-O" class="headerlink" title="异步阻塞 I/O"></a>异步阻塞 I/O</h3><p>另外一个阻塞解决方案是带有阻塞通知的非阻塞 I/O。在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 <code>select</code> 系统调用来确定一个 I/O 描述符何时有操作。使 <code>select</code> 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。</p>
<p align="center">图 4. 异步阻塞 I/O 模型的典型流程 (select)</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure4.gif" alt="异步阻塞 I/O 模型的典型流程"></p>
<p><code>select</code> 调用的主要问题是它的效率不是非常高。尽管这是异步通知使用的一种方便模型，但是对于高性能的 I/O 操作来说不建议使用。</p>
<h3 id="异步非阻塞-I-O（AIO）"><a href="#异步非阻塞-I-O（AIO）" class="headerlink" title="异步非阻塞 I/O（AIO）"></a>异步非阻塞 I/O（AIO）</h3><p>最后，异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 <code>read</code> 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 <code>read</code> 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p align="center">图 5. 异步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure5.gif" alt="异步非阻塞 I/O 模型的典型流程"></p>
<p>在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。</p>
<h2 id="异步-I-O-的动机"><a href="#异步-I-O-的动机" class="headerlink" title="异步 I/O 的动机"></a>异步 I/O 的动机</h2><p>从前面 I/O 模型的分类中，我们可以看出 AIO 的动机。这种阻塞模型需要在 I/O 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 I/O 操作。同步非阻塞模型允许处理和 I/O 操作重叠进行，但是这需要应用程序根据重现的规则来检查 I/O 操作的状态。这样就剩下异步非阻塞 I/O 了，它允许处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。</p>
<p>除了需要阻塞之外，<code>select</code> 函数所提供的功能（异步阻塞 I/O）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 I/O 调用进行阻塞。</p>
<h2 id="Linux-上的-AIO-简介"><a href="#Linux-上的-AIO-简介" class="headerlink" title="Linux 上的 AIO 简介"></a>Linux 上的 AIO 简介</h2><p>本节将探索 Linux 的异步 I/O 模型，从而帮助我们理解如何在应用程序中使用这种技术。</p>
<p>在传统的 I/O 模型中，有一个使用惟一句柄标识的 I/O 通道。在 UNIX® 中，这些句柄是文件描述符（这对等同于文件、管道、套接字等等）。在阻塞 I/O 中，我们发起了一次传输操作，当传输操作完成或发生错误时，系统调用就会返回。</p>
<h2 id="Linux-上的-AIO"><a href="#Linux-上的-AIO" class="headerlink" title="Linux 上的 AIO"></a>Linux 上的 AIO</h2><p>AIO 在 2.5 版本的内核中首次出现，现在已经是 2.6 版本的产品内核的一个标准特性了。</p>
<p>在异步非阻塞 I/O 中，我们可以同时发起多个传输操作。这需要每个传输操作都有惟一的上下文，这样我们才能在它们完成时区分到底是哪个传输操作完成了。在 AIO 中，这是一个 <code>aiocb</code>（AIO I/O Control Block）结构。这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。在产生 I/O （称为完成）通知时，<code>aiocb</code> 结构就被用来惟一标识所完成的 I/O 操作。这个 API 的展示显示了如何使用它。</p>
<p>本文为转载文章, 原文链接：<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bluestore调研]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/Bluestore%E8%B0%83%E7%A0%94/</url>
      <content type="html"><![CDATA[<p>这是之前关注bluestore时写的调研文章，主要介绍了bluestore的架构、存储模型、IO、元数据等，以及优势。现在ceph已经出到K版本了，虽然未在生产中实践，但已经可用。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Ceph是一种软件定义存储解决方案，因此Ceph的主要目标是保障存储数据的安全。为了达到数据安全的目的，我们需要原子特性。目前没有一种文件存储系统能够提供写和更新操作的原子特性（Btrfs拥有原子特性的事务, 这是人们为了解决上述问题作出的尝试，但事实上并不成功）。</p>
<p>​    Ceph开发者不得不探索其他的解决方案。这个解决方案就是大家非常熟悉的Ceph日志。ceph后端的存储引擎目前使用的是filestore，写采用的是WAL的方式，但是写前记录日志这种技术有一个主要缺陷就是它把你的硬盘性能降低到原来的二分之一（仅当日志和OSD数据共享同一个硬盘时），因为filestore在写数据前需要先写journal，所以有一倍的写放大。</p>
<p>​    同时filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑。bluestore的初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="bluestore架构图"></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>RocksDB</td>
<td>存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）</td>
</tr>
<tr>
<td>BlueRocksEnv</td>
<td>与RocksDB交互的接口</td>
</tr>
<tr>
<td>BlueFS</td>
<td>小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备</td>
</tr>
<tr>
<td>HDD</td>
<td>物理块设备，存储实际的数据</td>
</tr>
</tbody>
</table>
<p>​    rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（<em>rocksdb默认的Env是PosixEnv，直接对接本地文件系统</em>）。</p>
<p>​    BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p>
<p>​    为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（<em>BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备</em>）。</p>
<p>​    bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。</p>
<blockquote>
<p>读：目前块设备的读操作是同步的；</p>
<p>写：由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 </p>
</blockquote>
<p>​    Ceph数据对象(真正的‘数据’)直接被写入块物理设备。因为是直接管理裸设备，所以需要分配器（Allocator）来进行裸设备的空间管理。OSD附带的数据对象元数据被存储到键值数据库RocksDB中。</p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png" alt="bluestore存储模型"></p>
<p>这里把一个硬盘分了两个分区：</p>
<ol>
<li>第一个迷你小分区使用了XFS或ext4文件系统。它存储了Ceph文件（像初始系统描述符，状态，id，fsid，钥匙串等），和RocksDB文件(RocksDB元数据和预写式日志)。</li>
<li>第二个分区是没有文件系统的原始分区。</li>
</ol>
<p>​        每一个组件都可以存储在一个不同的物理设备上。在这张图中，RocksDB的预写式日志和数据可以被存储在不同的物理设备也可以存储在迷你小分区上。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>​    数据结构onode 保存了BlueStore中一个对象的数据结构，这是一个常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。一个onode里会存在多个lextent（逻辑的数据块），用一个map来记录。lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。blob和pextent是多对多的关系。</p>
<p>​    数据结构Enode定义了一个共享的extent，也就是这段数据被多个对象共享，一个对象的onode里保存一个enode数据结构，记录该对象被共享的extent。</p>
<h2 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h2><p>​    到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在执行写操作时，首先就会根据最小分配单位min_alloc_size进行判断，并按照min_alloc_size进行拆分，从而将I/O分为对齐和非对齐的。落到某一个min_alloc_size区间的写I/O执行非对齐写，min_alloc_size整数倍的写I/O执行对齐写。</p>
<p><strong>整块写（对齐写）</strong></p>
<p>​    也就是对齐到min_alloc_size的写请求，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍。如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。（PS:回收这部分还没看）</p>
<p><strong>部分写（非对齐写）</strong></p>
<p>​    在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p>
<p>1、没有找到可以复用的blob，新生成blob</p>
<p>​    在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操，然后再把对齐后的offset和len作为lextent，进而放到blob里。之所以需要进行补零操作是因为采用Direct I/O的方式写盘要求偏移和缓冲区都对齐的。</p>
<p>2、找到可以复用的blob</p>
<p>​    先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p>
<p><em>a) 直接写在blob未使用的空间上</em></p>
<p>​    这种情况下直接新生成lextent放到blob里。</p>
<p><em>b) 覆盖写的情况</em></p>
<p>​    通过WAL写到rocksdb。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p>
<p><strong>优点</strong></p>
<p>​    对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p>
<p>​    对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bluestore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RocksDB相比LevelDB的新特性]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/RocksDB%E7%9B%B8%E6%AF%94LevelDB%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>如题，具体列举了RocksDB中相比LevelDB的一些新特性。<br><a id="more"></a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>多线程压缩</li>
<li>多线程memtable插入</li>
<li>减少DB互斥体保持</li>
<li>优化的基于级别的压缩风格和通用压缩风格</li>
<li>前缀bloom过滤器</li>
<li>Memtable布隆过滤器</li>
<li>覆盖整个SST文件的单个布过滤器</li>
<li>写锁优化</li>
<li>改进<code>Iter :: Prev（）</code>性能</li>
<li>在SkipList搜索期间，较少的比较器调用</li>
<li>使用巨大的页面分配memtable内存</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>列簇（column families）</li>
<li>事务和WriteBatchWithIndex</li>
<li>备份和检查点</li>
<li>合并操作</li>
<li>压缩过滤器</li>
<li>RocksDB Java</li>
<li>手动压缩与自动压缩并行运行</li>
<li>持久化缓存</li>
<li>批量加载</li>
<li>前向迭代器/尾部迭代器</li>
<li>单个删除</li>
<li>范围删除文件</li>
<li>引脚迭代器key/value</li>
</ul>
<h2 id="替换的数据结构和格式"><a href="#替换的数据结构和格式" class="headerlink" title="替换的数据结构和格式"></a>替换的数据结构和格式</h2><ul>
<li>仅用于内存使用情况的纯表格式</li>
<li>基于向量和基于哈希的memtable格式</li>
<li>基于时钟的缓存（即将推出）</li>
<li>可插拔信息日志</li>
<li>使用blob注释事务日志写入（用于副本）</li>
</ul>
<h2 id="可调性"><a href="#可调性" class="headerlink" title="可调性"></a>可调性</h2><ul>
<li>速率限制</li>
<li>可调减速和停止阈值</li>
<li>保持所有文件打开的选项</li>
<li>将所有索引和bloom过滤器块保留在块缓存中的选项</li>
<li>多种WAL恢复模式</li>
<li>Fadvise提示用于预读和避免在OS页面缓存中缓存</li>
<li>用于在内存中固定L0文件的索引和bloom过滤器的选项</li>
<li>更多压缩类型：zlib，lz4，zstd</li>
<li>压缩字典</li>
<li>校验类型：xxhash</li>
<li>每级的不同级别尺寸乘法器和压缩类型</li>
</ul>
<h2 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h2><ul>
<li>统计</li>
<li>Thread-local分析</li>
<li>命令行工具中的更多命令</li>
<li>用户定义的表属性</li>
<li>事件侦听器</li>
<li>更多数据库属性</li>
<li>动态选项更改</li>
<li>从字符串或映射获取选项</li>
<li>选项文件的持久性选项</li>
</ul>
<p>英文原文链接：<a href="https://github.com/facebook/rocksdb/wiki/Features-Not-in-LevelDB" target="_blank" rel="external">Features Not in LevelDB</a></p>
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rocksdb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kernel modules (简体中文)]]></title>
      <url>http://xiaqunfeng.cc/2017/02/20/Kernel%20modules%20(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/</url>
      <content type="html"><![CDATA[<p>介绍了内核模块的相关操作。加载、查看info、卸载、配置等……<br><a id="more"></a></p>
<p>相关文章</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Boot_Debugging" target="_blank" rel="external">Boot Debugging</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernels_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernels (简体中文)</a>)</li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernel parameters (简体中文)</a>)</li>
</ul>
<p><strong>翻译状态： </strong>本文是英文页面 <a href="https://wiki.archlinux.org/index.php/Kernel_modules" target="_blank" rel="external">Kernel_modules</a> 的<a href="https://wiki.archlinux.org/index.php/ArchWiki_Translation_Team_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">翻译</a>)，最后翻译时间：2013-07-06，点击<a href="https://wiki.archlinux.org/index.php?title=Kernel_modules&amp;diff=0&amp;oldid=264846" target="_blank" rel="external">这里</a>可以查看翻译后英文页面的改动。</p>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module" target="_blank" rel="external">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<blockquote>
<p>本文为转载文章，原文链接见文末</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>要创建内核模块，请阅读<a href="http://tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="external">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<p>模块保存在 <code>/lib/modules/*kernel_release*</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意: </strong>模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>显示当前装入的内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lsmod</div></pre></td></tr></table></figure>
<p>显示模块信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modinfo module_name</div></pre></td></tr></table></figure>
<p>显示所有模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | less</div></pre></td></tr></table></figure>
<p>显示某个模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | grep module_name</div></pre></td></tr></table></figure>
<p>显示一个装入模块使用的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systool -v -m module_name</div></pre></td></tr></table></figure>
<p>显示模块的依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe --show-depends module_name</div></pre></td></tr></table></figure>
<h2 id="手动加载卸载"><a href="#手动加载卸载" class="headerlink" title="手动加载卸载"></a>手动加载卸载</h2><p>控制内核模块载入/移除的命令是<a href="https://www.archlinux.org/packages/?name=kmod" target="_blank" rel="external">kmod</a> 软件包提供的, 要手动装入模块的话，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe module_name</div></pre></td></tr></table></figure>
<p>如果要移除一个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe -r module_name</div></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rmmod module_name</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/index.php/Udev" target="_blank" rel="external">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<h3 id="开机加载"><a href="#开机加载" class="headerlink" title="开机加载"></a>开机加载</h3><p>systemd 读取 <code>/etc/modules-load.d/</code> 中的配置加载额外的内核模块。配置文件名称通常为 <code>/etc/modules-load.d/.conf</code>。格式很简单，一行一个要读取的模块名，而空行以及第一个非空格字符为<code>#</code>或<code>;</code>的行会被忽略，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modules-load.d/virtio-net.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Load virtio-net.ko at boot</div><div class="line">virtio-net</div></pre></td></tr></table></figure>
<p>另见<code>man 5 modules-load.d</code>。</p>
<h3 id="配置内核模块参数"><a href="#配置内核模块参数" class="headerlink" title="配置内核模块参数"></a>配置内核模块参数</h3><h3 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用 /etc/modprobe.d/中的文件"></a>使用 /etc/modprobe.d/中的文件</h3><p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myfilename.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">options modname parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/thinkfan.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># On thinkpads, this lets the thinkfan daemon control fan speed</div><div class="line">options thinkpad_acpi fan_control=1</div></pre></td></tr></table></figure>
<p><strong>注意: </strong>如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio.conf" target="_blank" rel="external">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h3 id="使用内核命令行"><a href="#使用内核命令行" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>, <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)的内核行加入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modname.parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thinkpad_acpi.fan_control=1</div></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myalias.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Lets you use &apos;mymod&apos; in MODULES, instead of &apos;really_long_module_name&apos;</div><div class="line">alias mymod really_long_module_name</div></pre></td></tr></table></figure>
<p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/modprobe.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Prevent autoload of bluetooth</div><div class="line">alias net-pf-31 off</div><div class="line"></div><div class="line"># Prevent autoload of ipv6</div><div class="line">alias net-pf-10 off</div></pre></td></tr></table></figure>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><h3 id="禁用内核模块"><a href="#禁用内核模块" class="headerlink" title="禁用内核模块"></a>禁用内核模块</h3><p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs" target="_blank" rel="external">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d/modprobe.conf</code> 中将它们加入黑名单。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果要禁用这些模块，记得在配置完成后,将<code>.conf</code>文件加入<code>/etc/mkinitcpio.conf</code> 的 FILES 部分，然后重新生成 initramfs。</p>
<h3 id="使用-etc-modprobe-d-中的文件-1"><a href="#使用-etc-modprobe-d-中的文件-1" class="headerlink" title="使用 /etc/modprobe.d/ 中的文件"></a>使用 /etc/modprobe.d/ 中的文件</h3><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/nobeep.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Do not load the pcspkr module on boot</div><div class="line">blacklist pcspkr</div></pre></td></tr></table></figure>
<p><strong>注意: </strong><code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，直接返回导入失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/blacklist.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">install MODULE /bin/false</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p>
<h3 id="使用内核命令行-1"><a href="#使用内核命令行-1" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>同样可以通过内核命令行(位于 <a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>、<a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)禁用模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe.blacklist=modname1,modname2,modname3</div></pre></td></tr></table></figure>
<p>当某个模块导致系统无法启动时，可以使用此方法禁用模块。</p>
<p>参阅<a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external">Kernel parameters</a>.</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="显示所有内核参数的脚本"><a href="#显示所有内核参数的脚本" class="headerlink" title="显示所有内核参数的脚本"></a>显示所有内核参数的脚本</h3><p>下面的 bash 脚本可以显示当前装入模块、模块参数及当前参数的数值。它使用 <code>/proc/modules</code> 获取当前装入模块的列表，然后用 modinfo 获取模块的描述和模块的参数，最后访问 sysfs 文件系统获得当前模块名和参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function aa_mod_parameters () </div><div class="line">&#123; </div><div class="line">    N=/dev/null;</div><div class="line">    C=`tput op` O=$(echo -en &quot;\n`tput setaf 2`&gt;&gt;&gt; `tput op`&quot;);</div><div class="line">    for mod in $(cat /proc/modules|cut -d&quot; &quot; -f1);</div><div class="line">    do</div><div class="line">        md=/sys/module/$mod/parameters;</div><div class="line">        [[ ! -d $md ]] &amp;&amp; continue;</div><div class="line">        m=$mod;</div><div class="line">        d=`modinfo -d $m 2&gt;$N | tr &quot;\n&quot; &quot;\t&quot;`;</div><div class="line">        echo -en &quot;$O$m$C&quot;;</div><div class="line">        [[ $&#123;#d&#125; -gt 0 ]] &amp;&amp; echo -n &quot; - $d&quot;;</div><div class="line">        echo;</div><div class="line">        for mc in $(cd $md; echo *);</div><div class="line">        do</div><div class="line">            de=`modinfo -p $mod 2&gt;$N | grep ^$mc 2&gt;$N|sed &quot;s/^$mc=//&quot; 2&gt;$N`;</div><div class="line">            echo -en &quot;\t$mc=`cat $md/$mc 2&gt;$N`&quot;;</div><div class="line">            [[ $&#123;#de&#125; -gt 1 ]] &amp;&amp; echo -en &quot; - $de&quot;;</div><div class="line">            echo;</div><div class="line">        done;</div><div class="line">    done</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># aa_mod_parameters</div><div class="line">&gt;&gt;&gt; ehci_hcd - USB 2.0 &apos;Enhanced&apos; Host Controller (EHCI) Driver</div><div class="line">        hird=0 - hird:host initiated resume duration, +1 for each 75us (int)</div><div class="line">        ignore_oc=N - ignore_oc:ignore bogus hardware overcurrent indications (bool)</div><div class="line">        log2_irq_thresh=0 - log2_irq_thresh:log2 IRQ latency, 1-64 microframes (int)</div><div class="line">        park=0 - park:park setting; 1-3 back-to-back async packets (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; processor - ACPI Processor Driver</div><div class="line">        ignore_ppc=-1 - ignore_ppc:If the frequency of your machine gets wronglylimited by BIOS, this should help (int)</div><div class="line">        ignore_tpc=0 - ignore_tpc:Disable broken BIOS _TPC throttling support (int)</div><div class="line">        latency_factor=2 - latency_factor: (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; usb_storage - USB Mass Storage driver for Linux</div><div class="line">        delay_use=1 - delay_use:seconds to delay before using a new device (uint)</div><div class="line">        option_zero_cd=1 - option_zero_cd:ZeroCD mode (1=Force Modem (default), 2=Allow CD-Rom (uint)</div><div class="line">        quirks= - quirks:supplemental list of device IDs and their quirks (string)</div><div class="line">        swi_tru_install=1 - swi_tru_install:TRU-Install mode (1=Full Logic (def), 2=Force CD-Rom, 3=Force Modem) (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; video - ACPI Video Driver</div><div class="line">        allow_duplicates=N - allow_duplicates: (bool)</div><div class="line">        brightness_switch_enabled=Y - brightness_switch_enabled: (bool)</div><div class="line">        use_bios_initial_backlight=Y - use_bios_initial_backlight: (bool)</div></pre></td></tr></table></figure>
<p>原文链接：<a href="https://wiki.archlinux.org/index.php/Kernel_modules_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">kernel modules</a>)</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——pgrep和pkill]]></title>
      <url>http://xiaqunfeng.cc/2017/02/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94pgrep%E5%92%8Cpkill/</url>
      <content type="html"><![CDATA[<p>通过程序名来查询进程PID的命令pgrep，以及对应的杀进程命令pkill。<br><a id="more"></a></p>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><p>在linux中查看进程信息，经常要用到<code>pa auxf</code>，具体到某个进程的时候，又需进行grep管道。如：<code>ps auxf|grep java|grep -v grep</code> ，即然这么长，可以不可以简化呢？当然可以，如果还是使用ps命令的话，可以改为<code>ps auxf|grep jav[a]</code>，这样就不用排除自身了。不过感觉命令还是长了点，能不能再简点，可以，使用<code>pgrep java</code>，不过此时得出的只是pid 。</p>
<p>pgrep是linux中常用的通过 <strong>程序名</strong> 来查询进程PID信息的命令。</p>
<p>pgrep命令相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep KeyWord</div></pre></td></tr></table></figure>
<p>注：pgrep命令查找的的是程序名，不包括其参数。如果参数里包括查找的keyword，而程序名中不包括，所则使用pgrep命令无法查到该进程。这时可以使用<code>ps -aux|grep keyword</code>命令。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep [options] &lt;pattern&gt;</div></pre></td></tr></table></figure>
<p>默认只显示PID，可以加选项来显示更多信息</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>通过命令 <code>pgrep --help</code> 获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line"> -d, --delimiter &lt;string&gt;  specify output delimiter</div><div class="line"> -l, --list-name           list PID and process name</div><div class="line"> -v, --inverse             negates the matching</div><div class="line"> -w, --lightweight         list all TID</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div></pre></td></tr></table></figure>
<p>翻译和解释如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>定义输出的多个进程之间的分隔符（默认使用换行符）</td>
</tr>
<tr>
<td>-l</td>
<td>列出pid 和 进程名</td>
</tr>
<tr>
<td>-v</td>
<td>否定匹配，即列出除了查找的进程以外的其他进程</td>
</tr>
<tr>
<td>-w</td>
<td>列出所有的TID</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配到的所有进程数量</td>
</tr>
<tr>
<td>-f</td>
<td>用进程全名去匹配</td>
</tr>
<tr>
<td>-g</td>
<td>匹配列出的进程组ID</td>
</tr>
<tr>
<td>-G</td>
<td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td>
</tr>
<tr>
<td>-n</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td>
</tr>
<tr>
<td>-o</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td>
</tr>
<tr>
<td>-P</td>
<td>根据父进程PID，找出所有子进程的pid</td>
</tr>
<tr>
<td>-s</td>
<td>匹配会话ID</td>
</tr>
<tr>
<td>-t</td>
<td>通过控制终端匹配</td>
</tr>
<tr>
<td>-u</td>
<td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td>
</tr>
<tr>
<td>-U</td>
<td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td>
</tr>
<tr>
<td>-x</td>
<td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td>
</tr>
<tr>
<td>-F</td>
<td>从文件中读取PID</td>
</tr>
<tr>
<td>-L</td>
<td>如果PID文件未锁定，则失败</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="列出要查找的进程"><a href="#列出要查找的进程" class="headerlink" title="列出要查找的进程"></a>列出要查找的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep ceph</div><div class="line">1478 [ceph-msgr]</div><div class="line">4682 [ceph-watch-noti]</div><div class="line">7058 /usr/bin/ceph-mon</div><div class="line">9371 /usr/bin/ceph-osd</div></pre></td></tr></table></figure>
<h4 id="自定义输出进程间分隔符"><a href="#自定义输出进程间分隔符" class="headerlink" title="自定义输出进程间分隔符"></a>自定义输出进程间分隔符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -d , ceph</div><div class="line">1478 ceph-msgr,4682 ceph-watch-noti,7058 ceph-mon,9371 ceph-osd</div><div class="line"># pgrep -l -d ... ceph</div><div class="line">1478 ceph-msgr...4682 ceph-watch-noti...7058 ceph-mon...9371 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="否定匹配"><a href="#否定匹配" class="headerlink" title="否定匹配"></a>否定匹配</h4><p>列出所有进程名中不包含 ceph 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -v ceph</div><div class="line">...</div><div class="line">4046 scst_mgmtd</div><div class="line">5408 kworker/2:1H</div><div class="line">6402 bioset</div><div class="line">6403 rbd00_0</div><div class="line">8734 rbd01_0</div><div class="line">8739 xfsalloc</div><div class="line">8741 xfs_mru_cache</div><div class="line">9153 xfs-buf/vdb1</div><div class="line">9154 xfs-data/vdb1</div><div class="line">9155 xfs-conv/vdb1</div><div class="line">9156 xfs-cil/vdb1</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="列出所有TID"><a href="#列出所有TID" class="headerlink" title="列出所有TID"></a>列出所有TID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -w ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">7062 ceph-mon</div><div class="line">7063 ceph-mon</div><div class="line">...</div><div class="line">6661 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line">9373 ceph-osd</div><div class="line">9374 ceph-osd</div><div class="line">...</div><div class="line">9702 ceph-osd</div><div class="line">27446 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="统计匹配到的进程数"><a href="#统计匹配到的进程数" class="headerlink" title="统计匹配到的进程数"></a>统计匹配到的进程数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -c ceph</div><div class="line">4</div></pre></td></tr></table></figure>
<h4 id="匹配全名"><a href="#匹配全名" class="headerlink" title="匹配全名"></a>匹配全名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -f ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>感觉并没有什么卵用</p>
<h4 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h4><p>//TODO</p>
<h4 id="查找最新和最旧进程"><a href="#查找最新和最旧进程" class="headerlink" title="查找最新和最旧进程"></a>查找最新和最旧进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>查找最新(newest)、最后启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -n ceph</div><div class="line">4682 ceph-watch-noti</div></pre></td></tr></table></figure>
<p>查找最旧(oldest)、最早启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -o ceph</div><div class="line">7058 ceph-mon</div></pre></td></tr></table></figure>
<blockquote>
<p>注：进程号越大，并不一定意味着进程的启动时间越晚、进程越新</p>
</blockquote>
<h4 id="显示所有父进程的子进程"><a href="#显示所有父进程的子进程" class="headerlink" title="显示所有父进程的子进程"></a>显示所有父进程的子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># pgrep -P 2380</div><div class="line">2381</div><div class="line">2382</div><div class="line">2383</div><div class="line">2384</div><div class="line">2385</div></pre></td></tr></table></figure>
<h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line"># pgrep -x ceph</div><div class="line"># pgrep -x ceph-osd</div><div class="line">9371</div></pre></td></tr></table></figure>
<h4 id="从文件中读取PID"><a href="#从文件中读取PID" class="headerlink" title="从文件中读取PID"></a>从文件中读取PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat pid-file.txt </div><div class="line">1478</div><div class="line">7051</div><div class="line">2222</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -F pid-file.txt </div><div class="line">1478 ceph-msgr</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>PID和TID的区别</p>
<p>pid是进程标识符，tid是线程标识符。</p>
<p>内核不会在它们之间做出真正的区分：线程就像进程一样，但它们与同一组的其他实例共享一些东西（内存，fds …）。</p>
<p>因此，tid实际上是内核（线程）中可调度对象的标识符，而pid是共享内存和fds（进程）的可调度对象组的标识符。当一个进程只有一个线程，pid和tid总是相同的。 所以任何使用tid的函数都会自动使用pid。</p>
<p>值得注意的是，许多函数/系统调用/命令行实用程序记录使用pid实际上使用tids。 但如果效果是过程范围的，你就不会注意到差异。</p>
<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>与 <code>pgrep</code> 使用方法基本类似，不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># pkill --help</div><div class="line"></div><div class="line">Usage:</div><div class="line"> pkill [options] &lt;pattern&gt;</div><div class="line"></div><div class="line">Options:</div><div class="line"> -&lt;sig&gt;, --signal &lt;sig&gt;    signal to send (either number or name)</div><div class="line"> -e, --echo                display what is killed</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see pgrep(1).</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——strace]]></title>
      <url>http://xiaqunfeng.cc/2017/02/16/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94strace/</url>
      <content type="html"><![CDATA[<p>strace命令，用来查看运行程序的系统调用，统计每个系统调用的时间。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<p>我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。 </p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usage: strace [-CdffhiqrtttTvVxxy] [-I n] [-e expr]...</div><div class="line">              [-a column] [-o file] [-s strsize] [-P path]...</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div><div class="line">   or: strace -c[df] [-I n] [-e expr]... [-O overhead] [-S sortby]</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</div><div class="line">-d 输出strace关于标准错误的调试信息.</div><div class="line">-f 跟踪由fork调用所产生的子进程.</div><div class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</div><div class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</div><div class="line">-h 输出简要的帮助信息.</div><div class="line">-i 输出系统调用的入口指针.</div><div class="line">-q 禁止输出关于脱离的消息.</div><div class="line">-r 打印出相对时间关于,,每一个系统调用.</div><div class="line">-t 在输出中的每一行前加上时间信息.</div><div class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</div><div class="line">-ttt 微秒级输出,以秒了表示时间.</div><div class="line">-T 显示每一调用所耗的时间.</div><div class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</div><div class="line">-V 输出strace的版本信息.</div><div class="line">-x 以十六进制形式输出非标准字符串</div><div class="line">-xx 所有字符串以十六进制形式输出.</div><div class="line">-a column</div><div class="line">设置返回值的输出位置.默认 为40.</div><div class="line">-e expr</div><div class="line">指定一个表达式,用来控制如何跟踪.格式如下:</div><div class="line">[qualifier=][!]value1[,value2]...</div><div class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</div><div class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</div><div class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</div><div class="line">-e trace=set</div><div class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</div><div class="line">-e trace=file</div><div class="line">只跟踪有关文件操作的系统调用.</div><div class="line">-e trace=process</div><div class="line">只跟踪有关进程控制的系统调用.</div><div class="line">-e trace=network</div><div class="line">跟踪与网络有关的所有系统调用.</div><div class="line">-e strace=signal</div><div class="line">跟踪所有与系统信号有关的 系统调用</div><div class="line">-e trace=ipc</div><div class="line">跟踪所有与进程通讯有关的系统调用</div><div class="line">-e abbrev=set</div><div class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</div><div class="line">-e raw=set</div><div class="line">将指 定的系统调用的参数以十六进制显示.</div><div class="line">-e signal=set</div><div class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</div><div class="line">-e read=set</div><div class="line">输出从指定文件中读出 的数据.例如:</div><div class="line">-e read=3,5</div><div class="line">-e write=set</div><div class="line">输出写入到指定文件中的数据.</div><div class="line">-o filename</div><div class="line">将strace的输出写入文件filename</div><div class="line">-p pid</div><div class="line">跟踪指定的进程pid.</div><div class="line">-s strsize</div><div class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</div><div class="line">-u username</div><div class="line">以username 的UID和GID执行被跟踪的命令</div></pre></td></tr></table></figure>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p>先用一个程序当例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#cat test.c </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() </div><div class="line">&#123; </div><div class="line">	int a; </div><div class="line">	scanf(&quot;%d&quot;, &amp;a); </div><div class="line">	printf(&quot;%09d\n&quot;, a); </div><div class="line">	return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译：<code>gcc -o test test.c</code> 得到可执行文件 test</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># strace ./test </div><div class="line">execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 20 vars */]) = 0</div><div class="line">brk(0)                                  = 0x9fa000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a68a000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=30643, ...&#125;) = 0</div><div class="line">mmap(NULL, 30643, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb60a682000</div><div class="line">close(3)                                = 0</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;..., 832) = 832</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1840928, ...&#125;) = 0</div><div class="line">mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb60a0a5000</div><div class="line">mprotect(0x7fb60a25f000, 2097152, PROT_NONE) = 0</div><div class="line">mmap(0x7fb60a45f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fb60a45f000</div><div class="line">mmap(0x7fb60a465000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb60a465000</div><div class="line">close(3)                                = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a681000</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a67f000</div><div class="line">arch_prctl(ARCH_SET_FS, 0x7fb60a67f740) = 0</div><div class="line">mprotect(0x7fb60a45f000, 16384, PROT_READ) = 0</div><div class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</div><div class="line">mprotect(0x7fb60a68c000, 4096, PROT_READ) = 0</div><div class="line">munmap(0x7fb60a682000, 30643)           = 0</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a689000</div><div class="line">read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)                  = 4</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a688000</div><div class="line">write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)             = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<ul>
<li>从trace结构可以看到，系统首先调用execve开始一个新的进行</li>
<li>接着进行些环境的初始化操作</li>
<li>最后停顿在”read(0,”上面，这也就是执行到了我们的scanf函数，等待我们输入数字</li>
<li>输入完100之后，再调用write函数将格式化后的数值”0000000100″输出到屏幕</li>
<li>最后调用exit_group退出进行，完成整个程序的执行过程</li>
</ul>
<p>如果在执行的过程中，进程 <code>test</code> 被kill掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd8d880a000</div><div class="line">read(0, 0x7fd8d880a000, 1024)           = ? ERESTARTSYS (To be restarted if SA_RESTART is set)</div><div class="line">--- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=1161, si_uid=0&#125; ---</div><div class="line">+++ killed by SIGTERM +++</div></pre></td></tr></table></figure>
<p>告诉你test进程”+++ killed by SIGTERM +++”</p>
<h3 id="系统调用统计"><a href="#系统调用统计" class="headerlink" title="系统调用统计"></a>系统调用统计</h3><p>使用参数 <code>-c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># strace -c ./test </div><div class="line">99</div><div class="line">000000099</div><div class="line">% time     seconds  usecs/call     calls    errors syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">  0.00    0.000000           0         2           read</div><div class="line">  0.00    0.000000           0         1           write</div><div class="line">  0.00    0.000000           0         2           open</div><div class="line">  0.00    0.000000           0         2           close</div><div class="line">  0.00    0.000000           0         4           fstat</div><div class="line">  0.00    0.000000           0         9           mmap</div><div class="line">  0.00    0.000000           0         4           mprotect</div><div class="line">  0.00    0.000000           0         1           munmap</div><div class="line">  0.00    0.000000           0         1           brk</div><div class="line">  0.00    0.000000           0         3         3 access</div><div class="line">  0.00    0.000000           0         1           execve</div><div class="line">  0.00    0.000000           0         1           arch_prctl</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">100.00    0.000000                    31         3 total</div></pre></td></tr></table></figure>
<p>很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。这里太快了，都是0。</p>
<h3 id="追踪现有进程"><a href="#追踪现有进程" class="headerlink" title="追踪现有进程"></a>追踪现有进程</h3><p>参数<code>-p</code> ，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -p pid</div></pre></td></tr></table></figure>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>使用参数<code>-o</code> 将strace的结果输出到文件中，如果不指定-o参数的话，默认的输出设备是STDERR，也就是说使用”-o filename”和” 2&gt;filename”的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 这两个命令都是将strace结果输出到文件test.txt中 </div><div class="line">strace -c -o test.txt ./test </div><div class="line">strace -c ./test 2&gt;test.txt</div></pre></td></tr></table></figure>
<h3 id="系统调用计时"><a href="#系统调用计时" class="headerlink" title="系统调用计时"></a>系统调用计时</h3><p>使用参数 <code>-T</code> 将每个系统调用所花费的时间打印出来，每个调用的时间花销现在在调用行最右边的尖括号里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000013&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31135000 &lt;0.000015&gt;</div><div class="line">read(0, 54</div><div class="line">&quot;54\n&quot;, 1024)                   = 3 &lt;9.354830&gt;</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000012&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31134000 &lt;0.000013&gt;</div><div class="line">write(1, &quot;000000054\n&quot;, 10000000054</div><div class="line">)             = 10 &lt;0.000010&gt;</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<p>使用参数 <code>-t</code> 输出结果精确到秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:21:20 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)         = 4</div><div class="line">20:21:24 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:21:24 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa926d0b000</div><div class="line">20:21:24 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)    = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-tt</code> 输出结果精确到微秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:24:52.063615 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)  = 4</div><div class="line">20:24:54.031118 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:24:54.031167 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2dc4bd3000</div><div class="line">20:24:54.031210 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-ttt</code> 输出结果精确到微秒，而且时间表示为unix时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1487247731.103542 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024) = 4</div><div class="line">1487247887.084673 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">1487247887.084717 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22beb1f000</div><div class="line">1487247887.084812 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<h3 id="截断输出"><a href="#截断输出" class="headerlink" title="截断输出"></a>截断输出</h3><p><code>-s</code> 参数用于指定trace结果的每一行输出的字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># strace -s 3 ./test </div><div class="line">...</div><div class="line">read(0, 1024</div><div class="line">&quot;102&quot;..., 1024)                 = 5</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdeeb74a000</div><div class="line">write(1, &quot;000&quot;..., 10000001024</div><div class="line">)                  = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<h3 id="跟踪服务程序"><a href="#跟踪服务程序" class="headerlink" title="跟踪服务程序"></a>跟踪服务程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o output.txt -T -tt -e trace=all -p 28979</div></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h3 id="跟踪可执行程序"><a href="#跟踪可执行程序" class="headerlink" title="跟踪可执行程序"></a>跟踪可执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -f -F -o ~/straceout.txt myserver</div></pre></td></tr></table></figure>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>参考资料：</p>
<p><a href="http://man.linuxde.net/strace" target="_blank" rel="external">strace命令</a></p>
<p><a href="http://huoding.com/2013/10/06/288" target="_blank" rel="external">通过Strace定位故障原因</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取每个osd的PG数]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%AAosd%E7%9A%84PG%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个shell脚本，用于获取ceph集群中每个osd的PG数，同时分别统计每个pool上的PG数信息。<br><a id="more"></a></p>
<h2 id="Ceph集群信息"><a href="#Ceph集群信息" class="headerlink" title="Ceph集群信息"></a>Ceph集群信息</h2><p><strong>pool信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd lspools</div><div class="line">0 rbd,1 testpool,</div></pre></td></tr></table></figure>
<p><strong>osd信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.54538 root default                                      </div><div class="line">-2 0.18179     host jewel0                                   </div><div class="line"> 0 0.18179         osd.0        up  1.00000          1.00000 </div><div class="line">-3 0.18179     host jewel1                                   </div><div class="line"> 1 0.18179         osd.1        up  1.00000          1.00000 </div><div class="line">-4 0.18179     host jewel2                                   </div><div class="line"> 2 0.18179         osd.2        up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h2 id="脚本执行结果展示"><a href="#脚本执行结果展示" class="headerlink" title="脚本执行结果展示"></a>脚本执行结果展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># sh pg-per-osd.sh </div><div class="line">dumped all in format plain</div><div class="line"></div><div class="line">pool :	0	1	| SUM </div><div class="line">--------------------------------</div><div class="line">osd.0	64	128	| 192</div><div class="line">osd.1	64	128	| 192</div><div class="line">osd.2	64	128	| 192</div><div class="line">--------------------------------</div><div class="line">SUM :	192	384</div></pre></td></tr></table></figure>
<p>每行显示单个OSD在每个pool中的PG数详情</p>
<p>每列显示单个pool中每个OSD的PG数详情</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat pg-per-osd.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ceph pg dump | awk &apos;</div><div class="line"> /^pg_stat/ &#123; col=1; while($col!=&quot;up&quot;) &#123;col++&#125;; col++ &#125;</div><div class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</div><div class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</div><div class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</div><div class="line">&#125;</div><div class="line">END &#123;</div><div class="line"> printf(&quot;\n&quot;);</div><div class="line"> printf(&quot;pool :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,i); printf(&quot;| SUM \n&quot;);</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> for (i in osdlist) &#123; printf(&quot;osd.%i\t&quot;, i); sum=0;</div><div class="line">   for (j in poollist) &#123; printf(&quot;%i\t&quot;, array[i,j]); sum+=array[i,j]; sumpool[j]+=array[i,j] &#125;; printf(&quot;| %i\n&quot;,sum) &#125;</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> printf(&quot;SUM :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,sumpool[i]); printf(&quot;|\n&quot;);</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> osd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RBD 相关操作]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/RBD-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要有两点：一、创建RBD设备用于测试；二、RBD相关其他操作。<br><a id="more"></a></p>
<p>查看系统和内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 14.04.4 LTS</div><div class="line">Release:	14.04</div><div class="line">Codename:	trusty</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">4.2.0-27-generic</div></pre></td></tr></table></figure>
<h2 id="创建RBD设备"><a href="#创建RBD设备" class="headerlink" title="创建RBD设备"></a>创建RBD设备</h2><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>1、<code>--image-format format-id</code></p>
<p>选择用哪个对象布局，默认为 2 。</p>
<ul>
<li>format 1 - 新建 rbd 映像时使用最初的格式。此格式兼容所有版本的 librbd 和内核模块，但是不支持较新的功能，像克隆。</li>
<li>format 2 - 使用第二版 rbd 格式， librbd 和 3.11 版以上内核模块才支持（除非是分拆的模块）。此格式增加了克隆支持，使得扩展更容易，还允许以后增加新功能。</li>
</ul>
<p>注意： <code>--image-format 1</code> 已不被支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-f1 --size 10G --image-format 1 --image-feature layering </div><div class="line">rbd: image format 1 is deprecated</div><div class="line">rbd: features not allowed with format 1; use --image-format 2</div></pre></td></tr></table></figure>
<p>2、<code>--image-feature   feature</code></p>
<p>选项指定使用特性，不用全部开启。如果仅需要使用快照等特性，开启layering即可。</p>
<ul>
<li>layering: 支持分层</li>
<li>striping: 支持条带化 v2</li>
<li>exclusive-lock: 支持独占锁</li>
<li>object-map: 支持对象映射（依赖 exclusive-lock ）</li>
<li>fast-diff: 快速计算差异（依赖 object-map ）</li>
<li>deep-flatten: 支持快照扁平化操作</li>
<li>journaling: 支持记录 IO 操作（依赖独占锁）</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>这里 <code>--image-format 2</code> 可以省略掉（命令如下），因为默认值就是 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-blue --size 20G --image-feature layering</div></pre></td></tr></table></figure>
<p>查看创建的RBD信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-blue</div><div class="line">rbd image &apos;rbd-blue&apos;:</div><div class="line">	size 20480 MB in 5120 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.105774b0dc51</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<h2 id="映射块设备"><a href="#映射块设备" class="headerlink" title="映射块设备"></a>映射块设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-blue</div><div class="line">/dev/rbd0</div></pre></td></tr></table></figure>
<p>查看映射后信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped </div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># fdisk -l /dev/rbd0</div><div class="line"># mkfs.xfs /dev/rbd0</div></pre></td></tr></table></figure>
<h3 id="创建文件夹并挂载"><a href="#创建文件夹并挂载" class="headerlink" title="创建文件夹并挂载"></a>创建文件夹并挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mkdir /mnt/ceph-disk1</div><div class="line"># mount /dev/rbd0 /mnt/ceph-disk1</div><div class="line"></div><div class="line"># df -h /mnt/ceph-disk1/</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/rbd0        20G   33M   20G   1% /mnt/ceph-disk1</div></pre></td></tr></table></figure>
<blockquote>
<p>此时，RBD设备已准备就绪，可以对RBD块设备进行测试了。</p>
</blockquote>
<h2 id="块设备其他操作"><a href="#块设备其他操作" class="headerlink" title="块设备其他操作"></a>块设备其他操作</h2><h3 id="罗列块设备映像"><a href="#罗列块设备映像" class="headerlink" title="罗列块设备映像"></a>罗列块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd ls &#123;poolname&#125;	# poolname默认是rbd，可省略</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># rbd ls</div><div class="line">rbd-blue</div><div class="line">rbd-tmp</div><div class="line">rbd-tmp1</div></pre></td></tr></table></figure>
<h3 id="检索镜像信息"><a href="#检索镜像信息" class="headerlink" title="检索镜像信息"></a>检索镜像信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;pool-name&#125;/&#123;image-name&#125;</div></pre></td></tr></table></figure>
<p>如果没有创建其他rbd的话，可以将命令简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;image-name&#125;</div></pre></td></tr></table></figure>
<h3 id="调整块设备映像大小"><a href="#调整块设备映像大小" class="headerlink" title="调整块设备映像大小"></a>调整块设备映像大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd resize --size 2048 rbd-blue (to increase)</div><div class="line">rbd resize --size 2048 rbd-blue --allow-shrink (to decrease)</div></pre></td></tr></table></figure>
<h3 id="删除块设备映像"><a href="#删除块设备映像" class="headerlink" title="删除块设备映像"></a>删除块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd rm &#123;pool-name&#125;/&#123;image-name&#125;	# 默认pool是rbd，可省略&#123;pool-name&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在删除前需要umap映像</p>
</blockquote>
<h4 id="正确删除过程"><a href="#正确删除过程" class="headerlink" title="正确删除过程"></a><strong>正确删除过程</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped</div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd unmap /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">Removing image: 100% complete...done.</div></pre></td></tr></table></figure>
<p>注意：命令 <code>service rbdmap stop</code> 并不管用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service rbdmap stop</div><div class="line">stop: Job failed while stopping</div></pre></td></tr></table></figure>
<h4 id="不unmap的删除"><a href="#不unmap的删除" class="headerlink" title="不unmap的删除"></a><strong>不unmap的删除</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">2017-02-08 11:17:47.700190 7f4ba6977000 -1 librbd: image has watchers - not removing</div><div class="line">Removing image: 0% complete...failed.</div><div class="line">rbd: error: image still has watchers</div><div class="line">This means the image is still open or the client using it crashed. Try again after closing/unmapping it or waiting 30s for the crashed client to timeout.</div></pre></td></tr></table></figure>
<p>提示image正在被使用。如果想查看谁正在使用的话，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-tmp1</div><div class="line">rbd image &apos;rbd-tmp1&apos;:</div><div class="line">	size 10240 MB in 2560 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.104c2ae8944a</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags: </div><div class="line"></div><div class="line"># rados -p rbd listwatchers rbd_header.104c2ae8944a</div><div class="line">watcher=172.20.1.151:0/1839598827 client.4186 cookie=3</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面这种方式创建RBD在map的时候会失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create --size 10240 rbd-test</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-test</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div><div class="line">rbd: map failed: (6) No such device or address</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rbd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Kraken release版本上测试Ceph BlueStore]]></title>
      <url>http://xiaqunfeng.cc/2017/02/07/%E5%9C%A8Kraken-release%E7%89%88%E6%9C%AC%E4%B8%8A%E6%B5%8B%E8%AF%95Ceph-BlueStore/</url>
      <content type="html"><![CDATA[<p>前面写了一篇文章《ceph升级到kraken版本》，在升级后的集群上重新部署OSD遇到一些问题。这里在干净的kraken环境下部署bluestore，用来测试一下性能。本文记录部署过程及遇到的问题和解决方法。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ceph版本Kraken（11.2.0）已经发布，发行说明告诉我们，用于OSD的新的BlueStore后端现在可用。</p>
<h2 id="bluestore"><a href="#bluestore" class="headerlink" title="bluestore"></a>bluestore</h2><p>OSD的当前后端是FileStore，它主要使用XFS文件系统来存储它的数据。 为了克服XFS和POSIX的一些限制，所以开发了BlueStore后端。</p>
<p>由于校验和压缩它将提供更多的性能（主要是写）和数据安全。</p>
<p>鼓励用户从Kraken发行版本开始，使用非生产和非关键数据集来测试BlueStore，并向社区报告。</p>
<h2 id="部署BlueStore"><a href="#部署BlueStore" class="headerlink" title="部署BlueStore"></a>部署BlueStore</h2><p>要使用BlueStore部署OSD，您可以使用<code>-bluestore</code>标志来使用ceph-deploy。</p>
<p>我创建了一个简单的测试集群，有三个机器：alpha，bravo和charlie。</p>
<p>每个机器将运行一个ceph-mon和ceph-osd进程。</p>
<p>这是我用来部署集群的ceph-deploy命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph-deploy new alpha bravo charlie</div><div class="line">ceph-deploy mon create alpha bravo charlie</div></pre></td></tr></table></figure>
<p>现在，编辑当前目录中的ceph.conf文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[osd]</div><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>有了这个设置我们允许使用BlueStore，我们现在可以部署我们的OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf osd create --bluestore alpha:sdb bravo:sdb charlie:sdb</div></pre></td></tr></table></figure>
<h2 id="运行Bluestore"><a href="#运行Bluestore" class="headerlink" title="运行Bluestore"></a>运行Bluestore</h2><p>这个微小的集群如何使用BlueStore运行三个OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph -s</div><div class="line">    cluster c824e460-2f09-4994-8b2f-108aedc52d19</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;alpha=[2001:db8::100]:6789/0,bravo=[2001:db8::101]:6789/0,charlie=[2001:db8::102]:6789/0&#125;</div><div class="line">            election epoch 14, quorum 0,1,2 alpha,bravo,charlie</div><div class="line">        mgr active: charlie standbys: alpha, bravo</div><div class="line">     osdmap e14: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v24: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            43356 kB used, 30374 MB / 30416 MB avail</div><div class="line">                  64 active+clean</div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.02907 root default                                       </div><div class="line">-2 0.00969     host alpha                                     </div><div class="line"> 0 0.00969         osd.0         up  1.00000          1.00000 </div><div class="line">-3 0.00969     host bravo                                     </div><div class="line"> 1 0.00969         osd.1         up  1.00000          1.00000 </div><div class="line">-4 0.00969     host charlie                                   </div><div class="line"> 2 0.00969         osd.2         up  1.00000          1.00000 </div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<p>在alpha我看到osd.0只有一个小分区的一点配置，其余的由BlueStore使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# df -h /var/lib/ceph/osd/ceph-0</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/sdb1        97M  5.4M   92M   6% /var/lib/ceph/osd/ceph-0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# lsblk </div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sda      8:0    0    8G  0 disk </div><div class="line">├─sda1   8:1    0  7.5G  0 part /</div><div class="line">├─sda2   8:2    0    1K  0 part </div><div class="line">└─sda5   8:5    0  510M  0 part [SWAP]</div><div class="line">sdb      8:16   0   10G  0 disk </div><div class="line">├─sdb1   8:17   0  100M  0 part /var/lib/ceph/osd/ceph-0</div><div class="line">└─sdb2   8:18   0  9.9G  0 part </div><div class="line">sdc      8:32   0   10G  0 disk</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# cat /var/lib/ceph/osd/ceph-0/type</div><div class="line">bluestore</div></pre></td></tr></table></figure>
<p>OSD应该像运行FileStore的OSD一样工作，但它们应该运行得更好。</p>
<blockquote>
<p>以上内容翻译自：<a href="https://blog.widodh.nl/2017/01/testing-ceph-bluestore-with-the-kraken-release/" target="_blank" rel="external">Testing Ceph BlueStore with the Kraken release</a>。亲测可以成功，觉得很好就不放自己的配置，直接翻译过来了。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>问题1</strong>、<code>ceph -s</code>的时候出现告警：<code>WARNING: the following dangerous and experimental features are enabled: bluestore</code></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">2017-02-07 10:10:34.266900 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">2017-02-07 10:10:34.271112 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">    cluster 7e9423ea-95f8-42d1-ae2d-7a384d68dea7</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;blue0=172.20.1.151:6789/0,blue1=172.20.1.152:6789/0,blue2=172.20.1.153:6789/0&#125;</div><div class="line">            election epoch 6, quorum 0,1,2 blue0,blue1,blue2</div><div class="line">        mgr no daemons active </div><div class="line">     osdmap e15: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v34: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            49092 kB used, 599 GB / 599 GB avail</div><div class="line">                  64 active+clean</div></pre></td></tr></table></figure>
<p>查了资料，无果，有些认为是<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2016-April/009059.html" target="_blank" rel="external">内核版本的问题</a>，然而并不对。</p>
<p>真正原因是在添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>的时候忘记在前面加上：<code>[osd]</code></p>
<p><strong>问题2</strong>、从jewel版本上升级到kraken版本，然后再通过上述方法创建OSD并不成功</p>
<p><strong>问题3</strong>、创建mon的时候出现error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf mon create-initial</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bluestore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用户态和内核态]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      <content type="html"><![CDATA[<p>以前整理的小知识点，关于用户态和内核态的解释。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内核态与用户态是操作系统的两种运行级别，intel cpu提供Ring0-Ring3三种级别的运行模式。Ring0级别最高，Ring3最低。</p>
<p>所以当CPU处于内核态，可以随意进入用户态。当CPU处于用户态，只能通过中断的方式进入内核态。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。</p>
<h2 id="cpu的四种状态"><a href="#cpu的四种状态" class="headerlink" title="cpu的四种状态"></a>cpu的四种状态</h2><p>在一台运行 Linux 的计算机中，CPU 在任何时候只会有如下四种状态：</p>
<ol>
<li>在处理一个硬中断。</li>
<li>在处理一个软中断，如 softirq、tasklet 和 bh。</li>
<li>运行于内核态，但有进程上下文，即与一个进程相关。</li>
<li>运行一个用户态进程。</li>
</ol>
<p>其中，【1】、【2】和【3】是运行于内核空间的，而【4】是在用户空间。其中除了【4】，其他状态只可以被在其之上的状态抢占。比如，软中断只可以被硬中断抢占。</p>
<h2 id="linux下详解"><a href="#linux下详解" class="headerlink" title="linux下详解"></a>linux下详解</h2><p>Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。</p>
<p>Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。</p>
<p>用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。</p>
<p>这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph升级到kraken版本]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/ceph%E5%8D%87%E7%BA%A7%E5%88%B0kraken%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>记录从jewel版本升级到kraken版本的过程，其中重启mon和osd部分官网上的命令并不凑效，这里纠正并记录之。<br><a id="more"></a></p>
<h2 id="1、在Jewel集群上设置sortbitwise标志"><a href="#1、在Jewel集群上设置sortbitwise标志" class="headerlink" title="1、在Jewel集群上设置sortbitwise标志"></a>1、在Jewel集群上设置sortbitwise标志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd set sortbitwise</div></pre></td></tr></table></figure>
<h2 id="2、添加安装源"><a href="#2、添加安装源" class="headerlink" title="2、添加安装源"></a>2、添加安装源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo deb https://download.ceph.com/debian-kraken/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div></pre></td></tr></table></figure>
<p><strong>设置环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-kraken</div></pre></td></tr></table></figure>
<h2 id="3、升级软件包"><a href="#3、升级软件包" class="headerlink" title="3、升级软件包"></a>3、升级软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --release kraken ceph-0 ceph-1 ceph-2</div></pre></td></tr></table></figure>
<p>此时，ceph已升级到 11.2.0 版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --version</div><div class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div></pre></td></tr></table></figure>
<p>但是，osd和mon的版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-1: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-2: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="4、在各节点上重启相关ceph守护进程"><a href="#4、在各节点上重启相关ceph守护进程" class="headerlink" title="4、在各节点上重启相关ceph守护进程"></a>4、在各节点上重启相关ceph守护进程</h2><p>安装官网上的命令操作是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-1 sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-2 sudo /etc/init.d/ceph -a restart</div></pre></td></tr></table></figure>
<p>然而，查看 mon 的进程号发现并没有重启，所以版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ps aux | grep ceph-osd</div><div class="line"># ps aux | grep ceph-mon</div></pre></td></tr></table></figure>
<p><strong>正确的重启命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 重启mon</div><div class="line">restart ceph-mon-all</div><div class="line">ssh ceph-1 restart ceph-mon-all</div><div class="line">ssh ceph-2 restart ceph-mon-all</div><div class="line"></div><div class="line"># 重启osd</div><div class="line">restart ceph-osd-all</div><div class="line">ssh ceph-1 restart ceph-osd-all</div><div class="line">ssh ceph-2 restart ceph-osd-all</div></pre></td></tr></table></figure>
<p>也可以单独重启某一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># restart ceph-mon id=ceph-0</div><div class="line">ceph-mon (ceph/ceph-0) start/running, process 23629</div><div class="line"></div><div class="line"># restart ceph-osd id=0</div><div class="line">ceph-osd (ceph/0) start/running, process 23700</div></pre></td></tr></table></figure>
<p>查看最新mon和osd版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-1: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-2: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行 <code>ceph -s</code> 的时候，出现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 7251c881-bb25-4c36-9be1-653f66c69e1c</div><div class="line">     health HEALTH_WARN</div><div class="line">            all OSDs are running kraken or later but the &apos;require_kraken_osds&apos; osdmap flag is not set</div><div class="line">...省略</div></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd set require_kraken_osds</div><div class="line">require_kraken_osds is set</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kraken </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dm-cache vs Bcache]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Dm-cache-vs-Bcache/</url>
      <content type="html"><![CDATA[<p>前面一篇文章介绍了flashcache和cache tier，并进行了对比，其实flashcache的原理和dm-cache是类似的。这里就介绍下dm-cache和bcache，这两种策略均已在linux内核中。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代硬盘驱动器（HDD）已经走了很长的路。他们旋转得越来越快;与过去的HDD相比具有更高的存储密度和更低的错误率，但是它们和其前身一样，仍然被视为性能瓶颈。随着时间的推移，我们已经看到了许多缓存方案来提高性能;有一些块缓存解决方案在磁盘驱动器（磁盘或存储控制器）或使用主机系统内存的文件系统级缓存解决方案附近使用某种类型的缓存。随着企业级的可接受性，大而经济的闪存存储技术的可用性，使用固态驱动器（SSD）的块缓存解决方案作为性能增强解决方案。使用基于SSD的块缓存，我们可以寻找SSD速度和HDD容量 - 快速，大而且实惠。</p>
<p>在块缓存解决方案中，概念上，将逻辑设备呈现给文件系统（或多个应用），而不是实际目的地HDD（或其它目的地块设备，例如iSCSI LUN），其中数据意在被存储。因此呈现的逻辑设备与原始设备具有相同的大小物理设备，而用于高速缓存的SSD可以跨越逻辑设备映射。</p>
<p>Linux开源社区有多个通用的块级缓存解决方案，其中包括bcache，dm-cache和flashcache。 Linux内核社区将内核3.9中的dm-cache上游和内核3.10中的bcache合并。虽然flashcache未在上游合并，但在某些生产环境中已经使用了一段时间。</p>
<h2 id="dm-cache"><a href="#dm-cache" class="headerlink" title="dm-cache"></a>dm-cache</h2><p>又叫 Device Mapper Cache。dm-cache是设备映射器目标，首先提交到kernel-3.9。它使用针对基于闪存的SSD进行优化的I / O调度和缓存管理技术。设备映射程序目标（dmcache）重新使用精简资源调配库中使用的元数据库。write-back和writethrough都由dm-cache支持，write-back是默认模式。</p>
<p>由dm-cache创建的虚拟缓存设备使用源设备（Origin device）、缓存设备（Cache device）和元数据设备（Metadata dev）这三个物理设备来构建。结构如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/dm-cache.png" alt="dm-cache"></p>
<p>源设备是实际（较慢）目的存储设备。</p>
<p>高速缓存设备是用于临时存储用户数据的较快设备。</p>
<p>元数据设备记录块布局，它们的dirty flags和其他内部数据所需的策略。</p>
<h2 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h2><p>bcache首先提交到kernel-3.10。它围绕基于闪存的SSD的独特特性设计，并使用混合btree/log结构来跟踪缓存的区域。它旨在不惜一切代价（at all cost）避免随机写。 bcache顺序填充一个擦除块，然后在重新使用之前发出一个丢弃（缓存数据可以是桶上的任意一个扇区。bcache最大程度上减少了随机写的代价，它按顺序填充一个桶，重新使用时只需将桶设置为无效）。支持write-through和write-back高速缓存。write-back默认关闭，但可以在运行时任意打开和关闭。</p>
<p>通过后端设备（backing device）和缓存设备（caching device）来创建虚拟的bcache 设备，如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/bcache.png" alt="bcache"></p>
<p>后端设备是实际（较慢）目的存储设备，而高速缓存设备是更快的设备。后备设备必须格式化为bcache 块设备；现有的格式化分区不能与bcache一起使用。（可以尝试 blocks to-bcache进行就地转换）。</p>
<p>默认状态下bcache不缓存顺序IO，只缓存随机读写。为避免随机写，bcache将随机写转换为顺序写，首先写到SSD，然后回写缓存使用SSD缓存大量的写，最后将写有序写到磁盘或者阵列上。</p>
<p>SSD的特点就是随机IO速度很快，而对于大块顺序IO的提升却并不大。bcache会检测顺序IO并忽略；还会对每一个任务记录动态的平均IO大小，当平均IO大小超过截止值时该任务后面的IO将会被忽略，这样就可以透传备份或者大文件拷贝。</p>
<h2 id="Dm-cache-vs-Bcache"><a href="#Dm-cache-vs-Bcache" class="headerlink" title="Dm-cache vs Bcache"></a>Dm-cache vs Bcache</h2><p>与 dm-cache 实现的的分级存储不同，bcache 更像一个传统的缓存。它可以用来存储任何 extents，甚至是是一个扇区，而 dm-cache 只能对整块数据进行缓存。</p>
<p>dm-cache方案假设缓存设备总是存在，bcache 并不要求 cache 设备一直都在。 </p>
<p>bcache 已经在实际产品中使用了，所以它有机会去碰到这些疑难场景，并可以处理这些缓存设备无法工作的情形。</p>
<p>dm-cache 确实还有很多事情要做。起初，它是进行 cache 和原始设备的并行 IO，但最终不得不回到顺序 IO。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flashcache vs Cache tier]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Flashcache-vs-Cache-tier/</url>
      <content type="html"><![CDATA[<p>使用SSD作为缓存来提高性能有多种方法，文章前言里会介绍，主要有bcache、dm-cache、flashcache、cache tier等，本文比较两种在ceph中的常用方案：flashcache 和 cache tier。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的HDD具备大容量的优势，但是性能相对偏低，尤其是随机IO性能，经常成为系统的性能瓶颈，在虚拟机化环境下表现的更明显，因为虚拟化场景会加剧IO随机化。相比HDD，SSD具有高性能的优势，尤其在随机IO这方面，优势非常明显，但是SSD的硬件成本比较高。</p>
<p>目前业界在结合HDD的大容量和SSD的高性能方面做了一些优化，基本思路是使用SSD作为HDD的cache。计算机领域，cache的思想无处不在，比如CPU的L1、L2 cache，raid card上的cache，TLB cache等。关于SSD作为HDD的cache的优化方案，主要有Linux bcache，Linux dm-cache，Facebook flashcache，btier，IBM flashcache等。</p>
<h2 id="flashcache"><a href="#flashcache" class="headerlink" title="flashcache"></a>flashcache</h2><p>flashcache 是 facebook 开源的 ssd 存储产品，它基于内核的 devicemapper 机制，允许将 ssd 设备映射为机械存储设备的缓存，堆叠成为一个虚拟设备供用户读写，从而在一定程度上兼顾 ssd 的高速与机械存储设备的高容量，更加经济高效地支撑线上业务。</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/flashcache.png" alt="flashcache"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Device Mapper层，对外服务体现方式是块设备，无需修改应用。</p>
<p>确保内核已启用 DeviceMapper，编译内核模块并安装之后：</p>
<ul>
<li>创建缓存设备: flashcache_wt_create /dev/cachedev /dev/sda1 /dev/hda1</li>
<li>删除缓存设备: dmsetup remove cachedev </li>
</ul>
<p>使用者需要注意建立缓存设备之后，就不应该再对 /dev/sda1 和 /dev/hda1 两个设备直接读写了。</p>
<p>用户操作接口是映射之后的虚拟设备，即/dev/mapper/*下面的设备，如cachedev，而不是基设备</p>
<h3 id="缓存的组织"><a href="#缓存的组织" class="headerlink" title="缓存的组织"></a>缓存的组织</h3><p>flashcache是建立在Linux devicemapper之上的，由devicemapper在SSD和backing HDD之上创建了一个逻辑的mapped device，用户使用的就是这个mapped device。</p>
<p>flashcache把cache（SSD）按照哈希的方式进行结构化管理，flashcache 中缓存的盘块的默认大小为 4kb，按照多路组相连的形式组织缓存块，每组含有 512 个缓存块，简单按照取模分组。缓存的查找，就是对后端设备块号取模得到组号，然后凭偏移遍历组中的缓存块。具体管理方式可以参考小结末参考资料。</p>
<p>虽然数据会被写入 ssd 设备，但缓存的组织信息一律保存在内存中，即 cache_c 对象。它里面保存了基本的配置选项、统计信息、对两个设备的引用、每个缓存块的相关信息(cache, cache_state)、 以及缓存组中 FIFO 数组(虽然名字叫做 LRU)的下标。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>flashcache 支持三种缓存策略：</p>
<ul>
<li>writethrough：disk write会在cache中保留一份，但同时也会把数据write到backing disk中，直到write backing disk完成才会返回。</li>
<li>writearound：disk write会bypass cache，直接写到backing disk中，disk read会把从backing disk中读取的数据在cache中缓存。</li>
<li>writeback：write首先会写到cache中，然后更新metadata中得dirty bit，数据并不会立即同步到backing disk中。</li>
</ul>
<p>针对writethrough和writearound，disk read首先根据目的sector找到对应的cache set，然后查找有没有相应的block，如果找到了，也就是cache hit，则直接从cache中读取，如果没有找到，就从backing disk中读取数据，同时也在cache中进行缓存。</p>
<h3 id="数据调度"><a href="#数据调度" class="headerlink" title="数据调度"></a>数据调度</h3><p>DM层request送往flashcache，并将读写请求按照目标设备的blocksize进行划分，切割成blocksize大小的bio。</p>
<p><strong>读</strong></p>
<p>接收到bio，首先，根据bio-&gt;bi_sector，即硬盘的扇区号，得到SSD上的set；</p>
<p>其次，在set内查找是否命中，如果命中，则将硬盘的扇区号转换为SSD的扇区号，然后将此bio向SSD提交，进行读取；</p>
<p>如果未命中，则首先向硬盘驱动提交bio，从硬盘读数据，读取完成后，由回调函数启动回写SSD操作，将bio的扇区号转换为SSD的=扇区号，然后向SSD驱动程序提交，将硬盘读取的数据写入SSD。</p>
<p><strong>写</strong></p>
<p>同文件系统页缓冲，并不直接写入硬盘，而是写入SSD，同时，保持一个阀值，一般为20%，在脏块数目达到此数值时，写回磁盘。</p>
<p>另外：如果<strong>IO size小于blocksize</strong>，flashcache则不会缓存该IO，而是先查找cache中有没有overlap的脏数据：</p>
<p>如果有的话，就先刷脏数据，然后再把刚才从devicemapper传来的IO写到backing disk上</p>
<p>如果没有脏数据，则直接写到backing disk上，这也就是为什么当使用fio测试小于4KB的随机IO时，flashcache几乎没有效果。</p>
<p>部分参考资料：</p>
<p><a href="http://mogu.io/Facebook_flashcache-81" target="_blank" rel="external">Facebook flashcache介绍与使用</a></p>
<p><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/flashcache-introduction?lang=en" target="_blank" rel="external">flashcache 简介</a></p>
<p><a href="http://blog.csdn.net/kidd_3/article/category/905673" target="_blank" rel="external">其他flashcache资料</a></p>
<h2 id="cache-tier"><a href="#cache-tier" class="headerlink" title="cache tier"></a>cache tier</h2><p>缓存分层通过将一部分数据存到缓存层，给ceph客户端提供更好的IO性能。通常是在更快的磁盘上创建存储池，如SSD/NVMe。数据最终被透明的写入常规的存储池中，它们由副本或纠删码类型的存储池所构建。</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/cache%20tier.png" alt="cache tier"></p>
<p>缓存层代理自动处理缓存层和后端存储之间的数据迁移，对客户端透明，管理员可以配置迁移进行的方式。</p>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>缓存分层主要有两种模式：writeback 和 read-only。如果是write-back模式，那么该cache pool 既是read tier ，又是 write tier； 如果只是read only 模式，那么实际上，cache pool 只是 read tier，没有write tier。</p>
<h3 id="writeback模式"><a href="#writeback模式" class="headerlink" title="writeback模式"></a>writeback模式</h3><p>客户端写数据到缓存层后立刻收到确认回复。基于配置的flush/evict策略，数据从缓存层迁移到存储层，最后缓存分层代理从缓存层中将数据删除。</p>
<p>当读操作在缓存中miss的时候</p>
<p>1、返回client结果为cache miss，重新向存储层发起读请求。</p>
<p>2、cache层向存储层发起读请求，返回client的同时缓存一份在cache层</p>
<p>写操作在缓存中miss的时候</p>
<p>直接向存储层写，然后逐级返回，并不将数据缓存在cache层</p>
<p>这种模式适合大量修改数据的场景。</p>
<h3 id="read-only模式"><a href="#read-only模式" class="headerlink" title="read-only模式"></a>read-only模式</h3><p>缓存层只服务于客户端的读操作。当读请求在缓存层中miss的时候，从存储层中读上来，并设置一个expire时间，过期自动被删除。cache层可以设置为单副本，极大减少缓存空间占用率。写操作直接写到后端的存储层。</p>
<p>这种模式适合一次写入多次读取的场景。</p>
<h2 id="Flashcache-vs-Cache-tier"><a href="#Flashcache-vs-Cache-tier" class="headerlink" title="Flashcache vs Cache tier"></a>Flashcache vs Cache tier</h2><p>flashcache将缓存在块层的东西，而缓存池将缓存对象层的东西。 在每种情况下都有潜在的优点和缺点。 一些初始猜测：</p>
<p><strong>flashcache</strong></p>
<ul>
<li>[x] 所有缓存对一个节点是本地的，更少的开销（包括网络）。</li>
<li>[x] 在许多对象访问和大量热的inodes / dentries的情况下可以做得更好</li>
<li>无法仅为高速缓存定义不同的 副本/ EC 策略。</li>
<li>缓存写入是非原子的</li>
</ul>
<p><strong>Ceph cache tier</strong></p>
<ul>
<li>[x] 潜在可以做的事情，如副本缓存和EC存冷数据。</li>
<li>[x] 更安全</li>
<li>更多的网络开销，可能会有更多的CPU开销。</li>
<li>需要更长的时间才能将内容缓存</li>
</ul>
<p>参考资料：<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2014-March/037861.html" target="_blank" rel="external"> OSD + FlashCache vs. Cache Pool for RBD</a></p>
<p><strong>关于成本</strong></p>
<p>高速缓存中的数据总是硬盘驱动器上的数据的第二个副本。 缓存的故障很少产生数据丢失，只是性能损失，因为一切都需要从机械驱动器提供，直到缓存可以被替换。</p>
<p> SSD层可能是自动分层系统中唯一的数据副本，不能容忍SSD层的故障，因此这些系统必须通过使用类似RAID的数据保护方案在冗余配置中设置SSD层。 不得不购买额外的SSD来支持类似RAID的功能，使已经高价的技术更加昂贵。</p>
<p><strong>关于读</strong></p>
<p>在大多数情况下，两个选项之间的read 性能应该大致相同。 大多数情况下，read 性能的效率将取决于缓存设备提升数据的效率和可定制性。 目标应该是确保正确的数据在正确的时间存在缓存中。缓存和自动分层需要在关于他们缓存什么和什么时候缓存需要变得更加聪明。</p>
<p><strong>终上所述</strong></p>
<p>从用户的角度来看，如果适当的冗余存在，缓存或分层没有显着的优势，因此不应该单独选择基于闪存的存储系统。 IT规划人员可能想要调查其他因素，例如将某些数据集固定到闪存层或缓存区，以及与环境或应用程序集成的能力。</p>
<p>参考资料：（这两篇文章是同一个作者）</p>
<p><a href="http://www.networkcomputing.com/storage/ssd-options-tier-vs-cache/1267262167" target="_blank" rel="external">SSD Options: Tier Vs. Cache</a></p>
<p><a href="http://searchsolidstatestorage.techtarget.com/tip/Tiering-vs-caching-in-flash-based-storage-systems" target="_blank" rel="external">Tiering vs. caching in flash-based storage systems</a></p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 

]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——parted]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94parted/</url>
      <content type="html"><![CDATA[<p>一直用parted命令来进行磁盘分区，这里学习一下总结一下。顺带对比一下MBR和GPT两种分区表，以及parted命令和fdisk命令的区别。<br><a id="more"></a></p>
<h2 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h2><p>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区（包含随意数目的逻辑分区）。</p>
<p>GPT：GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。GPT的分区信息是在分区中，而MBR在主引导扇区。</p>
<p>与MBR分区方式相比，具有如下优点：</p>
<ul>
<li>突破MBR 4个主分区限制，每个磁盘最多支持128个主分区。</li>
<li>支持大于2T的分区，最大卷可达18EB。</li>
</ul>
<h2 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h2><ul>
<li><strong>主分区</strong>又叫主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘。一个硬盘的主分区也就是包含操作系统启动所必需的文件和数据的硬盘分区，要在硬盘上安装操作系统，则该硬盘必须得有一个主分区。</li>
<li><strong>扩展分区</strong>不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。</li>
<li><strong>逻辑分区</strong>也相当于一个逻辑磁盘，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中。</li>
</ul>
<p>MBR模式分区只能划分四个分区，现在GPT分区至少可以划分128个主分区，未来很有可能将不存在扩展分区和逻辑分区的概念。</p>
<h2 id="parted和fdisk"><a href="#parted和fdisk" class="headerlink" title="parted和fdisk"></a>parted和fdisk</h2><p>parted命令可以划分单个分区大于2T的GPT格式的分区，也可以划分普通的MBR分区，并且允许调整分区的大小。</p>
<p>fdisk命令对于大于2T的分区无法划分，所以用fdisk无法看到parted划分的GPT格式的分区。</p>
<p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p>
<h2 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h2><p>Parted 命令分为两种模式：命令行模式和交互模式</p>
<p> 1、命令行模式：<code>parted [option] device [command]</code> ，该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用，比如利用脚本批量执行命令。</p>
<p> 2、交互模式：<code>parted [option] device</code>类似于使用<code>fdisk /dev/xxx</code>，这种适合当个操作。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><h4 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<p>parted有个不提示用户参数选项，就是通过这个选项来实现非交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-s, --script</div><div class="line">              never prompts for user intervention</div></pre></td></tr></table></figure>
<h4 id="2、添加分区"><a href="#2、添加分区" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb mklabel gpt			# 定义分区表格式</div><div class="line"># parted -s /dev/vdb mkpart primary ext4 1 10G		# 划分主分区</div><div class="line"># parted -s /dev/vdb mkpart logic 10G 20G		# 划分逻辑分区</div><div class="line"># parted -s /dev/vdb mkpart logic ext3 20G 40G</div><div class="line"># parted -s /dev/vdb mkpart entended 40G 100%		# 划分扩展分区，100%表示使用剩余所有空间</div><div class="line"></div><div class="line"># parted -s /dev/vdb p					# 查看分区详情</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          logic</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div><div class="line"> 4      40.0GB  107GB   67.4GB               entended</div></pre></td></tr></table></figure>
<p>查看分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">├─vdb2 253:18   0   9.3G  0 part </div><div class="line">├─vdb3 253:19   0  18.6G  0 part </div><div class="line">└─vdb4 253:18   0  62.8G  0 part</div></pre></td></tr></table></figure>
<h4 id="3、删除分区"><a href="#3、删除分区" class="headerlink" title="3、删除分区"></a>3、删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb rm 2</div><div class="line"></div><div class="line"># parted -s /dev/vdb p</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div></pre></td></tr></table></figure>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h4 id="1、初始状态-1"><a href="#1、初始状态-1" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<h4 id="2、添加分区-1"><a href="#2、添加分区-1" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><p>针对盘 vdb 开始分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># parted /dev/vdb</div><div class="line">GNU Parted 2.3</div><div class="line">Using /dev/vdb</div><div class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</div><div class="line">(parted)mklabel gpt 				# 定义分区表格式</div><div class="line">...</div><div class="line">(parted) mkpart p1      			# 创建第一个分区，名称为p1                                                  </div><div class="line">File system type?  [ext2]? ext4     		# 定义分区格式                                      </div><div class="line">Start? 1 					# 定义分区的起始位置（单位支持K,M,G,T）                                                              </div><div class="line">End? 10G      					# 定义分区的结束为止(单位支持K,M,G,T)                                                            </div><div class="line">(parted) print     				# 查看当前分区情况                                                       </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"></div><div class="line">(parted) mkpart part2                                                    </div><div class="line">File system type?  [ext2]? ext3                                           </div><div class="line">Start? 10G                                                                </div><div class="line">End? 20G                                                                  </div><div class="line">(parted) p					# print可以简写成“p“                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB               part2</div><div class="line"></div><div class="line">(parted) quit					# 退出。quit可以简写为”q“ </div><div class="line">Information: You may need to update /etc/fstab.</div></pre></td></tr></table></figure>
<h4 id="3、设置文件系统"><a href="#3、设置文件系统" class="headerlink" title="3、设置文件系统"></a>3、设置文件系统</h4><p>不知道为啥，print的时候不现实文件系统格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># mkfs.ext4 /dev/vdb1</div><div class="line"># mkfs.xfs /dev/vdb2</div></pre></td></tr></table></figure>
<p>再查看文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(parted) print                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          part2</div></pre></td></tr></table></figure>
<p>发现分区的 File system 变成了 ext4 和 xfs。所以，还是通过命令的方式来定义文件系统格式。</p>
<p>查看一下分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">└─vdb2 253:18   0   9.3G  0 part</div></pre></td></tr></table></figure>
<h4 id="4、删除分区"><a href="#4、删除分区" class="headerlink" title="4、删除分区"></a>4、删除分区</h4><p>删除分区 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(parted) rm                                                             </div><div class="line">Partition number? 2  </div><div class="line"></div><div class="line"># 或者直接</div><div class="line">(parted) rm 2    </div><div class="line"></div><div class="line">(parted) print</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div></pre></td></tr></table></figure>
<h4 id="5、修改分区大小"><a href="#5、修改分区大小" class="headerlink" title="5、修改分区大小"></a>5、修改分区大小</h4><p>暂时不支持改变分区的大小（resize操作），针对有无文件系统报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># none</div><div class="line">Error: Could not detect file system.  </div><div class="line"></div><div class="line"># ext4，ext3</div><div class="line">Error: File system has an incompatible feature enabled.  Compatible       </div><div class="line">features are has_journal, dir_index, filetype, sparse_super and large_file.</div><div class="line">Use tune2fs or debugfs to remove features.</div><div class="line"></div><div class="line"># xfs</div><div class="line">No Implementation: Support for opening xfs file systems is not implemented</div><div class="line">yet.</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[认识SSD]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/%E8%AE%A4%E8%AF%86SSD/</url>
      <content type="html"><![CDATA[<p>SSD越来越火，性能提升比较快，成本也有所下降，是未来的方向和主流，这里认识和学习一下SSD相关知识，以便更好的理解和应用SSD的特性。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>固态硬盘（Solid State Disk）用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。<br>一块SSD，<strong>核心部件</strong>是一颗控制器和多颗Flash颗粒，一般还会有一些内存和超级电容。</p>
<pre><code>--&gt;控制器主要作用是提供高效的手段来访问这些Flash颗粒。
--&gt;内存的作用主要是表项管理和读写CACHE。
--&gt;超级电容的作用是在异常下电时保证关键数据不丢失。
</code></pre><p>而<strong>Flash颗粒</strong>是SSD最重要的器件，其相关特性决定了SSD的实现方式。</p>
<h2 id="FLASH颗粒"><a href="#FLASH颗粒" class="headerlink" title="FLASH颗粒"></a>FLASH颗粒</h2><h3 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h3><blockquote>
<p>闪存是一种不挥发性（ Non-Volatile ）内存，在没有电流供应的条件下也能够长久地保持数据，其存储特性相当于硬盘，这项特性正是闪存得以成为各类便携型数字设备的存储介质的基础。</p>
</blockquote>
<p>Flash颗粒是SSD最重要的器件，其相关特性决定了SSD的实现方式。目前业界主要有两种类型的Flash技术：NOR（Intel开发）和NAND（东芝开发）。由于这两种技术在如下方面的一些差异：</p>
<pre><code>--&gt;NOR的读取速度略快于NAND；
--&gt;NOR的写入速度远低于NAND；
--&gt;NOR的擦除速度远低于NAND；
--&gt;的擦写次数约为NAND的1/10；
--&gt;的单元尺寸约为NAND的2倍；
</code></pre><p>导致1~16M的闪存市场主要采用NOR颗粒（主要用于保存嵌入式设备的程序），而<strong>更大容量的数据存储（例如SSD）则主要选择NAND颗粒</strong>。</p>
<h3 id="SLC和MLC"><a href="#SLC和MLC" class="headerlink" title="SLC和MLC"></a>SLC和MLC</h3><p>NAND FLASH芯片，flash颗粒有两种类型：SLC和MLC</p>
<p>SLC：Single Level Cell，每个存储单元均只能存储1个bit的数据。只包含0和1两个电压符。<br>MLC：Multi Level Cell，每个存储单元能够存储2个bit或者更多bit的数据。包含四个电压符（00,01,10,11）。</p>
<p><strong>SLC和MLC的比较：</strong><br>MLC容量比SLC大，且价格便宜。<br>但在性能、使用寿命和稳定性上：<br>1、SLC更简单可靠；<br>2、SLC读取和写入的速度都比MLC更快；<br>3、SLC比MLC更耐用，MLC每单元可擦除1w次，而SLC可擦除10w次。</p>
<p>一般而言，<strong>SLC主要用于企业级市场</strong>，MLC主要用于消费级市场。下表显示了SLC和MLC两种Flash颗粒的一些性能指标：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>SLC</th>
<th>MLC</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机读</td>
<td>25us</td>
<td>50us</td>
</tr>
<tr>
<td>擦除</td>
<td>2ms</td>
<td>2ms</td>
</tr>
<tr>
<td>编程</td>
<td>250us</td>
<td>900us</td>
</tr>
<tr>
<td>擦除次数</td>
<td>100k</td>
<td>10k</td>
</tr>
</tbody>
</table>
<h2 id="SSD的内部逻辑划分"><a href="#SSD的内部逻辑划分" class="headerlink" title="SSD的内部逻辑划分"></a>SSD的内部逻辑划分</h2><p>一颗NAND Flash颗粒，其内部被划分为若干block，每个block又包含若干page。page的大小一般为2k/4k/8k（同一颗Flash颗粒内的page大小是固定且相同的）。</p>
<p>Flash的一个特点是：不能对任意bit位进行0/1互转，只能按照一定的颗粒度进行擦除和编程操作；</p>
<pre><code>--&gt;擦除 —— 颗粒度为block，是将指定block中所有的bit位全部设置为1；
--&gt;编程 —— 颗粒度为page，是将指定page中指定的bit位设置为0；
</code></pre><p>因此，对SSD进行写的操作实际上对需要写的Page所在的Block全部完成“擦除”(全部bit位置1)后，才能对指定的Page进行“编程”(部分bit位置0)。PS：实际上SSD硬盘在出厂时，厂商都会把所有Block完成擦除操作。</p>
<h2 id="SSD的表项管理"><a href="#SSD的表项管理" class="headerlink" title="SSD的表项管理"></a>SSD的表项管理</h2><p>  每一个IO读写都是下发给一个地址，这个地址称为LBA(Logic Block Address)，其真正对应在磁盘上的地址称为PBA(Physical Block Address)，和传统机械硬盘中LBA到PBA的映射通过磁轨、磁道、扇区来进行唯一对应不同的是，<strong>SSD的LBA到PBA</strong>的映射通过一张<strong>映射表</strong>来记录。<br>&emsp;&emsp;LBA的粒度是扇区，而Flash颗粒的擦粒度是block，写粒度是page，均为扇区的若干倍，在这种条件下，如果仍以扇区为粒度进行映射，虽然理论上可行，但是显然是增加实现难度和性能的.<br>&emsp;&emsp;同时，如果强制以扇区为粒度进行映射，会导致所需要的映射表空间超过物理内存的限制，这就直接决定了不可能以扇区为粒度进行映射。<br>&emsp;&emsp;即使以page为粒度进行映射，也可能存在物理内存不够用的情况（现在正在使用的SSD盘即属于这种情况），所以需要以更大一些的粒度进行管理。<br>&emsp;&emsp;这个粒度成为”<strong>小块(Sub Block)</strong>“,是SSD进行擦除和编程的最小单位。每个block中，均包含多个sub block；每个sub block，由多个page组成；每个sub block，可能的状态包括：有效、垃圾、空白：</p>
<pre><code>--&gt;有效：该小块中的数据正在被引用；
--&gt;垃圾：该小块中的数据没有被引用；
--&gt;空白：该小块可用于写入新的数据；
</code></pre><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>&emsp;&emsp;SSD的写要先进行整个Block的擦除，然后才能对指定的Sub Block进行编程。实际上，如果某一个写操作需要修改一个Sub Block的内容，是无法直接进行修改的，而是写到一个新的Sub Block中，把该LBA的映射指向新的这个Sub Block，同时把原来数据所在的Sub Block标记为“垃圾”。<br>  这样，随着SSD使用时间的越来越长，新的未被编程过的Sub Block越来越少，后面新的写请求则只能重新擦除所有Sub Block均为垃圾的Block才能再次写入，这样必然会造成写操作的性能降低，因此，在SSD内部引入了一个重要的机制——垃圾回收（Garbage Collection），用以提升SSD长期写入操作的性能。</p>
<p><strong>垃圾回收的工作：</strong></p>
<pre><code>--&gt;找出合适的block
--&gt;将该block中的有效小块迁移到别的地方，同时更改映射表
--&gt;将该block擦除，并放入空白块表
</code></pre><p>&emsp;&emsp;所谓“最合适进行回收的block”，是指这个block的垃圾小块足够多、有效/空白小块足够少。<br>&emsp;&emsp;垃圾回收算法是否高效，与该SSD的性能有很强的联系。</p>
<h2 id="SSD的磨损均衡"><a href="#SSD的磨损均衡" class="headerlink" title="SSD的磨损均衡"></a>SSD的磨损均衡</h2><p>  上面说过，每个Flash颗粒中Block的可擦除次数是有限制的，如果颗粒中的某些Block很快达到了擦除次数上限，而其他大部分都几乎没有被擦除过，则会很快的造成整个SSD失效。而磨损均衡（Wear Leveling）则是通过各种手段，保证整个SSD所有的block的擦除次数是相近的从而延长SSD的使用寿命。</p>
<p>磨损均衡分为  <strong>动态磨损均衡</strong>  和  <strong>静态磨损均衡</strong>：</p>
<blockquote>
<p>动态磨损均衡，是指在外部力量的驱动下，自然完成磨损均衡。这里外部力量，包括写IO和垃圾回收。<br>静态磨损均衡，是指磨损均衡功能模块主动地查找那些长时间没有变化的数据，将这些数据搬移到其他位置，以便释放出擦除次数较少的block，使其投入到擦除/编程的循环之中。</p>
</blockquote>
<h2 id="SSD使用寿命计算举例"><a href="#SSD使用寿命计算举例" class="headerlink" title="SSD使用寿命计算举例"></a>SSD使用寿命计算举例</h2><p>&emsp;&emsp;虽然一个block擦写次数只有100k（SLC），但是因为动态映射、磨损均衡等机制的存在，使得SSD的寿命远不止写入100k个IO。<br>计算SSD寿命的方式，一般是先确认一个block在其生命周期内能够写入多少数据量，再乘以该SSD具有的block数量，再除以一个估计的写入带宽，最后得到寿命值。<br>&emsp;&emsp;以我司（<strong>你们猜o(^▽^)o</strong>）自研的100G SLC SSD为例，16片Flash颗粒，每片颗粒拥有32k个block，每个block拥有64个4k的page，每个block可以被擦除100k次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">16 x (32 x 1024) x 64 x (4 x 1024) x 100000 = 12500 TB</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;12500 TB，这是当所有block同时达到擦除次数上限时，可以写入的数据总量。<br>按照用户平均每秒钟写入10MB的数据进行计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(12500 x 1024 x 1024) / (10 x 60 x 60 x 24 x 365.25) = 41.5 年</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;41.5年，这是在10MB/s的压力下、持续不断地向SSD写入数据的使用寿命。<br>&emsp;&emsp;考虑到其他一些因素的影响，一块SLC SSD的使用寿命，10年是可以保证的。</p>
<h2 id="SSD和传统磁盘的对比"><a href="#SSD和传统磁盘的对比" class="headerlink" title="SSD和传统磁盘的对比"></a>SSD和传统磁盘的对比</h2><p>&emsp;&emsp;SSD与传统磁盘相比:<br>&emsp;&emsp;第一是没有机械装置;<br>&emsp;&emsp;第二是由磁介质改为了电介质。<br>&emsp;&emsp;在SSD内部有一个FTL(Flash Transalation Layer)，它相当于磁盘中的控制器，主要功能就是作地址映射，将flash memory的物理地址映射为磁盘的LBA逻辑地址，并提供给OS作透明访问。</p>
<h3 id="读方面"><a href="#读方面" class="headerlink" title="读方面"></a>读方面</h3><p><strong>随机读</strong><br>  SSD没有传统磁盘的寻道时间和延迟时间，所以SSD可以提供非常高的随机读取能力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<p><strong>连续读</strong><br>  SSD连续读的能力相比普通磁盘优势并不明显。传统磁盘连续读，并不需要寻道时间：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<h3 id="写方面"><a href="#写方面" class="headerlink" title="写方面"></a>写方面</h3><p>  Page为最小的读写单位，Block为最小的擦除/编程单位，其中1个Page为4KB，1个Block由256个Page组成，1个Plane由2048个Block组成，2个Plane组成1个Die，也就是最小的芯片(4GB)</p>
<p>&emsp;&emsp;向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元（page）的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入。SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。因为这个特性，引入<strong>“写放大”</strong>的概念。</p>
<p>&emsp;&emsp;比如你想改写4K的数据，必须首先将整个擦除块（1024KB）中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了1024KB的数据，写入放大系数是256。写入放大最好的情况是1，就是不存在放大的情况。</p>
<p>&emsp;&emsp;在<strong>长时间写入</strong>后，MLC随机写IO下降得非常厉害，而<strong>SLC表现则比较稳定</strong>，可以稳定在3000 IOPS，而MLC随机写IOPS甚至降低到300。</p>
<p>&emsp;&emsp;当某个单元长时间被反复擦写时（比如Oracle redo），不仅会造成写入的性能问题，而且会大大缩短SSD的使用寿命。所以，引入磨损均衡算法（wear leveling）。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力<br>！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph — V11.2.0 KRAKEN(译)]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/Ceph-KRAKEN(V11.2.0)/</url>
      <content type="html"><![CDATA[<p>ceph的版本出到K了，针对bluestore又有了新的优化，并进行了一定的压力和故障测试，当然还有其他的特性，针对Jewel版本有较多改动。当前还没有什么中文资料，<a href="http://docs.ceph.org.cn/" target="_blank" rel="external">ceph中文社区</a>中关于V11.2.0还没有更新进去，所以闲暇之余翻译了一下，也给大家节省时间。<br><a id="more"></a></p>
<p>英文原文链接：<a href="http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken" target="_blank" rel="external">http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken</a></p>
<h2 id="V11-2-0-KRAKEN"><a href="#V11-2-0-KRAKEN" class="headerlink" title="V11.2.0 KRAKEN"></a>V11.2.0 KRAKEN</h2><p>这是Kraken系列的第一个release版本。它适用于生产部署，并将维护到下一个稳定的版本Luminous，将在2017年春季完成。</p>
<h2 id="对比JEWEL版本的主要变化"><a href="#对比JEWEL版本的主要变化" class="headerlink" title="对比JEWEL版本的主要变化"></a>对比JEWEL版本的主要变化</h2><h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><ul>
<li>新的BlueStore 后端现在有一个稳定的磁盘格式，并通过了我们的故障和压力测试。尽管该后端仍被标记为实验性的，但我们鼓励用户使用非生产集群和非关键数据集进行尝试。</li>
<li>RADOS现在已经对EC-pool上的覆盖写（overwrites）进行了实验性支持。因为磁盘格式和实现尚未完成，所以必须启用特殊pool选项才能测试新功能。在群集上启用此选项将永久禁止该群集升级到将来的版本。</li>
<li>我们现在默认使用AsyncMessenger（ms type = async）而不是传统的SimpleMessenger。最明显的区别是，我们现在使用固定大小的线程池用于网络连接（而不是使用SimpleMessenger的每个套接字两个线程）。</li>
<li>现在一些OSD的故障几乎可以立即检测到，而先前心跳超时（默认为20秒）必须到期。这可以防止IO在主机保持启动但ceph-osd进程不再运行的故障情况下长时间阻塞。</li>
<li>有一个新的ceph-mgr守护进程。它目前与默认监视器并置，并且尚未使用太多，但基本的基础设施现在已到位。</li>
<li>减少了编码OSDMaps的大小。</li>
<li>当恢复（recovery）或重新平衡（rebalanceing）正在进行时，OSD现在停止擦除（scrubbing）。</li>
</ul>
<h3 id="RGW"><a href="#RGW" class="headerlink" title="RGW"></a>RGW</h3><ul>
<li>RGW现在支持一种新的区域类型，可用于通过ElasticSearch进行元数据索引。</li>
<li>RGW现在支持S3复合对象复制部分API。</li>
<li>现在可以重新分割现有的桶。注意，桶重新分片目前需要停止对特定桶的所有IO（特别是写）。</li>
<li>RGW现在支持对象的数据压缩。</li>
<li>Civetweb版本已经升级到1.8。</li>
<li>现在支持Swift静态网站API（以前已经添加了S3支持）。</li>
<li>S3桶生命周期API已添加。注意，目前它只支持对象到期。</li>
<li>支持自定义搜索过滤器已添加到LDAP身份验证实现中。</li>
<li>支持NFS版本3已添加到RGW NFS网关。</li>
<li>为librgw创建了一个Python绑定。</li>
</ul>
<h3 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h3><ul>
<li>RBD现在支持使用新的(实验)覆盖写(overwrite)支持在 EC RADOS pool 中存储images。必须使用新的rbd CLI <code>“-data-pool &lt;ec pool&gt;”</code> 选项来创建images，用以指定EC池存储后端数据对象。尝试在EC池上直接创建image不会成功，因为image的后端元数据仅在副本池上被支持。</li>
<li>rbd-mirror守护进程现在支持从主image复制动态image特征更新和image元数据key/value对到非主image。</li>
<li>image快照的数量可以选择性地限制为可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<h3 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h3><ul>
<li>libcephfs函数的定义已更改为启用适当的uid / gid控制。库版本已增加以反映接口更改。</li>
<li>备用的回放(replay)MDS守护程序现在在执行删除操作的工作负载上消耗更少的内存。</li>
<li>Scrub现在修复backtrace，并用已发现的错误填充损坏ls。</li>
<li>cephfs-data-scan的新的pg_files子命令可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性“未能响应缓存压力”警告已修复。</li>
</ul>
<h2 id="UPGRADING-FROM-JEWEL"><a href="#UPGRADING-FROM-JEWEL" class="headerlink" title="UPGRADING FROM JEWEL"></a>UPGRADING FROM JEWEL</h2><ul>
<li>所有集群必须首先升级到 Jewel 10.2.z，然后升级到 Kraken 11.2.z（或者，最终，Luminous 12.2.z）。</li>
<li>升级到Kraken之前，必须在Jewel集群上设置sortbitwise标志。如果未设置标志，则最新的Jewel（10.2.4+）版本会发出健康警告，因此可能已设置。如果不是，Kraken OSDs将拒绝启动，并将在其日志中打印和错误消息。</li>
<li>您可以按任意顺序升级OSD，监视器和MDS。 RGW守护进程应该最后升级。</li>
<li>升级时，新的ceph-mgr守护进程实例将自动被创建，与任何监视器一起。在Jewel到Kraken和Jewel到Luminous的升级中这将是事实，但在未来高于Luminous版本的升级中可能不是这样。如果你不与他们共置ceph-mon守护进程的话，你当然可以自由创建新的ceph-mgr守护进程实例，并销毁自动创建的实例。</li>
</ul>
<h2 id="BLUESTORE"><a href="#BLUESTORE" class="headerlink" title="BLUESTORE"></a>BLUESTORE</h2><p>BlueStore是一个新的后端，用于管理直接硬盘或SSD上每个OSD存储的数据。与现有的FileStore实现（它利用XFS文件系统将对象存储为文件）不同，BlueStore直接管理底层块设备。实现它自己的文件系统类磁盘结构，专为Ceph OSD工作负载而设计。 BlueStore的主要特点包括：</p>
<ul>
<li>默认情况下启用写入磁盘的所有数据的校验和，所有读取的校验和验证。</li>
<li>内联压缩支持，可以分别通过池属性或客户端提示在每个池或每个对象的基础上启用。</li>
<li>高效日记。与将所有数据写入其日志设备的FileStore不同，BlueStore仅记录元数据和（在某些情况下）小型写入，从而减少其日志的大小和吞吐量要求。与文件存储一样，日志可以与其他数据共存在同一设备上，或者分配在较小的高性能设备（例如，SSD或NVMe设备）上。 BlueStore日志默认只有512 MB。</li>
</ul>
<p>BlueStore磁盘格式预计将继续发展。但是，我们将在OSD中提供支持，以便在升级时迁移到新格式。</p>
<p>为了启用BlueStore，将以下内容添加到ceph.conf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable experimental unrecoverable data corrupting features = bluestore</div></pre></td></tr></table></figure>
<p>要创建一个BlueStore OSD，在OSD创建期间将-bluestore选项传递给ceph-disk或ceph-deploy。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Crushmap学习]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/Crushmap%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>介绍了ceph中crush的优点、原理及作用，同时dump出自己的crushmap内容，进行详细的分解学习。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着大规模分布式存储系统的出现。这些系统必须平衡的分布数据和负载，最大化系统的性能，并要处理系统的扩展和硬件失效。但是简单HASH分布不能有效处理设备数量的变化，导致大量数据迁移。ceph设计了CRUSH，用在分布式对象存储系统上，可以有效映射数据对象到存储设备上(不需要中心设备)。因为大型系统的结构式动态变化的，CRUSH能够处理存储设备的添加和移除，并最小化由于存储设备的的添加和移动而导致的数据迁移。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CRUSH算法，全称 Controlled Replication Under Scalable Hashing。它是一种伪随机的算法，在相同的环境下，它能够在层级结构的存储集群中有效的分布对象的副本。</p>
<p>CRUSH实现了一种伪随机(确定性)的函数，它的参数是object id或object group id，并返回一组存储设备(用于保存object副本)。相似的输入得到的结果之间没有相关性，相同的输入得到的结果是确定的。</p>
<p>CRUSH需要cluster map(描述存储集群的层级结构)、和副本分布策略(rule)就可以根据一个整型的输入得到存放数据的一个设备列表。</p>
<p>CRUSH有两个关键优点：</p>
<ul>
<li>任何组件都可以独立计算出每个object所在的位置(去中心化)。</li>
<li>只需要很少的元数据(cluster map)，只要当删除添加设备时，这些元数据才需要改变。</li>
</ul>
<h2 id="crush的作用"><a href="#crush的作用" class="headerlink" title="crush的作用"></a>crush的作用</h2><p>传统存储的架构体系需要一个MDC（meta data controll），ceph不使用这种架构，而是通过引入CRUSH算法，将数据分布的查询操作变成了计算操作，并且是在client端完成。同时，Crush算法还有效缓解了普通hash算法在处理存储设备增删时带来的数据迁移问题。</p>
<p>ceph允许客户端直接访问OSD守护进程，从而消除集中式查询元数据中心的需求。ceph使用一个monitor集群来保证系统的高可用性。同时采用crush算法来实现去中心化，使用crush算法后，客户端根据需要来计算数据被写到哪里，以及从哪读数据。</p>
<p><strong>ceph集群的一个写操作流程</strong></p>
<p>1、client首先访问ceph monitor获取cluster map的一份副本，共五个map（monitor map，OSD map，MDS map，CRUSH map，PG map），知晓集群的状态和配置；</p>
<p>2、数据被转化为一个或多个对象，每个对象都具有对象名称和存储池名称；</p>
<p>3、以PG数为基数做hash，将对象映射到一个PG钟；</p>
<p>4、根据计算出的PG，再通过CRUSH算法得到存放数据的一组OSD位置（副本个数），第一个是主，后面是从；</p>
<p>5、客户端获得OSD ID，直接和这些OSD通信并存放数据。</p>
<p><strong>注</strong>：所有的这些操作都是在<strong>客户端</strong>完成的，不会影响ceph集群服务器端的性能。</p>
<p><strong>一句话描述</strong></p>
<p>说了半天，一句话说明CRUSH的作用，就是——<strong>根据PG ID得到一个OSD列表</strong>。</p>
<h2 id="crush的工作形式"><a href="#crush的工作形式" class="headerlink" title="crush的工作形式"></a>crush的工作形式</h2><p>CRUSH是基于一张描述当前集群资源状态的map（Crush map）按照一定的规则（rules）得到这个OSD列表的。Ceph将系统的所有硬件资源描述成一个树状结构，然后再基于这个结构按照一定的容错规则生成一个逻辑上的树形结构作为Crush map。数的叶子节点是OSD。</p>
<h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><p>三个节点（ceph1，ceph2，ceph3），每个节点三个OSD，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME      UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 1.36345 root default                                     </div><div class="line">-2 0.45448     host ceph1                                   </div><div class="line"> 0 0.09090         osd.0       up  1.00000          1.00000 </div><div class="line"> 1 0.18179         osd.1       up  1.00000          1.00000 </div><div class="line"> 2 0.18179         osd.2       up  1.00000          1.00000 </div><div class="line">-3 0.45448     host ceph2                                   </div><div class="line"> 3 0.09090         osd.3       up  1.00000          1.00000 </div><div class="line"> 4 0.18179         osd.4       up  1.00000          1.00000 </div><div class="line"> 5 0.18179         osd.5       up  1.00000          1.00000 </div><div class="line">-4 0.45448     host ceph3                                   </div><div class="line"> 6 0.09090         osd.6       up  1.00000          1.00000 </div><div class="line"> 7 0.18179         osd.7       up  1.00000          1.00000 </div><div class="line"> 8 0.18179         osd.8       up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="crushmap内容"><a href="#crushmap内容" class="headerlink" title="crushmap内容"></a>crushmap内容</h3><p>来看一下crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"># begin crush map</div><div class="line">tunable choose_local_tries 0</div><div class="line">tunable choose_local_fallback_tries 0</div><div class="line">tunable choose_total_tries 50</div><div class="line">tunable chooseleaf_descend_once 1</div><div class="line">tunable chooseleaf_vary_r 1</div><div class="line">tunable straw_calc_version 1</div><div class="line"></div><div class="line"># devices</div><div class="line">device 0 osd.0</div><div class="line">device 1 osd.1</div><div class="line">device 2 osd.2</div><div class="line">device 3 osd.3</div><div class="line">device 4 osd.4</div><div class="line">device 5 osd.5</div><div class="line">device 6 osd.6</div><div class="line">device 7 osd.7</div><div class="line">device 8 osd.8</div><div class="line"></div><div class="line"># types</div><div class="line">type 0 osd</div><div class="line">type 1 host</div><div class="line">type 2 chassis</div><div class="line">type 3 rack</div><div class="line">type 4 row</div><div class="line">type 5 pdu</div><div class="line">type 6 pod</div><div class="line">type 7 room</div><div class="line">type 8 datacenter</div><div class="line">type 9 region</div><div class="line">type 10 root</div><div class="line"></div><div class="line"># buckets</div><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph2 &#123;</div><div class="line">	id -3		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.3 weight 0.091</div><div class="line">	item osd.4 weight 0.182</div><div class="line">	item osd.5 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph3 &#123;</div><div class="line">	id -4		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.6 weight 0.091</div><div class="line">	item osd.7 weight 0.182</div><div class="line">	item osd.8 weight 0.182</div><div class="line">&#125;</div><div class="line">root default &#123;</div><div class="line">	id -1		# do not change unnecessarily</div><div class="line">	# weight 1.363</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item ceph1 weight 0.454</div><div class="line">	item ceph2 weight 0.454</div><div class="line">	item ceph3 weight 0.454</div><div class="line">&#125;</div><div class="line"></div><div class="line"># rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line"># end crush map</div></pre></td></tr></table></figure>
<h3 id="begin-crush-map"><a href="#begin-crush-map" class="headerlink" title="begin crush map"></a>begin crush map</h3><p>配置参数</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>列出集群的OSD设备</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p>表示buckets的类型 <img src="http://ojet8bprn.bkt.clouddn.com/osdmap.png" alt="osdmap"></p>
<h3 id="Buckets"><a href="#Buckets" class="headerlink" title="Buckets"></a>Buckets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的定义是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[bucket-type] [bucket-name] &#123;</div><div class="line">  	id 		[a unique negative numeric ID]</div><div class="line">  	weight	[the relative capacity the item]</div><div class="line">  	alg		[the bucket type: uniform | list | tree | straw | straw2]</div><div class="line">  	hash	[the hash type: 0 by default]</div><div class="line">  	item	[item-name]		weight		[weight]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bucket-type: bucket的类型，用来指定OSD在CRUSH分层结构中的位置</p>
<p>bucket-name：唯一的bucket名称</p>
<p>id：唯一的ID，用一个负整数表示</p>
<p>weight：OSD的权重，权重越高，说明它的物理存储容量越大。建议1TB存储设备的权重为1.00，500G的权重为0.50。当然这是一个相对值。</p>
<p>alg：bucket类型的算法选择</p>
<blockquote>
<p>见最后bucket的类型</p>
</blockquote>
<p>hash：每个bucket都具有hash算法。目前ceph支持jrenkins1算法，默认hash设置为0使用该算法。</p>
<p>item：bucket里包含的元素，即叶子bucket，及其权重。这里bucket为host，叶子为OSD。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rule [rulename] &#123;</div><div class="line">  	ruleset		[ruleset]</div><div class="line">  	type		[replicated | erasure]</div><div class="line">  	min_size	[min-size]</div><div class="line">  	max_size	[max-size]</div><div class="line">  	step take	[bucket-type]</div><div class="line">  	step		[choose | chooseleaf]	firstn	[num]	type	[bucket-type]</div><div class="line">  	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rulename：定义的规则名称</p>
<p>ruleset：一个整数值，指定这条规则所属的规则集</p>
<p>min_size和max_size用来限定这个rule的使用范围，即当一个pool的副本数小于min_size或者大于max_size的时候不使用这个rule。</p>
<p>step take：选择一个bucket，然后从这个bucket开始往下遍历，找出OSD</p>
<p>choose是从bucket中找出若干个type类型的项</p>
<p>chooseleaf操作是bucket中选出若干个type类型的leaf节点</p>
<blockquote>
<p>如果在一台机器上部署3各OSD，这里就要将type后面的“host”改为“OSD”，否则一直是HEALTH_ERR，因为选择规则是在bucket（host）中选择3个host类型的leaf节点，显然你这里没有，改为OSD的话就刚好。</p>
</blockquote>
<p>firstn后面的数字，表示按照前面规则选出节点的个数。如果是0，就按照副本数选择，如果是正数，就按个数来，如果是负数，就按副本数＋负数得到的值来选。</p>
<p>step emit：它首先弹出当前值，并清空栈。它会被典型的应用于rule结尾，也可以用于组织同一条rule的不同树。</p>
<h2 id="Bucket的类型"><a href="#Bucket的类型" class="headerlink" title="Bucket的类型"></a>Bucket的类型</h2><p>Cluster map由device和bucket组成，它们都有id和权重值。Bucket可以包含任意数量item。item可以都是的devices或者都是buckets。管理员控制存储设备的权重。权重和存储设备的容量有关。Bucket的权重被定义为它所包含所有item的权重之和。CRUSH基于4种不同的bucket type，每种有不同的选择算法。</p>
<p>CRUSH映射算法解决了效率和扩展性这两个矛盾的目标。而且当存储集群发生变化时，可以最小化数据迁移，并重新恢复平衡分布。CRUSH定义了四种具有不同算法的的buckets。每种bucket基于不同的数据结构，并有不同的c(r,x)伪随机选择函数。</p>
<p>不同的bucket有不同的性能和特性：</p>
<ul>
<li>Uniform：适用于具有相同权重的item，而且bucket很少添加删除item。它的查找速度是最快的。</li>
<li>List：它的结构是链表结构，所包含的item可以具有任意的权重。CRUSH从表头开始查找副本的位置，它先得到表头item的权重Wh、剩余链表中所有item的权重之和Ws，然后根据hash(x, r, item)得到一个[0~1]的值v，假如这个值v在[0~Wh/Ws)之中，则副本在表头item中，并返回表头item的id。否者继续遍历剩余的链表。</li>
<li>Tree：链表的查找复杂度是O(n)，决策树的查找复杂度是O(log n)。item是决策树的叶子节点，决策树中的其他节点知道它左右子树的权重，节点的权重等于左右子树的权重之和。CRUSH从root节点开始查找副本的位置，它先得到节点的左子树的权重Wl，得到节点的权重Wn，然后根据hash(x, r, node_id)得到一个[0~1]的值v，假如这个值v在[0~Wl/Wn)中，则副本在左子树中，否者在右子树中。继续遍历节点，直到到达叶子节点。Tree Bucket的关键是当添加删除叶子节点时，决策树中的其他节点的node_id不变。决策树中节点的node_id的标识是根据对二叉树的中序遍历来决定的(node_id不等于item的id，也不等于节点的权重)。</li>
<li>Straw：这种类型让bucket所包含的所有item<strong>公平竞争</strong>(不像list和tree一样需要遍历)。这种算法就像抽签一样，所有的item都有机会被抽中(只有最长的签才能被抽中)。每个签的长度是由length = f(Wi)<em>hash(x, r, i) 决定的，f(Wi)和item的权重有关，i是item的id号。c(r, x) = MAXi(f(Wi) </em> hash(x, r, i))。</li>
<li><strong>Straw2</strong>：它是改进的straw bucket。它会在项目A和B的<strong>权重都没有改变时避免任何数据移动</strong>。例如，增加或删除一个项目C，改变它的权重，数据只会移动到它上面或者从它上面移动到其他地方，而不会在bucket内的其他项目之间出现数据移动。因此，该算法减少了集群发生改变后的数据移动量。这是目前使用最广的bucket类型。（《ceph cookbook》）</li>
</ul>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 


]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph中严重数据不一致性BUG]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/Ceph%E4%B8%AD%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7BUG/</url>
      <content type="html"><![CDATA[<p>目前，块存储服务是Ceph存储中被使用的最普遍的服务之一，通过块存储服务，可以向客户端以使用块设备一样访问Ceph集群。然而，目前在使用块存储服务时，尤其是OpenStack与Ceph对接时，如果没有严格的控制Ceph端的对象大小（使用 &gt;= 8MB对象时），将有可能导致严重的数据不一致情况，该异常由于XFS文件系统本身对Fiemap的支持特性导致的。<br><a id="more"></a></p>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>XFS使用fiemap时，当extents数量大于1364时，通过ioctl的FS_IOC_FIEMAP接口，获取的extents数量上限为1364，导致超出部分extents数据获取不到。这将导致，在开启fiemap时，Ceph集群进行recovery与backfill之后，产生大量数据不一致的情况，也是迄今为止Ceph中影响最大的，最严重的数据不一致BUG。</p>
<p>由于fiemap BUG，碎片化对象在recovery与backfill之后（fiemap 获取不正确的数据），从而使的恢复的对象数据与原对象数据不一致。而恢复后的副本若成为主副本，则可能发生静默读错误，并且如果使用Ceph策略自动修复对象（repair object之后），可能将错误数据覆盖至正确数据，数据将永远损毁。在某些情况下，还会触发对象永远处于inconsistent状态。</p>
<h2 id="复现方式"><a href="#复现方式" class="headerlink" title="复现方式"></a>复现方式</h2><p>初始化大量extents碎片文件test，使其成为一个拥有3999个extents的碎片文件。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/1.png" alt="1"></p>
<p>通过fiemap系统调用，获取这些extents<br><a href="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" target="_blank" rel="external"><img src="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" alt="2"></a><br>编译g++ do_fiemap.cc -o do_fiemap</p>
<p>通过该程序可以打印出可以获取的到fiemap extents, do_fiemap test，通过xfs_bmap test 打印出真正的extents数量后，进行比较。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/3.jpg" alt="3"></p>
<p>可以看到，我们最先写了2000个extents，并通过xfs_bmap获取到了 2000个有内容的extents，但是通过fiemap系统调用，只获取到了1364个有数据的extents，所以在ceph中使用fiemap系统调用在某些情况下导致数据一致性BUG。</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>1）目前，在使用块存储使用场景时，通常情况下，默认使用4MB对象。在无特殊情况下，不用使用大于4MB 对象的RBD 镜像。</p>
<p>2）在I版以后，通过新的系统调用，seek_data, seek_hole，可以避免触发该BUG，防止extents过多时使用fiemap调用产生的问题<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/4.png" alt="4"></p>
<p>这组系统调用，可以让使用者通过while循环，反复的发现文件中的data 与 hole，从而组织出一个文件中真正存在的数据，能够避免产生与fiemap系统调用类似的BUG，又保证了recovery或者clone时候只复制有用数据，而反复的系统调，应该会带来一定性能上的影响，请读者们自行测试。</p>
<p>目前，在I版本以后的ceph中，提供参数filestore_seek_data_hole，来启用该功能。当filestore_seek_data_hole 与 filestore_fiemap同时设置时，只用文件系统支持seek_data_hole，那么就会先通过seek_data_hole方式来获取文件的extents，所以在I版本以后的ceph中，应启用filestore_seek_data_hole功能来替代filestore_fiemap 功能。</p>
<p>3）对于已经使用8MB，16MB 甚至更大对象大小的RBD镜像，请暂时设置禁用Fiemap功能，并等待后续版本修复。</p>
<p>原文链接：<a href="https://www.ustack.com/blog/%E9%98%B2%E7%81%AB%E9%98%B2%E7%9B%97%E9%98%B2bug-%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%E5%9B%A2%E9%98%9F%E5%85%AC%E5%B8%83ceph%E4%B8%AD%E6%9C%80%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80/" target="_blank" rel="external">有云存储团队公布Ceph中最严重数据不一致BUG!</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[块存储的世界]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>在OpenStack中，存储是非常重要的一块，但是因为其提供方式的不同，即使是专业的工程师也会感到十分困惑。OpenStack的存储主要分为三大类，一是对象    存储服务，Swift解决的问题，二是块设备存储服务，在OpenStack里主要是提供给虚拟机的作为“硬盘”的存储，这里又分为本地块存储和分布式块存储，Cinder项目正    在解决相关的问题；第三类，数据库存储服务，Databases as a Service(DBaaS), 对应AWS里面的RDC，目前是一个正在孵化的项目，Trove，前身是Rackspace开源出&gt;    来的RedDwarf。本文重点介绍块存储服务。<br><a id="more"></a></p>
<blockquote>
<p>转载的文章，原文排版看的心累，链接见文末。</p>
</blockquote>
<p>​    UnitedStack OS的块存储是在OpenStack Cinder框架下开发的，开发过程中，我们对目前主流的块存储服务提供商和开源的块存储软件做了一个简要分析，希望能给从事块存储开发的工程师对于块存储一个全局的认识。        </p>
<p>​    块存储，简单来说就是提供了块设备存储的接口。用户需要把块存储卷附加到虚拟机(或者裸机)上后才可以与其交互。这些卷都是持久的: 它们可以被从运行实例上解除或者重新附加而数据保持完整不变。下面会先介绍常见的单机块设备工具来建立对块存储的初步印象。</p>
<h2 id="单机块存储"><a href="#单机块存储" class="headerlink" title="单机块存储"></a>单机块存储</h2><p>​    首先一个硬盘是一个块设备，内核检测到硬盘然后在/dev/下会看到/dev/sda/。因为我们需要利用一个硬盘来得到不同的分区来做不同的事，通过fdisk工具得到/dev/sda1, /dev/sda2等，这种通过直接写入分区表来规定和切分硬盘,是最死板的分区方式。</p>
<h3 id="LVM-amp-Device-mapper"><a href="#LVM-amp-Device-mapper" class="headerlink" title="LVM &amp; Device-mapper"></a>LVM &amp; Device-mapper</h3><p>​    LVM是一种逻辑卷管理器，通过LVM来对硬盘创建逻辑卷组和得到逻辑卷来完成目的比fdisk方式更加弹性。LVM对于不太熟悉其机制的人看来可能会造成不小的开销，但是相对于LVM对来的易用性其映射机制的负载小的足以忽略(在snapshot的情况会有不小的负载)。</p>
<p>​    LVM在大多数Linux使用者看来非常普通的工具，它同时也是OpenStack块存储项目的一种backend并且是默认的。通过LVM在每个主机创建Volume Group，通过Cinder(OpenStack块存储项目)的调度器可以在任何一个合适的主机(满足容量和其他要求)使用lvcreate创建一个块设备供Nova(OpenStack Computing项目)使用。</p>
<p>​    Device-mapper是一种支持逻辑卷管理的通用设备映射机制，为存储资源管理的块设备驱动提供了一个高度模块化的内核架构。LVM是基于Device-mapper的用户程序实现。</p>
<p>​    Device-mapper在内核中它通过一个模块化的Target Driver插件实现对IO请求的过滤或者重定向工作，当前已经实现的Target Driver插件包括软Raid、软加密、逻辑卷条带、多路径、镜像、快照等。整个 device mapper 机制由两部分组成–内核空间的 device mapper 驱动、用户空间的device mapper 库以及它提供的 dmsetup 工具。内核中主要提供完成这些策略所需要的机制。Device-mapper 用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等等，而具体过滤和重定向 IO 请求的工作由内核中相关代码完成。</p>
<h3 id="SAN-amp-iSCSI"><a href="#SAN-amp-iSCSI" class="headerlink" title="SAN &amp; iSCSI"></a>SAN &amp; iSCSI</h3><p>​    在接触了单机下的逻辑卷管理后，你需要了解<a href="http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">SAN</a>，目前主流的企业级存储方式。</p>
<p>​    大部分SAN使用<a href="http://en.wikipedia.org/wiki/SCSI" target="_blank" rel="external">SCSI</a>协议在服务器和存储设备之间传输和沟通，通过在SCSI之上建立不同镜像层，可以实现存储网络的连接。常见的有<a href="http://zh.wikipedia.org/wiki/ISCSI" target="_blank" rel="external">iSCSI</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_Protocol" target="_blank" rel="external">FCP</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet" target="_blank" rel="external">Fibre Channel over Ethernet</a>等。</p>
<p>​    SAN通常需要在专用存储设备中建立，而iSCSI是基于TCP/IP的SCSI映射，通过iSCSI协议和<a href="http://linux-iscsi.sourceforge.net/" target="_blank" rel="external">Linux iSCSI</a>项目我们可以在常见的PC机上建立SAN存储。。</p>
<p>​    如何建立在PC机上的SAN可以参考<a href="http://linux.vbird.org/linux_server/0460iscsi.php" target="_blank" rel="external">iSCSI建立</a>，这篇文章的iSCSI target管理方式不太方便，通常利用<a href="http://linux-iscsi.org/wiki/Targetcli" target="_blank" rel="external">targetcli</a>管理target是及其方便的。targetcli可以直接建立和管理不同backstone类型的逻辑卷和不同的export方式，如建立ramdisk并且通过iSCSI export非常方便，操作方式见<a href="http://www.youtube.com/watch?v=mKjBsgOlYmE" target="_blank" rel="external">targetcli screencast Part 2 of 3: ISCSI – YouTube</a>。</p>
<h2 id="分布式块存储服务"><a href="#分布式块存储服务" class="headerlink" title="分布式块存储服务"></a>分布式块存储服务</h2><p>​    以上都是我们经常解除的单机下块存储环境，接下来开始本文的正式分享内容，包括公共云技术服务提供的块存储服务，开源的块存储框架和OpenStack目前对块存储的定义和支持情况。</p>
<h3 id="分布式块存储"><a href="#分布式块存储" class="headerlink" title="分布式块存储"></a>分布式块存储</h3><p>​    在面对极具弹性的存储需求和性能要求下，单机或者独立的SAN越来越不能满足企业的需要。如同数据库系统一样，块存储在scale up的瓶颈下也面临着scale out的需要。我们可以用以下几个特点来描述分布式块存储系统的概念:</p>
<ul>
<li>分布式块存储可以为任何物理机或者虚拟机提供持久化的块存储设备</li>
<li>分布式块存储系统管理块设备的创建、删除和attach/deattach。</li>
<li>分布式块存储支持强大的快照功能，快照可以用来恢复或者创建新的块设备</li>
<li>分布式存储系统能够提供不同IO性能要求的块设备</li>
</ul>
<h3 id="Amazon-EBS-amp-阿里云磁盘"><a href="#Amazon-EBS-amp-阿里云磁盘" class="headerlink" title="Amazon EBS &amp; 阿里云磁盘"></a>Amazon EBS &amp; 阿里云磁盘</h3><p>​    Amazon作为领先的IAAS服务商，其API目前是IAAS的事实标准。Amazon EC2目前仍然一骑绝尘，在大多数方面远超其他IAAS服务商。通过Amazon EC2的<a href="http://aws.amazon.com/cn/ec2/" target="_blank" rel="external">产品介绍</a>是快速了解Amazon EC2的捷径。</p>
<p>​    而<a href="http://aws.amazon.com/cn/ebs/" target="_blank" rel="external">EBS</a>是Amazon提供的块存储服务，通过EBS，用户可以随时增删迁移volume和快照操作。</p>
<p>​    Amazon EC2实例可以将根设备数据存储在Amazon EBS或者本地实例存储上。使用 Amazon EBS时，根设备中的数据将独立于实例的生命周期保留下来，使得在停止实例后仍可以重新启动使用，与笔记本电脑关机并在再次需要时重新启动相似。另一方面，本地实例存储仅在实例的生命周期内保留。这是启动实例的一种经济方式，因为数据没有存储到根设备中。</p>
<p>​    Amazon EBS提供两种类型的卷，即标准卷和预配置IOPS卷。它们的性能特点和价格不同，可以根据应用程序的要求和预算定制所需的存储性能。</p>
<p>​    标准卷可为要求有适度或突发式I/O的应用程序提供存储。这些卷平均可以提供大约 100 IOPS，最多可突增至数百 IOPS。标准卷也非常适合用作引导卷，其突发能力可提供快速的实例启动时间(通常十几秒)。</p>
<p>​    预配置 IOPS 卷旨在为数据库等 I/O 密集型随机读写工作负载提供可预计的高性能。创建一个卷时，利用预置 IOPS 为卷确定 IOPS 速率，随之 Amazon EBS 在该卷的生命周期内提供该速率。Amazon EBS 目前支持每预配置 IOPS 卷最多 4000 个IOPS。您可以将多个条带式卷组合在一起，为您的应程程序提供每个Amazon EC2数千IOPS的能力。</p>
<p>​    EBS可以在卷连接和使用期间实时拍摄快照。不过，快照只能捕获已写入Amazon EBS 卷的数据，不包含应用程序或操作系统已在本地缓存的数据。如果需要确保能为实例连接的卷获得一致的快照，需要先彻底地断开卷连接，再发出快照命令，然后重新连接卷。</p>
<p>​    EBS快照目前可以跨regions增量备份，意味着EBS快照时间会大大缩短，从另一面增加了EBS使用的安全性。</p>
<p>​    总的来说，Amazon EBS是目前IAAS服务商最引入注目的服务之一，目前的OpenStack、CloudStack等等其他开源框架都无法提供Amazon EBS对于的如此弹性和强大的服务。了解和使用Amazon EBS是学习IAAS块存储的最好手段。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>​    阿里云是国内的公共云计算服务商，不过这里阿里云目前的块存储服务较于Amazon EBS差的太远，阿里云磁盘目前仅支持在创建云主机的时候绑定云磁盘或者在升级云主机的进行云磁盘扩容，这从根本上就是传统的虚拟主机的特点而不是所谓的“云磁盘”。</p>
<p>从目前的阿里云磁盘的限制:</p>
<ul>
<li>无法快速创建或删除volume，在进行扩容时需要升级云主机才能达到，而升级云主机只有在下月云主机套餐到期时才能生效(想起了中国移动套餐)</li>
<li>一个云主机最多只能绑定3个云磁盘</li>
</ul>
<p>从阿里云磁盘目前的使用分析，阿里云磁盘系统目前还很不成熟，以下是我对阿里云磁盘实现的推测</p>
<ul>
<li>阿里云主机是跟磁盘绑定的，这意味着阿里云的云磁盘是local volume(因此性能还是挺可观的)。如果用户需要扩容、减少都是需要下个月更说明了这点，整个主机在扩容时去调度合适的有足够存储空间的host，然后进行扩容。</li>
<li>阿里云磁盘是分布式块存储系统，但是由于其QoS无法保证和其他资源调度原因无法提供足够的块存储支持。</li>
</ul>
<p>从<a href="http://www.infoq.com/cn/news/2013/06/aliyun-nihao-storage" target="_blank" rel="external">演讲回顾：阿里云存储技术的演进，以及云服务用例最佳实践</a>中了解到阿里云是基于自家的“盘古”系统，那么从实际使用来说，远没达到一般的分布式块存储系统的要求。</p>
<h3 id="Ceph-amp-Sheepdog"><a href="#Ceph-amp-Sheepdog" class="headerlink" title="Ceph &amp; Sheepdog"></a>Ceph &amp; Sheepdog</h3><p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是开源实现的PB级分布式文件系统，通过其分布式对象存储机制为上层提供了文件接口、块存储接口和对象存储接口。<a href="http://www.inktank.com/" target="_blank" rel="external">Inktank</a>是Ceph的主要支持商，也是目前Ceph开源社区的主要力量。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/11.png" alt="1"></p>
<p>​    Ceph目前是OpenStack支持的Backend中一个不错的开源块存储实现系统(即Cinder项目backend driver之一)，其实现分为三个部分: OSD, Monitor, MDS。OSD是底层对象存储系统，Monitor是集群管理系统，MDS是用来支持POSIX文件接口的Metadata Server。从Ceph的原始论文(<a href="http://ceph.newdream.net/papers/weil-thesis.pdf" target="_blank" rel="external">Ceph: Reliable, Scalable, and High-Performance Distributed Storage</a>)来看，Ceph专注于扩展性，高可用性和容错性。Ceph放弃了传统的Metadata查表方式(HDFS)而改用算法(CRUSH)去定位具体的block。</p>
<p>​    利用Ceph提供的RULES可以弹性地制订存储策略和Pool选择，Monitor作为集群管理系统掌握了全部的Cluster Map，Client在没有Map的情况下需要先向Monitor请求得到，然后通过Object id计算相应的OSD Server。</p>
<p>​    Ceph支持传统的POSIX文件接口，因此需要额外的MDS(Meatadata Server)支持文件元信息(Ceph的块存储和对象存储支持不需要MDS服务)。Ceph将Data和Metadata分离到两个服务上，跟传统的分布式系统如Lustre相比可以大大增强扩展性。在小文件读写上，Ceph读写文件会有[RTT*2]，在每次open时，会先去Metadata Server查询一次，然后再去Object Server。除了Open操作外，Ceph在Delete上也有问题，它需要到Metadata Server擦除对应的Metadata，是n(2)复杂度。Ceph在Metadata上并非只有坏处，通过Metadata Server，像目录列表等目录操作为非常快速，远超GlusterFS等其他分布式文件系统的目录或文件元操作。</p>
<p>利用Ceph可以作两种不同类型的“共享存储”支持:</p>
<ol>
<li>利用CephFS作分布式系统，所有虚拟机的块设备直接使用CephFS的命名空间</li>
<li>使用Ceph RBD块设备接口，从Ceph Cluster中导出Volume作为块设备Attach到虚拟机。</li>
</ol>
<p>关于Ceph作为块存储项目的几个问题需要考虑:</p>
<ul>
<li>Ceph在读写上不太稳定（有Btrfs的原因），目前Ceph官方推荐XFS作为底层文件系统</li>
<li>Ceph的扩展性和架构较复杂，如果需要介入Ceph，需要较长时间深入了解</li>
<li>Ceph的部署不够简易，目前Ceph的官方部署工具不太成熟，而对于的Pupet模块或者其他都没有公认的较好实现。</li>
<li>Ceph的稳定性依赖高版本Linux的一些特性，并且Ceph的rbd.ko在高版本中更具稳定性。</li>
</ul>
<h3 id="Sheepdog"><a href="#Sheepdog" class="headerlink" title="Sheepdog"></a>Sheepdog</h3><p>​    <a href="http://www.osrg.net/sheepdog/" target="_blank" rel="external">Sheepdog</a>是另一个分布式块存储系统实现，它与Ceph相比，最大优势就是代码短小好维护和hack的成本很小。Sheepdog也有很多Ceph不支持的特性，比如说Multi-Disk, Cluster-wide Snapshot等。</p>
<p>​    Sheepdog主要有两部分，一个是集群管理，另一个是存储服务。集群管理目前使用Corosync或者Zookper来完成，其存储服务的特点是在Client和存储Host有Cache的实现可以大大减小数据流量。</p>
<p>​    目前Sheepdog只在QEMU端提供Drive，而缺少library支持，这是Sheepdog目前最主要的问题。但是社区已经有相关的Blueprint在讨论这个问题。</p>
<p>了解Sheepdog通过以下链接:</p>
<ul>
<li><a href="http://www.slideshare.net/multics/overview-of-sheepdog" target="_blank" rel="external">Sheepdog Overview</a></li>
<li><a href="http://rdc.taobao.com/blog/cs/?tag=sheepdog" target="_blank" rel="external">Sheepdog 淘宝核心系统团队</a></li>
<li><a href="https://github.com/collie/sheepdog/wiki" target="_blank" rel="external">Sheepdog wiki</a>: Sheepdog的一系列Wiki如同它的代码一样简短出色</li>
</ul>
<p>目前Taobao是Sheepdog主要用户和社区贡献者，国内也有Startup参与Sheepdog的社区开发。</p>
<h3 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h3><p>​    <a href="https://wiki.openstack.org/wiki/Main_Page" target="_blank" rel="external">OpenStack</a>是目前流行的IAAS框架，提供了AWS类似的服务并且兼容其API。OpenStack Nova是计算服务，Swift是对象存储服务，Quantum是网络服务，Glance是镜像服务，Cinder是块存储服务，Keystone是身份认证服务，Horizon是Dashboard，另外还有Heat、Oslo、Ceilometer、Ironic等等项目。</p>
<p>​    <a href="https://wiki.openstack.org/wiki/Cinder" target="_blank" rel="external">Cinder</a>是OpenStack中提供类似于EBS块存储服务的API框架，它并没有实现对块设备的管理和实际服务提供，用来为后端不同的存储结构提供统一的接口与OpenStack进行整合，不同的块设备服务厂商在Cinder中实现其驱动支持。后端的存储可以是DAS，NAS，SAN，对象存储或者分布式文件系统。也就是说，Cinder的块存储数据完整性，可用性保障是由后端存储提供的。在<a href="https://wiki.openstack.org/wiki/CinderSupportMatrix" target="_blank" rel="external">CinderSupportMatrix</a>中可以看到众多存储厂商如NetAPP、IBM、SolidFire、EMC和众多开源块存储系统对Cinder的支持，在这里我们也可以看到OpenStack是非常受欢迎的。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/2.png" alt="2"></p>
<p>​    从上图我们也可以看到，Cinder只是提供了一层抽象，然后通过其后段支持的driver实现来发出命令来得到回应。关于块存储的分配信息以及选项配置等会被保存到OpenStack统一的DB中。</p>
<p>​    目前Cinder项目支持的操作包括创建/删除Volume，创建/删除Snapshot，Clone Volume，将Volume制作成Image或者将Image导出到Volume，备份/恢复Volume和扩展Volume大小，不同的Backend会实现不同程度的操作，但基本的创建Volume和快照操作都是支持的。目前令人振奋的Amazon EBS的QoS机制已经在Cinder社区中得到广泛讨论，在经历近两个月的Patch Review之后，整个QoS机制即将正式进入Cinder项目。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    目前分布式块存储的实现仍然是由Amazon EBS领衔，其卓越稳定的读写性能、强大的增量快照和跨区域块设备迁移，以及令人惊叹的QoS控制都是目前开源或者其他商业实现无法比拟的。</p>
<p>​    不过Amazon EBS始终不是公司私有存储的一部分，作为企业IT成本的重要部分，块存储正在发生改变。EMC在一个月前发布了其ViPR平台，并开放了其接口试图接纳其他厂商和开源实现。Nexenta在颠覆传统的的存储专有硬件，在其上软件实现原来只有专有SDN的能力，让企业客户完全摆脱存储与厂商的绑定。Inktank极力融合OpenStack并推动Ceph在OpenStack社区的影响力都说明了无论是目前的存储厂商还是开源社区都在极力推动整个分布式块存储的发展，存储专有设备的局限性正在进一步弱化了原有企业的存储架构。</p>
<p>​    在分布式块存储和OpenStack之间我们可以打造更巩固的纽带，UnitedStack存储团队在开源存储的基础上，结合本地块存储和分布式块存储的优势，为UnitedStack OS提供一个通用的存储解决方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-1/" target="_blank" rel="external">通用线程: 学习 Linux LVM，第 1 部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-2/" target="_blank" rel="external">通用线程：学习 Linux LVM，第 2部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/" target="_blank" rel="external">Linux 内核中的 Device Mapper 机制</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="external">Ceph：一个 Linux PB 级分布式文件系统</a></li>
<li><a href="http://www.alidata.org/archives/1589" target="_blank" rel="external">分布式文件系统Ceph调研1 – RADOS</a></li>
<li><a href="http://ceph.com/docs/next/architecture/" target="_blank" rel="external">Ceph Architecture</a></li>
<li><a href="http://way4ever.com/?p=375" target="_blank" rel="external">Ceph的现状</a></li>
<li><a href="http://way4ever.com/?p=122" target="_blank" rel="external">ceph的CRUSH数据分布算法介绍</a></li>
<li><a href="http://ceph.com/docs/next/dev/" target="_blank" rel="external">Ceph INTERNAL DEVELOPER DOCUMENTATION</a></li>
<li>原文链接：<a href="https://www.ustack.com/blog/block-storage-overview/" target="_blank" rel="external">块存储的世界</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——uptime]]></title>
      <url>http://xiaqunfeng.cc/2017/01/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94uptime/</url>
      <content type="html"><![CDATA[<p>打印系统总共运行了多长时间和系统的平均负载。<br><a id="more"></a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line"> uptime [options]</div><div class="line"></div><div class="line">Options:</div><div class="line"> -p, --pretty   show uptime in pretty format</div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -s, --since    system up since</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see uptime(1).</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime</div><div class="line"> 17:40:45 up 1 day,  6:37,  3 users,  load average: 0.27, 0.21, 0.31</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>显示内容</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:40:45</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day,  6:37</td>
<td>主机已运行时间，时间越大，说明机器越稳定</td>
</tr>
<tr>
<td>3 users</td>
<td>用户连接数，是总连接数而不是用户数</td>
</tr>
<tr>
<td>load average: 0.27, 0.21, 0.31</td>
<td>最近1，5，15分钟的系统平均负载</td>
</tr>
</tbody>
</table>
<p><strong>系统平均负载</strong>：在特定时间间隔内运行队列中的平均进程数。</p>
<p><strong>查看CPU内核数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</div><div class="line">4</div></pre></td></tr></table></figure>
<p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
<h3 id="运行时间格式输出"><a href="#运行时间格式输出" class="headerlink" title="运行时间格式输出"></a>运行时间格式输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -p</div><div class="line">up 1 day, 6 hours, 56 minutes</div></pre></td></tr></table></figure>
<h3 id="系统启动的时间"><a href="#系统启动的时间" class="headerlink" title="系统启动的时间"></a>系统启动的时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -s</div><div class="line">2017-01-16 11:03:35</div></pre></td></tr></table></figure>
<h3 id="uptime版本"><a href="#uptime版本" class="headerlink" title="uptime版本"></a>uptime版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -V</div><div class="line">uptime from procps-ng 3.3.9</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dd磁盘命令小记]]></title>
      <url>http://xiaqunfeng.cc/2017/01/12/dd%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>dd是经常使用的命令了，方便快捷，这里闲来小总结一下，以及怎样测出最真实的写入速度。<br><a id="more"></a></p>
<h2 id="命令的使用"><a href="#命令的使用" class="headerlink" title="命令的使用"></a>命令的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd --help</div><div class="line">Usage: dd [OPERAND]...</div><div class="line">  or:  dd OPTION</div><div class="line">Copy a file, converting and formatting according to the operands.</div><div class="line"></div><div class="line">  bs=BYTES        read and write up to BYTES bytes at a time</div><div class="line">  cbs=BYTES       convert BYTES bytes at a time</div><div class="line">  conv=CONVS      convert the file as per the comma separated symbol list</div><div class="line">  count=N         copy only N input blocks</div><div class="line">  ibs=BYTES       read up to BYTES bytes at a time (default: 512)</div><div class="line">  if=FILE         read from FILE instead of stdin</div><div class="line">  iflag=FLAGS     read as per the comma separated symbol list</div><div class="line">  obs=BYTES       write BYTES bytes at a time (default: 512)</div><div class="line">  of=FILE         write to FILE instead of stdout</div><div class="line">  oflag=FLAGS     write as per the comma separated symbol list</div><div class="line">  seek=N          skip N obs-sized blocks at start of output</div><div class="line">  skip=N          skip N ibs-sized blocks at start of input</div><div class="line">  status=WHICH    WHICH info to suppress outputting to stderr;</div><div class="line">                  &apos;noxfer&apos; suppresses transfer stats, &apos;none&apos; suppresses all</div></pre></td></tr></table></figure>
<p><strong>翻译</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bs</td>
<td>同时设置读写块的大小为 bytes ，可代替 ibs 和 obs</td>
</tr>
<tr>
<td>cbs</td>
<td>一次转换 bytes 个字节，即转换缓冲区大小</td>
</tr>
<tr>
<td>conv</td>
<td>转换参数</td>
</tr>
<tr>
<td>count</td>
<td>复制的块数</td>
</tr>
<tr>
<td>ibs</td>
<td>一次读入 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>if</td>
<td>输入文件 或 设备名称</td>
</tr>
<tr>
<td>iflag</td>
<td>按照逗号来分隔读参数</td>
</tr>
<tr>
<td>obs</td>
<td>一次写 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>of</td>
<td>输出文件 或 设备名称</td>
</tr>
<tr>
<td>oflag</td>
<td>按照逗号来分隔写参数</td>
</tr>
<tr>
<td>seek</td>
<td>从输出文件开头跳过 blocks 个块后再开始复制</td>
</tr>
<tr>
<td>skip</td>
<td>从输入文件开头跳过 blocks 个块后再开始复制</td>
</tr>
</tbody>
</table>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd --version</div></pre></td></tr></table></figure>
<h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><p><strong>两个特殊的设备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/dev/null：伪设备，相当于黑洞，of到该设备不会产生IO</div><div class="line">/dev/zero：伪设备，它只产生空字符流，对它不会产生IO</div></pre></td></tr></table></figure>
<p><strong>1、测试磁盘写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/zero of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO都集中在of文件中，of文件只用于写，相当于测试磁盘的写能力。</p>
<p><strong>2、测试磁盘读能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/dev/null bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO只发生在/dev/sdb1上，相当于测试磁盘的读能力。</p>
<p><strong>3、测试同时读写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>一个是物理分区，一个是实际的文件，对它们的读写都会产生IO，如果它们都在一个磁盘中，该命令就相当于测试磁盘的同时读写能力。</p>
<h2 id="几种测试写磁盘的区别"><a href="#几种测试写磁盘的区别" class="headerlink" title="几种测试写磁盘的区别"></a>几种测试写磁盘的区别</h2><p>先给出四种测试方式的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd if=/dev/zero of=test bs=1M count=128</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.116559 s, 1.2 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 ; sync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.125106 s, 1.1 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 1.76802 s, 75.9 MB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 4.91353 s, 27.3 MB/s</div></pre></td></tr></table></figure>
<p>1、<code>dd if=/dev/zero of=test bs=1M count=128</code></p>
<p>没有加任何参数，命令只是单纯地把这128MB的数据读到内存缓冲当中，dd命令完成前并没有让系统真正把文件写到磁盘上。所以得到的是一个超级快的速度。直到dd完成后系统才开始真正往磁盘上写数据,但这个速度你是看不到了。</p>
<p>2、<code>dd if=/dev/zero of=test bs=1M count=128 ; sync</code></p>
<p>这事先后两个独立的命令。当sync命令准备开始往磁盘上真正写入数据的时候，前面dd命令已经把错误的“写入速度”值显示在屏幕上了。所以得到的不是真正的写入速度。</p>
<p><strong>3、<code>dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</code></strong></p>
<p>加入参数 <code>conv=fdatasync</code> 后，dd命令执行到最后会真正执行一次“同步(sync)”操作，所以这时候得到的是读取这128M数据到内存并写入到磁盘上所需的时间，这样算出来的时间才是<strong>比较符合实际</strong>的。这种方式最接近计算机实际操作，所以测出来的数据最有参考价值。</p>
<p>4、<code>dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</code></p>
<p>加入参数 <code>oflag=dsync</code> 后，dd在执行时每次都会进行同步写入操作。这条命令每次读取1M后就要先把这1M写入磁盘，然后再读取下面这1M，一共重复128次。这是最慢的一种方式，因为基本上没有用到写缓存(write cache)。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决calamari无法获取集群hosts信息的BUG]]></title>
      <url>http://xiaqunfeng.cc/2017/01/12/%E8%A7%A3%E5%86%B3calamari%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E9%9B%86%E7%BE%A4hosts%E4%BF%A1%E6%81%AF%E7%9A%84BUG/</url>
      <content type="html"><![CDATA[<p>如题，环境是ubuntu 14.04，解决过程和方法详见正文。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在磨磨的文章中看到这个问题，他是在CentOS上，通过修改 <code>/usr/lib/python2.7/site-packages/salt/master.py</code> 文件，然后重启salt-master和salt-minion服务来解决的，链接在文末。原理类似，可ubuntu上并不能完全照搬。</p>
<h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><blockquote>
<p>这部分的内容为折腾求证的过程，想看解决方法的可以直接跳过！</p>
</blockquote>
<p>在ubuntu上并没有这个文件和路径，通过tab可以看到site开头的只有这几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# vim /usr/lib/python2.7/site</div><div class="line">sitecustomize.py   sitecustomize.pyc  site.py            site.pyc</div></pre></td></tr></table></figure>
<p>我以为可能是系统下包安装的位置不对而已，好，那我就查看一下ubuntu下salt-master的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# dpkg -L salt-master</div><div class="line">/.</div><div class="line">/usr</div><div class="line">/usr/share</div><div class="line">/usr/share/man</div><div class="line">/usr/share/man/man1</div><div class="line">/usr/share/man/man1/salt.1.gz</div><div class="line">/usr/share/man/man1/salt-run.1.gz</div><div class="line">/usr/share/man/man1/salt-master.1.gz</div><div class="line">/usr/share/man/man1/salt-key.1.gz</div><div class="line">/usr/share/man/man1/salt-cp.1.gz</div><div class="line">/usr/share/doc</div><div class="line">/usr/share/doc/salt-master</div><div class="line">/usr/share/doc/salt-master/changelog.Debian.gz</div><div class="line">/usr/share/doc/salt-master/NEWS.Debian.gz</div><div class="line">/usr/share/doc/salt-master/copyright</div><div class="line">/usr/bin</div><div class="line">/usr/bin/salt-run</div><div class="line">/usr/bin/salt-master</div><div class="line">/usr/bin/salt-key</div><div class="line">/usr/bin/salt-cp</div><div class="line">/usr/bin/salt</div><div class="line">/lib</div><div class="line">/lib/systemd</div><div class="line">/lib/systemd/system</div><div class="line">/lib/systemd/system/salt-master.service</div><div class="line">/etc</div><div class="line">/etc/init.d</div><div class="line">/etc/init.d/salt-master</div><div class="line">/etc/init</div><div class="line">/etc/init/salt-master.conf</div><div class="line">/etc/salt</div><div class="line">/etc/salt/master</div><div class="line">/etc/salt/master.d</div></pre></td></tr></table></figure>
<p>然后通过 <code>find</code> 命令去 <code>/etc, /usr, /lib</code> 这几个目录下找 <code>master.py</code> ，结果真没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find: `master.py&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>好吧，下面来看问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在calamari的web界面下，查看 MANAGE -&gt; Cluster -&gt;HOSTS 信息，发现啥也没有，如下图所示：<img src="http://ojet8bprn.bkt.clouddn.com/calamari-1.png" alt="calamari-1"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>calamari的salt-master节点在读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/cache/salt/master/minions/&#123;minion-hostname&#125;/data.p</div></pre></td></tr></table></figure>
<p>该文件的时候有权限问题，当前权限为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw------- 1 root root 3019 Jan 10 11:06 data.p</div></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改权限为 644 即可，写了个脚本，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for x in 0 1 2</div><div class="line">do</div><div class="line">    chmod 644 /var/cache/salt/master/minions/ceph$x/data.p</div><div class="line">done</div></pre></td></tr></table></figure>
<p>修改完后，再次查看，可以看到hosts的详细信息了<img src="http://ojet8bprn.bkt.clouddn.com/calamari-2.png" alt="calamari-2"></p>
<blockquote>
<p>当然，重启 salt-minion 后又需要在 salt-master 机器上重新执行一遍，<del>~~(&gt;_&lt;)</del>~~，忧伤~</p>
</blockquote>
<p>磨磨的方法：<a href="http://www.zphj1987.com/2017/01/09/calamari-node-info/" target="_blank" rel="external">centos下该问题的解决方法</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下配置邮件发送]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
      <content type="html"><![CDATA[<p>Linux下发送email有很多种方式，包括sendmail、mailx、mutt、uuencode等等。这里介绍ubuntu下使用mutt和msmtp发送邮件的配置方法。<br><a id="more"></a></p>
<h2 id="软件包的安装"><a href="#软件包的安装" class="headerlink" title="软件包的安装"></a>软件包的安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mutt</div><div class="line">sudo apt-get install msmtp</div></pre></td></tr></table></figure>
<h2 id="文件的配置"><a href="#文件的配置" class="headerlink" title="文件的配置"></a>文件的配置</h2><h3 id="配置-mutt"><a href="#配置-mutt" class="headerlink" title="配置 mutt"></a>配置 mutt</h3><p>,系统全局设置配置文件在 /etc/Muttrc,如果使用某个系统用户，可以在~/.muttc中设置，没有该文件，就自己创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi .muttrc</div><div class="line"></div><div class="line">set sendmail=&quot;/usr/bin/msmtp&quot;</div><div class="line">set use_from=yes</div><div class="line">set realname=&quot;xia&quot;</div><div class="line">set from=abcdefg@126.com</div><div class="line">set envelope_from=yes</div></pre></td></tr></table></figure>
<h3 id="配置msmtp"><a href="#配置msmtp" class="headerlink" title="配置msmtp"></a>配置msmtp</h3><p>创建 ~/.msmtprc 和 ~/.msmtp.log，分别为配置文件和日志文件。</p>
<p><strong>1、创建配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .msmtprc</div></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">account default</div><div class="line">host smtp.126.com</div><div class="line">from youremailname@126.com</div><div class="line">auth plain</div><div class="line">user youremailname@126.com</div><div class="line">password xxxxxxx</div><div class="line">logfile ~/.msmtp.log</div></pre></td></tr></table></figure>
<p>由于password是明文，所以需要修改此文件的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 .msmtprc</div></pre></td></tr></table></figure>
<p><strong>特别注意</strong>：</p>
<blockquote>
<p>这里的密码填的是你的授权密码，不是登录密码!</p>
</blockquote>
<p><strong>2、创建日志文件 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch ~/.msmtp.log</div></pre></td></tr></table></figure>
<h2 id="邮件发送测试"><a href="#邮件发送测试" class="headerlink" title="邮件发送测试"></a>邮件发送测试</h2><p>查看SMTP服务器是否支持认证的TLS加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># msmtp --host=smtp.126.com --serverinfo</div><div class="line">SMTP server at smtp.126.com (m15-111.126.com [220.181.15.111]), port 25:</div><div class="line">    126.com Anti-spam GT for Coremail System (126com[20140526])</div><div class="line">Capabilities:</div><div class="line">    PIPELINING:</div><div class="line">        Support for command grouping for faster transmission</div><div class="line">    STARTTLS:</div><div class="line">        Support for TLS encryption via the STARTTLS command</div><div class="line">    AUTH:</div><div class="line">        Supported authentication methods:</div><div class="line">        PLAIN LOGIN </div><div class="line">This server might advertise more or other capabilities when TLS is active.</div></pre></td></tr></table></figure>
<p>发送一个简单的邮件测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello world&quot; | mutt -s &quot;title&quot; 12456789@qq.com</div></pre></td></tr></table></figure>
<p>登录QQ邮箱，可以正常收到邮件，成功！</p>
<h2 id="四种发送方式"><a href="#四种发送方式" class="headerlink" title="四种发送方式"></a>四种发送方式</h2><p>1、<strong>带有主题，从文件中读取邮件的正文，并发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mutt -s &quot;hello mutt&quot; user@example.com &lt; message.txt</div></pre></td></tr></table></figure>
<p>2、<strong>通过管道获取 <code>echo</code>命令输出作为邮件内容发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com</div></pre></td></tr></table></figure>
<p>3、<strong>发送带附件的邮件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com -a test.tar.gz</div></pre></td></tr></table></figure>
<p>多个附件的话在每个附件前加上 <code>-a</code> 即可。</p>
<p>4、<strong>发送给多个收件人</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello mutt&quot; | mutt -s &quot;Testing muttt&quot; 111111@qq.com,222222@163.com -c 3333333@qq.com -b 44444444@126.com</div></pre></td></tr></table></figure>
<p>多个收件人之间用逗号隔开</p>
<p><strong>抄送</strong>，前面加参数 <code>-c</code> </p>
<p><strong>密送</strong>，前面加参数 <code>-b</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1、出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">msmtp: authentication failed (method PLAIN)</div><div class="line">msmtp: server message: 530 Error: A secure connection is requiered(such as ssl). More information at http://service.mail.qq.com/cgi-bin/help?id=28</div><div class="line">msmtp: could not send mail (account default from /root/.msmtprc)</div><div class="line">Error sending message, child exited 77 (Insufficient permission.).</div><div class="line">Could not send the message.</div></pre></td></tr></table></figure>
<p>原因，没有权限进行操作</p>
<p>解决方法：</p>
<blockquote>
<p>登录网页邮箱，设置开启POP3/SMTP服务、IMAP/SMTP服务</p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="http://www.cnblogs.com/xiazh/archive/2011/04/15/2016966.html" target="_blank" rel="external">ubuntu下使用mutt和msmtp发送邮件的简单配置</a></p>
<p><a href="https://linux.cn/article-5502-1.html" target="_blank" rel="external">4个可以发送电子邮件的命令行工具</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下系统打包]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu%E4%B8%8B%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>介绍在ubuntu下利用remastersys工具给系统打包成 iso 镜像的方法，在其他系统（centos、windows等）下方法类似，不在赘述。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在初始环境下，经过多次反复安装和配置才组建完成的自己需要的环境，其中各种版本问题和依赖较多，安装过程繁杂，为了避免痛苦的安装过程轮回发生，需要给系统打个包，后续使用直接安装即可。</p>
<p>使用工具：Remastersys</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、依赖项的安装"><a href="#1、依赖项的安装" class="headerlink" title="1、依赖项的安装"></a>1、依赖项的安装</h3><p>依赖：<a href="ftp://ftp.gwdg.de/pub/linux/easyvdr/mirror/remastersys/ubuntu/remastersys/remastersys_3.0.4-2_all.deb" target="_blank" rel="external">remastersys_3.0.4-2_all.deb</a>，点击即可下载，也可以自己去去<a href="http://www.filewatcher.com/" target="_blank" rel="external">filewatcher</a>搜索下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install plymouth-x11 </div><div class="line">sudo dpkg -i remastersys_3.0.4-2_all.deb</div></pre></td></tr></table></figure>
<h3 id="2、Remastersys安装"><a href="#2、Remastersys安装" class="headerlink" title="2、Remastersys安装"></a>2、Remastersys安装</h3><p>2.1、添加安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;deb http://www.remastersys.com/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list</div></pre></td></tr></table></figure>
<p>2.2、更新安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo install remastersys</div><div class="line">sudo remastersys</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys  backup|clean|dist  [cdfs|iso]  [filename.iso]</div></pre></td></tr></table></figure>
<p>两种打包方式：backup和dist</p>
<p>backup 是对整个系统完全打包，包含个人文件</p>
<p>dist 方式用做发行，不包含个人文件</p>
<blockquote>
<p>更多使用方法可以参考<a href="http://forum.ubuntu.org.cn/viewtopic.php?t=174719" target="_blank" rel="external">ubuntu论坛</a></p>
</blockquote>
<h3 id="系统打包"><a href="#系统打包" class="headerlink" title="系统打包"></a>系统打包</h3><p>3.1、产生一个只有档案系统的可发布的 livecd/dvd </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist cdfs</div></pre></td></tr></table></figure>
<p>3.2、产生一个可发布其名叫 filename.iso的ISO文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist iso filename.iso</div></pre></td></tr></table></figure>
<p>3.3、将产生的iso文件移动到安全的位置(如果不移动会被清除掉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv /home/remastersys/remastersys/filename.iso /root/</div></pre></td></tr></table></figure>
<p>3.4、清除由 remastersys产生的临时文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys clean</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——history及其优化]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94history%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>没啥好说的，就是查看历史输入的命令。这里引入两个优化点，一是历史记录带时间，二是可以统计汇总不同终端下的命令。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">history [n]</div><div class="line">history [-c]</div><div class="line">history [-raw] histfiles</div></pre></td></tr></table></figure>
<p>参数解释：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数字，列出最近的 n 条命令列表</td>
</tr>
<tr>
<td>-c</td>
<td>将目前的shell中的所有 history 内容全部清除</td>
</tr>
<tr>
<td>-a</td>
<td>将目前新增的history指令新增入 histfiles中，若没有➕histfiles，则预设写入 ~/.bash_history</td>
</tr>
<tr>
<td>-r</td>
<td>将histfiles的内容读到目前这个shell的history记忆中</td>
</tr>
<tr>
<td>-w</td>
<td>将目前的history记忆内容写入histfiles</td>
</tr>
</tbody>
</table>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more, less, tail, head</code> 来使用，其他复杂用法这里不作介绍。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">history | more</div><div class="line">history | tail -4</div></pre></td></tr></table></figure>
<h2 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h2><p><strong>出发点</strong>：在项目中，在不同终端下执行了一系列的命令后，翻不到历史记录，也没有汇总，也不知道每条命令的执行时间，所以需要对该命令进行优化。</p>
<p><strong>优化点</strong></p>
<ul>
<li>历史记录里面每条命令带有时间</li>
<li>所有终端命令都记录到history当中去</li>
</ul>
<blockquote>
<p>命令的汇总限同一个机器下的同一个用户</p>
</blockquote>
<p>注：以下设置方法适用ubuntu，其他系统类似。ubuntu上修改的文件是 <code>/etc/bash.bashrc</code>，mac上修改的文件是 <code>/etc/bashrc</code> 。</p>
<h3 id="添加日期"><a href="#添加日期" class="headerlink" title="添加日期"></a>添加日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</div><div class="line">export HISTTIMEFORMAT</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候，history命令的显示就带有日期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">448  2017-01-11 11:42:01 vim /etc/bash.bashrc </div><div class="line">449  2017-01-11 11:42:45 source /etc/bash.bashrc </div><div class="line">450  2017-01-11 11:40:18 history</div><div class="line">451  2017-01-11 11:41:11 ls</div><div class="line">452  2017-01-11 11:41:12 pwd</div><div class="line">453  2017-01-11 11:41:35 history</div></pre></td></tr></table></figure>
<h3 id="不同终端命令汇总"><a href="#不同终端命令汇总" class="headerlink" title="不同终端命令汇总"></a>不同终端命令汇总</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div><div class="line"># When the shell exits, append to the history file instead of overwriting it</div><div class="line">shopt -s histappend</div><div class="line"></div><div class="line"># After each command, append to the history file and reread it</div><div class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&apos;\n&apos;&#125;history -a; history -c; history -r&quot;</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候就可以看到之前在该机器该用户下的所有命令操作。</p>
<h3 id="调整记录命令长度"><a href="#调整记录命令长度" class="headerlink" title="调整记录命令长度"></a>调整记录命令长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTSIZE=1000	# 该数字自己定</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<h3 id="剔除连续重复的条目"><a href="#剔除连续重复的条目" class="headerlink" title="剔除连续重复的条目"></a>剔除连续重复的条目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>将 HISTCONTROL 设置为 ignoredups</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下利用screen进行屏幕协作]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E4%B8%8B%E5%88%A9%E7%94%A8screen%E8%BF%9B%E8%A1%8C%E5%B1%8F%E5%B9%95%E5%8D%8F%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>Linux本身是支持多终端并行处理的，但是某些时候我们可能需要两个人同时处理同一个终端，比如远程协助定位问题等。screen正好能满足这个需求。<br><a id="more"></a></p>
<h2 id="screen的安装"><a href="#screen的安装" class="headerlink" title="screen的安装"></a>screen的安装</h2><p>debian和ubuntu下安装方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install screen</div></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>假设现在有a和b需要进行屏幕协作。</p>
<blockquote>
<p>他们需要登录同一台服务器/机器</p>
<p>必须使用相同的账户，不同账户之前不能屏幕协作</p>
</blockquote>
<p>第一步：a 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -S zp</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>S</code> 是大写</p>
<p>第二步：b 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -x zp</div></pre></td></tr></table></figure>
<p>这时两边的操作是实时而且同步的。</p>
<h2 id="退出协作"><a href="#退出协作" class="headerlink" title="退出协作"></a>退出协作</h2><p>在任意一个终端上输入命令：<code>exit</code> ，输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[screen is terminating]</div></pre></td></tr></table></figure>
<p>表示退出成功。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——crontab]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94crontab/</url>
      <content type="html"><![CDATA[<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>crontab使用格式说明</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/crontab%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.png" alt="crontab格式说明"></p>
<p>如图所示：</p>
<ul>
<li>第1列分钟0～59</li>
<li>第2列小时0～23（0表示子夜）</li>
<li>第3列日1～31</li>
<li>第4列月1～12</li>
<li>第5列星期0～7（0和7表示星期天）</li>
<li>第6列要运行的命令</li>
</ul>
<p><strong>TIPS</strong></p>
<p>每一列之间用空格隔开。</p>
<p>破折号 <code>-</code> 表示一个整数范围。例如：“2-4”表示“2,3,4”。</p>
<p>逗号 <code>,</code> 表示枚举的意思，一个指定的集合。例如：“1,5,8”。</p>
<p>正向斜杠 <code>/</code> 表示间隔频率。例如：“8-20/2”表示从8点到20点每2小时执行一次。</p>
<p><code>/</code> 可以和 <code>*</code> 一起使用。例如<code>*/5</code>，如果用在minute字段，表示每五分钟执行一次。<code>* */1 * * *</code>  表示每一小时执行一次。</p>
<p><strong>命令格式</strong></p>
<p><code>crontab [-u user] file crontab [-u user][ -e | -l | -r ]</code></p>
<h2 id="选项详解"><a href="#选项详解" class="headerlink" title="选项详解"></a>选项详解</h2><ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><p>1、创建crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab yourcron</div></pre></td></tr></table></figure>
<p>2、列出crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>3、编辑crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab -e</div></pre></td></tr></table></figure>
<p>4、删除crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$crontab -r</div></pre></td></tr></table></figure>
<p>5、ubuntu下启动、停止与重启cron</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron start</div><div class="line">$sudo /etc/init.d/cron stop</div><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p>6、清理用户的邮件日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p><code>&gt; /dev/null 2&gt;&amp;1</code> 表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<blockquote>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要</p>
</blockquote>
<h3 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h3><p><strong>一种是新建crontab任务，然后重启cron服务</strong></p>
<p>第一步、创建一个crontab文件</p>
<p>设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。使用vi的话，在$HOME目录下的. profile文件中加入一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EDITOR=vi; export EDITOR</div></pre></td></tr></table></figure>
<p>创建一个比如名为 testcron 的文件，在其中加入自己想要执行的命令，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>把这个新创建的文件作为cron命令的参数，用来创建crontab任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab testcron</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>失败！</strong></p>
<blockquote>
<p>试过多次，不知道为啥这种通过自己创建crontab文件的方式不行，查资料也未果。后续有机会再试试，就暂时先用后一种可用的方法吧。有知道的忘不吝指教。</p>
</blockquote>
<p><strong>另一种是把要执行的命令直接写入 <code>/etc/crontab</code> 中，然后重启cron服务</strong></p>
<p>第一步、直接编辑 /etc/crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/crontab</div><div class="line">添加自己的任务</div><div class="line">* * * * * root sh myjob.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>成功！</strong></p>
<p>如果需要停止该任务的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron stop</div></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实例1：每1分钟执行一次myCommand</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例2：每小时的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例3：在上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * * myCommand</div></pre></td></tr></table></figure>
<p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 */2  *  * myCommand</div></pre></td></tr></table></figure>
<p>实例5：每周一上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * 1 myCommand</div></pre></td></tr></table></figure>
<p>实例6：每晚的21:30重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 21 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例7：每月1、10、22日的4 : 45重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">45 4 1,10,22 * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例8：每周六、周日的1 : 10重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 1 * * 6,0 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,30 18-23 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例10：每星期六的晚上11 : 00 pm重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23 * * 6 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例11：每一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* */1 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例12：晚上11点到早上7点之间，每隔一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23-7 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件中。</p>
<p>2、新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>3、<code>crontab -r</code> 将从Crontab目录（/var/spool/cron）中删除用户的Crontab文件，该用户的所有crontab都将被删除。</p>
<p>4、在crontab中 <code>%</code> 表示换行的意思。使用的时候必须进行转义%。比如经常使用的 <code>date ‘+%Y%m%d’</code> 在crontab里是不会执行的，应该换成 <code>date ‘+\%Y\%m\%d’’</code>。</p>
<p><strong>参考资料</strong>：<a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">crontab 定时任务</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上hexo博客的搭建]]></title>
      <url>http://xiaqunfeng.cc/2017/01/06/hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>​    第一篇hexo博客，介绍了在mac上搭建hexo博客的全过程。包括：准备工作、本地站点的建立、启动和部署站点、创建新文章、发布到github、更换主题 和 绑定域名。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><strong>github</strong></li>
<li><strong>homebrew</strong></li>
<li><strong>node.js 和 npm</strong></li>
<li><strong>hexo</strong></li>
</ol>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>1、github账号</p>
<p>​    这部分略过，没有的话自己注册一个。然后将mac上的公钥添加到github上去。</p>
<p>2、建立仓库</p>
<p>​    严格按照 <code>git用户名</code>.<code>github</code>.<code>io</code> 来命名。我这里就叫：<code>xiaqunfeng.github.io</code> 。</p>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><p>homebrew 是MAC OSX 上面用来安装 或者 卸载软件用的非常方面的一个软件。在终端上执行如下命令即可安装，参考<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>不推荐使用 brew 安装node， 直接从<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载，然后双击安装。我这里选择的版本是：v6.9.3 LTS。node.js 集成带有npm。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v6.9.3</div><div class="line"></div><div class="line">$ npm -v</div><div class="line">3.10.10</div></pre></td></tr></table></figure>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ hexo -v</div><div class="line">hexo: 3.2.2</div><div class="line">hexo-cli: 1.0.2</div><div class="line">os: Darwin 16.1.0 darwin x64</div><div class="line">http_parser: 2.7.0</div><div class="line">node: 6.9.3</div><div class="line">v8: 5.1.281.89</div><div class="line">uv: 1.9.1</div><div class="line">zlib: 1.2.8</div><div class="line">ares: 1.10.1-DEV</div><div class="line">icu: 57.1</div><div class="line">modules: 48</div><div class="line">openssl: 1.0.2j</div></pre></td></tr></table></figure>
<h2 id="hexo命令行使用"><a href="#hexo命令行使用" class="headerlink" title="hexo命令行使用"></a>hexo命令行使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">常用命令：</div><div class="line">hexo help			#查看帮助</div><div class="line">hexo init 			#初始化一个目录</div><div class="line">hexo new &quot;postName&quot; 		#新建文章</div><div class="line">hexo new page &quot;pageName&quot; 	#新建页面</div><div class="line">hexo generate 			#生成网页，可以在 public 目录查看整个网站的文件</div><div class="line">hexo server 			#本地预览，&apos;Ctrl+C&apos;关闭</div><div class="line">hexo deploy 			#部署.deploy目录</div><div class="line">hexo clean 			#清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</div><div class="line"></div><div class="line">简写：</div><div class="line">hexo n == hexo new</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure>
<h2 id="建立本地站点"><a href="#建立本地站点" class="headerlink" title="建立本地站点"></a>建立本地站点</h2><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。（文件夹不需要提前建好，会自行创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>新建文件夹目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy 		#需要部署的文件</div><div class="line">├── node_modules 	#Hexo插件</div><div class="line">├── public 		#生成的静态网页文件</div><div class="line">├── scaffolds 		#模板</div><div class="line">├── source 		#博客正文和其他源文件</div><div class="line">| ├── _drafts 		#草稿(刚开始没有)</div><div class="line">| └── _posts 		#文章</div><div class="line">├── themes 		#主题</div><div class="line">├── _config.yml 	#全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h2 id="启动站点"><a href="#启动站点" class="headerlink" title="启动站点"></a>启动站点</h2><p>执行 hexo server 启动站点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure>
<p>在浏览器中输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到站点了。</p>
<h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><p>编辑文件 <code>_config.yml</code> ，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repository: https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line">   branch: master</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：冒号后面要留 <strong>空格</strong>！！</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p><strong>方法1</strong>、<code>hexo n</code>创建新文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo n &quot;我的第一篇hexo博客&quot;</div><div class="line">INFO  Created: ~/hexo-blog/source/_posts/我的第一篇hexo博客.md</div></pre></td></tr></table></figure>
<p>然后用编辑器打开编辑即可。</p>
<p><strong>方法2</strong>、直接在 <code>source/_posts</code> 中新建一个md文件，进行编辑</p>
<p>在hexo-blog文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>然后在浏览器中输入<code>http://localhost:4000</code>就可以看到新加的文章了。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>执行 <code>hexo d</code> ，发现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">ERROR Deployer not found: git</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div><div class="line">hexo-site@0.0.0 /Users/xiaqunfeng/hexo-blog</div><div class="line">└── hexo-deployer-git@0.2.0</div></pre></td></tr></table></figure>
<p>再执行 <code>hexo d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div><div class="line">Username for &apos;https://github.com&apos;: xiaqunfeng</div><div class="line">Password for &apos;https://xiaqunfeng@github.com&apos;: </div><div class="line">To https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line"> * [new branch]      HEAD -&gt; master</div><div class="line">Branch master set up to track remote branch master from https://github.com/xiaqunfeng/xiaqunfeng.github.io.git.</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>输入github的用户名和密码即可。此时，博客已经完全搭建起来了。</p>
<p>在浏览器中输入：<a href="https://xiaqunfeng.github.io/" target="_blank" rel="external">https://xiaqunfeng.github.io/</a> 即可访问。</p>
<p>预览如下： <img src="http://ojet8bprn.bkt.clouddn.com/hexo-new.png" alt=""></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>自己google一下hexo主题，选一个自己喜欢的，然后git clone下来。比如 Next 主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure>
<p>然后打开_config.yml文件，替换其中的 <code>theme</code> 属性，默认为 <code>landscape</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态页面，生成的内容在public文件夹下</div><div class="line">$ hexo s #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试</div></pre></td></tr></table></figure>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>1、清理之前生成的内容，即public文件。</p>
<p><strong>注意</strong>：这一步必须要，不然有时因为缓存问题，服务器更新不了主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>2、生成静态文件并部署到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态文件</div><div class="line">$ hexo d #部署到github</div></pre></td></tr></table></figure>
<p>上面两个命令可以合并为一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d -g #在部署前先生成</div></pre></td></tr></table></figure>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><blockquote>
<p>update 2017.06.25。已购买域名，特来补充完善。</p>
</blockquote>
<p>1、购买域名</p>
<p>某乎<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="external">这里</a>有各种推荐，自己可以参考的看看。</p>
<p>godaddy地址: <a href="https://www.godaddy.com/" target="_blank" rel="external">https://www.godaddy.com</a></p>
<p>阿里云域名地址: <a href="http://wanwang.aliyun.com/" target="_blank" rel="external">http://wanwang.aliyun.com</a></p>
<p><strong> 总结 </strong><br>某乎上那些推荐都看了一遍，也琢磨了一下，最后发现，还是阿里云上的比较便宜，然后操作起来也比较方便，于是就在阿里云上买了。</p>
<p>我的域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">www.xiaqunfeng.cc</div></pre></td></tr></table></figure></p>
<p><strong> 关于域名选择 </strong></p>
<p>.com .cn .net .org 这种比较适合网站比较大的，当然，价格也贵一点，.com .cn 还需要网站备案什么的。现在一些其他后缀也很不错，比如 .cc .me .im .pro .top .info 等等，这些资料大家可以自己去查，就不细说了，强烈推荐 .me 和 .cc ，不过 .me 比 .cc贵，特别是买的时间越久或者续费都贵。我的 .cc 16块一年，哈哈，便宜，然后也挺好。</p>
<p>2、域名解析</p>
<p>域名解析-&gt;解析设置-&gt;添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，可以随便填一个，或者两个都填，线路就默认，CNAME记录值填你的github博客网址</p>
<p>我的如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/domain-hexo.jpg" alt="domain"></p>
<p>3、创建<code>CNAME</code>文件</p>
<p>这一步没做的话，打开网址访问不来博客。</p>
<p>在hexo 博客的根目录下source文件夹里创建CNAME文件，里面填上域名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat CNAME</div><div class="line">xiaqunfeng.cc</div></pre></td></tr></table></figure>
<blockquote>
<p>注：如果里面填的是 www.xiaqunfeng.cc，那以后就只能用它来访问；如果填的是 xiaqunfeng.cc，那以后用 www.xiaqunfeng.cc 和 xiaqunfeng.cc 都可以访问。</p>
</blockquote>
<p>等待生效，一般几分钟就好了，然后就可通过域名浏览你的博客主页了。</p>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
