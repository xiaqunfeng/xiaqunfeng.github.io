<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[VSM部署]]></title>
      <url>http://xiaqunfeng.github.io/2017/05/02/VSM%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>本文介在已有ceph集群机器上部署VSM的过程，涵盖centos和ubuntu两种系统。<br><a id="more"></a></p>
<h2 id="VSM-Virtual-Storage-Manager"><a href="#VSM-Virtual-Storage-Manager" class="headerlink" title="VSM - Virtual Storage Manager"></a>VSM - Virtual Storage Manager</h2><p>最新发布的release版本为2.1，pre-release版本为2.2，已不再更新和维护（因为负责人<a href="mailto:yaguang.wang@intel.com" target="_blank" rel="external">yaguang.wang@intel.com</a> or <a href="mailto:ferber.dan@intel.com" target="_blank" rel="external">ferber.dan@intel.com</a>已经从intel离职了）。</p>
<p>从2.1版本开始，VSM支持在已有ceph集群上部署，正是因为这个原因，才开始尝试部署VSM。</p>
<p>VSM 2.1的代码组件分为四个：</p>
<ul>
<li>vsm-dashboard：VSM的管理与监控web界面</li>
<li>python-vsmclient：调用restapi的client</li>
<li>vsm：VSM的核心组件（包括api、scheduler、conductor、agent等）</li>
<li>vsm-deploy：ceph部署工具</li>
</ul>
<p>代码基于Python语言，使用了wsgi、django等技术框架。</p>
<p>Git主页：<br><a href="https://github.com/01org/virtual-storage-manager" target="_blank" rel="external">https://github.com/01org/virtual-storage-manager</a></p>
<p>vsm-dependencies：<br><a href="https://github.com/01org/vsm-dependencies" target="_blank" rel="external">https://github.com/01org/vsm-dependencies</a></p>
<p>架构图如下：<img src="http://oow6unnib.bkt.clouddn.com/vsm-architecture.png" alt="vsm-architecture"></p>
<h2 id="centos上部署"><a href="#centos上部署" class="headerlink" title="centos上部署"></a>centos上部署</h2><p>OS：CentOS 7.2</p>
<p>VSM：v2.1 released</p>
<p>4台机器，一个作为controller，三台ceph集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">172.20.2.76     ceph0</div><div class="line">172.20.2.77     ceph1</div><div class="line">172.20.2.79     ceph2</div><div class="line">172.20.2.81     controller</div></pre></td></tr></table></figure>
<p>1、从controller机器上设置到ceph集群机器和自己的免密登录</p>
<p>2、关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># systemctl disable firewalld</div><div class="line"># systemctl stop firewalld</div></pre></td></tr></table></figure>
<p>3、关闭selinux</p>
<p>临时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setenforce 0</div></pre></td></tr></table></figure>
<p>永久</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/selinux/config | grep -v &quot;#&quot;</div><div class="line"></div><div class="line">SELINUX=disabled</div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
<h3 id="下载VSM："><a href="#下载VSM：" class="headerlink" title="下载VSM："></a>下载VSM：</h3><p>在controller机器上执行如下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336_centos7.tar.gz</div><div class="line"># tar -zxvf 2.1.0-336_centos7.tar.gz</div><div class="line"># cd 2.1.0-336</div><div class="line"># ls</div><div class="line">CHANGELOG.md   INSTALL.pdf  manifest      RELEASE       vsm-dep-repo</div><div class="line">CHANGELOG.pdf  installrc    NOTICE        rpms.lst      vsm-dep.repo</div><div class="line">get_pass.sh    install.sh   prov_node.sh  uninstall.sh  vsmrepo</div><div class="line">INSTALL.md     LICENSE      README.md     VERSION       vsm.repo</div></pre></td></tr></table></figure>
<h3 id="配置文件installrc"><a href="#配置文件installrc" class="headerlink" title="配置文件installrc"></a>配置文件installrc</h3><p>设置控制节点和代理节点的地址，设置完如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cat installrc | egrep -v &quot;#|^$&quot;</div><div class="line">AGENT_ADDRESS_LIST=&quot;172.20.2.76 172.20.2.77 172.20.2.79&quot;</div><div class="line">CONTROLLER_ADDRESS=&quot;172.20.2.81&quot;</div></pre></td></tr></table></figure>
<h3 id="配置manifest"><a href="#配置manifest" class="headerlink" title="配置manifest"></a>配置manifest</h3><p>在文件夹manifest中，分别创建以管理IP地址命名的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls manifest/</div><div class="line">172.20.2.76  172.20.2.79  cluster.manifest.sample</div><div class="line">172.20.2.77  172.20.2.81  server.manifest.sample</div></pre></td></tr></table></figure>
<p>将cluster.manifest.sample 文件复制到 172.20.2.81/cluster.manifest，编辑改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[management_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[100.64.0.22ceph_public_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[ceph_cluster_addr]</div><div class="line">172.20.2.0/24</div></pre></td></tr></table></figure>
<p>将server.manifest.sample 文件复制到 76、77、79文件夹下，重命名为server.manifest，改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vsm_controller_ip]</div><div class="line">172.20.2.81</div></pre></td></tr></table></figure>
<p>注：这里添加磁盘部分不用处理，因为是在已有ceph的集群上安装的。</p>
<p>manifest文件夹目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># tree</div><div class="line">.</div><div class="line">├── 172.20.2.76</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.77</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.79</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.81</div><div class="line">│   └── cluster.manifest</div><div class="line">├── cluster.manifest.sample</div><div class="line">└── server.manifest.sample</div></pre></td></tr></table></figure>
<h3 id="添加epel源"><a href="#添加epel源" class="headerlink" title="添加epel源"></a>添加epel源</h3><p>在ceph集群机器上添加epel源，一般在安装ceph集群的时候就应该已经添加了，如果没有添加的话这里加一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./install.sh -u cephuser -v 2.1 --check-dependence-package</div></pre></td></tr></table></figure>
<p>安装完成后，调用get_pass.sh提取管理密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ./get_pass.sh</div><div class="line">24195bcbce558aa7bd2c</div></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录VSM仪表盘，地址：<a href="http://172.20.2.81:dashboard/vsm" target="_blank" rel="external">http://172.20.2.81:dashboard/vsm</a></p>
<p>用户名：admin</p>
<p>密码：24195bcbce558aa7bd2c</p>
<h2 id="ubuntu上部署"><a href="#ubuntu上部署" class="headerlink" title="ubuntu上部署"></a>ubuntu上部署</h2><p>OS：ubuntu 14.04</p>
<p>安装方法和centos上基本类似，不一样的地方有：</p>
<p>1、下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336-ubuntu14.tar.gz</div></pre></td></tr></table></figure>
<p>2、不需要添加epel源</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于在非ceph集群集群上安装并创建ceph集群后续有空补充。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令清单]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/24/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<p>转载的文章，里面git命令应有尽有，包含所有常用命令，mark之。<br><a id="more"></a></p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; # 在当前目录新建一个Git代码库</div><div class="line">&gt; $ git init</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个目录，将其初始化为Git代码库</div><div class="line">&gt; $ git init [project-name]</div><div class="line">&gt;</div><div class="line">&gt; # 下载一个项目和它的整个代码历史</div><div class="line">&gt; $ git clone [url]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示当前的Git配置</div><div class="line">&gt; $ git config --list</div><div class="line">&gt;</div><div class="line">&gt; # 编辑Git配置文件</div><div class="line">&gt; $ git config -e [--global]</div><div class="line">&gt;</div><div class="line">&gt; # 设置提交代码时的用户信息</div><div class="line">&gt; $ git config [--global] user.name &quot;[name]&quot;</div><div class="line">&gt; $ git config [--global] user.email &quot;[email address]&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; # 添加指定文件到暂存区</div><div class="line">&gt; $ git add [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 添加指定目录到暂存区，包括子目录</div><div class="line">&gt; $ git add [dir]</div><div class="line">&gt;</div><div class="line">&gt; # 添加当前目录的所有文件到暂存区</div><div class="line">&gt; $ git add .</div><div class="line">&gt;</div><div class="line">&gt; # 添加每个变化前，都会要求确认</div><div class="line">&gt; # 对于同一个文件的多处变化，可以实现分次提交</div><div class="line">&gt; $ git add -p</div><div class="line">&gt;</div><div class="line">&gt; # 删除工作区文件，并且将这次删除放入暂存区</div><div class="line">&gt; $ git rm [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 停止追踪指定文件，但该文件会保留在工作区</div><div class="line">&gt; $ git rm --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 改名文件，并且将这个改名放入暂存区</div><div class="line">&gt; $ git mv [file-original] [file-renamed]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; # 提交暂存区到仓库区</div><div class="line">&gt; $ git commit -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交暂存区的指定文件到仓库区</div><div class="line">&gt; $ git commit [file1] [file2] ... -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交工作区自上次commit之后的变化，直接到仓库区</div><div class="line">&gt; $ git commit -a</div><div class="line">&gt;</div><div class="line">&gt; # 提交时显示所有diff信息</div><div class="line">&gt; $ git commit -v</div><div class="line">&gt;</div><div class="line">&gt; # 使用一次新的commit，替代上一次提交</div><div class="line">&gt; # 如果代码没有任何新变化，则用来改写上一次commit的提交信息</div><div class="line">&gt; $ git commit --amend -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 重做上一次commit，并包括指定文件的新变化</div><div class="line">&gt; $ git commit --amend [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有本地分支</div><div class="line">&gt; $ git branch</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有远程分支</div><div class="line">&gt; $ git branch -r</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有本地分支和远程分支</div><div class="line">&gt; $ git branch -a</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，但依然停留在当前分支</div><div class="line">&gt; $ git branch [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，并切换到该分支</div><div class="line">&gt; $ git checkout -b [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向指定commit</div><div class="line">&gt; $ git branch [branch] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，与指定的远程分支建立追踪关系</div><div class="line">&gt; $ git branch --track [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到指定分支，并更新工作区</div><div class="line">&gt; $ git checkout [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到上一个分支</div><div class="line">&gt; $ git checkout -</div><div class="line">&gt;</div><div class="line">&gt; # 建立追踪关系，在现有分支与指定的远程分支之间</div><div class="line">&gt; $ git branch --set-upstream [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 合并指定分支到当前分支</div><div class="line">&gt; $ git merge [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 选择一个commit，合并进当前分支</div><div class="line">&gt; $ git cherry-pick [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除分支</div><div class="line">&gt; $ git branch -d [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程分支</div><div class="line">&gt; $ git push origin --delete [branch-name]</div><div class="line">&gt; $ git branch -dr [remote/branch]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有tag</div><div class="line">&gt; $ git tag</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在当前commit</div><div class="line">&gt; $ git tag [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在指定commit</div><div class="line">&gt; $ git tag [tag] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除本地tag</div><div class="line">&gt; $ git tag -d [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程tag</div><div class="line">&gt; $ git push origin :refs/tags/[tagName]</div><div class="line">&gt;</div><div class="line">&gt; # 查看tag信息</div><div class="line">&gt; $ git show [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交指定tag</div><div class="line">&gt; $ git push [remote] [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交所有tag</div><div class="line">&gt; $ git push [remote] --tags</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向某个tag</div><div class="line">&gt; $ git checkout -b [branch] [tag]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示有变更的文件</div><div class="line">&gt; $ git status</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的版本历史</div><div class="line">&gt; $ git log</div><div class="line">&gt;</div><div class="line">&gt; # 显示commit历史，以及每次commit发生变更的文件</div><div class="line">&gt; $ git log --stat</div><div class="line">&gt;</div><div class="line">&gt; # 搜索提交历史，根据关键词</div><div class="line">&gt; $ git log -S [keyword]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，每个commit占据一行</div><div class="line">&gt; $ git log [tag] HEAD --pretty=format:%s</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</div><div class="line">&gt; $ git log [tag] HEAD --grep feature</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个文件的版本历史，包括文件改名</div><div class="line">&gt; $ git log --follow [file]</div><div class="line">&gt; $ git whatchanged [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件相关的每一次diff</div><div class="line">&gt; $ git log -p [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示过去5次提交</div><div class="line">&gt; $ git log -5 --pretty --oneline</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有提交过的用户，按提交次数排序</div><div class="line">&gt; $ git shortlog -sn</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件是什么人在什么时间修改过</div><div class="line">&gt; $ git blame [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和工作区的差异</div><div class="line">&gt; $ git diff</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和上一个commit的差异</div><div class="line">&gt; $ git diff --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示工作区与当前分支最新commit之间的差异</div><div class="line">&gt; $ git diff HEAD</div><div class="line">&gt;</div><div class="line">&gt; # 显示两次提交之间的差异</div><div class="line">&gt; $ git diff [first-branch]...[second-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 显示今天你写了多少行代码</div><div class="line">&gt; $ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交的元数据和内容变化</div><div class="line">&gt; $ git show [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交发生变化的文件</div><div class="line">&gt; $ git show --name-only [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交时，某个文件的内容</div><div class="line">&gt; $ git show [commit]:[filename]</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的最近几次提交</div><div class="line">&gt; $ git reflog</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; # 下载远程仓库的所有变动</div><div class="line">&gt; $ git fetch [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有远程仓库</div><div class="line">&gt; $ git remote -v</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个远程仓库的信息</div><div class="line">&gt; $ git remote show [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 增加一个新的远程仓库，并命名</div><div class="line">&gt; $ git remote add [shortname] [url]</div><div class="line">&gt;</div><div class="line">&gt; # 取回远程仓库的变化，并与本地分支合并</div><div class="line">&gt; $ git pull [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 上传本地指定分支到远程仓库</div><div class="line">&gt; $ git push [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 强行推送当前分支到远程仓库，即使有冲突</div><div class="line">&gt; $ git push [remote] --force</div><div class="line">&gt;</div><div class="line">&gt; # 推送所有分支到远程仓库</div><div class="line">&gt; $ git push [remote] --all</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt; # 恢复暂存区的指定文件到工作区</div><div class="line">&gt; $ git checkout [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复某个commit的指定文件到暂存区和工作区</div><div class="line">&gt; $ git checkout [commit] [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复暂存区的所有文件到工作区</div><div class="line">&gt; $ git checkout .</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</div><div class="line">&gt; $ git reset [file]</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区与工作区，与上一次commit保持一致</div><div class="line">&gt; $ git reset --hard</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</div><div class="line">&gt; $ git reset [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">&gt; $ git reset --hard [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class="line">&gt; $ git reset --keep [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个commit，用来撤销指定commit</div><div class="line">&gt; # 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class="line">&gt; $ git revert [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 暂时将未提交的变化移除，稍后再移入</div><div class="line">&gt; $ git stash</div><div class="line">&gt; $ git stash pop</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; # 生成一个可供发布的压缩包</div><div class="line">&gt; $ git archive</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>（完）</p>
<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解socket编程]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/24/%E7%90%86%E8%A7%A3socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>理解socket编程的思想，介绍各个函数及其作用，文末有一个server和client的代码，可直接运行。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本地进程通信</strong></p>
<p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p><strong>网络进程通信</strong></p>
<p>但是网络中进程之间如何通信？</p>
<p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p>
<p>TCP/IP协议族已经帮我们解决了这个问题：</p>
<ul>
<li>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机</li>
<li>传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</li>
</ul>
<p>这样利用三元组<strong>（ip地址，协议，端口）</strong>就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<h2 id="socket基本操作"><a href="#socket基本操作" class="headerlink" title="socket基本操作"></a>socket基本操作</h2><h3 id="1、socket-函数"><a href="#1、socket-函数" class="headerlink" title="1、socket()函数"></a>1、socket()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的<strong>打开</strong>操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符</strong>（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，<strong>AF_INET</strong>、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，<strong>SOCK_STREAM</strong>、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，<strong>IPPROTO_TCP</strong>、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li>
</ul>
<p>当我们调用<strong>socket()</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h3 id="2、bind-函数"><a href="#2、bind-函数" class="headerlink" title="2、bind()函数"></a>2、bind()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># ipv4</div><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div><div class="line"># ipv6对应的是： </div><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line"># Unix域对应的是： </div><div class="line">#define UNIX_PATH_MAX    108</div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
</blockquote>
<h3 id="3、listen-函数"><a href="#3、listen-函数" class="headerlink" title="3、listen()函数"></a>3、listen()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int listen(int sockfd, int backlog);</div></pre></td></tr></table></figure>
<p>两个参数</p>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>backlog：相应socket可以排队的最大连接个数</li>
</ul>
<p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<h3 id="4、connect-函数"><a href="#4、connect-函数" class="headerlink" title="4、connect()函数"></a>4、connect()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>addr：服务器的socket地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<p>客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h3 id="5、accept-函数"><a href="#5、accept-函数" class="headerlink" title="5、accept()函数"></a>5、accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p>
<p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p>
<p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：服务器的socket描述字</li>
<li>addr：指向struct sockaddr *的指针，用于返回客户端的协议地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<blockquote>
<p>服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
</blockquote>
<h3 id="6、网络I-O"><a href="#6、网络I-O" class="headerlink" title="6、网络I/O"></a>6、网络I/O</h3><p>服务端：socket、bind、listen、accept</p>
<p>客户端：socket、connect</p>
<p>至此服务器与客户已经建立好连接，可以调用网络I/O进行读写操作，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure>
<p>recvmsg()/sendmsg()这两个函数是最通用的I/O函数。各函数需要对应的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">                      const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
<h3 id="7、close-函数"><a href="#7、close-函数" class="headerlink" title="7、close()函数"></a>7、close()函数</h3><p>服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int close(int fd);</div></pre></td></tr></table></figure>
<blockquote>
<p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
</blockquote>
<p>以上参考了这篇文章：<a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="external">Linux Socket编程（不限Linux）</a>，写的很不错。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// server.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"></div><div class="line">#define SERVER_PORT    	6666 </div><div class="line">#define BUFFER_SIZE 	1024</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    // server的socket地址结构server_addr,三元组(地址,协议,端口)</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr)); //把一段内存区的内容全部设置为0</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line"></div><div class="line">    // socket描述符</div><div class="line">    int server_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( server_socket &lt; 0)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Create Socket Failed!&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 给socket 描述符绑定一个地址，地址是我们上面定义好的</div><div class="line">    if( bind(server_socket,(struct sockaddr*)&amp;server_addr,sizeof(server_addr)))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Server Bind Port : %d Failed!&quot;, SERVER_PORT); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    // 监听这个socket, 第二个参数是排队的最大连接数</div><div class="line">    if ( listen(server_socket, 10) )</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server Listen Failed!&quot;); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    while (1) </div><div class="line">    &#123;   </div><div class="line">        // 定义客户端的socket地址结构client_addr</div><div class="line">        struct sockaddr_in client_addr;</div><div class="line">        socklen_t len = sizeof(client_addr);</div><div class="line"></div><div class="line">        // 如果没有连接请求,就等待到有连接请求--这是accept函数的特性</div><div class="line">        // accept函数返回一个新的socket,这个socket(new_server_socket)用于同连接到的客户的通信，代表了服务器和客户端之间的一个通信通道</div><div class="line">        // accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中</div><div class="line">        int new_server_socket = accept(server_socket,(struct sockaddr*)&amp;client_addr,&amp;len);</div><div class="line">        if ( new_server_socket &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Accept Failed!\n&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        char buffer[BUFFER_SIZE];</div><div class="line">        bzero(buffer, BUFFER_SIZE);</div><div class="line">        // 接收从客户端来的请求</div><div class="line">        len = recv(new_server_socket,buffer,BUFFER_SIZE,0);</div><div class="line">        if (len &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Recieve Data Failed!\n&quot;);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        buffer[len] = &apos;\0&apos;;</div><div class="line">        printf(&quot;recv msg from client: %s\n&quot;, buffer);</div><div class="line">        close(new_server_socket);</div><div class="line">    &#125;</div><div class="line">    close(server_socket);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端：socket() -&gt; connect() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// client.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"> </div><div class="line">#define SERVER_PORT 6666 </div><div class="line">#define BUFFER_SIZE 1024</div><div class="line"> </div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    if (argc != 2)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Usage: ./%s ServerIPAddress\n&quot;,argv[0]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //创建socket描述符</div><div class="line">    int client_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( client_socket &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Create Socket Failed!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //设置server的地址，三元组</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr));</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line">    if(inet_aton(argv[1],&amp;server_addr.sin_addr) == 0) //服务器的IP地址来自程序的参数</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server IP Address Error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    //向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接</div><div class="line">    if(connect(client_socket,(struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Can Not Connect To %s!\n&quot;,argv[1]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line">    printf(&quot;send msg to server!\n&quot;);</div><div class="line">    char sendline[BUFFER_SIZE];</div><div class="line">    fgets(sendline, BUFFER_SIZE, stdin);</div><div class="line"></div><div class="line">	// 向服务器发送数据</div><div class="line">    if (send(client_socket, sendline, strlen(sendline), 0) &lt; 0)&#123;</div><div class="line">        printf(&quot;send msg error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(client_socket);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gcc server.c -o s</div><div class="line">gcc client.c -o c</div><div class="line"></div><div class="line"># ./s</div><div class="line">recv msg from client: hello socket</div><div class="line"></div><div class="line"># ./c 127.0.0.1</div><div class="line">send msg to server!</div><div class="line">hello socket     		// 交互输入</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cow和row快照机制的区别]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/09/cow%E5%92%8Crow%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>很清晰的讲解快照两种模式cow和row的区别。<br><a id="more"></a></p>
<p>所谓快照，是指某数据集在某一时刻一个完全可用的拷贝。也叫即时拷贝。注意是一个完全可用的。如果是在window环境下，则要结合VSS 机制，把应用程序的buffer,文件系统的buffer,操作系统的buffer全部刷向磁盘后，再做快照。﻿</p>
<p>当前快照有两种实现，分别是COW（Copy on first write） 和ROW(Redirect on first write).﻿﻿﻿</p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、读取第8个物理块﻿</li>
<li>3、新读取的第8个物理块数据写入到第9个物理块。﻿</li>
<li>4、更新快照卷map,指向第9个物理块﻿</li>
<li>5、更新第8个物理块﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/cow.jpg" alt="COW"></p>
<p>从上面可以看出，本来写一个物理块，变成了1读3写。﻿</p>
<p>COW 优点：﻿</p>
<p>1、原始卷物理块连续。没有碎片。﻿</p>
<p>COW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成1读3写。﻿﻿﻿</p>
<h2 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h2><p>对ROW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、数据写入到第9个物理块。﻿</li>
<li>3、更新原始卷map,指向第9个物理块﻿﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/row.jpg" alt="ROW"></p>
<p>从上面可以看出，本来写一个物理块，变成了2写。﻿</p>
<p>ROW 优点：﻿</p>
<p>1、性能比COW 好。﻿</p>
<p>ROW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成2写。﻿</p>
<p>2、原始卷物理块不连续。没、有碎片。</p>
<blockquote>
<p>本文为转载，原始链接未找到</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(5、6、7)]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/09/Machine-Learning-Yearning-5%E3%80%816/</url>
      <content type="html"><![CDATA[<p>第5、6、7三章，主要讲开发集和测试集，包括选型、大小、比例等。<br><a id="more"></a></p>
<p>Setting up development and test sets</p>
<p>设置开发和测试集</p>
<h2 id="Chapter-5、Your-development-and-test-sets"><a href="#Chapter-5、Your-development-and-test-sets" class="headerlink" title="Chapter 5、Your development and test sets"></a>Chapter 5、Your development and test sets</h2><p><strong>您的开发和测试集</strong><br>​    让我们回到我们早期猫图片的那个例子：你运行一个移动app，用户正在上传很多不同事物的图片到该app中。你想自动找到猫的图片。<br>​    您的团队通过从不同网站上下载猫（positive examples，正样本）和非猫（negative examples，负样本）的图获得一个大的训练集。 他们将数据集按照比例70％/ 30％分成训练集/测试集。 使用这些数据，他们构建了一个在训练集和测试集上都表现很好的的猫检测器。<br>​    但是当你将这个分类器部署到移动app时，你发现表现真的很糟糕！</p>
<p><img src="http://img.blog.csdn.net/20161209012152300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<p>​    发生了什么？<br>​    您发现用户上传的图片与您构建训练集的网站图片有所不同：用户上传的照片使用手机拍摄，这些照片往往分辨率较低，比较模糊，并且采光不好。 由于您的训练集/测试集是由网站图片构建的，您的算法没有很好的兼顾到你所关心的智能手机图片的实际分布。<br>​    在大数据的时代之前，在机器学习中使用随机的70％/ 30％来分割训练集和测试集是常见的规则。 这种做法可以工作，但在越来越多的应用程序，如训练集的分布（上面例子中的网站图像）不同于你最终关心的分布（手机图像），这是一个坏主意。</p>
<p>​    我们通常定义：</p>
<ul>
<li>训练集 - 学习算法运行在这上面。</li>
<li>Dev（开发）集 - 用于调整参数，选择特征，以及对学习算法做出其他决定。 有时也称为维持交叉验证集(hold-out cross validation set)。</li>
<li>测试集 - 用于评估算法的性能，但不要做出关于使用什么学习算法或参数的任何决定。</li>
</ul>
<p>​    你定义一个开发集和测试集，你的团队会尝试很多想法，如不同的学习算法参数，看看什么是最好的。 开发集和测试集能够使你的团队快速看到你的算法做得有多好。</p>
<p>​    换句话说，开发和测试集的目的是指导你的团队对机器学习系统进行最重要的更改。<br>​    所以，你应该做如下事情：</p>
<ul>
<li>选择开发和测试集，以反映您期望在未来获得的数据，并希望做好。</li>
</ul>
<p>​    换句话说，您的测试集不应该只是可用数据的30％这么简单，特别是如果您期望您的未来数据（移动app图片）在性质上与您的训练集（网站图像）不同时。</p>
<p>​    如果您尚未启动移动app，可能还没有任何用户，因此可能无法获取准确反映您未来需要做的更好的数据。 但你可能仍然尝试去靠近它。 例如，请你的朋友拍一些手机图片，并发送给你。 一旦app启动后，您可以使用实际的用户数据更新您的开发集/测试集。<br>​    如果你真的没有任何方法来获得接近你期望的未来数据，也许你可以从使用网站图像开始。 但是你应该意识到这将导致系统不能一般化的很好的风险。<br>​    我们需要判断去决定多少投资开发好的开发集和测试集。 但是不要假定你的训练分布与你的测试分布是一样的。 尝试选择反映您最终想要表现良好的测试样本，而不是训练遇到的任何数据。</p>
<h2 id="Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution"><a href="#Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution" class="headerlink" title="Chapter 6、Your dev and test sets should come from the same distribution"></a>Chapter 6、Your dev and test sets should come from the same distribution</h2><p><strong>你的开发集和测试集应该来自相同的分布</strong></p>
<p>根据您最大的市场，将猫应用图片数据分为四个区域：（i）美国，（ii）中国，（iii）印度和（iv）其他。要想出一个开发集和一个测试集，我们可以随机分配这两个区域到开发集，另外两个到测试集，对吧？ 比如美国和印度在开发集; 中国和其他在测试集。</p>
<p><img src="http://img.blog.csdn.net/20161209022552344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>​    一旦定义了开发集和测试集，您的团队将专注于提高开发集的性能。 因此，开发集应该反映你最想提高的任务：在所有四个地区都要做得很好，而不只是两个。<br>​    开发集和测试集的不同分布带来的第二个问题：有一个机会，你的团队将构建一些在开发集件上工作得很好，只是发现它在测试集上做得不好。 我曾经在很多失望和白费的努力中看到这个结果。 避免让这些发生在你身上。<br>​    例如，假设您的团队开发的系统在开发集上工作的很好，但在测试集上并不如意。 如果你的开发集和测试集合来自相同的分布，那么你会有一个非常明确的诊断哪里出错了：你在开发集上过拟合(overfit)了。显而易见的方法是去获得更多的开发集数据。</p>
<p>​    但是如果开发集和测试集来自不同的分布，那么你的选择是不清晰的。几方面可能会出错：</p>
<ul>
<li>1、在开发集上过拟合。</li>
<li>2、测试集比开发集更难。所以你的算法可能做的和预期一样好，因此没有进一步的重大改进的可能了。</li>
<li>3、测试集不一定更难，但只是和开发集不同。所以在开发集上表现很好但并不能在测试集上表现一样。这种情况下，之前很多提高开发集性能的努力可能都白费了。</li>
</ul>
<p>​    在机器学习应用程序上工作是很艰难的。具有不匹配的开发和测试集引入了关于是否改进开发集分布也提高测试集性能额外的不确定性。具有不匹配的开发和测试集，使得更难找出什么是有效和无效的努力，因此使得更难以确定工作的优先级。<br>​    如果你面临的是第三方基准测试 问题，他们的创建者可能会指定开发集和测试集来自不同的分布。相比开发和测试集来自同一分布，此时运气，而不是技术，将对这样的基准的性能有更大的影响。开发一个在一个分布上训练的很好同时能够很好的推广到另一个分布中的学习算法是一个重要的研究问题。但是如果你的目标是在一个特定的机器学习应用中取得进展，而不是研究进展，我建议尝试选择开发集和测试集从相同的分布。这将使您的团队更有效率。</p>
<h2 id="Chapter-7、How-large-do-the-dev-test-sets-need-to-be"><a href="#Chapter-7、How-large-do-the-dev-test-sets-need-to-be" class="headerlink" title="Chapter 7、How large do the dev/test sets need to be?"></a>Chapter 7、How large do the dev/test sets need to be?</h2><p><strong>开发集/测试集需要多大？</strong></p>
<p>​    开发集应该足够大，以检测您尝试的算法之间的差异。例如，如果分类器A具有90.0％的准确度，分类器B具有90.1％的准确度，那么100个样本的开发集将不能检测出这0.1％的差异。与我看到的其他机器学习问题相比，100个样本的开发集太小了。常见的开发集的大小在1,000到10,000个样本之间。有10,000个样本，你将有很好的机会检测到这0.1％的提升。[2]<br>​    对于成熟和重要的应用，例如广告，网络搜索和产品建议 - 我也看到了很多团队，甚至为提升0.01％积极努力，因为它对公司的利润有直接影响。在这种情况下，开发集可以远大于10,000，以便检测出更小的提升。<br>​    测试集的大小应该多大？它应该足够大，使得对系统的整体性能有一个高的信心。一个流行的启发式方法是将30％的数据用于测试集。当你有适量的样本，比如100到10,000的样本，它会工作的很好。但在大数据的时代，我们现在有机器学习问题，有时会超过十亿个样本，分配给开发集/测试集的比例一直在缩小，即使开发集 /测试集中的样本绝对数量一直在增长。除了需要评估算法的性能之外，没有必要提供过大的开发集/测试集。</p>
<p>——————————</p>
<p>[2]. 在理论上，我们可以测试算法的变化是否对开发集产生统计上显着的差异。 在实践中，大多数团队不会为此困扰（除非他们出版学术研究论文），我通常没法发现统计意义的测试对测量临时进展是有用的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(3、4)]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/03/Machine-Learning-Yearning-3%E3%80%814/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，第三章：预备知识和注释；第四章：规模驱使机器学习前进。<br><a id="more"></a></p>
<h2 id="Chapter-3、Prerequisites-and-Notation"><a href="#Chapter-3、Prerequisites-and-Notation" class="headerlink" title="Chapter 3、Prerequisites and Notation"></a>Chapter 3、Prerequisites and Notation</h2><p><strong>预备知识和注释</strong><br>​    如果你有学习过机器学习课程，比如我在Coursera上的的机器学习MOOC，或者如果你有应用监督学习的经验，你也将能够理解这段文字。<br>​    我假设你熟悉监督学习（supervised learning）：使用标记的训练样本（x，y）去学习一个从x映射到y的函数。 监督学习算法包括线性回归（linear regression），逻辑回归（logistic regression）和神经网络（neural networks）。 机器学习的形式有很多，但是现如今大部分机器学习的实用价值来自于监督学习。<br>​    我将经常提到神经网络（也称为“deep learning”）。你只需要遵循本问对它是什么有一个基本的理解就可以了。<br>​    如果您不熟悉这里提到的概念，请观看在Coursera上前三周 机器学习视频课程<a href="http://ml-class.org" target="_blank" rel="external">http://ml-class.org</a></p>
<p><img src="http://img.blog.csdn.net/20161208234928384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Chapter-4、Scale-drives-machine-learning-progress"><a href="#Chapter-4、Scale-drives-machine-learning-progress" class="headerlink" title="Chapter 4、Scale drives machine learning progress"></a>Chapter 4、Scale drives machine learning progress</h2><p><strong>规模驱使机器学习前进</strong></p>
<p>深度学习（神经网络）的许多想法已经存在几十年了。 为什么这些想法现在才火起来？<br>最近得以进步的最大驱动因素有两个：</p>
<ul>
<li>数据可用性。 人们现在在数字设备（笔记本电脑，移动设备）上花费更多的时间。这些活动产生大量的数据，我们可以使用这些数据来训练和反馈我们的学习算法。</li>
<li>计算尺度。 我们几年前才开始能够训练足够大的神经网络，以利用我们现在拥有的巨大的数据集。</li>
</ul>
<p>具体来说，即使你积累了更多的数据，通常传统学习算法（如逻辑回归）的性能表现“平稳”。这意味着它的学习曲线“平坦”，即使你给它更多的数据，算法也不会再有提升效果。</p>
<p><img src="http://img.blog.csdn.net/20161209001935676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这就好像传统的算法不知道如何处理我们现在拥有的所有数据。<br>如果你在同一个监督学习任务上训练一个小的神经网络（NN），你可能会获得略好一点的性能：</p>
<p><img src="http://img.blog.csdn.net/20161209002633511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里，“小的神经网络”是指仅具有少量隐藏单位/层/参数的神经网络。 最后，如果你训练越来越大的神经网络，你可以获得更好的性能：[1]</p>
<p><img src="http://img.blog.csdn.net/20161209003804359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>因此，当你做到下面两点的时候你会获得最佳的性能（i）训练一个非常大的神经网络，使其在上面的绿色曲线上; （ii）有大量的数据。<br>许多其他细节，如神经网络架构也很重要，这里已经有很多创新。 但是现在提高算法性能的更可靠的方法之一仍然是（i）训练更大的网络和（ii）获得更多的数据。<br>如何完成（i）和（ii）的方法是极其复杂的。 这本书将详细讨论细节。 我们将从对传统学习算法和神经网络都有用的一般策略开始，并建立构建深度学习系统所需的最先进策略。</p>
<p>[1]这个图表展示了NN在小数据集下做得更好。这种效果不如NNs在大数据集中表现良好的效果一致。 在小数据系统中，取决于特征是如何手工设计的，传统算法可能做的很好，也可能做得并不好。 例如，如果你有20个训练样本，那么使用逻辑回归还是神经网络可能并不重要; 手工特征的选择将比算法的选择产生更大的影响。 但如果你有100万的样本，我更倾向于神经网络。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(开篇、1、2)]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/02/Machine-Learning-Yearning-%E5%BC%80%E7%AF%87%E3%80%811%E3%80%812/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，翻译过来，这里是开篇、第一章和第二章的内容。<br><a id="more"></a></p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>网上搜了一下，发现已经有一些翻译后的资料了，我这里就是边学习边翻译记录，主要作为给自己的学习笔记吧，并不冲突。</p>
<p>官网：<a href="http://www.mlyearning.org/" target="_blank" rel="external">http://www.mlyearning.org/</a></p>
<p>这里可以留下你的邮箱，当有更新的时候会发到你的邮箱（好像我关注后就没发过）。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这本书的目的是教你如何做组织一个机器学习项目所需的大量的决定。 你将学习：</p>
<ul>
<li>如何建立你的开发和测试集</li>
<li>基本错误分析</li>
<li>如何使用偏差和方差来决定该做什么</li>
<li>学习曲线</li>
<li>将学习算法与人类水平的表现进行比较</li>
<li>调试推理算法</li>
<li>什么时候应该和不应该使用端到端的深度学习</li>
<li>按部进行错误分析</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>当前更新了14章，下载如下：</p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_01.pdf" target="_blank" rel="external">1-12章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_02.pdf" target="_blank" rel="external">13章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_03.pdf" target="_blank" rel="external">14章</a></p>
<h3 id="章节名称"><a href="#章节名称" class="headerlink" title="章节名称"></a>章节名称</h3><p>Chapter 1、Why Machine Learning Strategy<br>Chapter 2、How to use this book to help your team<br>Chapter 4、Prerequisites and Notation<br>Chapter 5、Scale drives machine learning progress<br>Chapter 6、Your development and test sets<br>Chapter 7、Your dev and test sets should come from the same distribution<br>Chapter 8、How large do the dev/test sets need to be?<br>Chapter 9、Establish a single-number evaluation metric for your team to optimize<br>Chapter 10、Optimizingandsatisficingmetrics<br>Chapter 11、Having a dev set and metric speeds up iterations<br>Chapter 12、When to change dev/test sets and metrics<br>Chapter 13、Takeaways: Setting up development and test sets<br>Chapter 14、Build your first system quickly, then iterate<br>Chapter 15、Error analysis: Look at dev set examples to evaluate ideas<br>Chapter 16、Evaluate multiple ideas in parallel during error analysis </p>
<p>（待添加）                </p>
<h2 id="Chapter-1、Why-Machine-Learning-Strategy"><a href="#Chapter-1、Why-Machine-Learning-Strategy" class="headerlink" title="Chapter 1、Why Machine Learning Strategy"></a>Chapter 1、Why Machine Learning Strategy</h2><p>为什么是机器学习策略</p>
<p>机器学习是无数重要应用程序的基础，包括网页搜索，电子邮件反垃圾邮件，语音识别，产品推荐等。我假设你或你的团队正在一个机器学习应用程序，并且你想要快速进步。那么这本书将帮助到你。</p>
<p>示例：构建一个cat图片启动</p>
<p>假设你正在建立一个创业公司，将为猫爱好者提供一个无尽的猫图片流。并使用神经网络建立一个计算机视觉系统，以检测图片中的猫。</p>
<p><img src="http://img.blog.csdn.net/20161208213001211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但悲剧的是，你的学习算法的准确性还不够好。你面临着提高猫检测算法的巨大压力。你该怎么做？</p>
<p>您的团队有很多想法，例如：</p>
<p>•获取更多的数据：收集更多的猫的照片</p>
<p>•收集更多样化的培训集。例如，猫在不寻常的位置的图片;猫不寻常的着色;各种相机设置下拍摄出的猫图; ….</p>
<p>•通过运行更多的梯度下降迭代来增加算法的训练时间</p>
<p>•尝试更大的神经网络，具有更多的层/隐藏单位/参数</p>
<p>•尝试更小的神经网络。</p>
<p>•尝试添加正则化（例如L2正则化）</p>
<p>•改变神经网络架构（激活功能，隐藏单位数等）</p>
<p>•…</p>
<p>在这些可能的方向中，如果选择的好，你将会建立领先的猫图片平台，并带领公司走向成功。如果选择 不好，可能会浪费几个月的时间。你该怎么做？</p>
<p>这本书会告诉你怎么做。大多数机器学习问题留下的线索告诉你什么是有用的的尝试，什么是没用的尝试。学会阅读这些线索会节省你几个月甚至几年的开发时间。</p>
<h2 id="Chapter-2、How-to-use-this-book-to-help-your-team"><a href="#Chapter-2、How-to-use-this-book-to-help-your-team" class="headerlink" title="Chapter 2、How to use this book to help your team"></a>Chapter 2、How to use this book to help your team</h2><p>如何使用这本书来帮助你的团队<br>阅读完本书后，您将对如何设置机器学习项目的技术方向有深入的了解。<br>但是你的队友可能不明白你为什么要推荐一个特定的方向。 也许你希望你的团队定义一个单数评估指标，但他们不相信。 你如何说服他们？<br>这就是为什么我把章节短：所以，你可以打印出来，让你的队友只读你需要他们知道的那一两页。<br>优先级上的一些改变会对您的团队的生产力产生巨大的影响。 通过帮助您的团队进行一些这样的改变，我希望您可以成为您的团队的超级英雄！</p>
<p><img src="http://img.blog.csdn.net/20161208232515575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[异步IO]]></title>
      <url>http://xiaqunfeng.github.io/2017/03/01/%E5%BC%82%E6%AD%A5IO/</url>
      <content type="html"><![CDATA[<p>介绍了AIO，以及四种IO模型。<br><a id="more"></a></p>
<p>Linux® 中最常用的输入/输出（I/O）模型是同步 I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是很好的一种解决方案，因为调用应用程序在等待 I/O 请求完成时不需要使用任何中央处理单元（CPU）。但是在某些情况中，I/O 请求可能需要与其他进程产生交叠。可移植操作系统接口（POSIX）异步 I/O（AIO）应用程序接口（API）就提供了这种功能。在本文中，我们将对这个 API 概要进行介绍，并来了解一下如何使用它。</p>
<h2 id="AIO-简介"><a href="#AIO-简介" class="headerlink" title="AIO 简介"></a>AIO 简介</h2><p>Linux 异步 I/O 是 Linux 内核中提供的一个相当新的增强。它是 2.6 版本内核的一个标准特性，但是我们在 2.4 版本内核的补丁中也可以找到它。AIO 背后的基本思想是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。</p>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>在深入介绍 AIO API 之前，让我们先来探索一下 Linux 上可以使用的不同 I/O 模型。这并不是一个详尽的介绍，但是我们将试图介绍最常用的一些模型来解释它们与异步 I/O 之间的区别。图 1 给出了同步和异步模型，以及阻塞和非阻塞的模型。</p>
<p align="center">图 1. 基本 Linux I/O 模型的简单矩阵</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure1.gif" alt="基本 Linux I/O 模型的简单矩阵"></p>
<p>每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。</p>
<h3 id="同步阻塞-I-O"><a href="#同步阻塞-I-O" class="headerlink" title="同步阻塞 I/O"></a>同步阻塞 I/O</h3><h2 id="I-O-密集型与-CPU-密集型进程的比较"><a href="#I-O-密集型与-CPU-密集型进程的比较" class="headerlink" title="I/O 密集型与 CPU 密集型进程的比较"></a>I/O 密集型与 CPU 密集型进程的比较</h2><p>I/O 密集型进程所执行的 I/O 操作比执行的处理操作更多。CPU 密集型的进程所执行的处理操作比 I/O 操作更多。Linux 2.6 的调度器实际上更加偏爱 I/O 密集型的进程，因为它们通常会发起一个 I/O 操作，然后进行阻塞，这就意味着其他工作都可以在两者之间有效地交错进行。</p>
<p>最常用的一个模型是同步阻塞 I/O 模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>图 2 给出了传统的阻塞 I/O 模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用 <code>read</code> 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（<code>read</code> 调用返回）。</p>
<p align="center">图 2. 同步阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure2.gif" alt="同步阻塞 I/O 模型的典型流程"></p>
<p>从应用程序的角度来说，<code>read</code> 调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。</p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I/O"></a>同步非阻塞 I/O</h3><p>同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，<code>read</code>操作可能会返回一个错误代码，说明这个命令不能立即满足（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>），如图 3 所示。</p>
<p align="center">图 3. 同步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure3.gif" alt="同步非阻塞 I/O 模型的典型流程"></p>
<p>非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图 3 所示的一样，这个方法可以引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 <code>read</code> 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。</p>
<h3 id="异步阻塞-I-O"><a href="#异步阻塞-I-O" class="headerlink" title="异步阻塞 I/O"></a>异步阻塞 I/O</h3><p>另外一个阻塞解决方案是带有阻塞通知的非阻塞 I/O。在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 <code>select</code> 系统调用来确定一个 I/O 描述符何时有操作。使 <code>select</code> 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。</p>
<p align="center">图 4. 异步阻塞 I/O 模型的典型流程 (select)</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure4.gif" alt="异步阻塞 I/O 模型的典型流程"></p>
<p><code>select</code> 调用的主要问题是它的效率不是非常高。尽管这是异步通知使用的一种方便模型，但是对于高性能的 I/O 操作来说不建议使用。</p>
<h3 id="异步非阻塞-I-O（AIO）"><a href="#异步非阻塞-I-O（AIO）" class="headerlink" title="异步非阻塞 I/O（AIO）"></a>异步非阻塞 I/O（AIO）</h3><p>最后，异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 <code>read</code> 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 <code>read</code> 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p align="center">图 5. 异步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure5.gif" alt="异步非阻塞 I/O 模型的典型流程"></p>
<p>在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。</p>
<h2 id="异步-I-O-的动机"><a href="#异步-I-O-的动机" class="headerlink" title="异步 I/O 的动机"></a>异步 I/O 的动机</h2><p>从前面 I/O 模型的分类中，我们可以看出 AIO 的动机。这种阻塞模型需要在 I/O 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 I/O 操作。同步非阻塞模型允许处理和 I/O 操作重叠进行，但是这需要应用程序根据重现的规则来检查 I/O 操作的状态。这样就剩下异步非阻塞 I/O 了，它允许处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。</p>
<p>除了需要阻塞之外，<code>select</code> 函数所提供的功能（异步阻塞 I/O）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 I/O 调用进行阻塞。</p>
<h2 id="Linux-上的-AIO-简介"><a href="#Linux-上的-AIO-简介" class="headerlink" title="Linux 上的 AIO 简介"></a>Linux 上的 AIO 简介</h2><p>本节将探索 Linux 的异步 I/O 模型，从而帮助我们理解如何在应用程序中使用这种技术。</p>
<p>在传统的 I/O 模型中，有一个使用惟一句柄标识的 I/O 通道。在 UNIX® 中，这些句柄是文件描述符（这对等同于文件、管道、套接字等等）。在阻塞 I/O 中，我们发起了一次传输操作，当传输操作完成或发生错误时，系统调用就会返回。</p>
<h2 id="Linux-上的-AIO"><a href="#Linux-上的-AIO" class="headerlink" title="Linux 上的 AIO"></a>Linux 上的 AIO</h2><p>AIO 在 2.5 版本的内核中首次出现，现在已经是 2.6 版本的产品内核的一个标准特性了。</p>
<p>在异步非阻塞 I/O 中，我们可以同时发起多个传输操作。这需要每个传输操作都有惟一的上下文，这样我们才能在它们完成时区分到底是哪个传输操作完成了。在 AIO 中，这是一个 <code>aiocb</code>（AIO I/O Control Block）结构。这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。在产生 I/O （称为完成）通知时，<code>aiocb</code> 结构就被用来惟一标识所完成的 I/O 操作。这个 API 的展示显示了如何使用它。</p>
<p>本文为转载文章, 原文链接：<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bluestore调研]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/23/Bluestore%E8%B0%83%E7%A0%94/</url>
      <content type="html"><![CDATA[<p>这是之前关注bluestore时写的调研文章，主要介绍了bluestore的架构、存储模型、IO、元数据等，以及优势。现在ceph已经出到K版本了，虽然未在生产中实践，但已经可用。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Ceph是一种软件定义存储解决方案，因此Ceph的主要目标是保障存储数据的安全。为了达到数据安全的目的，我们需要原子特性。目前没有一种文件存储系统能够提供写和更新操作的原子特性（Btrfs拥有原子特性的事务, 这是人们为了解决上述问题作出的尝试，但事实上并不成功）。</p>
<p>​    Ceph开发者不得不探索其他的解决方案。这个解决方案就是大家非常熟悉的Ceph日志。ceph后端的存储引擎目前使用的是filestore，写采用的是WAL的方式，但是写前记录日志这种技术有一个主要缺陷就是它把你的硬盘性能降低到原来的二分之一（仅当日志和OSD数据共享同一个硬盘时），因为filestore在写数据前需要先写journal，所以有一倍的写放大。</p>
<p>​    同时filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑。bluestore的初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="bluestore架构图"></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>RocksDB</td>
<td>存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）</td>
</tr>
<tr>
<td>BlueRocksEnv</td>
<td>与RocksDB交互的接口</td>
</tr>
<tr>
<td>BlueFS</td>
<td>小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备</td>
</tr>
<tr>
<td>HDD</td>
<td>物理块设备，存储实际的数据</td>
</tr>
</tbody>
</table>
<p>​    rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（<em>rocksdb默认的Env是PosixEnv，直接对接本地文件系统</em>）。</p>
<p>​    BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p>
<p>​    为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（<em>BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备</em>）。</p>
<p>​    bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。</p>
<blockquote>
<p>读：目前块设备的读操作是同步的；</p>
<p>写：由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 </p>
</blockquote>
<p>​    Ceph数据对象(真正的‘数据’)直接被写入块物理设备。因为是直接管理裸设备，所以需要分配器（Allocator）来进行裸设备的空间管理。OSD附带的数据对象元数据被存储到键值数据库RocksDB中。</p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png" alt="bluestore存储模型"></p>
<p>这里把一个硬盘分了两个分区：</p>
<ol>
<li>第一个迷你小分区使用了XFS或ext4文件系统。它存储了Ceph文件（像初始系统描述符，状态，id，fsid，钥匙串等），和RocksDB文件(RocksDB元数据和预写式日志)。</li>
<li>第二个分区是没有文件系统的原始分区。</li>
</ol>
<p>​        每一个组件都可以存储在一个不同的物理设备上。在这张图中，RocksDB的预写式日志和数据可以被存储在不同的物理设备也可以存储在迷你小分区上。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>​    数据结构onode 保存了BlueStore中一个对象的数据结构，这是一个常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。一个onode里会存在多个lextent（逻辑的数据块），用一个map来记录。lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。blob和pextent是多对多的关系。</p>
<p>​    数据结构Enode定义了一个共享的extent，也就是这段数据被多个对象共享，一个对象的onode里保存一个enode数据结构，记录该对象被共享的extent。</p>
<h2 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h2><p>​    到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在执行写操作时，首先就会根据最小分配单位min_alloc_size进行判断，并按照min_alloc_size进行拆分，从而将I/O分为对齐和非对齐的。落到某一个min_alloc_size区间的写I/O执行非对齐写，min_alloc_size整数倍的写I/O执行对齐写。</p>
<p><strong>整块写（对齐写）</strong></p>
<p>​    也就是对齐到min_alloc_size的写请求，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍。如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。（PS:回收这部分还没看）</p>
<p><strong>部分写（非对齐写）</strong></p>
<p>​    在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p>
<p>1、没有找到可以复用的blob，新生成blob</p>
<p>​    在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操，然后再把对齐后的offset和len作为lextent，进而放到blob里。之所以需要进行补零操作是因为采用Direct I/O的方式写盘要求偏移和缓冲区都对齐的。</p>
<p>2、找到可以复用的blob</p>
<p>​    先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p>
<p><em>a) 直接写在blob未使用的空间上</em></p>
<p>​    这种情况下直接新生成lextent放到blob里。</p>
<p><em>b) 覆盖写的情况</em></p>
<p>​    通过WAL写到rocksdb。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p>
<p><strong>优点</strong></p>
<p>​    对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p>
<p>​    对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RocksDB相比LevelDB的新特性]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/23/RocksDB%E7%9B%B8%E6%AF%94LevelDB%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>如题，具体列举了RocksDB中相比LevelDB的一些新特性。<br><a id="more"></a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>多线程压缩</li>
<li>多线程memtable插入</li>
<li>减少DB互斥体保持</li>
<li>优化的基于级别的压缩风格和通用压缩风格</li>
<li>前缀bloom过滤器</li>
<li>Memtable布隆过滤器</li>
<li>覆盖整个SST文件的单个布过滤器</li>
<li>写锁优化</li>
<li>改进<code>Iter :: Prev（）</code>性能</li>
<li>在SkipList搜索期间，较少的比较器调用</li>
<li>使用巨大的页面分配memtable内存</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>列簇（column families）</li>
<li>事务和WriteBatchWithIndex</li>
<li>备份和检查点</li>
<li>合并操作</li>
<li>压缩过滤器</li>
<li>RocksDB Java</li>
<li>手动压缩与自动压缩并行运行</li>
<li>持久化缓存</li>
<li>批量加载</li>
<li>前向迭代器/尾部迭代器</li>
<li>单个删除</li>
<li>范围删除文件</li>
<li>引脚迭代器key/value</li>
</ul>
<h2 id="替换的数据结构和格式"><a href="#替换的数据结构和格式" class="headerlink" title="替换的数据结构和格式"></a>替换的数据结构和格式</h2><ul>
<li>仅用于内存使用情况的纯表格式</li>
<li>基于向量和基于哈希的memtable格式</li>
<li>基于时钟的缓存（即将推出）</li>
<li>可插拔信息日志</li>
<li>使用blob注释事务日志写入（用于副本）</li>
</ul>
<h2 id="可调性"><a href="#可调性" class="headerlink" title="可调性"></a>可调性</h2><ul>
<li>速率限制</li>
<li>可调减速和停止阈值</li>
<li>保持所有文件打开的选项</li>
<li>将所有索引和bloom过滤器块保留在块缓存中的选项</li>
<li>多种WAL恢复模式</li>
<li>Fadvise提示用于预读和避免在OS页面缓存中缓存</li>
<li>用于在内存中固定L0文件的索引和bloom过滤器的选项</li>
<li>更多压缩类型：zlib，lz4，zstd</li>
<li>压缩字典</li>
<li>校验类型：xxhash</li>
<li>每级的不同级别尺寸乘法器和压缩类型</li>
</ul>
<h2 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h2><ul>
<li>统计</li>
<li>Thread-local分析</li>
<li>命令行工具中的更多命令</li>
<li>用户定义的表属性</li>
<li>事件侦听器</li>
<li>更多数据库属性</li>
<li>动态选项更改</li>
<li>从字符串或映射获取选项</li>
<li>选项文件的持久性选项</li>
</ul>
<p>英文原文链接：<a href="https://github.com/facebook/rocksdb/wiki/Features-Not-in-LevelDB" target="_blank" rel="external">Features Not in LevelDB</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kernel modules (简体中文)]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/20/Kernel%20modules%20(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/</url>
      <content type="html"><![CDATA[<p>介绍了内核模块的相关操作。加载、查看info、卸载、配置等……<br><a id="more"></a></p>
<p>相关文章</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Boot_Debugging" target="_blank" rel="external">Boot Debugging</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernels_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernels (简体中文)</a>)</li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernel parameters (简体中文)</a>)</li>
</ul>
<p><strong>翻译状态： </strong>本文是英文页面 <a href="https://wiki.archlinux.org/index.php/Kernel_modules" target="_blank" rel="external">Kernel_modules</a> 的<a href="https://wiki.archlinux.org/index.php/ArchWiki_Translation_Team_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">翻译</a>)，最后翻译时间：2013-07-06，点击<a href="https://wiki.archlinux.org/index.php?title=Kernel_modules&amp;diff=0&amp;oldid=264846" target="_blank" rel="external">这里</a>可以查看翻译后英文页面的改动。</p>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module" target="_blank" rel="external">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<blockquote>
<p>本文为转载文章，原文链接见文末</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>要创建内核模块，请阅读<a href="http://tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="external">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<p>模块保存在 <code>/lib/modules/*kernel_release*</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意: </strong>模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>显示当前装入的内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lsmod</div></pre></td></tr></table></figure>
<p>显示模块信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modinfo module_name</div></pre></td></tr></table></figure>
<p>显示所有模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | less</div></pre></td></tr></table></figure>
<p>显示某个模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | grep module_name</div></pre></td></tr></table></figure>
<p>显示一个装入模块使用的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systool -v -m module_name</div></pre></td></tr></table></figure>
<p>显示模块的依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe --show-depends module_name</div></pre></td></tr></table></figure>
<h2 id="手动加载卸载"><a href="#手动加载卸载" class="headerlink" title="手动加载卸载"></a>手动加载卸载</h2><p>控制内核模块载入/移除的命令是<a href="https://www.archlinux.org/packages/?name=kmod" target="_blank" rel="external">kmod</a> 软件包提供的, 要手动装入模块的话，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe module_name</div></pre></td></tr></table></figure>
<p>如果要移除一个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe -r module_name</div></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rmmod module_name</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/index.php/Udev" target="_blank" rel="external">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<h3 id="开机加载"><a href="#开机加载" class="headerlink" title="开机加载"></a>开机加载</h3><p>systemd 读取 <code>/etc/modules-load.d/</code> 中的配置加载额外的内核模块。配置文件名称通常为 <code>/etc/modules-load.d/.conf</code>。格式很简单，一行一个要读取的模块名，而空行以及第一个非空格字符为<code>#</code>或<code>;</code>的行会被忽略，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modules-load.d/virtio-net.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Load virtio-net.ko at boot</div><div class="line">virtio-net</div></pre></td></tr></table></figure>
<p>另见<code>man 5 modules-load.d</code>。</p>
<h3 id="配置内核模块参数"><a href="#配置内核模块参数" class="headerlink" title="配置内核模块参数"></a>配置内核模块参数</h3><h3 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用 /etc/modprobe.d/中的文件"></a>使用 /etc/modprobe.d/中的文件</h3><p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myfilename.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">options modname parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/thinkfan.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># On thinkpads, this lets the thinkfan daemon control fan speed</div><div class="line">options thinkpad_acpi fan_control=1</div></pre></td></tr></table></figure>
<p><strong>注意: </strong>如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio.conf" target="_blank" rel="external">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h3 id="使用内核命令行"><a href="#使用内核命令行" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>, <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)的内核行加入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modname.parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thinkpad_acpi.fan_control=1</div></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myalias.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Lets you use &apos;mymod&apos; in MODULES, instead of &apos;really_long_module_name&apos;</div><div class="line">alias mymod really_long_module_name</div></pre></td></tr></table></figure>
<p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/modprobe.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Prevent autoload of bluetooth</div><div class="line">alias net-pf-31 off</div><div class="line"></div><div class="line"># Prevent autoload of ipv6</div><div class="line">alias net-pf-10 off</div></pre></td></tr></table></figure>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><h3 id="禁用内核模块"><a href="#禁用内核模块" class="headerlink" title="禁用内核模块"></a>禁用内核模块</h3><p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs" target="_blank" rel="external">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d/modprobe.conf</code> 中将它们加入黑名单。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果要禁用这些模块，记得在配置完成后,将<code>.conf</code>文件加入<code>/etc/mkinitcpio.conf</code> 的 FILES 部分，然后重新生成 initramfs。</p>
<h3 id="使用-etc-modprobe-d-中的文件-1"><a href="#使用-etc-modprobe-d-中的文件-1" class="headerlink" title="使用 /etc/modprobe.d/ 中的文件"></a>使用 /etc/modprobe.d/ 中的文件</h3><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/nobeep.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Do not load the pcspkr module on boot</div><div class="line">blacklist pcspkr</div></pre></td></tr></table></figure>
<p><strong>注意: </strong><code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，直接返回导入失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/blacklist.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">install MODULE /bin/false</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p>
<h3 id="使用内核命令行-1"><a href="#使用内核命令行-1" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>同样可以通过内核命令行(位于 <a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>、<a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)禁用模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe.blacklist=modname1,modname2,modname3</div></pre></td></tr></table></figure>
<p>当某个模块导致系统无法启动时，可以使用此方法禁用模块。</p>
<p>参阅<a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external">Kernel parameters</a>.</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="显示所有内核参数的脚本"><a href="#显示所有内核参数的脚本" class="headerlink" title="显示所有内核参数的脚本"></a>显示所有内核参数的脚本</h3><p>下面的 bash 脚本可以显示当前装入模块、模块参数及当前参数的数值。它使用 <code>/proc/modules</code> 获取当前装入模块的列表，然后用 modinfo 获取模块的描述和模块的参数，最后访问 sysfs 文件系统获得当前模块名和参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function aa_mod_parameters () </div><div class="line">&#123; </div><div class="line">    N=/dev/null;</div><div class="line">    C=`tput op` O=$(echo -en &quot;\n`tput setaf 2`&gt;&gt;&gt; `tput op`&quot;);</div><div class="line">    for mod in $(cat /proc/modules|cut -d&quot; &quot; -f1);</div><div class="line">    do</div><div class="line">        md=/sys/module/$mod/parameters;</div><div class="line">        [[ ! -d $md ]] &amp;&amp; continue;</div><div class="line">        m=$mod;</div><div class="line">        d=`modinfo -d $m 2&gt;$N | tr &quot;\n&quot; &quot;\t&quot;`;</div><div class="line">        echo -en &quot;$O$m$C&quot;;</div><div class="line">        [[ $&#123;#d&#125; -gt 0 ]] &amp;&amp; echo -n &quot; - $d&quot;;</div><div class="line">        echo;</div><div class="line">        for mc in $(cd $md; echo *);</div><div class="line">        do</div><div class="line">            de=`modinfo -p $mod 2&gt;$N | grep ^$mc 2&gt;$N|sed &quot;s/^$mc=//&quot; 2&gt;$N`;</div><div class="line">            echo -en &quot;\t$mc=`cat $md/$mc 2&gt;$N`&quot;;</div><div class="line">            [[ $&#123;#de&#125; -gt 1 ]] &amp;&amp; echo -en &quot; - $de&quot;;</div><div class="line">            echo;</div><div class="line">        done;</div><div class="line">    done</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># aa_mod_parameters</div><div class="line">&gt;&gt;&gt; ehci_hcd - USB 2.0 &apos;Enhanced&apos; Host Controller (EHCI) Driver</div><div class="line">        hird=0 - hird:host initiated resume duration, +1 for each 75us (int)</div><div class="line">        ignore_oc=N - ignore_oc:ignore bogus hardware overcurrent indications (bool)</div><div class="line">        log2_irq_thresh=0 - log2_irq_thresh:log2 IRQ latency, 1-64 microframes (int)</div><div class="line">        park=0 - park:park setting; 1-3 back-to-back async packets (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; processor - ACPI Processor Driver</div><div class="line">        ignore_ppc=-1 - ignore_ppc:If the frequency of your machine gets wronglylimited by BIOS, this should help (int)</div><div class="line">        ignore_tpc=0 - ignore_tpc:Disable broken BIOS _TPC throttling support (int)</div><div class="line">        latency_factor=2 - latency_factor: (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; usb_storage - USB Mass Storage driver for Linux</div><div class="line">        delay_use=1 - delay_use:seconds to delay before using a new device (uint)</div><div class="line">        option_zero_cd=1 - option_zero_cd:ZeroCD mode (1=Force Modem (default), 2=Allow CD-Rom (uint)</div><div class="line">        quirks= - quirks:supplemental list of device IDs and their quirks (string)</div><div class="line">        swi_tru_install=1 - swi_tru_install:TRU-Install mode (1=Full Logic (def), 2=Force CD-Rom, 3=Force Modem) (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; video - ACPI Video Driver</div><div class="line">        allow_duplicates=N - allow_duplicates: (bool)</div><div class="line">        brightness_switch_enabled=Y - brightness_switch_enabled: (bool)</div><div class="line">        use_bios_initial_backlight=Y - use_bios_initial_backlight: (bool)</div></pre></td></tr></table></figure>
<p>原文链接：<a href="https://wiki.archlinux.org/index.php/Kernel_modules_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">kernel modules</a>)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——pgrep和pkill]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94pgrep%E5%92%8Cpkill/</url>
      <content type="html"><![CDATA[<p>通过程序名来查询进程PID的命令pgrep，以及对应的杀进程命令pkill。<br><a id="more"></a></p>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><p>在linux中查看进程信息，经常要用到<code>pa auxf</code>，具体到某个进程的时候，又需进行grep管道。如：<code>ps auxf|grep java|grep -v grep</code> ，即然这么长，可以不可以简化呢？当然可以，如果还是使用ps命令的话，可以改为<code>ps auxf|grep jav[a]</code>，这样就不用排除自身了。不过感觉命令还是长了点，能不能再简点，可以，使用<code>pgrep java</code>，不过此时得出的只是pid 。</p>
<p>pgrep是linux中常用的通过 <strong>程序名</strong> 来查询进程PID信息的命令。</p>
<p>pgrep命令相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep KeyWord</div></pre></td></tr></table></figure>
<p>注：pgrep命令查找的的是程序名，不包括其参数。如果参数里包括查找的keyword，而程序名中不包括，所则使用pgrep命令无法查到该进程。这时可以使用<code>ps -aux|grep keyword</code>命令。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep [options] &lt;pattern&gt;</div></pre></td></tr></table></figure>
<p>默认只显示PID，可以加选项来显示更多信息</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>通过命令 <code>pgrep --help</code> 获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line"> -d, --delimiter &lt;string&gt;  specify output delimiter</div><div class="line"> -l, --list-name           list PID and process name</div><div class="line"> -v, --inverse             negates the matching</div><div class="line"> -w, --lightweight         list all TID</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div></pre></td></tr></table></figure>
<p>翻译和解释如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>定义输出的多个进程之间的分隔符（默认使用换行符）</td>
</tr>
<tr>
<td>-l</td>
<td>列出pid 和 进程名</td>
</tr>
<tr>
<td>-v</td>
<td>否定匹配，即列出除了查找的进程以外的其他进程</td>
</tr>
<tr>
<td>-w</td>
<td>列出所有的TID</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配到的所有进程数量</td>
</tr>
<tr>
<td>-f</td>
<td>用进程全名去匹配</td>
</tr>
<tr>
<td>-g</td>
<td>匹配列出的进程组ID</td>
</tr>
<tr>
<td>-G</td>
<td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td>
</tr>
<tr>
<td>-n</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td>
</tr>
<tr>
<td>-o</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td>
</tr>
<tr>
<td>-P</td>
<td>根据父进程PID，找出所有子进程的pid</td>
</tr>
<tr>
<td>-s</td>
<td>匹配会话ID</td>
</tr>
<tr>
<td>-t</td>
<td>通过控制终端匹配</td>
</tr>
<tr>
<td>-u</td>
<td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td>
</tr>
<tr>
<td>-U</td>
<td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td>
</tr>
<tr>
<td>-x</td>
<td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td>
</tr>
<tr>
<td>-F</td>
<td>从文件中读取PID</td>
</tr>
<tr>
<td>-L</td>
<td>如果PID文件未锁定，则失败</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="列出要查找的进程"><a href="#列出要查找的进程" class="headerlink" title="列出要查找的进程"></a>列出要查找的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep ceph</div><div class="line">1478 [ceph-msgr]</div><div class="line">4682 [ceph-watch-noti]</div><div class="line">7058 /usr/bin/ceph-mon</div><div class="line">9371 /usr/bin/ceph-osd</div></pre></td></tr></table></figure>
<h4 id="自定义输出进程间分隔符"><a href="#自定义输出进程间分隔符" class="headerlink" title="自定义输出进程间分隔符"></a>自定义输出进程间分隔符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -d , ceph</div><div class="line">1478 ceph-msgr,4682 ceph-watch-noti,7058 ceph-mon,9371 ceph-osd</div><div class="line"># pgrep -l -d ... ceph</div><div class="line">1478 ceph-msgr...4682 ceph-watch-noti...7058 ceph-mon...9371 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="否定匹配"><a href="#否定匹配" class="headerlink" title="否定匹配"></a>否定匹配</h4><p>列出所有进程名中不包含 ceph 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -v ceph</div><div class="line">...</div><div class="line">4046 scst_mgmtd</div><div class="line">5408 kworker/2:1H</div><div class="line">6402 bioset</div><div class="line">6403 rbd00_0</div><div class="line">8734 rbd01_0</div><div class="line">8739 xfsalloc</div><div class="line">8741 xfs_mru_cache</div><div class="line">9153 xfs-buf/vdb1</div><div class="line">9154 xfs-data/vdb1</div><div class="line">9155 xfs-conv/vdb1</div><div class="line">9156 xfs-cil/vdb1</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="列出所有TID"><a href="#列出所有TID" class="headerlink" title="列出所有TID"></a>列出所有TID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -w ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">7062 ceph-mon</div><div class="line">7063 ceph-mon</div><div class="line">...</div><div class="line">6661 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line">9373 ceph-osd</div><div class="line">9374 ceph-osd</div><div class="line">...</div><div class="line">9702 ceph-osd</div><div class="line">27446 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="统计匹配到的进程数"><a href="#统计匹配到的进程数" class="headerlink" title="统计匹配到的进程数"></a>统计匹配到的进程数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -c ceph</div><div class="line">4</div></pre></td></tr></table></figure>
<h4 id="匹配全名"><a href="#匹配全名" class="headerlink" title="匹配全名"></a>匹配全名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -f ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>感觉并没有什么卵用</p>
<h4 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h4><p>//TODO</p>
<h4 id="查找最新和最旧进程"><a href="#查找最新和最旧进程" class="headerlink" title="查找最新和最旧进程"></a>查找最新和最旧进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>查找最新(newest)、最后启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -n ceph</div><div class="line">4682 ceph-watch-noti</div></pre></td></tr></table></figure>
<p>查找最旧(oldest)、最早启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -o ceph</div><div class="line">7058 ceph-mon</div></pre></td></tr></table></figure>
<blockquote>
<p>注：进程号越大，并不一定意味着进程的启动时间越晚、进程越新</p>
</blockquote>
<h4 id="显示所有父进程的子进程"><a href="#显示所有父进程的子进程" class="headerlink" title="显示所有父进程的子进程"></a>显示所有父进程的子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># pgrep -P 2380</div><div class="line">2381</div><div class="line">2382</div><div class="line">2383</div><div class="line">2384</div><div class="line">2385</div></pre></td></tr></table></figure>
<h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line"># pgrep -x ceph</div><div class="line"># pgrep -x ceph-osd</div><div class="line">9371</div></pre></td></tr></table></figure>
<h4 id="从文件中读取PID"><a href="#从文件中读取PID" class="headerlink" title="从文件中读取PID"></a>从文件中读取PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat pid-file.txt </div><div class="line">1478</div><div class="line">7051</div><div class="line">2222</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -F pid-file.txt </div><div class="line">1478 ceph-msgr</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>PID和TID的区别</p>
<p>pid是进程标识符，tid是线程标识符。</p>
<p>内核不会在它们之间做出真正的区分：线程就像进程一样，但它们与同一组的其他实例共享一些东西（内存，fds …）。</p>
<p>因此，tid实际上是内核（线程）中可调度对象的标识符，而pid是共享内存和fds（进程）的可调度对象组的标识符。当一个进程只有一个线程，pid和tid总是相同的。 所以任何使用tid的函数都会自动使用pid。</p>
<p>值得注意的是，许多函数/系统调用/命令行实用程序记录使用pid实际上使用tids。 但如果效果是过程范围的，你就不会注意到差异。</p>
<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>与 <code>pgrep</code> 使用方法基本类似，不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># pkill --help</div><div class="line"></div><div class="line">Usage:</div><div class="line"> pkill [options] &lt;pattern&gt;</div><div class="line"></div><div class="line">Options:</div><div class="line"> -&lt;sig&gt;, --signal &lt;sig&gt;    signal to send (either number or name)</div><div class="line"> -e, --echo                display what is killed</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see pgrep(1).</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——strace]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/16/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94strace/</url>
      <content type="html"><![CDATA[<p>strace命令，用来查看运行程序的系统调用，统计每个系统调用的时间。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<p>我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。 </p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usage: strace [-CdffhiqrtttTvVxxy] [-I n] [-e expr]...</div><div class="line">              [-a column] [-o file] [-s strsize] [-P path]...</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div><div class="line">   or: strace -c[df] [-I n] [-e expr]... [-O overhead] [-S sortby]</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</div><div class="line">-d 输出strace关于标准错误的调试信息.</div><div class="line">-f 跟踪由fork调用所产生的子进程.</div><div class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</div><div class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</div><div class="line">-h 输出简要的帮助信息.</div><div class="line">-i 输出系统调用的入口指针.</div><div class="line">-q 禁止输出关于脱离的消息.</div><div class="line">-r 打印出相对时间关于,,每一个系统调用.</div><div class="line">-t 在输出中的每一行前加上时间信息.</div><div class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</div><div class="line">-ttt 微秒级输出,以秒了表示时间.</div><div class="line">-T 显示每一调用所耗的时间.</div><div class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</div><div class="line">-V 输出strace的版本信息.</div><div class="line">-x 以十六进制形式输出非标准字符串</div><div class="line">-xx 所有字符串以十六进制形式输出.</div><div class="line">-a column</div><div class="line">设置返回值的输出位置.默认 为40.</div><div class="line">-e expr</div><div class="line">指定一个表达式,用来控制如何跟踪.格式如下:</div><div class="line">[qualifier=][!]value1[,value2]...</div><div class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</div><div class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</div><div class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</div><div class="line">-e trace=set</div><div class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</div><div class="line">-e trace=file</div><div class="line">只跟踪有关文件操作的系统调用.</div><div class="line">-e trace=process</div><div class="line">只跟踪有关进程控制的系统调用.</div><div class="line">-e trace=network</div><div class="line">跟踪与网络有关的所有系统调用.</div><div class="line">-e strace=signal</div><div class="line">跟踪所有与系统信号有关的 系统调用</div><div class="line">-e trace=ipc</div><div class="line">跟踪所有与进程通讯有关的系统调用</div><div class="line">-e abbrev=set</div><div class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</div><div class="line">-e raw=set</div><div class="line">将指 定的系统调用的参数以十六进制显示.</div><div class="line">-e signal=set</div><div class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</div><div class="line">-e read=set</div><div class="line">输出从指定文件中读出 的数据.例如:</div><div class="line">-e read=3,5</div><div class="line">-e write=set</div><div class="line">输出写入到指定文件中的数据.</div><div class="line">-o filename</div><div class="line">将strace的输出写入文件filename</div><div class="line">-p pid</div><div class="line">跟踪指定的进程pid.</div><div class="line">-s strsize</div><div class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</div><div class="line">-u username</div><div class="line">以username 的UID和GID执行被跟踪的命令</div></pre></td></tr></table></figure>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p>先用一个程序当例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#cat test.c </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() </div><div class="line">&#123; </div><div class="line">	int a; </div><div class="line">	scanf(&quot;%d&quot;, &amp;a); </div><div class="line">	printf(&quot;%09d\n&quot;, a); </div><div class="line">	return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译：<code>gcc -o test test.c</code> 得到可执行文件 test</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># strace ./test </div><div class="line">execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 20 vars */]) = 0</div><div class="line">brk(0)                                  = 0x9fa000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a68a000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=30643, ...&#125;) = 0</div><div class="line">mmap(NULL, 30643, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb60a682000</div><div class="line">close(3)                                = 0</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;..., 832) = 832</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1840928, ...&#125;) = 0</div><div class="line">mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb60a0a5000</div><div class="line">mprotect(0x7fb60a25f000, 2097152, PROT_NONE) = 0</div><div class="line">mmap(0x7fb60a45f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fb60a45f000</div><div class="line">mmap(0x7fb60a465000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb60a465000</div><div class="line">close(3)                                = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a681000</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a67f000</div><div class="line">arch_prctl(ARCH_SET_FS, 0x7fb60a67f740) = 0</div><div class="line">mprotect(0x7fb60a45f000, 16384, PROT_READ) = 0</div><div class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</div><div class="line">mprotect(0x7fb60a68c000, 4096, PROT_READ) = 0</div><div class="line">munmap(0x7fb60a682000, 30643)           = 0</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a689000</div><div class="line">read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)                  = 4</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a688000</div><div class="line">write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)             = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<ul>
<li>从trace结构可以看到，系统首先调用execve开始一个新的进行</li>
<li>接着进行些环境的初始化操作</li>
<li>最后停顿在”read(0,”上面，这也就是执行到了我们的scanf函数，等待我们输入数字</li>
<li>输入完100之后，再调用write函数将格式化后的数值”0000000100″输出到屏幕</li>
<li>最后调用exit_group退出进行，完成整个程序的执行过程</li>
</ul>
<p>如果在执行的过程中，进程 <code>test</code> 被kill掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd8d880a000</div><div class="line">read(0, 0x7fd8d880a000, 1024)           = ? ERESTARTSYS (To be restarted if SA_RESTART is set)</div><div class="line">--- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=1161, si_uid=0&#125; ---</div><div class="line">+++ killed by SIGTERM +++</div></pre></td></tr></table></figure>
<p>告诉你test进程”+++ killed by SIGTERM +++”</p>
<h3 id="系统调用统计"><a href="#系统调用统计" class="headerlink" title="系统调用统计"></a>系统调用统计</h3><p>使用参数 <code>-c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># strace -c ./test </div><div class="line">99</div><div class="line">000000099</div><div class="line">% time     seconds  usecs/call     calls    errors syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">  0.00    0.000000           0         2           read</div><div class="line">  0.00    0.000000           0         1           write</div><div class="line">  0.00    0.000000           0         2           open</div><div class="line">  0.00    0.000000           0         2           close</div><div class="line">  0.00    0.000000           0         4           fstat</div><div class="line">  0.00    0.000000           0         9           mmap</div><div class="line">  0.00    0.000000           0         4           mprotect</div><div class="line">  0.00    0.000000           0         1           munmap</div><div class="line">  0.00    0.000000           0         1           brk</div><div class="line">  0.00    0.000000           0         3         3 access</div><div class="line">  0.00    0.000000           0         1           execve</div><div class="line">  0.00    0.000000           0         1           arch_prctl</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">100.00    0.000000                    31         3 total</div></pre></td></tr></table></figure>
<p>很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。这里太快了，都是0。</p>
<h3 id="追踪现有进程"><a href="#追踪现有进程" class="headerlink" title="追踪现有进程"></a>追踪现有进程</h3><p>参数<code>-p</code> ，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -p pid</div></pre></td></tr></table></figure>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>使用参数<code>-o</code> 将strace的结果输出到文件中，如果不指定-o参数的话，默认的输出设备是STDERR，也就是说使用”-o filename”和” 2&gt;filename”的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 这两个命令都是将strace结果输出到文件test.txt中 </div><div class="line">strace -c -o test.txt ./test </div><div class="line">strace -c ./test 2&gt;test.txt</div></pre></td></tr></table></figure>
<h3 id="系统调用计时"><a href="#系统调用计时" class="headerlink" title="系统调用计时"></a>系统调用计时</h3><p>使用参数 <code>-T</code> 将每个系统调用所花费的时间打印出来，每个调用的时间花销现在在调用行最右边的尖括号里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000013&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31135000 &lt;0.000015&gt;</div><div class="line">read(0, 54</div><div class="line">&quot;54\n&quot;, 1024)                   = 3 &lt;9.354830&gt;</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000012&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31134000 &lt;0.000013&gt;</div><div class="line">write(1, &quot;000000054\n&quot;, 10000000054</div><div class="line">)             = 10 &lt;0.000010&gt;</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<p>使用参数 <code>-t</code> 输出结果精确到秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:21:20 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)         = 4</div><div class="line">20:21:24 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:21:24 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa926d0b000</div><div class="line">20:21:24 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)    = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-tt</code> 输出结果精确到微秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:24:52.063615 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)  = 4</div><div class="line">20:24:54.031118 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:24:54.031167 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2dc4bd3000</div><div class="line">20:24:54.031210 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-ttt</code> 输出结果精确到微秒，而且时间表示为unix时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1487247731.103542 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024) = 4</div><div class="line">1487247887.084673 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">1487247887.084717 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22beb1f000</div><div class="line">1487247887.084812 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<h3 id="截断输出"><a href="#截断输出" class="headerlink" title="截断输出"></a>截断输出</h3><p><code>-s</code> 参数用于指定trace结果的每一行输出的字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># strace -s 3 ./test </div><div class="line">...</div><div class="line">read(0, 1024</div><div class="line">&quot;102&quot;..., 1024)                 = 5</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdeeb74a000</div><div class="line">write(1, &quot;000&quot;..., 10000001024</div><div class="line">)                  = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<h3 id="跟踪服务程序"><a href="#跟踪服务程序" class="headerlink" title="跟踪服务程序"></a>跟踪服务程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o output.txt -T -tt -e trace=all -p 28979</div></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h3 id="跟踪可执行程序"><a href="#跟踪可执行程序" class="headerlink" title="跟踪可执行程序"></a>跟踪可执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -f -F -o ~/straceout.txt myserver</div></pre></td></tr></table></figure>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>参考资料：</p>
<p><a href="http://man.linuxde.net/strace" target="_blank" rel="external">strace命令</a></p>
<p><a href="http://huoding.com/2013/10/06/288" target="_blank" rel="external">通过Strace定位故障原因</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[获取每个osd的PG数]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/10/%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%AAosd%E7%9A%84PG%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个shell脚本，用于获取ceph集群中每个osd的PG数，同时分别统计每个pool上的PG数信息。<br><a id="more"></a></p>
<h2 id="Ceph集群信息"><a href="#Ceph集群信息" class="headerlink" title="Ceph集群信息"></a>Ceph集群信息</h2><p><strong>pool信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd lspools</div><div class="line">0 rbd,1 testpool,</div></pre></td></tr></table></figure>
<p><strong>osd信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.54538 root default                                      </div><div class="line">-2 0.18179     host jewel0                                   </div><div class="line"> 0 0.18179         osd.0        up  1.00000          1.00000 </div><div class="line">-3 0.18179     host jewel1                                   </div><div class="line"> 1 0.18179         osd.1        up  1.00000          1.00000 </div><div class="line">-4 0.18179     host jewel2                                   </div><div class="line"> 2 0.18179         osd.2        up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h2 id="脚本执行结果展示"><a href="#脚本执行结果展示" class="headerlink" title="脚本执行结果展示"></a>脚本执行结果展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># sh pg-per-osd.sh </div><div class="line">dumped all in format plain</div><div class="line"></div><div class="line">pool :	0	1	| SUM </div><div class="line">--------------------------------</div><div class="line">osd.0	64	128	| 192</div><div class="line">osd.1	64	128	| 192</div><div class="line">osd.2	64	128	| 192</div><div class="line">--------------------------------</div><div class="line">SUM :	192	384</div></pre></td></tr></table></figure>
<p>每行显示单个OSD在每个pool中的PG数详情</p>
<p>每列显示单个pool中每个OSD的PG数详情</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat pg-per-osd.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ceph pg dump | awk &apos;</div><div class="line"> /^pg_stat/ &#123; col=1; while($col!=&quot;up&quot;) &#123;col++&#125;; col++ &#125;</div><div class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</div><div class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</div><div class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</div><div class="line">&#125;</div><div class="line">END &#123;</div><div class="line"> printf(&quot;\n&quot;);</div><div class="line"> printf(&quot;pool :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,i); printf(&quot;| SUM \n&quot;);</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> for (i in osdlist) &#123; printf(&quot;osd.%i\t&quot;, i); sum=0;</div><div class="line">   for (j in poollist) &#123; printf(&quot;%i\t&quot;, array[i,j]); sum+=array[i,j]; sumpool[j]+=array[i,j] &#125;; printf(&quot;| %i\n&quot;,sum) &#125;</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> printf(&quot;SUM :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,sumpool[i]); printf(&quot;|\n&quot;);</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RBD 相关操作]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/10/RBD-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要有两点：一、创建RBD设备用于测试；二、RBD相关其他操作。<br><a id="more"></a></p>
<p>查看系统和内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 14.04.4 LTS</div><div class="line">Release:	14.04</div><div class="line">Codename:	trusty</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">4.2.0-27-generic</div></pre></td></tr></table></figure>
<h2 id="创建RBD设备"><a href="#创建RBD设备" class="headerlink" title="创建RBD设备"></a>创建RBD设备</h2><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>1、<code>--image-format format-id</code></p>
<p>选择用哪个对象布局，默认为 2 。</p>
<ul>
<li>format 1 - 新建 rbd 映像时使用最初的格式。此格式兼容所有版本的 librbd 和内核模块，但是不支持较新的功能，像克隆。</li>
<li>format 2 - 使用第二版 rbd 格式， librbd 和 3.11 版以上内核模块才支持（除非是分拆的模块）。此格式增加了克隆支持，使得扩展更容易，还允许以后增加新功能。</li>
</ul>
<p>注意： <code>--image-format 1</code> 已不被支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-f1 --size 10G --image-format 1 --image-feature layering </div><div class="line">rbd: image format 1 is deprecated</div><div class="line">rbd: features not allowed with format 1; use --image-format 2</div></pre></td></tr></table></figure>
<p>2、<code>--image-feature   feature</code></p>
<p>选项指定使用特性，不用全部开启。如果仅需要使用快照等特性，开启layering即可。</p>
<ul>
<li>layering: 支持分层</li>
<li>striping: 支持条带化 v2</li>
<li>exclusive-lock: 支持独占锁</li>
<li>object-map: 支持对象映射（依赖 exclusive-lock ）</li>
<li>fast-diff: 快速计算差异（依赖 object-map ）</li>
<li>deep-flatten: 支持快照扁平化操作</li>
<li>journaling: 支持记录 IO 操作（依赖独占锁）</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>这里 <code>--image-format 2</code> 可以省略掉（命令如下），因为默认值就是 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-blue --size 20G --image-feature layering</div></pre></td></tr></table></figure>
<p>查看创建的RBD信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-blue</div><div class="line">rbd image &apos;rbd-blue&apos;:</div><div class="line">	size 20480 MB in 5120 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.105774b0dc51</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<h2 id="映射块设备"><a href="#映射块设备" class="headerlink" title="映射块设备"></a>映射块设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-blue</div><div class="line">/dev/rbd0</div></pre></td></tr></table></figure>
<p>查看映射后信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped </div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># fdisk -l /dev/rbd0</div><div class="line"># mkfs.xfs /dev/rbd0</div></pre></td></tr></table></figure>
<h3 id="创建文件夹并挂载"><a href="#创建文件夹并挂载" class="headerlink" title="创建文件夹并挂载"></a>创建文件夹并挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mkdir /mnt/ceph-disk1</div><div class="line"># mount /dev/rbd0 /mnt/ceph-disk1</div><div class="line"></div><div class="line"># df -h /mnt/ceph-disk1/</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/rbd0        20G   33M   20G   1% /mnt/ceph-disk1</div></pre></td></tr></table></figure>
<blockquote>
<p>此时，RBD设备已准备就绪，可以对RBD块设备进行测试了。</p>
</blockquote>
<h2 id="块设备其他操作"><a href="#块设备其他操作" class="headerlink" title="块设备其他操作"></a>块设备其他操作</h2><h3 id="罗列块设备映像"><a href="#罗列块设备映像" class="headerlink" title="罗列块设备映像"></a>罗列块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd ls &#123;poolname&#125;	# poolname默认是rbd，可省略</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># rbd ls</div><div class="line">rbd-blue</div><div class="line">rbd-tmp</div><div class="line">rbd-tmp1</div></pre></td></tr></table></figure>
<h3 id="检索镜像信息"><a href="#检索镜像信息" class="headerlink" title="检索镜像信息"></a>检索镜像信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;pool-name&#125;/&#123;image-name&#125;</div></pre></td></tr></table></figure>
<p>如果没有创建其他rbd的话，可以将命令简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;image-name&#125;</div></pre></td></tr></table></figure>
<h3 id="调整块设备映像大小"><a href="#调整块设备映像大小" class="headerlink" title="调整块设备映像大小"></a>调整块设备映像大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd resize --size 2048 rbd-blue (to increase)</div><div class="line">rbd resize --size 2048 rbd-blue --allow-shrink (to decrease)</div></pre></td></tr></table></figure>
<h3 id="删除块设备映像"><a href="#删除块设备映像" class="headerlink" title="删除块设备映像"></a>删除块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd rm &#123;pool-name&#125;/&#123;image-name&#125;	# 默认pool是rbd，可省略&#123;pool-name&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在删除前需要umap映像</p>
</blockquote>
<h4 id="正确删除过程"><a href="#正确删除过程" class="headerlink" title="正确删除过程"></a><strong>正确删除过程</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped</div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd unmap /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">Removing image: 100% complete...done.</div></pre></td></tr></table></figure>
<p>注意：命令 <code>service rbdmap stop</code> 并不管用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service rbdmap stop</div><div class="line">stop: Job failed while stopping</div></pre></td></tr></table></figure>
<h4 id="不unmap的删除"><a href="#不unmap的删除" class="headerlink" title="不unmap的删除"></a><strong>不unmap的删除</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">2017-02-08 11:17:47.700190 7f4ba6977000 -1 librbd: image has watchers - not removing</div><div class="line">Removing image: 0% complete...failed.</div><div class="line">rbd: error: image still has watchers</div><div class="line">This means the image is still open or the client using it crashed. Try again after closing/unmapping it or waiting 30s for the crashed client to timeout.</div></pre></td></tr></table></figure>
<p>提示image正在被使用。如果想查看谁正在使用的话，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-tmp1</div><div class="line">rbd image &apos;rbd-tmp1&apos;:</div><div class="line">	size 10240 MB in 2560 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.104c2ae8944a</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags: </div><div class="line"></div><div class="line"># rados -p rbd listwatchers rbd_header.104c2ae8944a</div><div class="line">watcher=172.20.1.151:0/1839598827 client.4186 cookie=3</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面这种方式创建RBD在map的时候会失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create --size 10240 rbd-test</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-test</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div><div class="line">rbd: map failed: (6) No such device or address</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Kraken release版本上测试Ceph BlueStore]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/07/%E5%9C%A8Kraken-release%E7%89%88%E6%9C%AC%E4%B8%8A%E6%B5%8B%E8%AF%95Ceph-BlueStore/</url>
      <content type="html"><![CDATA[<p>前面写了一篇文章《ceph升级到kraken版本》，在升级后的集群上重新部署OSD遇到一些问题。这里在干净的kraken环境下部署bluestore，用来测试一下性能。本文记录部署过程及遇到的问题和解决方法。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ceph版本Kraken（11.2.0）已经发布，发行说明告诉我们，用于OSD的新的BlueStore后端现在可用。</p>
<h2 id="bluestore"><a href="#bluestore" class="headerlink" title="bluestore"></a>bluestore</h2><p>OSD的当前后端是FileStore，它主要使用XFS文件系统来存储它的数据。 为了克服XFS和POSIX的一些限制，所以开发了BlueStore后端。</p>
<p>由于校验和压缩它将提供更多的性能（主要是写）和数据安全。</p>
<p>鼓励用户从Kraken发行版本开始，使用非生产和非关键数据集来测试BlueStore，并向社区报告。</p>
<h2 id="部署BlueStore"><a href="#部署BlueStore" class="headerlink" title="部署BlueStore"></a>部署BlueStore</h2><p>要使用BlueStore部署OSD，您可以使用<code>-bluestore</code>标志来使用ceph-deploy。</p>
<p>我创建了一个简单的测试集群，有三个机器：alpha，bravo和charlie。</p>
<p>每个机器将运行一个ceph-mon和ceph-osd进程。</p>
<p>这是我用来部署集群的ceph-deploy命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph-deploy new alpha bravo charlie</div><div class="line">ceph-deploy mon create alpha bravo charlie</div></pre></td></tr></table></figure>
<p>现在，编辑当前目录中的ceph.conf文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[osd]</div><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>有了这个设置我们允许使用BlueStore，我们现在可以部署我们的OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf osd create --bluestore alpha:sdb bravo:sdb charlie:sdb</div></pre></td></tr></table></figure>
<h2 id="运行Bluestore"><a href="#运行Bluestore" class="headerlink" title="运行Bluestore"></a>运行Bluestore</h2><p>这个微小的集群如何使用BlueStore运行三个OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph -s</div><div class="line">    cluster c824e460-2f09-4994-8b2f-108aedc52d19</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;alpha=[2001:db8::100]:6789/0,bravo=[2001:db8::101]:6789/0,charlie=[2001:db8::102]:6789/0&#125;</div><div class="line">            election epoch 14, quorum 0,1,2 alpha,bravo,charlie</div><div class="line">        mgr active: charlie standbys: alpha, bravo</div><div class="line">     osdmap e14: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v24: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            43356 kB used, 30374 MB / 30416 MB avail</div><div class="line">                  64 active+clean</div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.02907 root default                                       </div><div class="line">-2 0.00969     host alpha                                     </div><div class="line"> 0 0.00969         osd.0         up  1.00000          1.00000 </div><div class="line">-3 0.00969     host bravo                                     </div><div class="line"> 1 0.00969         osd.1         up  1.00000          1.00000 </div><div class="line">-4 0.00969     host charlie                                   </div><div class="line"> 2 0.00969         osd.2         up  1.00000          1.00000 </div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<p>在alpha我看到osd.0只有一个小分区的一点配置，其余的由BlueStore使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# df -h /var/lib/ceph/osd/ceph-0</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/sdb1        97M  5.4M   92M   6% /var/lib/ceph/osd/ceph-0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# lsblk </div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sda      8:0    0    8G  0 disk </div><div class="line">├─sda1   8:1    0  7.5G  0 part /</div><div class="line">├─sda2   8:2    0    1K  0 part </div><div class="line">└─sda5   8:5    0  510M  0 part [SWAP]</div><div class="line">sdb      8:16   0   10G  0 disk </div><div class="line">├─sdb1   8:17   0  100M  0 part /var/lib/ceph/osd/ceph-0</div><div class="line">└─sdb2   8:18   0  9.9G  0 part </div><div class="line">sdc      8:32   0   10G  0 disk</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# cat /var/lib/ceph/osd/ceph-0/type</div><div class="line">bluestore</div></pre></td></tr></table></figure>
<p>OSD应该像运行FileStore的OSD一样工作，但它们应该运行得更好。</p>
<blockquote>
<p>以上内容翻译自：<a href="https://blog.widodh.nl/2017/01/testing-ceph-bluestore-with-the-kraken-release/" target="_blank" rel="external">Testing Ceph BlueStore with the Kraken release</a>。亲测可以成功，觉得很好就不放自己的配置，直接翻译过来了。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>问题1</strong>、<code>ceph -s</code>的时候出现告警：<code>WARNING: the following dangerous and experimental features are enabled: bluestore</code></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">2017-02-07 10:10:34.266900 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">2017-02-07 10:10:34.271112 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">    cluster 7e9423ea-95f8-42d1-ae2d-7a384d68dea7</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;blue0=172.20.1.151:6789/0,blue1=172.20.1.152:6789/0,blue2=172.20.1.153:6789/0&#125;</div><div class="line">            election epoch 6, quorum 0,1,2 blue0,blue1,blue2</div><div class="line">        mgr no daemons active </div><div class="line">     osdmap e15: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v34: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            49092 kB used, 599 GB / 599 GB avail</div><div class="line">                  64 active+clean</div></pre></td></tr></table></figure>
<p>查了资料，无果，有些认为是<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2016-April/009059.html" target="_blank" rel="external">内核版本的问题</a>，然而并不对。</p>
<p>真正原因是在添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>的时候忘记在前面加上：<code>[osd]</code></p>
<p><strong>问题2</strong>、从jewel版本上升级到kraken版本，然后再通过上述方法创建OSD并不成功</p>
<p><strong>问题3</strong>、创建mon的时候出现error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf mon create-initial</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用户态和内核态]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/04/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      <content type="html"><![CDATA[<p>以前整理的小知识点，关于用户态和内核态的解释。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内核态与用户态是操作系统的两种运行级别，intel cpu提供Ring0-Ring3三种级别的运行模式。Ring0级别最高，Ring3最低。</p>
<p>所以当CPU处于内核态，可以随意进入用户态。当CPU处于用户态，只能通过中断的方式进入内核态。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。</p>
<h2 id="cpu的四种状态"><a href="#cpu的四种状态" class="headerlink" title="cpu的四种状态"></a>cpu的四种状态</h2><p>在一台运行 Linux 的计算机中，CPU 在任何时候只会有如下四种状态：</p>
<ol>
<li>在处理一个硬中断。</li>
<li>在处理一个软中断，如 softirq、tasklet 和 bh。</li>
<li>运行于内核态，但有进程上下文，即与一个进程相关。</li>
<li>运行一个用户态进程。</li>
</ol>
<p>其中，【1】、【2】和【3】是运行于内核空间的，而【4】是在用户空间。其中除了【4】，其他状态只可以被在其之上的状态抢占。比如，软中断只可以被硬中断抢占。</p>
<h2 id="linux下详解"><a href="#linux下详解" class="headerlink" title="linux下详解"></a>linux下详解</h2><p>Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。</p>
<p>Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。</p>
<p>用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。</p>
<p>这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ceph升级到kraken版本]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/04/ceph%E5%8D%87%E7%BA%A7%E5%88%B0kraken%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>记录从jewel版本升级到kraken版本的过程，其中重启mon和osd部分官网上的命令并不凑效，这里纠正并记录之。<br><a id="more"></a></p>
<h2 id="1、在Jewel集群上设置sortbitwise标志"><a href="#1、在Jewel集群上设置sortbitwise标志" class="headerlink" title="1、在Jewel集群上设置sortbitwise标志"></a>1、在Jewel集群上设置sortbitwise标志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd set sortbitwise</div></pre></td></tr></table></figure>
<h2 id="2、添加安装源"><a href="#2、添加安装源" class="headerlink" title="2、添加安装源"></a>2、添加安装源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo deb https://download.ceph.com/debian-kraken/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div></pre></td></tr></table></figure>
<p><strong>设置环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-kraken</div></pre></td></tr></table></figure>
<h2 id="3、升级软件包"><a href="#3、升级软件包" class="headerlink" title="3、升级软件包"></a>3、升级软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --release kraken ceph-0 ceph-1 ceph-2</div></pre></td></tr></table></figure>
<p>此时，ceph已升级到 11.2.0 版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --version</div><div class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div></pre></td></tr></table></figure>
<p>但是，osd和mon的版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-1: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-2: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="4、在各节点上重启相关ceph守护进程"><a href="#4、在各节点上重启相关ceph守护进程" class="headerlink" title="4、在各节点上重启相关ceph守护进程"></a>4、在各节点上重启相关ceph守护进程</h2><p>安装官网上的命令操作是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-1 sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-2 sudo /etc/init.d/ceph -a restart</div></pre></td></tr></table></figure>
<p>然而，查看 mon 的进程号发现并没有重启，所以版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ps aux | grep ceph-osd</div><div class="line"># ps aux | grep ceph-mon</div></pre></td></tr></table></figure>
<p><strong>正确的重启命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 重启mon</div><div class="line">restart ceph-mon-all</div><div class="line">ssh ceph-1 restart ceph-mon-all</div><div class="line">ssh ceph-2 restart ceph-mon-all</div><div class="line"></div><div class="line"># 重启osd</div><div class="line">restart ceph-osd-all</div><div class="line">ssh ceph-1 restart ceph-osd-all</div><div class="line">ssh ceph-2 restart ceph-osd-all</div></pre></td></tr></table></figure>
<p>也可以单独重启某一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># restart ceph-mon id=ceph-0</div><div class="line">ceph-mon (ceph/ceph-0) start/running, process 23629</div><div class="line"></div><div class="line"># restart ceph-osd id=0</div><div class="line">ceph-osd (ceph/0) start/running, process 23700</div></pre></td></tr></table></figure>
<p>查看最新mon和osd版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-1: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-2: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行 <code>ceph -s</code> 的时候，出现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 7251c881-bb25-4c36-9be1-653f66c69e1c</div><div class="line">     health HEALTH_WARN</div><div class="line">            all OSDs are running kraken or later but the &apos;require_kraken_osds&apos; osdmap flag is not set</div><div class="line">...省略</div></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd set require_kraken_osds</div><div class="line">require_kraken_osds is set</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dm-cache vs Bcache]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/03/Dm-cache-vs-Bcache/</url>
      <content type="html"><![CDATA[<p>前面一篇文章介绍了flashcache和cache tier，并进行了对比，其实flashcache的原理和dm-cache是类似的。这里就介绍下dm-cache和bcache，这两种策略均已在linux内核中。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代硬盘驱动器（HDD）已经走了很长的路。他们旋转得越来越快;与过去的HDD相比具有更高的存储密度和更低的错误率，但是它们和其前身一样，仍然被视为性能瓶颈。随着时间的推移，我们已经看到了许多缓存方案来提高性能;有一些块缓存解决方案在磁盘驱动器（磁盘或存储控制器）或使用主机系统内存的文件系统级缓存解决方案附近使用某种类型的缓存。随着企业级的可接受性，大而经济的闪存存储技术的可用性，使用固态驱动器（SSD）的块缓存解决方案作为性能增强解决方案。使用基于SSD的块缓存，我们可以寻找SSD速度和HDD容量 - 快速，大而且实惠。</p>
<p>在块缓存解决方案中，概念上，将逻辑设备呈现给文件系统（或多个应用），而不是实际目的地HDD（或其它目的地块设备，例如iSCSI LUN），其中数据意在被存储。因此呈现的逻辑设备与原始设备具有相同的大小物理设备，而用于高速缓存的SSD可以跨越逻辑设备映射。</p>
<p>Linux开源社区有多个通用的块级缓存解决方案，其中包括bcache，dm-cache和flashcache。 Linux内核社区将内核3.9中的dm-cache上游和内核3.10中的bcache合并。虽然flashcache未在上游合并，但在某些生产环境中已经使用了一段时间。</p>
<h2 id="dm-cache"><a href="#dm-cache" class="headerlink" title="dm-cache"></a>dm-cache</h2><p>又叫 Device Mapper Cache。dm-cache是设备映射器目标，首先提交到kernel-3.9。它使用针对基于闪存的SSD进行优化的I / O调度和缓存管理技术。设备映射程序目标（dmcache）重新使用精简资源调配库中使用的元数据库。write-back和writethrough都由dm-cache支持，write-back是默认模式。</p>
<p>由dm-cache创建的虚拟缓存设备使用源设备（Origin device）、缓存设备（Cache device）和元数据设备（Metadata dev）这三个物理设备来构建。结构如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/dm-cache.png" alt="dm-cache"></p>
<p>源设备是实际（较慢）目的存储设备。</p>
<p>高速缓存设备是用于临时存储用户数据的较快设备。</p>
<p>元数据设备记录块布局，它们的dirty flags和其他内部数据所需的策略。</p>
<h2 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h2><p>bcache首先提交到kernel-3.10。它围绕基于闪存的SSD的独特特性设计，并使用混合btree/log结构来跟踪缓存的区域。它旨在不惜一切代价（at all cost）避免随机写。 bcache顺序填充一个擦除块，然后在重新使用之前发出一个丢弃（缓存数据可以是桶上的任意一个扇区。bcache最大程度上减少了随机写的代价，它按顺序填充一个桶，重新使用时只需将桶设置为无效）。支持write-through和write-back高速缓存。write-back默认关闭，但可以在运行时任意打开和关闭。</p>
<p>通过后端设备（backing device）和缓存设备（caching device）来创建虚拟的bcache 设备，如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/bcache.png" alt="bcache"></p>
<p>后端设备是实际（较慢）目的存储设备，而高速缓存设备是更快的设备。后备设备必须格式化为bcache 块设备；现有的格式化分区不能与bcache一起使用。（可以尝试 blocks to-bcache进行就地转换）。</p>
<p>默认状态下bcache不缓存顺序IO，只缓存随机读写。为避免随机写，bcache将随机写转换为顺序写，首先写到SSD，然后回写缓存使用SSD缓存大量的写，最后将写有序写到磁盘或者阵列上。</p>
<p>SSD的特点就是随机IO速度很快，而对于大块顺序IO的提升却并不大。bcache会检测顺序IO并忽略；还会对每一个任务记录动态的平均IO大小，当平均IO大小超过截止值时该任务后面的IO将会被忽略，这样就可以透传备份或者大文件拷贝。</p>
<h2 id="Dm-cache-vs-Bcache"><a href="#Dm-cache-vs-Bcache" class="headerlink" title="Dm-cache vs Bcache"></a>Dm-cache vs Bcache</h2><p>与 dm-cache 实现的的分级存储不同，bcache 更像一个传统的缓存。它可以用来存储任何 extents，甚至是是一个扇区，而 dm-cache 只能对整块数据进行缓存。</p>
<p>dm-cache方案假设缓存设备总是存在，bcache 并不要求 cache 设备一直都在。 </p>
<p>bcache 已经在实际产品中使用了，所以它有机会去碰到这些疑难场景，并可以处理这些缓存设备无法工作的情形。</p>
<p>dm-cache 确实还有很多事情要做。起初，它是进行 cache 和原始设备的并行 IO，但最终不得不回到顺序 IO。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Flashcache vs Cache tier]]></title>
      <url>http://xiaqunfeng.github.io/2017/02/03/Flashcache-vs-Cache-tier/</url>
      <content type="html"><![CDATA[<p>使用SSD作为缓存来提高性能有多种方法，文章前言里会介绍，主要有bcache、dm-cache、flashcache、cache tier等，本文比较两种在ceph中的常用方案：flashcache 和 cache tier。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的HDD具备大容量的优势，但是性能相对偏低，尤其是随机IO性能，经常成为系统的性能瓶颈，在虚拟机化环境下表现的更明显，因为虚拟化场景会加剧IO随机化。相比HDD，SSD具有高性能的优势，尤其在随机IO这方面，优势非常明显，但是SSD的硬件成本比较高。</p>
<p>目前业界在结合HDD的大容量和SSD的高性能方面做了一些优化，基本思路是使用SSD作为HDD的cache。计算机领域，cache的思想无处不在，比如CPU的L1、L2 cache，raid card上的cache，TLB cache等。关于SSD作为HDD的cache的优化方案，主要有Linux bcache，Linux dm-cache，Facebook flashcache，btier，IBM flashcache等。</p>
<h2 id="flashcache"><a href="#flashcache" class="headerlink" title="flashcache"></a>flashcache</h2><p>flashcache 是 facebook 开源的 ssd 存储产品，它基于内核的 devicemapper 机制，允许将 ssd 设备映射为机械存储设备的缓存，堆叠成为一个虚拟设备供用户读写，从而在一定程度上兼顾 ssd 的高速与机械存储设备的高容量，更加经济高效地支撑线上业务。</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/flashcache.png" alt="flashcache"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Device Mapper层，对外服务体现方式是块设备，无需修改应用。</p>
<p>确保内核已启用 DeviceMapper，编译内核模块并安装之后：</p>
<ul>
<li>创建缓存设备: flashcache_wt_create /dev/cachedev /dev/sda1 /dev/hda1</li>
<li>删除缓存设备: dmsetup remove cachedev </li>
</ul>
<p>使用者需要注意建立缓存设备之后，就不应该再对 /dev/sda1 和 /dev/hda1 两个设备直接读写了。</p>
<p>用户操作接口是映射之后的虚拟设备，即/dev/mapper/*下面的设备，如cachedev，而不是基设备</p>
<h3 id="缓存的组织"><a href="#缓存的组织" class="headerlink" title="缓存的组织"></a>缓存的组织</h3><p>flashcache是建立在Linux devicemapper之上的，由devicemapper在SSD和backing HDD之上创建了一个逻辑的mapped device，用户使用的就是这个mapped device。</p>
<p>flashcache把cache（SSD）按照哈希的方式进行结构化管理，flashcache 中缓存的盘块的默认大小为 4kb，按照多路组相连的形式组织缓存块，每组含有 512 个缓存块，简单按照取模分组。缓存的查找，就是对后端设备块号取模得到组号，然后凭偏移遍历组中的缓存块。具体管理方式可以参考小结末参考资料。</p>
<p>虽然数据会被写入 ssd 设备，但缓存的组织信息一律保存在内存中，即 cache_c 对象。它里面保存了基本的配置选项、统计信息、对两个设备的引用、每个缓存块的相关信息(cache, cache_state)、 以及缓存组中 FIFO 数组(虽然名字叫做 LRU)的下标。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>flashcache 支持三种缓存策略：</p>
<ul>
<li>writethrough：disk write会在cache中保留一份，但同时也会把数据write到backing disk中，直到write backing disk完成才会返回。</li>
<li>writearound：disk write会bypass cache，直接写到backing disk中，disk read会把从backing disk中读取的数据在cache中缓存。</li>
<li>writeback：write首先会写到cache中，然后更新metadata中得dirty bit，数据并不会立即同步到backing disk中。</li>
</ul>
<p>针对writethrough和writearound，disk read首先根据目的sector找到对应的cache set，然后查找有没有相应的block，如果找到了，也就是cache hit，则直接从cache中读取，如果没有找到，就从backing disk中读取数据，同时也在cache中进行缓存。</p>
<h3 id="数据调度"><a href="#数据调度" class="headerlink" title="数据调度"></a>数据调度</h3><p>DM层request送往flashcache，并将读写请求按照目标设备的blocksize进行划分，切割成blocksize大小的bio。</p>
<p><strong>读</strong></p>
<p>接收到bio，首先，根据bio-&gt;bi_sector，即硬盘的扇区号，得到SSD上的set；</p>
<p>其次，在set内查找是否命中，如果命中，则将硬盘的扇区号转换为SSD的扇区号，然后将此bio向SSD提交，进行读取；</p>
<p>如果未命中，则首先向硬盘驱动提交bio，从硬盘读数据，读取完成后，由回调函数启动回写SSD操作，将bio的扇区号转换为SSD的=扇区号，然后向SSD驱动程序提交，将硬盘读取的数据写入SSD。</p>
<p><strong>写</strong></p>
<p>同文件系统页缓冲，并不直接写入硬盘，而是写入SSD，同时，保持一个阀值，一般为20%，在脏块数目达到此数值时，写回磁盘。</p>
<p>另外：如果<strong>IO size小于blocksize</strong>，flashcache则不会缓存该IO，而是先查找cache中有没有overlap的脏数据：</p>
<p>如果有的话，就先刷脏数据，然后再把刚才从devicemapper传来的IO写到backing disk上</p>
<p>如果没有脏数据，则直接写到backing disk上，这也就是为什么当使用fio测试小于4KB的随机IO时，flashcache几乎没有效果。</p>
<p>部分参考资料：</p>
<p><a href="http://mogu.io/Facebook_flashcache-81" target="_blank" rel="external">Facebook flashcache介绍与使用</a></p>
<p><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/flashcache-introduction?lang=en" target="_blank" rel="external">flashcache 简介</a></p>
<p><a href="http://blog.csdn.net/kidd_3/article/category/905673" target="_blank" rel="external">其他flashcache资料</a></p>
<h2 id="cache-tier"><a href="#cache-tier" class="headerlink" title="cache tier"></a>cache tier</h2><p>缓存分层通过将一部分数据存到缓存层，给ceph客户端提供更好的IO性能。通常是在更快的磁盘上创建存储池，如SSD/NVMe。数据最终被透明的写入常规的存储池中，它们由副本或纠删码类型的存储池所构建。</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/cache%20tier.png" alt="cache tier"></p>
<p>缓存层代理自动处理缓存层和后端存储之间的数据迁移，对客户端透明，管理员可以配置迁移进行的方式。</p>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>缓存分层主要有两种模式：writeback 和 read-only。如果是write-back模式，那么该cache pool 既是read tier ，又是 write tier； 如果只是read only 模式，那么实际上，cache pool 只是 read tier，没有write tier。</p>
<h3 id="writeback模式"><a href="#writeback模式" class="headerlink" title="writeback模式"></a>writeback模式</h3><p>客户端写数据到缓存层后立刻收到确认回复。基于配置的flush/evict策略，数据从缓存层迁移到存储层，最后缓存分层代理从缓存层中将数据删除。</p>
<p>当读操作在缓存中miss的时候</p>
<p>1、返回client结果为cache miss，重新向存储层发起读请求。</p>
<p>2、cache层向存储层发起读请求，返回client的同时缓存一份在cache层</p>
<p>写操作在缓存中miss的时候</p>
<p>直接向存储层写，然后逐级返回，并不将数据缓存在cache层</p>
<p>这种模式适合大量修改数据的场景。</p>
<h3 id="read-only模式"><a href="#read-only模式" class="headerlink" title="read-only模式"></a>read-only模式</h3><p>缓存层只服务于客户端的读操作。当读请求在缓存层中miss的时候，从存储层中读上来，并设置一个expire时间，过期自动被删除。cache层可以设置为单副本，极大减少缓存空间占用率。写操作直接写到后端的存储层。</p>
<p>这种模式适合一次写入多次读取的场景。</p>
<h2 id="Flashcache-vs-Cache-tier"><a href="#Flashcache-vs-Cache-tier" class="headerlink" title="Flashcache vs Cache tier"></a>Flashcache vs Cache tier</h2><p>flashcache将缓存在块层的东西，而缓存池将缓存对象层的东西。 在每种情况下都有潜在的优点和缺点。 一些初始猜测：</p>
<p><strong>flashcache</strong></p>
<ul>
<li>[x] 所有缓存对一个节点是本地的，更少的开销（包括网络）。</li>
<li>[x] 在许多对象访问和大量热的inodes / dentries的情况下可以做得更好</li>
<li>无法仅为高速缓存定义不同的 副本/ EC 策略。</li>
<li>缓存写入是非原子的</li>
</ul>
<p><strong>Ceph cache tier</strong></p>
<ul>
<li>[x] 潜在可以做的事情，如副本缓存和EC存冷数据。</li>
<li>[x] 更安全</li>
<li>更多的网络开销，可能会有更多的CPU开销。</li>
<li>需要更长的时间才能将内容缓存</li>
</ul>
<p>参考资料：<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2014-March/037861.html" target="_blank" rel="external"> OSD + FlashCache vs. Cache Pool for RBD</a></p>
<p><strong>关于成本</strong></p>
<p>高速缓存中的数据总是硬盘驱动器上的数据的第二个副本。 缓存的故障很少产生数据丢失，只是性能损失，因为一切都需要从机械驱动器提供，直到缓存可以被替换。</p>
<p> SSD层可能是自动分层系统中唯一的数据副本，不能容忍SSD层的故障，因此这些系统必须通过使用类似RAID的数据保护方案在冗余配置中设置SSD层。 不得不购买额外的SSD来支持类似RAID的功能，使已经高价的技术更加昂贵。</p>
<p><strong>关于读</strong></p>
<p>在大多数情况下，两个选项之间的read 性能应该大致相同。 大多数情况下，read 性能的效率将取决于缓存设备提升数据的效率和可定制性。 目标应该是确保正确的数据在正确的时间存在缓存中。缓存和自动分层需要在关于他们缓存什么和什么时候缓存需要变得更加聪明。</p>
<p><strong>终上所述</strong></p>
<p>从用户的角度来看，如果适当的冗余存在，缓存或分层没有显着的优势，因此不应该单独选择基于闪存的存储系统。 IT规划人员可能想要调查其他因素，例如将某些数据集固定到闪存层或缓存区，以及与环境或应用程序集成的能力。</p>
<p>参考资料：（这两篇文章是同一个作者）</p>
<p><a href="http://www.networkcomputing.com/storage/ssd-options-tier-vs-cache/1267262167" target="_blank" rel="external">SSD Options: Tier Vs. Cache</a></p>
<p><a href="http://searchsolidstatestorage.techtarget.com/tip/Tiering-vs-caching-in-flash-based-storage-systems" target="_blank" rel="external">Tiering vs. caching in flash-based storage systems</a></p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 

]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——parted]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/25/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94parted/</url>
      <content type="html"><![CDATA[<p>一直用parted命令来进行磁盘分区，这里学习一下总结一下。顺带对比一下MBR和GPT两种分区表，以及parted命令和fdisk命令的区别。<br><a id="more"></a></p>
<h2 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h2><p>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区（包含随意数目的逻辑分区）。</p>
<p>GPT：GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。GPT的分区信息是在分区中，而MBR在主引导扇区。</p>
<p>与MBR分区方式相比，具有如下优点：</p>
<ul>
<li>突破MBR 4个主分区限制，每个磁盘最多支持128个主分区。</li>
<li>支持大于2T的分区，最大卷可达18EB。</li>
</ul>
<h2 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h2><ul>
<li><strong>主分区</strong>又叫主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘。一个硬盘的主分区也就是包含操作系统启动所必需的文件和数据的硬盘分区，要在硬盘上安装操作系统，则该硬盘必须得有一个主分区。</li>
<li><strong>扩展分区</strong>不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。</li>
<li><strong>逻辑分区</strong>也相当于一个逻辑磁盘，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中。</li>
</ul>
<p>MBR模式分区只能划分四个分区，现在GPT分区至少可以划分128个主分区，未来很有可能将不存在扩展分区和逻辑分区的概念。</p>
<h2 id="parted和fdisk"><a href="#parted和fdisk" class="headerlink" title="parted和fdisk"></a>parted和fdisk</h2><p>parted命令可以划分单个分区大于2T的GPT格式的分区，也可以划分普通的MBR分区，并且允许调整分区的大小。</p>
<p>fdisk命令对于大于2T的分区无法划分，所以用fdisk无法看到parted划分的GPT格式的分区。</p>
<p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p>
<h2 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h2><p>Parted 命令分为两种模式：命令行模式和交互模式</p>
<p> 1、命令行模式：<code>parted [option] device [command]</code> ，该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用，比如利用脚本批量执行命令。</p>
<p> 2、交互模式：<code>parted [option] device</code>类似于使用<code>fdisk /dev/xxx</code>，这种适合当个操作。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><h4 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<p>parted有个不提示用户参数选项，就是通过这个选项来实现非交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-s, --script</div><div class="line">              never prompts for user intervention</div></pre></td></tr></table></figure>
<h4 id="2、添加分区"><a href="#2、添加分区" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb mklabel gpt			# 定义分区表格式</div><div class="line"># parted -s /dev/vdb mkpart primary ext4 1 10G		# 划分主分区</div><div class="line"># parted -s /dev/vdb mkpart logic 10G 20G		# 划分逻辑分区</div><div class="line"># parted -s /dev/vdb mkpart logic ext3 20G 40G</div><div class="line"># parted -s /dev/vdb mkpart entended 40G 100%		# 划分扩展分区，100%表示使用剩余所有空间</div><div class="line"></div><div class="line"># parted -s /dev/vdb p					# 查看分区详情</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          logic</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div><div class="line"> 4      40.0GB  107GB   67.4GB               entended</div></pre></td></tr></table></figure>
<p>查看分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">├─vdb2 253:18   0   9.3G  0 part </div><div class="line">├─vdb3 253:19   0  18.6G  0 part </div><div class="line">└─vdb4 253:18   0  62.8G  0 part</div></pre></td></tr></table></figure>
<h4 id="3、删除分区"><a href="#3、删除分区" class="headerlink" title="3、删除分区"></a>3、删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb rm 2</div><div class="line"></div><div class="line"># parted -s /dev/vdb p</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div></pre></td></tr></table></figure>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h4 id="1、初始状态-1"><a href="#1、初始状态-1" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<h4 id="2、添加分区-1"><a href="#2、添加分区-1" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><p>针对盘 vdb 开始分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># parted /dev/vdb</div><div class="line">GNU Parted 2.3</div><div class="line">Using /dev/vdb</div><div class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</div><div class="line">(parted)mklabel gpt 				# 定义分区表格式</div><div class="line">...</div><div class="line">(parted) mkpart p1      			# 创建第一个分区，名称为p1                                                  </div><div class="line">File system type?  [ext2]? ext4     		# 定义分区格式                                      </div><div class="line">Start? 1 					# 定义分区的起始位置（单位支持K,M,G,T）                                                              </div><div class="line">End? 10G      					# 定义分区的结束为止(单位支持K,M,G,T)                                                            </div><div class="line">(parted) print     				# 查看当前分区情况                                                       </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"></div><div class="line">(parted) mkpart part2                                                    </div><div class="line">File system type?  [ext2]? ext3                                           </div><div class="line">Start? 10G                                                                </div><div class="line">End? 20G                                                                  </div><div class="line">(parted) p					# print可以简写成“p“                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB               part2</div><div class="line"></div><div class="line">(parted) quit					# 退出。quit可以简写为”q“ </div><div class="line">Information: You may need to update /etc/fstab.</div></pre></td></tr></table></figure>
<h4 id="3、设置文件系统"><a href="#3、设置文件系统" class="headerlink" title="3、设置文件系统"></a>3、设置文件系统</h4><p>不知道为啥，print的时候不现实文件系统格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># mkfs.ext4 /dev/vdb1</div><div class="line"># mkfs.xfs /dev/vdb2</div></pre></td></tr></table></figure>
<p>再查看文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(parted) print                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          part2</div></pre></td></tr></table></figure>
<p>发现分区的 File system 变成了 ext4 和 xfs。所以，还是通过命令的方式来定义文件系统格式。</p>
<p>查看一下分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">└─vdb2 253:18   0   9.3G  0 part</div></pre></td></tr></table></figure>
<h4 id="4、删除分区"><a href="#4、删除分区" class="headerlink" title="4、删除分区"></a>4、删除分区</h4><p>删除分区 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(parted) rm                                                             </div><div class="line">Partition number? 2  </div><div class="line"></div><div class="line"># 或者直接</div><div class="line">(parted) rm 2    </div><div class="line"></div><div class="line">(parted) print</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div></pre></td></tr></table></figure>
<h4 id="5、修改分区大小"><a href="#5、修改分区大小" class="headerlink" title="5、修改分区大小"></a>5、修改分区大小</h4><p>暂时不支持改变分区的大小（resize操作），针对有无文件系统报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># none</div><div class="line">Error: Could not detect file system.  </div><div class="line"></div><div class="line"># ext4，ext3</div><div class="line">Error: File system has an incompatible feature enabled.  Compatible       </div><div class="line">features are has_journal, dir_index, filetype, sparse_super and large_file.</div><div class="line">Use tune2fs or debugfs to remove features.</div><div class="line"></div><div class="line"># xfs</div><div class="line">No Implementation: Support for opening xfs file systems is not implemented</div><div class="line">yet.</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[认识SSD]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/25/%E8%AE%A4%E8%AF%86SSD/</url>
      <content type="html"><![CDATA[<p>SSD越来越火，性能提升比较快，成本也有所下降，是未来的方向和主流，这里认识和学习一下SSD相关知识，以便更好的理解和应用SSD的特性。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>固态硬盘（Solid State Disk）用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。<br>一块SSD，<strong>核心部件</strong>是一颗控制器和多颗Flash颗粒，一般还会有一些内存和超级电容。</p>
<pre><code>--&gt;控制器主要作用是提供高效的手段来访问这些Flash颗粒。
--&gt;内存的作用主要是表项管理和读写CACHE。
--&gt;超级电容的作用是在异常下电时保证关键数据不丢失。
</code></pre><p>而<strong>Flash颗粒</strong>是SSD最重要的器件，其相关特性决定了SSD的实现方式。</p>
<h2 id="FLASH颗粒"><a href="#FLASH颗粒" class="headerlink" title="FLASH颗粒"></a>FLASH颗粒</h2><h3 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h3><blockquote>
<p>闪存是一种不挥发性（ Non-Volatile ）内存，在没有电流供应的条件下也能够长久地保持数据，其存储特性相当于硬盘，这项特性正是闪存得以成为各类便携型数字设备的存储介质的基础。</p>
</blockquote>
<p>Flash颗粒是SSD最重要的器件，其相关特性决定了SSD的实现方式。目前业界主要有两种类型的Flash技术：NOR（Intel开发）和NAND（东芝开发）。由于这两种技术在如下方面的一些差异：</p>
<pre><code>--&gt;NOR的读取速度略快于NAND；
--&gt;NOR的写入速度远低于NAND；
--&gt;NOR的擦除速度远低于NAND；
--&gt;的擦写次数约为NAND的1/10；
--&gt;的单元尺寸约为NAND的2倍；
</code></pre><p>导致1~16M的闪存市场主要采用NOR颗粒（主要用于保存嵌入式设备的程序），而<strong>更大容量的数据存储（例如SSD）则主要选择NAND颗粒</strong>。</p>
<h3 id="SLC和MLC"><a href="#SLC和MLC" class="headerlink" title="SLC和MLC"></a>SLC和MLC</h3><p>NAND FLASH芯片，flash颗粒有两种类型：SLC和MLC</p>
<p>SLC：Single Level Cell，每个存储单元均只能存储1个bit的数据。只包含0和1两个电压符。<br>MLC：Multi Level Cell，每个存储单元能够存储2个bit或者更多bit的数据。包含四个电压符（00,01,10,11）。</p>
<p><strong>SLC和MLC的比较：</strong><br>MLC容量比SLC大，且价格便宜。<br>但在性能、使用寿命和稳定性上：<br>1、SLC更简单可靠；<br>2、SLC读取和写入的速度都比MLC更快；<br>3、SLC比MLC更耐用，MLC每单元可擦除1w次，而SLC可擦除10w次。</p>
<p>一般而言，<strong>SLC主要用于企业级市场</strong>，MLC主要用于消费级市场。下表显示了SLC和MLC两种Flash颗粒的一些性能指标：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>SLC</th>
<th>MLC</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机读</td>
<td>25us</td>
<td>50us</td>
</tr>
<tr>
<td>擦除</td>
<td>2ms</td>
<td>2ms</td>
</tr>
<tr>
<td>编程</td>
<td>250us</td>
<td>900us</td>
</tr>
<tr>
<td>擦除次数</td>
<td>100k</td>
<td>10k</td>
</tr>
</tbody>
</table>
<h2 id="SSD的内部逻辑划分"><a href="#SSD的内部逻辑划分" class="headerlink" title="SSD的内部逻辑划分"></a>SSD的内部逻辑划分</h2><p>一颗NAND Flash颗粒，其内部被划分为若干block，每个block又包含若干page。page的大小一般为2k/4k/8k（同一颗Flash颗粒内的page大小是固定且相同的）。</p>
<p>Flash的一个特点是：不能对任意bit位进行0/1互转，只能按照一定的颗粒度进行擦除和编程操作；</p>
<pre><code>--&gt;擦除 —— 颗粒度为block，是将指定block中所有的bit位全部设置为1；
--&gt;编程 —— 颗粒度为page，是将指定page中指定的bit位设置为0；
</code></pre><p>因此，对SSD进行写的操作实际上对需要写的Page所在的Block全部完成“擦除”(全部bit位置1)后，才能对指定的Page进行“编程”(部分bit位置0)。PS：实际上SSD硬盘在出厂时，厂商都会把所有Block完成擦除操作。</p>
<h2 id="SSD的表项管理"><a href="#SSD的表项管理" class="headerlink" title="SSD的表项管理"></a>SSD的表项管理</h2><p>  每一个IO读写都是下发给一个地址，这个地址称为LBA(Logic Block Address)，其真正对应在磁盘上的地址称为PBA(Physical Block Address)，和传统机械硬盘中LBA到PBA的映射通过磁轨、磁道、扇区来进行唯一对应不同的是，<strong>SSD的LBA到PBA</strong>的映射通过一张<strong>映射表</strong>来记录。<br>&emsp;&emsp;LBA的粒度是扇区，而Flash颗粒的擦粒度是block，写粒度是page，均为扇区的若干倍，在这种条件下，如果仍以扇区为粒度进行映射，虽然理论上可行，但是显然是增加实现难度和性能的.<br>&emsp;&emsp;同时，如果强制以扇区为粒度进行映射，会导致所需要的映射表空间超过物理内存的限制，这就直接决定了不可能以扇区为粒度进行映射。<br>&emsp;&emsp;即使以page为粒度进行映射，也可能存在物理内存不够用的情况（现在正在使用的SSD盘即属于这种情况），所以需要以更大一些的粒度进行管理。<br>&emsp;&emsp;这个粒度成为”<strong>小块(Sub Block)</strong>“,是SSD进行擦除和编程的最小单位。每个block中，均包含多个sub block；每个sub block，由多个page组成；每个sub block，可能的状态包括：有效、垃圾、空白：</p>
<pre><code>--&gt;有效：该小块中的数据正在被引用；
--&gt;垃圾：该小块中的数据没有被引用；
--&gt;空白：该小块可用于写入新的数据；
</code></pre><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>&emsp;&emsp;SSD的写要先进行整个Block的擦除，然后才能对指定的Sub Block进行编程。实际上，如果某一个写操作需要修改一个Sub Block的内容，是无法直接进行修改的，而是写到一个新的Sub Block中，把该LBA的映射指向新的这个Sub Block，同时把原来数据所在的Sub Block标记为“垃圾”。<br>  这样，随着SSD使用时间的越来越长，新的未被编程过的Sub Block越来越少，后面新的写请求则只能重新擦除所有Sub Block均为垃圾的Block才能再次写入，这样必然会造成写操作的性能降低，因此，在SSD内部引入了一个重要的机制——垃圾回收（Garbage Collection），用以提升SSD长期写入操作的性能。</p>
<p><strong>垃圾回收的工作：</strong></p>
<pre><code>--&gt;找出合适的block
--&gt;将该block中的有效小块迁移到别的地方，同时更改映射表
--&gt;将该block擦除，并放入空白块表
</code></pre><p>&emsp;&emsp;所谓“最合适进行回收的block”，是指这个block的垃圾小块足够多、有效/空白小块足够少。<br>&emsp;&emsp;垃圾回收算法是否高效，与该SSD的性能有很强的联系。</p>
<h2 id="SSD的磨损均衡"><a href="#SSD的磨损均衡" class="headerlink" title="SSD的磨损均衡"></a>SSD的磨损均衡</h2><p>  上面说过，每个Flash颗粒中Block的可擦除次数是有限制的，如果颗粒中的某些Block很快达到了擦除次数上限，而其他大部分都几乎没有被擦除过，则会很快的造成整个SSD失效。而磨损均衡（Wear Leveling）则是通过各种手段，保证整个SSD所有的block的擦除次数是相近的从而延长SSD的使用寿命。</p>
<p>磨损均衡分为  <strong>动态磨损均衡</strong>  和  <strong>静态磨损均衡</strong>：</p>
<blockquote>
<p>动态磨损均衡，是指在外部力量的驱动下，自然完成磨损均衡。这里外部力量，包括写IO和垃圾回收。<br>静态磨损均衡，是指磨损均衡功能模块主动地查找那些长时间没有变化的数据，将这些数据搬移到其他位置，以便释放出擦除次数较少的block，使其投入到擦除/编程的循环之中。</p>
</blockquote>
<h2 id="SSD使用寿命计算举例"><a href="#SSD使用寿命计算举例" class="headerlink" title="SSD使用寿命计算举例"></a>SSD使用寿命计算举例</h2><p>&emsp;&emsp;虽然一个block擦写次数只有100k（SLC），但是因为动态映射、磨损均衡等机制的存在，使得SSD的寿命远不止写入100k个IO。<br>计算SSD寿命的方式，一般是先确认一个block在其生命周期内能够写入多少数据量，再乘以该SSD具有的block数量，再除以一个估计的写入带宽，最后得到寿命值。<br>&emsp;&emsp;以我司（<strong>你们猜o(^▽^)o</strong>）自研的100G SLC SSD为例，16片Flash颗粒，每片颗粒拥有32k个block，每个block拥有64个4k的page，每个block可以被擦除100k次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">16 x (32 x 1024) x 64 x (4 x 1024) x 100000 = 12500 TB</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;12500 TB，这是当所有block同时达到擦除次数上限时，可以写入的数据总量。<br>按照用户平均每秒钟写入10MB的数据进行计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(12500 x 1024 x 1024) / (10 x 60 x 60 x 24 x 365.25) = 41.5 年</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;41.5年，这是在10MB/s的压力下、持续不断地向SSD写入数据的使用寿命。<br>&emsp;&emsp;考虑到其他一些因素的影响，一块SLC SSD的使用寿命，10年是可以保证的。</p>
<h2 id="SSD和传统磁盘的对比"><a href="#SSD和传统磁盘的对比" class="headerlink" title="SSD和传统磁盘的对比"></a>SSD和传统磁盘的对比</h2><p>&emsp;&emsp;SSD与传统磁盘相比:<br>&emsp;&emsp;第一是没有机械装置;<br>&emsp;&emsp;第二是由磁介质改为了电介质。<br>&emsp;&emsp;在SSD内部有一个FTL(Flash Transalation Layer)，它相当于磁盘中的控制器，主要功能就是作地址映射，将flash memory的物理地址映射为磁盘的LBA逻辑地址，并提供给OS作透明访问。</p>
<h3 id="读方面"><a href="#读方面" class="headerlink" title="读方面"></a>读方面</h3><p><strong>随机读</strong><br>  SSD没有传统磁盘的寻道时间和延迟时间，所以SSD可以提供非常高的随机读取能力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<p><strong>连续读</strong><br>  SSD连续读的能力相比普通磁盘优势并不明显。传统磁盘连续读，并不需要寻道时间：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<h3 id="写方面"><a href="#写方面" class="headerlink" title="写方面"></a>写方面</h3><p>  Page为最小的读写单位，Block为最小的擦除/编程单位，其中1个Page为4KB，1个Block由256个Page组成，1个Plane由2048个Block组成，2个Plane组成1个Die，也就是最小的芯片(4GB)</p>
<p>&emsp;&emsp;向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元（page）的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入。SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。因为这个特性，引入<strong>“写放大”</strong>的概念。</p>
<p>&emsp;&emsp;比如你想改写4K的数据，必须首先将整个擦除块（1024KB）中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了1024KB的数据，写入放大系数是256。写入放大最好的情况是1，就是不存在放大的情况。</p>
<p>&emsp;&emsp;在<strong>长时间写入</strong>后，MLC随机写IO下降得非常厉害，而<strong>SLC表现则比较稳定</strong>，可以稳定在3000 IOPS，而MLC随机写IOPS甚至降低到300。</p>
<p>&emsp;&emsp;当某个单元长时间被反复擦写时（比如Oracle redo），不仅会造成写入的性能问题，而且会大大缩短SSD的使用寿命。所以，引入磨损均衡算法（wear leveling）。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力<br>！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ceph — V11.2.0 KRAKEN(译)]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/24/Ceph-KRAKEN(V11.2.0)/</url>
      <content type="html"><![CDATA[<p>ceph的版本出到K了，针对bluestore又有了新的优化，并进行了一定的压力和故障测试，当然还有其他的特性，针对Jewel版本有较多改动。当前还没有什么中文资料，<a href="http://docs.ceph.org.cn/" target="_blank" rel="external">ceph中文社区</a>中关于V11.2.0还没有更新进去，所以闲暇之余翻译了一下，也给大家节省时间。<br><a id="more"></a></p>
<p>英文原文链接：<a href="http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken" target="_blank" rel="external">http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken</a></p>
<h2 id="V11-2-0-KRAKEN"><a href="#V11-2-0-KRAKEN" class="headerlink" title="V11.2.0 KRAKEN"></a>V11.2.0 KRAKEN</h2><p>这是Kraken系列的第一个release版本。它适用于生产部署，并将维护到下一个稳定的版本Luminous，将在2017年春季完成。</p>
<h2 id="对比JEWEL版本的主要变化"><a href="#对比JEWEL版本的主要变化" class="headerlink" title="对比JEWEL版本的主要变化"></a>对比JEWEL版本的主要变化</h2><h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><ul>
<li>新的BlueStore 后端现在有一个稳定的磁盘格式，并通过了我们的故障和压力测试。尽管该后端仍被标记为实验性的，但我们鼓励用户使用非生产集群和非关键数据集进行尝试。</li>
<li>RADOS现在已经对EC-pool上的覆盖写（overwrites）进行了实验性支持。因为磁盘格式和实现尚未完成，所以必须启用特殊pool选项才能测试新功能。在群集上启用此选项将永久禁止该群集升级到将来的版本。</li>
<li>我们现在默认使用AsyncMessenger（ms type = async）而不是传统的SimpleMessenger。最明显的区别是，我们现在使用固定大小的线程池用于网络连接（而不是使用SimpleMessenger的每个套接字两个线程）。</li>
<li>现在一些OSD的故障几乎可以立即检测到，而先前心跳超时（默认为20秒）必须到期。这可以防止IO在主机保持启动但ceph-osd进程不再运行的故障情况下长时间阻塞。</li>
<li>有一个新的ceph-mgr守护进程。它目前与默认监视器并置，并且尚未使用太多，但基本的基础设施现在已到位。</li>
<li>减少了编码OSDMaps的大小。</li>
<li>当恢复（recovery）或重新平衡（rebalanceing）正在进行时，OSD现在停止擦除（scrubbing）。</li>
</ul>
<h3 id="RGW"><a href="#RGW" class="headerlink" title="RGW"></a>RGW</h3><ul>
<li>RGW现在支持一种新的区域类型，可用于通过ElasticSearch进行元数据索引。</li>
<li>RGW现在支持S3复合对象复制部分API。</li>
<li>现在可以重新分割现有的桶。注意，桶重新分片目前需要停止对特定桶的所有IO（特别是写）。</li>
<li>RGW现在支持对象的数据压缩。</li>
<li>Civetweb版本已经升级到1.8。</li>
<li>现在支持Swift静态网站API（以前已经添加了S3支持）。</li>
<li>S3桶生命周期API已添加。注意，目前它只支持对象到期。</li>
<li>支持自定义搜索过滤器已添加到LDAP身份验证实现中。</li>
<li>支持NFS版本3已添加到RGW NFS网关。</li>
<li>为librgw创建了一个Python绑定。</li>
</ul>
<h3 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h3><ul>
<li>RBD现在支持使用新的(实验)覆盖写(overwrite)支持在 EC RADOS pool 中存储images。必须使用新的rbd CLI <code>“-data-pool &lt;ec pool&gt;”</code> 选项来创建images，用以指定EC池存储后端数据对象。尝试在EC池上直接创建image不会成功，因为image的后端元数据仅在副本池上被支持。</li>
<li>rbd-mirror守护进程现在支持从主image复制动态image特征更新和image元数据key/value对到非主image。</li>
<li>image快照的数量可以选择性地限制为可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<h3 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h3><ul>
<li>libcephfs函数的定义已更改为启用适当的uid / gid控制。库版本已增加以反映接口更改。</li>
<li>备用的回放(replay)MDS守护程序现在在执行删除操作的工作负载上消耗更少的内存。</li>
<li>Scrub现在修复backtrace，并用已发现的错误填充损坏ls。</li>
<li>cephfs-data-scan的新的pg_files子命令可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性“未能响应缓存压力”警告已修复。</li>
</ul>
<h2 id="UPGRADING-FROM-JEWEL"><a href="#UPGRADING-FROM-JEWEL" class="headerlink" title="UPGRADING FROM JEWEL"></a>UPGRADING FROM JEWEL</h2><ul>
<li>所有集群必须首先升级到 Jewel 10.2.z，然后升级到 Kraken 11.2.z（或者，最终，Luminous 12.2.z）。</li>
<li>升级到Kraken之前，必须在Jewel集群上设置sortbitwise标志。如果未设置标志，则最新的Jewel（10.2.4+）版本会发出健康警告，因此可能已设置。如果不是，Kraken OSDs将拒绝启动，并将在其日志中打印和错误消息。</li>
<li>您可以按任意顺序升级OSD，监视器和MDS。 RGW守护进程应该最后升级。</li>
<li>升级时，新的ceph-mgr守护进程实例将自动被创建，与任何监视器一起。在Jewel到Kraken和Jewel到Luminous的升级中这将是事实，但在未来高于Luminous版本的升级中可能不是这样。如果你不与他们共置ceph-mon守护进程的话，你当然可以自由创建新的ceph-mgr守护进程实例，并销毁自动创建的实例。</li>
</ul>
<h2 id="BLUESTORE"><a href="#BLUESTORE" class="headerlink" title="BLUESTORE"></a>BLUESTORE</h2><p>BlueStore是一个新的后端，用于管理直接硬盘或SSD上每个OSD存储的数据。与现有的FileStore实现（它利用XFS文件系统将对象存储为文件）不同，BlueStore直接管理底层块设备。实现它自己的文件系统类磁盘结构，专为Ceph OSD工作负载而设计。 BlueStore的主要特点包括：</p>
<ul>
<li>默认情况下启用写入磁盘的所有数据的校验和，所有读取的校验和验证。</li>
<li>内联压缩支持，可以分别通过池属性或客户端提示在每个池或每个对象的基础上启用。</li>
<li>高效日记。与将所有数据写入其日志设备的FileStore不同，BlueStore仅记录元数据和（在某些情况下）小型写入，从而减少其日志的大小和吞吐量要求。与文件存储一样，日志可以与其他数据共存在同一设备上，或者分配在较小的高性能设备（例如，SSD或NVMe设备）上。 BlueStore日志默认只有512 MB。</li>
</ul>
<p>BlueStore磁盘格式预计将继续发展。但是，我们将在OSD中提供支持，以便在升级时迁移到新格式。</p>
<p>为了启用BlueStore，将以下内容添加到ceph.conf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable experimental unrecoverable data corrupting features = bluestore</div></pre></td></tr></table></figure>
<p>要创建一个BlueStore OSD，在OSD创建期间将-bluestore选项传递给ceph-disk或ceph-deploy。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Crushmap学习]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/24/Crushmap%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>介绍了ceph中crush的优点、原理及作用，同时dump出自己的crushmap内容，进行详细的分解学习。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着大规模分布式存储系统的出现。这些系统必须平衡的分布数据和负载，最大化系统的性能，并要处理系统的扩展和硬件失效。但是简单HASH分布不能有效处理设备数量的变化，导致大量数据迁移。ceph设计了CRUSH，用在分布式对象存储系统上，可以有效映射数据对象到存储设备上(不需要中心设备)。因为大型系统的结构式动态变化的，CRUSH能够处理存储设备的添加和移除，并最小化由于存储设备的的添加和移动而导致的数据迁移。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CRUSH算法，全称 Controlled Replication Under Scalable Hashing。它是一种伪随机的算法，在相同的环境下，它能够在层级结构的存储集群中有效的分布对象的副本。</p>
<p>CRUSH实现了一种伪随机(确定性)的函数，它的参数是object id或object group id，并返回一组存储设备(用于保存object副本)。相似的输入得到的结果之间没有相关性，相同的输入得到的结果是确定的。</p>
<p>CRUSH需要cluster map(描述存储集群的层级结构)、和副本分布策略(rule)就可以根据一个整型的输入得到存放数据的一个设备列表。</p>
<p>CRUSH有两个关键优点：</p>
<ul>
<li>任何组件都可以独立计算出每个object所在的位置(去中心化)。</li>
<li>只需要很少的元数据(cluster map)，只要当删除添加设备时，这些元数据才需要改变。</li>
</ul>
<h2 id="crush的作用"><a href="#crush的作用" class="headerlink" title="crush的作用"></a>crush的作用</h2><p>传统存储的架构体系需要一个MDC（meta data controll），ceph不使用这种架构，而是通过引入CRUSH算法，将数据分布的查询操作变成了计算操作，并且是在client端完成。同时，Crush算法还有效缓解了普通hash算法在处理存储设备增删时带来的数据迁移问题。</p>
<p>ceph允许客户端直接访问OSD守护进程，从而消除集中式查询元数据中心的需求。ceph使用一个monitor集群来保证系统的高可用性。同时采用crush算法来实现去中心化，使用crush算法后，客户端根据需要来计算数据被写到哪里，以及从哪读数据。</p>
<p><strong>ceph集群的一个写操作流程</strong></p>
<p>1、client首先访问ceph monitor获取cluster map的一份副本，共五个map（monitor map，OSD map，MDS map，CRUSH map，PG map），知晓集群的状态和配置；</p>
<p>2、数据被转化为一个或多个对象，每个对象都具有对象名称和存储池名称；</p>
<p>3、以PG数为基数做hash，将对象映射到一个PG钟；</p>
<p>4、根据计算出的PG，再通过CRUSH算法得到存放数据的一组OSD位置（副本个数），第一个是主，后面是从；</p>
<p>5、客户端获得OSD ID，直接和这些OSD通信并存放数据。</p>
<p><strong>注</strong>：所有的这些操作都是在<strong>客户端</strong>完成的，不会影响ceph集群服务器端的性能。</p>
<p><strong>一句话描述</strong></p>
<p>说了半天，一句话说明CRUSH的作用，就是——<strong>根据PG ID得到一个OSD列表</strong>。</p>
<h2 id="crush的工作形式"><a href="#crush的工作形式" class="headerlink" title="crush的工作形式"></a>crush的工作形式</h2><p>CRUSH是基于一张描述当前集群资源状态的map（Crush map）按照一定的规则（rules）得到这个OSD列表的。Ceph将系统的所有硬件资源描述成一个树状结构，然后再基于这个结构按照一定的容错规则生成一个逻辑上的树形结构作为Crush map。数的叶子节点是OSD。</p>
<h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><p>三个节点（ceph1，ceph2，ceph3），每个节点三个OSD，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME      UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 1.36345 root default                                     </div><div class="line">-2 0.45448     host ceph1                                   </div><div class="line"> 0 0.09090         osd.0       up  1.00000          1.00000 </div><div class="line"> 1 0.18179         osd.1       up  1.00000          1.00000 </div><div class="line"> 2 0.18179         osd.2       up  1.00000          1.00000 </div><div class="line">-3 0.45448     host ceph2                                   </div><div class="line"> 3 0.09090         osd.3       up  1.00000          1.00000 </div><div class="line"> 4 0.18179         osd.4       up  1.00000          1.00000 </div><div class="line"> 5 0.18179         osd.5       up  1.00000          1.00000 </div><div class="line">-4 0.45448     host ceph3                                   </div><div class="line"> 6 0.09090         osd.6       up  1.00000          1.00000 </div><div class="line"> 7 0.18179         osd.7       up  1.00000          1.00000 </div><div class="line"> 8 0.18179         osd.8       up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="crushmap内容"><a href="#crushmap内容" class="headerlink" title="crushmap内容"></a>crushmap内容</h3><p>来看一下crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"># begin crush map</div><div class="line">tunable choose_local_tries 0</div><div class="line">tunable choose_local_fallback_tries 0</div><div class="line">tunable choose_total_tries 50</div><div class="line">tunable chooseleaf_descend_once 1</div><div class="line">tunable chooseleaf_vary_r 1</div><div class="line">tunable straw_calc_version 1</div><div class="line"></div><div class="line"># devices</div><div class="line">device 0 osd.0</div><div class="line">device 1 osd.1</div><div class="line">device 2 osd.2</div><div class="line">device 3 osd.3</div><div class="line">device 4 osd.4</div><div class="line">device 5 osd.5</div><div class="line">device 6 osd.6</div><div class="line">device 7 osd.7</div><div class="line">device 8 osd.8</div><div class="line"></div><div class="line"># types</div><div class="line">type 0 osd</div><div class="line">type 1 host</div><div class="line">type 2 chassis</div><div class="line">type 3 rack</div><div class="line">type 4 row</div><div class="line">type 5 pdu</div><div class="line">type 6 pod</div><div class="line">type 7 room</div><div class="line">type 8 datacenter</div><div class="line">type 9 region</div><div class="line">type 10 root</div><div class="line"></div><div class="line"># buckets</div><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph2 &#123;</div><div class="line">	id -3		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.3 weight 0.091</div><div class="line">	item osd.4 weight 0.182</div><div class="line">	item osd.5 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph3 &#123;</div><div class="line">	id -4		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.6 weight 0.091</div><div class="line">	item osd.7 weight 0.182</div><div class="line">	item osd.8 weight 0.182</div><div class="line">&#125;</div><div class="line">root default &#123;</div><div class="line">	id -1		# do not change unnecessarily</div><div class="line">	# weight 1.363</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item ceph1 weight 0.454</div><div class="line">	item ceph2 weight 0.454</div><div class="line">	item ceph3 weight 0.454</div><div class="line">&#125;</div><div class="line"></div><div class="line"># rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line"># end crush map</div></pre></td></tr></table></figure>
<h3 id="begin-crush-map"><a href="#begin-crush-map" class="headerlink" title="begin crush map"></a>begin crush map</h3><p>配置参数</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>列出集群的OSD设备</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p>表示buckets的类型 <img src="http://ojet8bprn.bkt.clouddn.com/osdmap.png" alt="osdmap"></p>
<h3 id="Buckets"><a href="#Buckets" class="headerlink" title="Buckets"></a>Buckets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的定义是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[bucket-type] [bucket-name] &#123;</div><div class="line">  	id 		[a unique negative numeric ID]</div><div class="line">  	weight	[the relative capacity the item]</div><div class="line">  	alg		[the bucket type: uniform | list | tree | straw | straw2]</div><div class="line">  	hash	[the hash type: 0 by default]</div><div class="line">  	item	[item-name]		weight		[weight]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bucket-type: bucket的类型，用来指定OSD在CRUSH分层结构中的位置</p>
<p>bucket-name：唯一的bucket名称</p>
<p>id：唯一的ID，用一个负整数表示</p>
<p>weight：OSD的权重，权重越高，说明它的物理存储容量越大。建议1TB存储设备的权重为1.00，500G的权重为0.50。当然这是一个相对值。</p>
<p>alg：bucket类型的算法选择</p>
<blockquote>
<p>见最后bucket的类型</p>
</blockquote>
<p>hash：每个bucket都具有hash算法。目前ceph支持jrenkins1算法，默认hash设置为0使用该算法。</p>
<p>item：bucket里包含的元素，即叶子bucket，及其权重。这里bucket为host，叶子为OSD。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rule [rulename] &#123;</div><div class="line">  	ruleset		[ruleset]</div><div class="line">  	type		[replicated | erasure]</div><div class="line">  	min_size	[min-size]</div><div class="line">  	max_size	[max-size]</div><div class="line">  	step take	[bucket-type]</div><div class="line">  	step		[choose | chooseleaf]	firstn	[num]	type	[bucket-type]</div><div class="line">  	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rulename：定义的规则名称</p>
<p>ruleset：一个整数值，指定这条规则所属的规则集</p>
<p>min_size和max_size用来限定这个rule的使用范围，即当一个pool的副本数小于min_size或者大于max_size的时候不使用这个rule。</p>
<p>step take：选择一个bucket，然后从这个bucket开始往下遍历，找出OSD</p>
<p>choose是从bucket中找出若干个type类型的项</p>
<p>chooseleaf操作是bucket中选出若干个type类型的leaf节点</p>
<blockquote>
<p>如果在一台机器上部署3各OSD，这里就要将type后面的“host”改为“OSD”，否则一直是HEALTH_ERR，因为选择规则是在bucket（host）中选择3个host类型的leaf节点，显然你这里没有，改为OSD的话就刚好。</p>
</blockquote>
<p>firstn后面的数字，表示按照前面规则选出节点的个数。如果是0，就按照副本数选择，如果是正数，就按个数来，如果是负数，就按副本数＋负数得到的值来选。</p>
<p>step emit：它首先弹出当前值，并清空栈。它会被典型的应用于rule结尾，也可以用于组织同一条rule的不同树。</p>
<h2 id="Bucket的类型"><a href="#Bucket的类型" class="headerlink" title="Bucket的类型"></a>Bucket的类型</h2><p>Cluster map由device和bucket组成，它们都有id和权重值。Bucket可以包含任意数量item。item可以都是的devices或者都是buckets。管理员控制存储设备的权重。权重和存储设备的容量有关。Bucket的权重被定义为它所包含所有item的权重之和。CRUSH基于4种不同的bucket type，每种有不同的选择算法。</p>
<p>CRUSH映射算法解决了效率和扩展性这两个矛盾的目标。而且当存储集群发生变化时，可以最小化数据迁移，并重新恢复平衡分布。CRUSH定义了四种具有不同算法的的buckets。每种bucket基于不同的数据结构，并有不同的c(r,x)伪随机选择函数。</p>
<p>不同的bucket有不同的性能和特性：</p>
<ul>
<li>Uniform：适用于具有相同权重的item，而且bucket很少添加删除item。它的查找速度是最快的。</li>
<li>List：它的结构是链表结构，所包含的item可以具有任意的权重。CRUSH从表头开始查找副本的位置，它先得到表头item的权重Wh、剩余链表中所有item的权重之和Ws，然后根据hash(x, r, item)得到一个[0~1]的值v，假如这个值v在[0~Wh/Ws)之中，则副本在表头item中，并返回表头item的id。否者继续遍历剩余的链表。</li>
<li>Tree：链表的查找复杂度是O(n)，决策树的查找复杂度是O(log n)。item是决策树的叶子节点，决策树中的其他节点知道它左右子树的权重，节点的权重等于左右子树的权重之和。CRUSH从root节点开始查找副本的位置，它先得到节点的左子树的权重Wl，得到节点的权重Wn，然后根据hash(x, r, node_id)得到一个[0~1]的值v，假如这个值v在[0~Wl/Wn)中，则副本在左子树中，否者在右子树中。继续遍历节点，直到到达叶子节点。Tree Bucket的关键是当添加删除叶子节点时，决策树中的其他节点的node_id不变。决策树中节点的node_id的标识是根据对二叉树的中序遍历来决定的(node_id不等于item的id，也不等于节点的权重)。</li>
<li>Straw：这种类型让bucket所包含的所有item<strong>公平竞争</strong>(不像list和tree一样需要遍历)。这种算法就像抽签一样，所有的item都有机会被抽中(只有最长的签才能被抽中)。每个签的长度是由length = f(Wi)<em>hash(x, r, i) 决定的，f(Wi)和item的权重有关，i是item的id号。c(r, x) = MAXi(f(Wi) </em> hash(x, r, i))。</li>
<li><strong>Straw2</strong>：它是改进的straw bucket。它会在项目A和B的<strong>权重都没有改变时避免任何数据移动</strong>。例如，增加或删除一个项目C，改变它的权重，数据只会移动到它上面或者从它上面移动到其他地方，而不会在bucket内的其他项目之间出现数据移动。因此，该算法减少了集群发生改变后的数据移动量。这是目前使用最广的bucket类型。（《ceph cookbook》）</li>
</ul>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 


]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ceph中严重数据不一致性BUG]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/20/Ceph%E4%B8%AD%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7BUG/</url>
      <content type="html"><![CDATA[<p>目前，块存储服务是Ceph存储中被使用的最普遍的服务之一，通过块存储服务，可以向客户端以使用块设备一样访问Ceph集群。然而，目前在使用块存储服务时，尤其是OpenStack与Ceph对接时，如果没有严格的控制Ceph端的对象大小（使用 &gt;= 8MB对象时），将有可能导致严重的数据不一致情况，该异常由于XFS文件系统本身对Fiemap的支持特性导致的。<br><a id="more"></a></p>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>XFS使用fiemap时，当extents数量大于1364时，通过ioctl的FS_IOC_FIEMAP接口，获取的extents数量上限为1364，导致超出部分extents数据获取不到。这将导致，在开启fiemap时，Ceph集群进行recovery与backfill之后，产生大量数据不一致的情况，也是迄今为止Ceph中影响最大的，最严重的数据不一致BUG。</p>
<p>由于fiemap BUG，碎片化对象在recovery与backfill之后（fiemap 获取不正确的数据），从而使的恢复的对象数据与原对象数据不一致。而恢复后的副本若成为主副本，则可能发生静默读错误，并且如果使用Ceph策略自动修复对象（repair object之后），可能将错误数据覆盖至正确数据，数据将永远损毁。在某些情况下，还会触发对象永远处于inconsistent状态。</p>
<h2 id="复现方式"><a href="#复现方式" class="headerlink" title="复现方式"></a>复现方式</h2><p>初始化大量extents碎片文件test，使其成为一个拥有3999个extents的碎片文件。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/1.png" alt="1"></p>
<p>通过fiemap系统调用，获取这些extents<br><a href="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" target="_blank" rel="external"><img src="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" alt="2"></a><br>编译g++ do_fiemap.cc -o do_fiemap</p>
<p>通过该程序可以打印出可以获取的到fiemap extents, do_fiemap test，通过xfs_bmap test 打印出真正的extents数量后，进行比较。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/3.jpg" alt="3"></p>
<p>可以看到，我们最先写了2000个extents，并通过xfs_bmap获取到了 2000个有内容的extents，但是通过fiemap系统调用，只获取到了1364个有数据的extents，所以在ceph中使用fiemap系统调用在某些情况下导致数据一致性BUG。</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>1）目前，在使用块存储使用场景时，通常情况下，默认使用4MB对象。在无特殊情况下，不用使用大于4MB 对象的RBD 镜像。</p>
<p>2）在I版以后，通过新的系统调用，seek_data, seek_hole，可以避免触发该BUG，防止extents过多时使用fiemap调用产生的问题<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/4.png" alt="4"></p>
<p>这组系统调用，可以让使用者通过while循环，反复的发现文件中的data 与 hole，从而组织出一个文件中真正存在的数据，能够避免产生与fiemap系统调用类似的BUG，又保证了recovery或者clone时候只复制有用数据，而反复的系统调，应该会带来一定性能上的影响，请读者们自行测试。</p>
<p>目前，在I版本以后的ceph中，提供参数filestore_seek_data_hole，来启用该功能。当filestore_seek_data_hole 与 filestore_fiemap同时设置时，只用文件系统支持seek_data_hole，那么就会先通过seek_data_hole方式来获取文件的extents，所以在I版本以后的ceph中，应启用filestore_seek_data_hole功能来替代filestore_fiemap 功能。</p>
<p>3）对于已经使用8MB，16MB 甚至更大对象大小的RBD镜像，请暂时设置禁用Fiemap功能，并等待后续版本修复。</p>
<p>原文链接：<a href="https://www.ustack.com/blog/%E9%98%B2%E7%81%AB%E9%98%B2%E7%9B%97%E9%98%B2bug-%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%E5%9B%A2%E9%98%9F%E5%85%AC%E5%B8%83ceph%E4%B8%AD%E6%9C%80%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80/" target="_blank" rel="external">有云存储团队公布Ceph中最严重数据不一致BUG!</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块存储的世界]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>在OpenStack中，存储是非常重要的一块，但是因为其提供方式的不同，即使是专业的工程师也会感到十分困惑。OpenStack的存储主要分为三大类，一是对象    存储服务，Swift解决的问题，二是块设备存储服务，在OpenStack里主要是提供给虚拟机的作为“硬盘”的存储，这里又分为本地块存储和分布式块存储，Cinder项目正    在解决相关的问题；第三类，数据库存储服务，Databases as a Service(DBaaS), 对应AWS里面的RDC，目前是一个正在孵化的项目，Trove，前身是Rackspace开源出&gt;    来的RedDwarf。本文重点介绍块存储服务。<br><a id="more"></a></p>
<blockquote>
<p>转载的文章，原文排版看的心累，链接见文末。</p>
</blockquote>
<p>​    UnitedStack OS的块存储是在OpenStack Cinder框架下开发的，开发过程中，我们对目前主流的块存储服务提供商和开源的块存储软件做了一个简要分析，希望能给从事块存储开发的工程师对于块存储一个全局的认识。        </p>
<p>​    块存储，简单来说就是提供了块设备存储的接口。用户需要把块存储卷附加到虚拟机(或者裸机)上后才可以与其交互。这些卷都是持久的: 它们可以被从运行实例上解除或者重新附加而数据保持完整不变。下面会先介绍常见的单机块设备工具来建立对块存储的初步印象。</p>
<h2 id="单机块存储"><a href="#单机块存储" class="headerlink" title="单机块存储"></a>单机块存储</h2><p>​    首先一个硬盘是一个块设备，内核检测到硬盘然后在/dev/下会看到/dev/sda/。因为我们需要利用一个硬盘来得到不同的分区来做不同的事，通过fdisk工具得到/dev/sda1, /dev/sda2等，这种通过直接写入分区表来规定和切分硬盘,是最死板的分区方式。</p>
<h3 id="LVM-amp-Device-mapper"><a href="#LVM-amp-Device-mapper" class="headerlink" title="LVM &amp; Device-mapper"></a>LVM &amp; Device-mapper</h3><p>​    LVM是一种逻辑卷管理器，通过LVM来对硬盘创建逻辑卷组和得到逻辑卷来完成目的比fdisk方式更加弹性。LVM对于不太熟悉其机制的人看来可能会造成不小的开销，但是相对于LVM对来的易用性其映射机制的负载小的足以忽略(在snapshot的情况会有不小的负载)。</p>
<p>​    LVM在大多数Linux使用者看来非常普通的工具，它同时也是OpenStack块存储项目的一种backend并且是默认的。通过LVM在每个主机创建Volume Group，通过Cinder(OpenStack块存储项目)的调度器可以在任何一个合适的主机(满足容量和其他要求)使用lvcreate创建一个块设备供Nova(OpenStack Computing项目)使用。</p>
<p>​    Device-mapper是一种支持逻辑卷管理的通用设备映射机制，为存储资源管理的块设备驱动提供了一个高度模块化的内核架构。LVM是基于Device-mapper的用户程序实现。</p>
<p>​    Device-mapper在内核中它通过一个模块化的Target Driver插件实现对IO请求的过滤或者重定向工作，当前已经实现的Target Driver插件包括软Raid、软加密、逻辑卷条带、多路径、镜像、快照等。整个 device mapper 机制由两部分组成–内核空间的 device mapper 驱动、用户空间的device mapper 库以及它提供的 dmsetup 工具。内核中主要提供完成这些策略所需要的机制。Device-mapper 用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等等，而具体过滤和重定向 IO 请求的工作由内核中相关代码完成。</p>
<h3 id="SAN-amp-iSCSI"><a href="#SAN-amp-iSCSI" class="headerlink" title="SAN &amp; iSCSI"></a>SAN &amp; iSCSI</h3><p>​    在接触了单机下的逻辑卷管理后，你需要了解<a href="http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">SAN</a>，目前主流的企业级存储方式。</p>
<p>​    大部分SAN使用<a href="http://en.wikipedia.org/wiki/SCSI" target="_blank" rel="external">SCSI</a>协议在服务器和存储设备之间传输和沟通，通过在SCSI之上建立不同镜像层，可以实现存储网络的连接。常见的有<a href="http://zh.wikipedia.org/wiki/ISCSI" target="_blank" rel="external">iSCSI</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_Protocol" target="_blank" rel="external">FCP</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet" target="_blank" rel="external">Fibre Channel over Ethernet</a>等。</p>
<p>​    SAN通常需要在专用存储设备中建立，而iSCSI是基于TCP/IP的SCSI映射，通过iSCSI协议和<a href="http://linux-iscsi.sourceforge.net/" target="_blank" rel="external">Linux iSCSI</a>项目我们可以在常见的PC机上建立SAN存储。。</p>
<p>​    如何建立在PC机上的SAN可以参考<a href="http://linux.vbird.org/linux_server/0460iscsi.php" target="_blank" rel="external">iSCSI建立</a>，这篇文章的iSCSI target管理方式不太方便，通常利用<a href="http://linux-iscsi.org/wiki/Targetcli" target="_blank" rel="external">targetcli</a>管理target是及其方便的。targetcli可以直接建立和管理不同backstone类型的逻辑卷和不同的export方式，如建立ramdisk并且通过iSCSI export非常方便，操作方式见<a href="http://www.youtube.com/watch?v=mKjBsgOlYmE" target="_blank" rel="external">targetcli screencast Part 2 of 3: ISCSI – YouTube</a>。</p>
<h2 id="分布式块存储服务"><a href="#分布式块存储服务" class="headerlink" title="分布式块存储服务"></a>分布式块存储服务</h2><p>​    以上都是我们经常解除的单机下块存储环境，接下来开始本文的正式分享内容，包括公共云技术服务提供的块存储服务，开源的块存储框架和OpenStack目前对块存储的定义和支持情况。</p>
<h3 id="分布式块存储"><a href="#分布式块存储" class="headerlink" title="分布式块存储"></a>分布式块存储</h3><p>​    在面对极具弹性的存储需求和性能要求下，单机或者独立的SAN越来越不能满足企业的需要。如同数据库系统一样，块存储在scale up的瓶颈下也面临着scale out的需要。我们可以用以下几个特点来描述分布式块存储系统的概念:</p>
<ul>
<li>分布式块存储可以为任何物理机或者虚拟机提供持久化的块存储设备</li>
<li>分布式块存储系统管理块设备的创建、删除和attach/deattach。</li>
<li>分布式块存储支持强大的快照功能，快照可以用来恢复或者创建新的块设备</li>
<li>分布式存储系统能够提供不同IO性能要求的块设备</li>
</ul>
<h3 id="Amazon-EBS-amp-阿里云磁盘"><a href="#Amazon-EBS-amp-阿里云磁盘" class="headerlink" title="Amazon EBS &amp; 阿里云磁盘"></a>Amazon EBS &amp; 阿里云磁盘</h3><p>​    Amazon作为领先的IAAS服务商，其API目前是IAAS的事实标准。Amazon EC2目前仍然一骑绝尘，在大多数方面远超其他IAAS服务商。通过Amazon EC2的<a href="http://aws.amazon.com/cn/ec2/" target="_blank" rel="external">产品介绍</a>是快速了解Amazon EC2的捷径。</p>
<p>​    而<a href="http://aws.amazon.com/cn/ebs/" target="_blank" rel="external">EBS</a>是Amazon提供的块存储服务，通过EBS，用户可以随时增删迁移volume和快照操作。</p>
<p>​    Amazon EC2实例可以将根设备数据存储在Amazon EBS或者本地实例存储上。使用 Amazon EBS时，根设备中的数据将独立于实例的生命周期保留下来，使得在停止实例后仍可以重新启动使用，与笔记本电脑关机并在再次需要时重新启动相似。另一方面，本地实例存储仅在实例的生命周期内保留。这是启动实例的一种经济方式，因为数据没有存储到根设备中。</p>
<p>​    Amazon EBS提供两种类型的卷，即标准卷和预配置IOPS卷。它们的性能特点和价格不同，可以根据应用程序的要求和预算定制所需的存储性能。</p>
<p>​    标准卷可为要求有适度或突发式I/O的应用程序提供存储。这些卷平均可以提供大约 100 IOPS，最多可突增至数百 IOPS。标准卷也非常适合用作引导卷，其突发能力可提供快速的实例启动时间(通常十几秒)。</p>
<p>​    预配置 IOPS 卷旨在为数据库等 I/O 密集型随机读写工作负载提供可预计的高性能。创建一个卷时，利用预置 IOPS 为卷确定 IOPS 速率，随之 Amazon EBS 在该卷的生命周期内提供该速率。Amazon EBS 目前支持每预配置 IOPS 卷最多 4000 个IOPS。您可以将多个条带式卷组合在一起，为您的应程程序提供每个Amazon EC2数千IOPS的能力。</p>
<p>​    EBS可以在卷连接和使用期间实时拍摄快照。不过，快照只能捕获已写入Amazon EBS 卷的数据，不包含应用程序或操作系统已在本地缓存的数据。如果需要确保能为实例连接的卷获得一致的快照，需要先彻底地断开卷连接，再发出快照命令，然后重新连接卷。</p>
<p>​    EBS快照目前可以跨regions增量备份，意味着EBS快照时间会大大缩短，从另一面增加了EBS使用的安全性。</p>
<p>​    总的来说，Amazon EBS是目前IAAS服务商最引入注目的服务之一，目前的OpenStack、CloudStack等等其他开源框架都无法提供Amazon EBS对于的如此弹性和强大的服务。了解和使用Amazon EBS是学习IAAS块存储的最好手段。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>​    阿里云是国内的公共云计算服务商，不过这里阿里云目前的块存储服务较于Amazon EBS差的太远，阿里云磁盘目前仅支持在创建云主机的时候绑定云磁盘或者在升级云主机的进行云磁盘扩容，这从根本上就是传统的虚拟主机的特点而不是所谓的“云磁盘”。</p>
<p>从目前的阿里云磁盘的限制:</p>
<ul>
<li>无法快速创建或删除volume，在进行扩容时需要升级云主机才能达到，而升级云主机只有在下月云主机套餐到期时才能生效(想起了中国移动套餐)</li>
<li>一个云主机最多只能绑定3个云磁盘</li>
</ul>
<p>从阿里云磁盘目前的使用分析，阿里云磁盘系统目前还很不成熟，以下是我对阿里云磁盘实现的推测</p>
<ul>
<li>阿里云主机是跟磁盘绑定的，这意味着阿里云的云磁盘是local volume(因此性能还是挺可观的)。如果用户需要扩容、减少都是需要下个月更说明了这点，整个主机在扩容时去调度合适的有足够存储空间的host，然后进行扩容。</li>
<li>阿里云磁盘是分布式块存储系统，但是由于其QoS无法保证和其他资源调度原因无法提供足够的块存储支持。</li>
</ul>
<p>从<a href="http://www.infoq.com/cn/news/2013/06/aliyun-nihao-storage" target="_blank" rel="external">演讲回顾：阿里云存储技术的演进，以及云服务用例最佳实践</a>中了解到阿里云是基于自家的“盘古”系统，那么从实际使用来说，远没达到一般的分布式块存储系统的要求。</p>
<h3 id="Ceph-amp-Sheepdog"><a href="#Ceph-amp-Sheepdog" class="headerlink" title="Ceph &amp; Sheepdog"></a>Ceph &amp; Sheepdog</h3><p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是开源实现的PB级分布式文件系统，通过其分布式对象存储机制为上层提供了文件接口、块存储接口和对象存储接口。<a href="http://www.inktank.com/" target="_blank" rel="external">Inktank</a>是Ceph的主要支持商，也是目前Ceph开源社区的主要力量。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/11.png" alt="1"></p>
<p>​    Ceph目前是OpenStack支持的Backend中一个不错的开源块存储实现系统(即Cinder项目backend driver之一)，其实现分为三个部分: OSD, Monitor, MDS。OSD是底层对象存储系统，Monitor是集群管理系统，MDS是用来支持POSIX文件接口的Metadata Server。从Ceph的原始论文(<a href="http://ceph.newdream.net/papers/weil-thesis.pdf" target="_blank" rel="external">Ceph: Reliable, Scalable, and High-Performance Distributed Storage</a>)来看，Ceph专注于扩展性，高可用性和容错性。Ceph放弃了传统的Metadata查表方式(HDFS)而改用算法(CRUSH)去定位具体的block。</p>
<p>​    利用Ceph提供的RULES可以弹性地制订存储策略和Pool选择，Monitor作为集群管理系统掌握了全部的Cluster Map，Client在没有Map的情况下需要先向Monitor请求得到，然后通过Object id计算相应的OSD Server。</p>
<p>​    Ceph支持传统的POSIX文件接口，因此需要额外的MDS(Meatadata Server)支持文件元信息(Ceph的块存储和对象存储支持不需要MDS服务)。Ceph将Data和Metadata分离到两个服务上，跟传统的分布式系统如Lustre相比可以大大增强扩展性。在小文件读写上，Ceph读写文件会有[RTT*2]，在每次open时，会先去Metadata Server查询一次，然后再去Object Server。除了Open操作外，Ceph在Delete上也有问题，它需要到Metadata Server擦除对应的Metadata，是n(2)复杂度。Ceph在Metadata上并非只有坏处，通过Metadata Server，像目录列表等目录操作为非常快速，远超GlusterFS等其他分布式文件系统的目录或文件元操作。</p>
<p>利用Ceph可以作两种不同类型的“共享存储”支持:</p>
<ol>
<li>利用CephFS作分布式系统，所有虚拟机的块设备直接使用CephFS的命名空间</li>
<li>使用Ceph RBD块设备接口，从Ceph Cluster中导出Volume作为块设备Attach到虚拟机。</li>
</ol>
<p>关于Ceph作为块存储项目的几个问题需要考虑:</p>
<ul>
<li>Ceph在读写上不太稳定（有Btrfs的原因），目前Ceph官方推荐XFS作为底层文件系统</li>
<li>Ceph的扩展性和架构较复杂，如果需要介入Ceph，需要较长时间深入了解</li>
<li>Ceph的部署不够简易，目前Ceph的官方部署工具不太成熟，而对于的Pupet模块或者其他都没有公认的较好实现。</li>
<li>Ceph的稳定性依赖高版本Linux的一些特性，并且Ceph的rbd.ko在高版本中更具稳定性。</li>
</ul>
<h3 id="Sheepdog"><a href="#Sheepdog" class="headerlink" title="Sheepdog"></a>Sheepdog</h3><p>​    <a href="http://www.osrg.net/sheepdog/" target="_blank" rel="external">Sheepdog</a>是另一个分布式块存储系统实现，它与Ceph相比，最大优势就是代码短小好维护和hack的成本很小。Sheepdog也有很多Ceph不支持的特性，比如说Multi-Disk, Cluster-wide Snapshot等。</p>
<p>​    Sheepdog主要有两部分，一个是集群管理，另一个是存储服务。集群管理目前使用Corosync或者Zookper来完成，其存储服务的特点是在Client和存储Host有Cache的实现可以大大减小数据流量。</p>
<p>​    目前Sheepdog只在QEMU端提供Drive，而缺少library支持，这是Sheepdog目前最主要的问题。但是社区已经有相关的Blueprint在讨论这个问题。</p>
<p>了解Sheepdog通过以下链接:</p>
<ul>
<li><a href="http://www.slideshare.net/multics/overview-of-sheepdog" target="_blank" rel="external">Sheepdog Overview</a></li>
<li><a href="http://rdc.taobao.com/blog/cs/?tag=sheepdog" target="_blank" rel="external">Sheepdog 淘宝核心系统团队</a></li>
<li><a href="https://github.com/collie/sheepdog/wiki" target="_blank" rel="external">Sheepdog wiki</a>: Sheepdog的一系列Wiki如同它的代码一样简短出色</li>
</ul>
<p>目前Taobao是Sheepdog主要用户和社区贡献者，国内也有Startup参与Sheepdog的社区开发。</p>
<h3 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h3><p>​    <a href="https://wiki.openstack.org/wiki/Main_Page" target="_blank" rel="external">OpenStack</a>是目前流行的IAAS框架，提供了AWS类似的服务并且兼容其API。OpenStack Nova是计算服务，Swift是对象存储服务，Quantum是网络服务，Glance是镜像服务，Cinder是块存储服务，Keystone是身份认证服务，Horizon是Dashboard，另外还有Heat、Oslo、Ceilometer、Ironic等等项目。</p>
<p>​    <a href="https://wiki.openstack.org/wiki/Cinder" target="_blank" rel="external">Cinder</a>是OpenStack中提供类似于EBS块存储服务的API框架，它并没有实现对块设备的管理和实际服务提供，用来为后端不同的存储结构提供统一的接口与OpenStack进行整合，不同的块设备服务厂商在Cinder中实现其驱动支持。后端的存储可以是DAS，NAS，SAN，对象存储或者分布式文件系统。也就是说，Cinder的块存储数据完整性，可用性保障是由后端存储提供的。在<a href="https://wiki.openstack.org/wiki/CinderSupportMatrix" target="_blank" rel="external">CinderSupportMatrix</a>中可以看到众多存储厂商如NetAPP、IBM、SolidFire、EMC和众多开源块存储系统对Cinder的支持，在这里我们也可以看到OpenStack是非常受欢迎的。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/2.png" alt="2"></p>
<p>​    从上图我们也可以看到，Cinder只是提供了一层抽象，然后通过其后段支持的driver实现来发出命令来得到回应。关于块存储的分配信息以及选项配置等会被保存到OpenStack统一的DB中。</p>
<p>​    目前Cinder项目支持的操作包括创建/删除Volume，创建/删除Snapshot，Clone Volume，将Volume制作成Image或者将Image导出到Volume，备份/恢复Volume和扩展Volume大小，不同的Backend会实现不同程度的操作，但基本的创建Volume和快照操作都是支持的。目前令人振奋的Amazon EBS的QoS机制已经在Cinder社区中得到广泛讨论，在经历近两个月的Patch Review之后，整个QoS机制即将正式进入Cinder项目。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    目前分布式块存储的实现仍然是由Amazon EBS领衔，其卓越稳定的读写性能、强大的增量快照和跨区域块设备迁移，以及令人惊叹的QoS控制都是目前开源或者其他商业实现无法比拟的。</p>
<p>​    不过Amazon EBS始终不是公司私有存储的一部分，作为企业IT成本的重要部分，块存储正在发生改变。EMC在一个月前发布了其ViPR平台，并开放了其接口试图接纳其他厂商和开源实现。Nexenta在颠覆传统的的存储专有硬件，在其上软件实现原来只有专有SDN的能力，让企业客户完全摆脱存储与厂商的绑定。Inktank极力融合OpenStack并推动Ceph在OpenStack社区的影响力都说明了无论是目前的存储厂商还是开源社区都在极力推动整个分布式块存储的发展，存储专有设备的局限性正在进一步弱化了原有企业的存储架构。</p>
<p>​    在分布式块存储和OpenStack之间我们可以打造更巩固的纽带，UnitedStack存储团队在开源存储的基础上，结合本地块存储和分布式块存储的优势，为UnitedStack OS提供一个通用的存储解决方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-1/" target="_blank" rel="external">通用线程: 学习 Linux LVM，第 1 部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-2/" target="_blank" rel="external">通用线程：学习 Linux LVM，第 2部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/" target="_blank" rel="external">Linux 内核中的 Device Mapper 机制</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="external">Ceph：一个 Linux PB 级分布式文件系统</a></li>
<li><a href="http://www.alidata.org/archives/1589" target="_blank" rel="external">分布式文件系统Ceph调研1 – RADOS</a></li>
<li><a href="http://ceph.com/docs/next/architecture/" target="_blank" rel="external">Ceph Architecture</a></li>
<li><a href="http://way4ever.com/?p=375" target="_blank" rel="external">Ceph的现状</a></li>
<li><a href="http://way4ever.com/?p=122" target="_blank" rel="external">ceph的CRUSH数据分布算法介绍</a></li>
<li><a href="http://ceph.com/docs/next/dev/" target="_blank" rel="external">Ceph INTERNAL DEVELOPER DOCUMENTATION</a></li>
<li>原文链接：<a href="https://www.ustack.com/blog/block-storage-overview/" target="_blank" rel="external">块存储的世界</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——uptime]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94uptime/</url>
      <content type="html"><![CDATA[<p>打印系统总共运行了多长时间和系统的平均负载。<br><a id="more"></a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line"> uptime [options]</div><div class="line"></div><div class="line">Options:</div><div class="line"> -p, --pretty   show uptime in pretty format</div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -s, --since    system up since</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see uptime(1).</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime</div><div class="line"> 17:40:45 up 1 day,  6:37,  3 users,  load average: 0.27, 0.21, 0.31</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>显示内容</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:40:45</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day,  6:37</td>
<td>主机已运行时间，时间越大，说明机器越稳定</td>
</tr>
<tr>
<td>3 users</td>
<td>用户连接数，是总连接数而不是用户数</td>
</tr>
<tr>
<td>load average: 0.27, 0.21, 0.31</td>
<td>最近1，5，15分钟的系统平均负载</td>
</tr>
</tbody>
</table>
<p><strong>系统平均负载</strong>：在特定时间间隔内运行队列中的平均进程数。</p>
<p><strong>查看CPU内核数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</div><div class="line">4</div></pre></td></tr></table></figure>
<p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
<h3 id="运行时间格式输出"><a href="#运行时间格式输出" class="headerlink" title="运行时间格式输出"></a>运行时间格式输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -p</div><div class="line">up 1 day, 6 hours, 56 minutes</div></pre></td></tr></table></figure>
<h3 id="系统启动的时间"><a href="#系统启动的时间" class="headerlink" title="系统启动的时间"></a>系统启动的时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -s</div><div class="line">2017-01-16 11:03:35</div></pre></td></tr></table></figure>
<h3 id="uptime版本"><a href="#uptime版本" class="headerlink" title="uptime版本"></a>uptime版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -V</div><div class="line">uptime from procps-ng 3.3.9</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dd磁盘命令小记]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/12/dd%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>dd是经常使用的命令了，方便快捷，这里闲来小总结一下，以及怎样测出最真实的写入速度。<br><a id="more"></a></p>
<h2 id="命令的使用"><a href="#命令的使用" class="headerlink" title="命令的使用"></a>命令的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd --help</div><div class="line">Usage: dd [OPERAND]...</div><div class="line">  or:  dd OPTION</div><div class="line">Copy a file, converting and formatting according to the operands.</div><div class="line"></div><div class="line">  bs=BYTES        read and write up to BYTES bytes at a time</div><div class="line">  cbs=BYTES       convert BYTES bytes at a time</div><div class="line">  conv=CONVS      convert the file as per the comma separated symbol list</div><div class="line">  count=N         copy only N input blocks</div><div class="line">  ibs=BYTES       read up to BYTES bytes at a time (default: 512)</div><div class="line">  if=FILE         read from FILE instead of stdin</div><div class="line">  iflag=FLAGS     read as per the comma separated symbol list</div><div class="line">  obs=BYTES       write BYTES bytes at a time (default: 512)</div><div class="line">  of=FILE         write to FILE instead of stdout</div><div class="line">  oflag=FLAGS     write as per the comma separated symbol list</div><div class="line">  seek=N          skip N obs-sized blocks at start of output</div><div class="line">  skip=N          skip N ibs-sized blocks at start of input</div><div class="line">  status=WHICH    WHICH info to suppress outputting to stderr;</div><div class="line">                  &apos;noxfer&apos; suppresses transfer stats, &apos;none&apos; suppresses all</div></pre></td></tr></table></figure>
<p><strong>翻译</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bs</td>
<td>同时设置读写块的大小为 bytes ，可代替 ibs 和 obs</td>
</tr>
<tr>
<td>cbs</td>
<td>一次转换 bytes 个字节，即转换缓冲区大小</td>
</tr>
<tr>
<td>conv</td>
<td>转换参数</td>
</tr>
<tr>
<td>count</td>
<td>复制的块数</td>
</tr>
<tr>
<td>ibs</td>
<td>一次读入 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>if</td>
<td>输入文件 或 设备名称</td>
</tr>
<tr>
<td>iflag</td>
<td>按照逗号来分隔读参数</td>
</tr>
<tr>
<td>obs</td>
<td>一次写 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>of</td>
<td>输出文件 或 设备名称</td>
</tr>
<tr>
<td>oflag</td>
<td>按照逗号来分隔写参数</td>
</tr>
<tr>
<td>seek</td>
<td>从输出文件开头跳过 blocks 个块后再开始复制</td>
</tr>
<tr>
<td>skip</td>
<td>从输入文件开头跳过 blocks 个块后再开始复制</td>
</tr>
</tbody>
</table>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd --version</div></pre></td></tr></table></figure>
<h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><p><strong>两个特殊的设备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/dev/null：伪设备，相当于黑洞，of到该设备不会产生IO</div><div class="line">/dev/zero：伪设备，它只产生空字符流，对它不会产生IO</div></pre></td></tr></table></figure>
<p><strong>1、测试磁盘写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/zero of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO都集中在of文件中，of文件只用于写，相当于测试磁盘的写能力。</p>
<p><strong>2、测试磁盘读能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/dev/null bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO只发生在/dev/sdb1上，相当于测试磁盘的读能力。</p>
<p><strong>3、测试同时读写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>一个是物理分区，一个是实际的文件，对它们的读写都会产生IO，如果它们都在一个磁盘中，该命令就相当于测试磁盘的同时读写能力。</p>
<h2 id="几种测试写磁盘的区别"><a href="#几种测试写磁盘的区别" class="headerlink" title="几种测试写磁盘的区别"></a>几种测试写磁盘的区别</h2><p>先给出四种测试方式的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd if=/dev/zero of=test bs=1M count=128</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.116559 s, 1.2 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 ; sync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.125106 s, 1.1 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 1.76802 s, 75.9 MB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 4.91353 s, 27.3 MB/s</div></pre></td></tr></table></figure>
<p>1、<code>dd if=/dev/zero of=test bs=1M count=128</code></p>
<p>没有加任何参数，命令只是单纯地把这128MB的数据读到内存缓冲当中，dd命令完成前并没有让系统真正把文件写到磁盘上。所以得到的是一个超级快的速度。直到dd完成后系统才开始真正往磁盘上写数据,但这个速度你是看不到了。</p>
<p>2、<code>dd if=/dev/zero of=test bs=1M count=128 ; sync</code></p>
<p>这事先后两个独立的命令。当sync命令准备开始往磁盘上真正写入数据的时候，前面dd命令已经把错误的“写入速度”值显示在屏幕上了。所以得到的不是真正的写入速度。</p>
<p><strong>3、<code>dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</code></strong></p>
<p>加入参数 <code>conv=fdatasync</code> 后，dd命令执行到最后会真正执行一次“同步(sync)”操作，所以这时候得到的是读取这128M数据到内存并写入到磁盘上所需的时间，这样算出来的时间才是<strong>比较符合实际</strong>的。这种方式最接近计算机实际操作，所以测出来的数据最有参考价值。</p>
<p>4、<code>dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</code></p>
<p>加入参数 <code>oflag=dsync</code> 后，dd在执行时每次都会进行同步写入操作。这条命令每次读取1M后就要先把这1M写入磁盘，然后再读取下面这1M，一共重复128次。这是最慢的一种方式，因为基本上没有用到写缓存(write cache)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决calamari无法获取集群hosts信息的BUG]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/12/%E8%A7%A3%E5%86%B3calamari%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E9%9B%86%E7%BE%A4hosts%E4%BF%A1%E6%81%AF%E7%9A%84BUG/</url>
      <content type="html"><![CDATA[<p>如题，环境是ubuntu 14.04，解决过程和方法详见正文。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在磨磨的文章中看到这个问题，他是在CentOS上，通过修改 <code>/usr/lib/python2.7/site-packages/salt/master.py</code> 文件，然后重启salt-master和salt-minion服务来解决的，链接在文末。原理类似，可ubuntu上并不能完全照搬。</p>
<h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><blockquote>
<p>这部分的内容为折腾求证的过程，想看解决方法的可以直接跳过！</p>
</blockquote>
<p>在ubuntu上并没有这个文件和路径，通过tab可以看到site开头的只有这几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# vim /usr/lib/python2.7/site</div><div class="line">sitecustomize.py   sitecustomize.pyc  site.py            site.pyc</div></pre></td></tr></table></figure>
<p>我以为可能是系统下包安装的位置不对而已，好，那我就查看一下ubuntu下salt-master的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# dpkg -L salt-master</div><div class="line">/.</div><div class="line">/usr</div><div class="line">/usr/share</div><div class="line">/usr/share/man</div><div class="line">/usr/share/man/man1</div><div class="line">/usr/share/man/man1/salt.1.gz</div><div class="line">/usr/share/man/man1/salt-run.1.gz</div><div class="line">/usr/share/man/man1/salt-master.1.gz</div><div class="line">/usr/share/man/man1/salt-key.1.gz</div><div class="line">/usr/share/man/man1/salt-cp.1.gz</div><div class="line">/usr/share/doc</div><div class="line">/usr/share/doc/salt-master</div><div class="line">/usr/share/doc/salt-master/changelog.Debian.gz</div><div class="line">/usr/share/doc/salt-master/NEWS.Debian.gz</div><div class="line">/usr/share/doc/salt-master/copyright</div><div class="line">/usr/bin</div><div class="line">/usr/bin/salt-run</div><div class="line">/usr/bin/salt-master</div><div class="line">/usr/bin/salt-key</div><div class="line">/usr/bin/salt-cp</div><div class="line">/usr/bin/salt</div><div class="line">/lib</div><div class="line">/lib/systemd</div><div class="line">/lib/systemd/system</div><div class="line">/lib/systemd/system/salt-master.service</div><div class="line">/etc</div><div class="line">/etc/init.d</div><div class="line">/etc/init.d/salt-master</div><div class="line">/etc/init</div><div class="line">/etc/init/salt-master.conf</div><div class="line">/etc/salt</div><div class="line">/etc/salt/master</div><div class="line">/etc/salt/master.d</div></pre></td></tr></table></figure>
<p>然后通过 <code>find</code> 命令去 <code>/etc, /usr, /lib</code> 这几个目录下找 <code>master.py</code> ，结果真没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find: `master.py&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>好吧，下面来看问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在calamari的web界面下，查看 MANAGE -&gt; Cluster -&gt;HOSTS 信息，发现啥也没有，如下图所示：<img src="http://ojet8bprn.bkt.clouddn.com/calamari-1.png" alt="calamari-1"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>calamari的salt-master节点在读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/cache/salt/master/minions/&#123;minion-hostname&#125;/data.p</div></pre></td></tr></table></figure>
<p>该文件的时候有权限问题，当前权限为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw------- 1 root root 3019 Jan 10 11:06 data.p</div></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改权限为 644 即可，写了个脚本，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for x in 0 1 2</div><div class="line">do</div><div class="line">    chmod 644 /var/cache/salt/master/minions/ceph$x/data.p</div><div class="line">done</div></pre></td></tr></table></figure>
<p>修改完后，再次查看，可以看到hosts的详细信息了<img src="http://ojet8bprn.bkt.clouddn.com/calamari-2.png" alt="calamari-2"></p>
<blockquote>
<p>当然，重启 salt-minion 后又需要在 salt-master 机器上重新执行一遍，<del>~~(&gt;_&lt;)</del>~~，忧伤~</p>
</blockquote>
<p>磨磨的方法：<a href="http://www.zphj1987.com/2017/01/09/calamari-node-info/" target="_blank" rel="external">centos下该问题的解决方法</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下配置邮件发送]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/11/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
      <content type="html"><![CDATA[<p>Linux下发送email有很多种方式，包括sendmail、mailx、mutt、uuencode等等。这里介绍ubuntu下使用mutt和msmtp发送邮件的配置方法。<br><a id="more"></a></p>
<h2 id="软件包的安装"><a href="#软件包的安装" class="headerlink" title="软件包的安装"></a>软件包的安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mutt</div><div class="line">sudo apt-get install msmtp</div></pre></td></tr></table></figure>
<h2 id="文件的配置"><a href="#文件的配置" class="headerlink" title="文件的配置"></a>文件的配置</h2><h3 id="配置-mutt"><a href="#配置-mutt" class="headerlink" title="配置 mutt"></a>配置 mutt</h3><p>,系统全局设置配置文件在 /etc/Muttrc,如果使用某个系统用户，可以在~/.muttc中设置，没有该文件，就自己创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi .muttrc</div><div class="line"></div><div class="line">set sendmail=&quot;/usr/bin/msmtp&quot;</div><div class="line">set use_from=yes</div><div class="line">set realname=&quot;xia&quot;</div><div class="line">set from=abcdefg@126.com</div><div class="line">set envelope_from=yes</div></pre></td></tr></table></figure>
<h3 id="配置msmtp"><a href="#配置msmtp" class="headerlink" title="配置msmtp"></a>配置msmtp</h3><p>创建 ~/.msmtprc 和 ~/.msmtp.log，分别为配置文件和日志文件。</p>
<p><strong>1、创建配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .msmtprc</div></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">account default</div><div class="line">host smtp.126.com</div><div class="line">from youremailname@126.com</div><div class="line">auth plain</div><div class="line">user youremailname@126.com</div><div class="line">password xxxxxxx</div><div class="line">logfile ~/.msmtp.log</div></pre></td></tr></table></figure>
<p>由于password是明文，所以需要修改此文件的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 .msmtprc</div></pre></td></tr></table></figure>
<p><strong>特别注意</strong>：</p>
<blockquote>
<p>这里的密码填的是你的授权密码，不是登录密码!</p>
</blockquote>
<p><strong>2、创建日志文件 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch ~/.msmtp.log</div></pre></td></tr></table></figure>
<h2 id="邮件发送测试"><a href="#邮件发送测试" class="headerlink" title="邮件发送测试"></a>邮件发送测试</h2><p>查看SMTP服务器是否支持认证的TLS加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># msmtp --host=smtp.126.com --serverinfo</div><div class="line">SMTP server at smtp.126.com (m15-111.126.com [220.181.15.111]), port 25:</div><div class="line">    126.com Anti-spam GT for Coremail System (126com[20140526])</div><div class="line">Capabilities:</div><div class="line">    PIPELINING:</div><div class="line">        Support for command grouping for faster transmission</div><div class="line">    STARTTLS:</div><div class="line">        Support for TLS encryption via the STARTTLS command</div><div class="line">    AUTH:</div><div class="line">        Supported authentication methods:</div><div class="line">        PLAIN LOGIN </div><div class="line">This server might advertise more or other capabilities when TLS is active.</div></pre></td></tr></table></figure>
<p>发送一个简单的邮件测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello world&quot; | mutt -s &quot;title&quot; 12456789@qq.com</div></pre></td></tr></table></figure>
<p>登录QQ邮箱，可以正常收到邮件，成功！</p>
<h2 id="四种发送方式"><a href="#四种发送方式" class="headerlink" title="四种发送方式"></a>四种发送方式</h2><p>1、<strong>带有主题，从文件中读取邮件的正文，并发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mutt -s &quot;hello mutt&quot; user@example.com &lt; message.txt</div></pre></td></tr></table></figure>
<p>2、<strong>通过管道获取 <code>echo</code>命令输出作为邮件内容发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com</div></pre></td></tr></table></figure>
<p>3、<strong>发送带附件的邮件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com -a test.tar.gz</div></pre></td></tr></table></figure>
<p>多个附件的话在每个附件前加上 <code>-a</code> 即可。</p>
<p>4、<strong>发送给多个收件人</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello mutt&quot; | mutt -s &quot;Testing muttt&quot; 111111@qq.com,222222@163.com -c 3333333@qq.com -b 44444444@126.com</div></pre></td></tr></table></figure>
<p>多个收件人之间用逗号隔开</p>
<p><strong>抄送</strong>，前面加参数 <code>-c</code> </p>
<p><strong>密送</strong>，前面加参数 <code>-b</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1、出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">msmtp: authentication failed (method PLAIN)</div><div class="line">msmtp: server message: 530 Error: A secure connection is requiered(such as ssl). More information at http://service.mail.qq.com/cgi-bin/help?id=28</div><div class="line">msmtp: could not send mail (account default from /root/.msmtprc)</div><div class="line">Error sending message, child exited 77 (Insufficient permission.).</div><div class="line">Could not send the message.</div></pre></td></tr></table></figure>
<p>原因，没有权限进行操作</p>
<p>解决方法：</p>
<blockquote>
<p>登录网页邮箱，设置开启POP3/SMTP服务、IMAP/SMTP服务</p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="http://www.cnblogs.com/xiazh/archive/2011/04/15/2016966.html" target="_blank" rel="external">ubuntu下使用mutt和msmtp发送邮件的简单配置</a></p>
<p><a href="https://linux.cn/article-5502-1.html" target="_blank" rel="external">4个可以发送电子邮件的命令行工具</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下系统打包]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/11/ubuntu%E4%B8%8B%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>介绍在ubuntu下利用remastersys工具给系统打包成 iso 镜像的方法，在其他系统（centos、windows等）下方法类似，不在赘述。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在初始环境下，经过多次反复安装和配置才组建完成的自己需要的环境，其中各种版本问题和依赖较多，安装过程繁杂，为了避免痛苦的安装过程轮回发生，需要给系统打个包，后续使用直接安装即可。</p>
<p>使用工具：Remastersys</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、依赖项的安装"><a href="#1、依赖项的安装" class="headerlink" title="1、依赖项的安装"></a>1、依赖项的安装</h3><p>依赖：<a href="ftp://ftp.gwdg.de/pub/linux/easyvdr/mirror/remastersys/ubuntu/remastersys/remastersys_3.0.4-2_all.deb" target="_blank" rel="external">remastersys_3.0.4-2_all.deb</a>，点击即可下载，也可以自己去去<a href="http://www.filewatcher.com/" target="_blank" rel="external">filewatcher</a>搜索下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install plymouth-x11 </div><div class="line">sudo dpkg -i remastersys_3.0.4-2_all.deb</div></pre></td></tr></table></figure>
<h3 id="2、Remastersys安装"><a href="#2、Remastersys安装" class="headerlink" title="2、Remastersys安装"></a>2、Remastersys安装</h3><p>2.1、添加安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;deb http://www.remastersys.com/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list</div></pre></td></tr></table></figure>
<p>2.2、更新安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo install remastersys</div><div class="line">sudo remastersys</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys  backup|clean|dist  [cdfs|iso]  [filename.iso]</div></pre></td></tr></table></figure>
<p>两种打包方式：backup和dist</p>
<p>backup 是对整个系统完全打包，包含个人文件</p>
<p>dist 方式用做发行，不包含个人文件</p>
<blockquote>
<p>更多使用方法可以参考<a href="http://forum.ubuntu.org.cn/viewtopic.php?t=174719" target="_blank" rel="external">ubuntu论坛</a></p>
</blockquote>
<h3 id="系统打包"><a href="#系统打包" class="headerlink" title="系统打包"></a>系统打包</h3><p>3.1、产生一个只有档案系统的可发布的 livecd/dvd </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist cdfs</div></pre></td></tr></table></figure>
<p>3.2、产生一个可发布其名叫 filename.iso的ISO文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist iso filename.iso</div></pre></td></tr></table></figure>
<p>3.3、将产生的iso文件移动到安全的位置(如果不移动会被清除掉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv /home/remastersys/remastersys/filename.iso /root/</div></pre></td></tr></table></figure>
<p>3.4、清除由 remastersys产生的临时文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys clean</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——history及其优化]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94history%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>没啥好说的，就是查看历史输入的命令。这里引入两个优化点，一是历史记录带时间，二是可以统计汇总不同终端下的命令。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">history [n]</div><div class="line">history [-c]</div><div class="line">history [-raw] histfiles</div></pre></td></tr></table></figure>
<p>参数解释：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数字，列出最近的 n 条命令列表</td>
</tr>
<tr>
<td>-c</td>
<td>将目前的shell中的所有 history 内容全部清除</td>
</tr>
<tr>
<td>-a</td>
<td>将目前新增的history指令新增入 histfiles中，若没有➕histfiles，则预设写入 ~/.bash_history</td>
</tr>
<tr>
<td>-r</td>
<td>将histfiles的内容读到目前这个shell的history记忆中</td>
</tr>
<tr>
<td>-w</td>
<td>将目前的history记忆内容写入histfiles</td>
</tr>
</tbody>
</table>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more, less, tail, head</code> 来使用，其他复杂用法这里不作介绍。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">history | more</div><div class="line">history | tail -4</div></pre></td></tr></table></figure>
<h2 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h2><p><strong>出发点</strong>：在项目中，在不同终端下执行了一系列的命令后，翻不到历史记录，也没有汇总，也不知道每条命令的执行时间，所以需要对该命令进行优化。</p>
<p><strong>优化点</strong></p>
<ul>
<li>历史记录里面每条命令带有时间</li>
<li>所有终端命令都记录到history当中去</li>
</ul>
<blockquote>
<p>命令的汇总限同一个机器下的同一个用户</p>
</blockquote>
<p>注：以下设置方法适用ubuntu，其他系统类似。ubuntu上修改的文件是 <code>/etc/bash.bashrc</code>，mac上修改的文件是 <code>/etc/bashrc</code> 。</p>
<h3 id="添加日期"><a href="#添加日期" class="headerlink" title="添加日期"></a>添加日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</div><div class="line">export HISTTIMEFORMAT</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候，history命令的显示就带有日期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">448  2017-01-11 11:42:01 vim /etc/bash.bashrc </div><div class="line">449  2017-01-11 11:42:45 source /etc/bash.bashrc </div><div class="line">450  2017-01-11 11:40:18 history</div><div class="line">451  2017-01-11 11:41:11 ls</div><div class="line">452  2017-01-11 11:41:12 pwd</div><div class="line">453  2017-01-11 11:41:35 history</div></pre></td></tr></table></figure>
<h3 id="不同终端命令汇总"><a href="#不同终端命令汇总" class="headerlink" title="不同终端命令汇总"></a>不同终端命令汇总</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div><div class="line"># When the shell exits, append to the history file instead of overwriting it</div><div class="line">shopt -s histappend</div><div class="line"></div><div class="line"># After each command, append to the history file and reread it</div><div class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&apos;\n&apos;&#125;history -a; history -c; history -r&quot;</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候就可以看到之前在该机器该用户下的所有命令操作。</p>
<h3 id="调整记录命令长度"><a href="#调整记录命令长度" class="headerlink" title="调整记录命令长度"></a>调整记录命令长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTSIZE=1000	# 该数字自己定</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<h3 id="剔除连续重复的条目"><a href="#剔除连续重复的条目" class="headerlink" title="剔除连续重复的条目"></a>剔除连续重复的条目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>将 HISTCONTROL 设置为 ignoredups</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下利用screen进行屏幕协作]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/11/Linux%E4%B8%8B%E5%88%A9%E7%94%A8screen%E8%BF%9B%E8%A1%8C%E5%B1%8F%E5%B9%95%E5%8D%8F%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>Linux本身是支持多终端并行处理的，但是某些时候我们可能需要两个人同时处理同一个终端，比如远程协助定位问题等。screen正好能满足这个需求。<br><a id="more"></a></p>
<h2 id="screen的安装"><a href="#screen的安装" class="headerlink" title="screen的安装"></a>screen的安装</h2><p>debian和ubuntu下安装方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install screen</div></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>假设现在有a和b需要进行屏幕协作。</p>
<blockquote>
<p>他们需要登录同一台服务器/机器</p>
<p>必须使用相同的账户，不同账户之前不能屏幕协作</p>
</blockquote>
<p>第一步：a 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -S zp</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>S</code> 是大写</p>
<p>第二步：b 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -x zp</div></pre></td></tr></table></figure>
<p>这时两边的操作是实时而且同步的。</p>
<h2 id="退出协作"><a href="#退出协作" class="headerlink" title="退出协作"></a>退出协作</h2><p>在任意一个终端上输入命令：<code>exit</code> ，输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[screen is terminating]</div></pre></td></tr></table></figure>
<p>表示退出成功。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——crontab]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94crontab/</url>
      <content type="html"><![CDATA[<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>crontab使用格式说明</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/crontab%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.png" alt="crontab格式说明"></p>
<p>如图所示：</p>
<ul>
<li>第1列分钟0～59</li>
<li>第2列小时0～23（0表示子夜）</li>
<li>第3列日1～31</li>
<li>第4列月1～12</li>
<li>第5列星期0～7（0和7表示星期天）</li>
<li>第6列要运行的命令</li>
</ul>
<p><strong>TIPS</strong></p>
<p>每一列之间用空格隔开。</p>
<p>破折号 <code>-</code> 表示一个整数范围。例如：“2-4”表示“2,3,4”。</p>
<p>逗号 <code>,</code> 表示枚举的意思，一个指定的集合。例如：“1,5,8”。</p>
<p>正向斜杠 <code>/</code> 表示间隔频率。例如：“8-20/2”表示从8点到20点每2小时执行一次。</p>
<p><code>/</code> 可以和 <code>*</code> 一起使用。例如<code>*/5</code>，如果用在minute字段，表示每五分钟执行一次。<code>* */1 * * *</code>  表示每一小时执行一次。</p>
<p><strong>命令格式</strong></p>
<p><code>crontab [-u user] file crontab [-u user][ -e | -l | -r ]</code></p>
<h2 id="选项详解"><a href="#选项详解" class="headerlink" title="选项详解"></a>选项详解</h2><ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><p>1、创建crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab yourcron</div></pre></td></tr></table></figure>
<p>2、列出crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>3、编辑crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab -e</div></pre></td></tr></table></figure>
<p>4、删除crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$crontab -r</div></pre></td></tr></table></figure>
<p>5、ubuntu下启动、停止与重启cron</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron start</div><div class="line">$sudo /etc/init.d/cron stop</div><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p>6、清理用户的邮件日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p><code>&gt; /dev/null 2&gt;&amp;1</code> 表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<blockquote>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要</p>
</blockquote>
<h3 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h3><p><strong>一种是新建crontab任务，然后重启cron服务</strong></p>
<p>第一步、创建一个crontab文件</p>
<p>设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。使用vi的话，在$HOME目录下的. profile文件中加入一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EDITOR=vi; export EDITOR</div></pre></td></tr></table></figure>
<p>创建一个比如名为 testcron 的文件，在其中加入自己想要执行的命令，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>把这个新创建的文件作为cron命令的参数，用来创建crontab任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab testcron</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>失败！</strong></p>
<blockquote>
<p>试过多次，不知道为啥这种通过自己创建crontab文件的方式不行，查资料也未果。后续有机会再试试，就暂时先用后一种可用的方法吧。有知道的忘不吝指教。</p>
</blockquote>
<p><strong>另一种是把要执行的命令直接写入 <code>/etc/crontab</code> 中，然后重启cron服务</strong></p>
<p>第一步、直接编辑 /etc/crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/crontab</div><div class="line">添加自己的任务</div><div class="line">* * * * * root sh myjob.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>成功！</strong></p>
<p>如果需要停止该任务的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron stop</div></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实例1：每1分钟执行一次myCommand</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例2：每小时的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例3：在上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * * myCommand</div></pre></td></tr></table></figure>
<p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 */2  *  * myCommand</div></pre></td></tr></table></figure>
<p>实例5：每周一上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * 1 myCommand</div></pre></td></tr></table></figure>
<p>实例6：每晚的21:30重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 21 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例7：每月1、10、22日的4 : 45重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">45 4 1,10,22 * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例8：每周六、周日的1 : 10重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 1 * * 6,0 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,30 18-23 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例10：每星期六的晚上11 : 00 pm重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23 * * 6 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例11：每一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* */1 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例12：晚上11点到早上7点之间，每隔一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23-7 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件中。</p>
<p>2、新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>3、<code>crontab -r</code> 将从Crontab目录（/var/spool/cron）中删除用户的Crontab文件，该用户的所有crontab都将被删除。</p>
<p>4、在crontab中 <code>%</code> 表示换行的意思。使用的时候必须进行转义%。比如经常使用的 <code>date ‘+%Y%m%d’</code> 在crontab里是不会执行的，应该换成 <code>date ‘+\%Y\%m\%d’’</code>。</p>
<p><strong>参考资料</strong>：<a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">crontab 定时任务</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac上hexo博客的搭建]]></title>
      <url>http://xiaqunfeng.github.io/2017/01/06/hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>​    第一篇hexo博客，介绍了在mac上搭建hexo博客的全过程。包括：准备工作、本地站点的建立、启动和部署站点、创建新文章、发布到github、更换主题 和 绑定域名。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><strong>github</strong></li>
<li><strong>homebrew</strong></li>
<li><strong>node.js 和 npm</strong></li>
<li><strong>hexo</strong></li>
</ol>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>1、github账号</p>
<p>​    这部分略过，没有的话自己注册一个。然后将mac上的公钥添加到github上去。</p>
<p>2、建立仓库</p>
<p>​    严格按照 <code>git用户名</code>.<code>github</code>.<code>io</code> 来命名。我这里就叫：<code>xiaqunfeng.github.io</code> 。</p>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><p>homebrew 是MAC OSX 上面用来安装 或者 卸载软件用的非常方面的一个软件。在终端上执行如下命令即可安装，参考<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>不推荐使用 brew 安装node， 直接从<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载，然后双击安装。我这里选择的版本是：v6.9.3 LTS。node.js 集成带有npm。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v6.9.3</div><div class="line"></div><div class="line">$ npm -v</div><div class="line">3.10.10</div></pre></td></tr></table></figure>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ hexo -v</div><div class="line">hexo: 3.2.2</div><div class="line">hexo-cli: 1.0.2</div><div class="line">os: Darwin 16.1.0 darwin x64</div><div class="line">http_parser: 2.7.0</div><div class="line">node: 6.9.3</div><div class="line">v8: 5.1.281.89</div><div class="line">uv: 1.9.1</div><div class="line">zlib: 1.2.8</div><div class="line">ares: 1.10.1-DEV</div><div class="line">icu: 57.1</div><div class="line">modules: 48</div><div class="line">openssl: 1.0.2j</div></pre></td></tr></table></figure>
<h2 id="hexo命令行使用"><a href="#hexo命令行使用" class="headerlink" title="hexo命令行使用"></a>hexo命令行使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">常用命令：</div><div class="line">hexo help			#查看帮助</div><div class="line">hexo init 			#初始化一个目录</div><div class="line">hexo new &quot;postName&quot; 		#新建文章</div><div class="line">hexo new page &quot;pageName&quot; 	#新建页面</div><div class="line">hexo generate 			#生成网页，可以在 public 目录查看整个网站的文件</div><div class="line">hexo server 			#本地预览，&apos;Ctrl+C&apos;关闭</div><div class="line">hexo deploy 			#部署.deploy目录</div><div class="line">hexo clean 			#清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</div><div class="line"></div><div class="line">简写：</div><div class="line">hexo n == hexo new</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure>
<h2 id="建立本地站点"><a href="#建立本地站点" class="headerlink" title="建立本地站点"></a>建立本地站点</h2><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。（文件夹不需要提前建好，会自行创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>新建文件夹目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy 		#需要部署的文件</div><div class="line">├── node_modules 	#Hexo插件</div><div class="line">├── public 		#生成的静态网页文件</div><div class="line">├── scaffolds 		#模板</div><div class="line">├── source 		#博客正文和其他源文件</div><div class="line">| ├── _drafts 		#草稿(刚开始没有)</div><div class="line">| └── _posts 		#文章</div><div class="line">├── themes 		#主题</div><div class="line">├── _config.yml 	#全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h2 id="启动站点"><a href="#启动站点" class="headerlink" title="启动站点"></a>启动站点</h2><p>执行 hexo server 启动站点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure>
<p>在浏览器中输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到站点了。</p>
<h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><p>编辑文件 <code>_config.yml</code> ，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repository: https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line">   branch: master</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：冒号后面要留 <strong>空格</strong>！！</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p><strong>方法1</strong>、<code>hexo n</code>创建新文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo n &quot;我的第一篇hexo博客&quot;</div><div class="line">INFO  Created: ~/hexo-blog/source/_posts/我的第一篇hexo博客.md</div></pre></td></tr></table></figure>
<p>然后用编辑器打开编辑即可。</p>
<p><strong>方法2</strong>、直接在 <code>source/_posts</code> 中新建一个md文件，进行编辑</p>
<p>在hexo-blog文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>然后在浏览器中输入<code>http://localhost:4000</code>就可以看到新加的文章了。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>执行 <code>hexo d</code> ，发现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">ERROR Deployer not found: git</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div><div class="line">hexo-site@0.0.0 /Users/xiaqunfeng/hexo-blog</div><div class="line">└── hexo-deployer-git@0.2.0</div></pre></td></tr></table></figure>
<p>再执行 <code>hexo d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div><div class="line">Username for &apos;https://github.com&apos;: xiaqunfeng</div><div class="line">Password for &apos;https://xiaqunfeng@github.com&apos;: </div><div class="line">To https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line"> * [new branch]      HEAD -&gt; master</div><div class="line">Branch master set up to track remote branch master from https://github.com/xiaqunfeng/xiaqunfeng.github.io.git.</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>输入github的用户名和密码即可。此时，博客已经完全搭建起来了。</p>
<p>在浏览器中输入：<a href="https://xiaqunfeng.github.io/">https://xiaqunfeng.github.io/</a> 即可访问。</p>
<p>预览如下： <img src="http://ojet8bprn.bkt.clouddn.com/hexo-new.png" alt=""></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>自己google一下hexo主题，选一个自己喜欢的，然后git clone下来。比如 Next 主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure>
<p>然后打开_config.yml文件，替换其中的 <code>theme</code> 属性，默认为 <code>landscape</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态页面，生成的内容在public文件夹下</div><div class="line">$ hexo s #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试</div></pre></td></tr></table></figure>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>1、清理之前生成的内容，即public文件。</p>
<p><strong>注意</strong>：这一步必须要，不然有时因为缓存问题，服务器更新不了主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>2、生成静态文件并部署到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态文件</div><div class="line">$ hexo d #部署到github</div></pre></td></tr></table></figure>
<p>上面两个命令可以合并为一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d -g #在部署前先生成</div></pre></td></tr></table></figure>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><blockquote>
<p>我暂时还没购买和绑定域名，就暂时先简单介绍一下，后续再来补充完善。</p>
</blockquote>
<p>1、购买域名</p>
<p>某乎<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="external">这里</a>有各种推荐，自己可以参考的看看。</p>
<p>godaddy地址: <a href="https://www.godaddy.com/" target="_blank" rel="external">https://www.godaddy.com</a></p>
<p>阿里云域名地址: <a href="http://wanwang.aliyun.com/" target="_blank" rel="external">http://wanwang.aliyun.com</a></p>
<p>2、到自己的gitHubPages的ip地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ping http://xiaqunfeng.github.io</div><div class="line">PING github.map.fastly.net (151.101.192.133): 56 data bytes</div><div class="line">64 bytes from 151.101.192.133: icmp_seq=0 ttl=49 time=62.670 ms</div><div class="line">64 bytes from 151.101.192.133: icmp_seq=1 ttl=49 time=65.062 ms</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里IP地址为：<code>151.101.192.133</code></p>
<p>3、域名绑定IP地址</p>
<p>登录自己购买域名的地方，找到域名相关选项</p>
<p>添加域名</p>
<p>添加记录：一个主机记录 <code>@</code>， 一个为<code>www</code>，记录值都是博客主页对应的ip。 </p>
<p>等待生效，最迟72小时生效，然后就可通过域名浏览你的博客主页了。</p>
]]></content>
    </entry>
    
  
  
</search>
