<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[XFS vs EXT4]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/XFS-vs-EXT4/</url>
      <content type="html"><![CDATA[<p>ceph默认的文件系统是XFS，centos7之前的版本默认文件系统是EXT4，现在是XFS，这里对比了一下，然后针对4k大小的随机读写进行了小小的测试。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux操作系统有很多不同的文件系统选择，所有现有的默认文件系统都是ext4。 通常文件系统被用来处理当程序不再使用信息之后如何保存信息，如何管理信息的可访问性，其他信息（元数据）与数据本身如何相关联等。</p>
<h2 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h2><p>Ext4是第四代扩展文件系统的缩写，它是2008年推出的。它是一个真正可靠的文件系统，它几乎在过去几年的大部分发行版中一直是默认选项，它是由比较老的代码生成的。它是一个日志文件系统，意味着它会对文件在磁盘中的位置以及任何其它对磁盘的更改做记录。如果系统崩溃，得益于journal技术，文件系统很少会损坏。</p>
<p>最大单个文件大小可以从16 GB到16 TB<br>最大文件系统大小为1EB（exabyte）<br>最大值包含64,000个子目录（ext3中的32,000个）</p>
<h2 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h2><p>XFS是由SGI为其IRIX平台设计的高性能64位日志文件系统。 XFS具有各种改进，使其能够在文件系统群体列表中脱颖而出，例如用于元数据操作的日志记录，可扩展/并行I / O，挂起/恢复I / O，在线碎片整理，延迟性能分配，等等</p>
<p>大概在2002年，XFS被合入Linux内核，2009年RHEL Linux版本5.4使用了XFS文件系统。 由于其高性能，架构可扩展性和鲁棒性，XFS一直是很多企业系统的首选，特别是拥有大量数据的企业系统。 现在，RHEL / CentOS 7和Oracle Linux使用XFS作为其默认文件系统。</p>
<p>最大单个文件大小可以是16 TB到16 Exabytes<br>最大文件系统大小为8EB（exabyte）<br>缺点：XFS文件系统不能缩小，当删除大量文件时会性能下降。</p>
<h2 id="更多对比"><a href="#更多对比" class="headerlink" title="更多对比"></a>更多对比</h2><ul>
<li>ext4不支持透明压缩、重复数据删除或者透明加密。技术上支持了快照，但该功能还处于实验性阶段。xfs也不能压缩，XFS 是基于B+ Ttree 管理元数据，即将支持reflink, dedupe等高级特性。</li>
<li>Ext4受限制于磁盘结构和兼容问题，可扩展性和scalability不如XFS。</li>
<li>虽然Ext4 目录索引采用了Hash Index Tree, 但是依然限制高度为2。</li>
<li>由于历史磁盘结构原因Ext4 的inode 个数限制(32位数)最多只能有大概40多亿文件。而且Ext4的单个文件大小最大只能支持到16T(4K block size) ，目前来说已经是瓶颈。XFS使用64位管理空间，文件系统规模可以达到EB级别。</li>
</ul>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>测试了一下4k随机读写的性能，direct=1，numjobs=20，iodepth=128</p>
<p>磁盘信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Disk /dev/sdc1: 4000.8 GB, 4000785104896 bytes, 7814033408 sectors</div><div class="line">Units = sectors of 1 * 512 = 512 bytes</div><div class="line">Sector size (logical/physical): 512 bytes / 512 bytes</div><div class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</div></pre></td></tr></table></figure>
<p>测试数据</p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>4k-randread</th>
<th>4k-read</th>
<th>4k-randwrite</th>
<th>4k-write</th>
</tr>
</thead>
<tbody>
<tr>
<td>XFS</td>
<td>iops=426</td>
<td>iops=42773</td>
<td>iops=313</td>
<td>iops=24732</td>
</tr>
<tr>
<td>EXT4</td>
<td>iops=430</td>
<td>iops=41636</td>
<td>iops=315</td>
<td>iops=19095</td>
</tr>
</tbody>
</table>
<p>在4k这个量级上IOPS基本没啥区别，4k随机写XFS略好于EXT4。</p>
<p>性能方面的对比：<a href="http://www.cnblogs.com/tommyli/p/3201047.html" target="_blank" rel="external">ext3，ext4，xfs和btrfs文件系统性能对比</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext3/4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Create a file system</td>
<td>mkfs.ext4 or mkfs.ext3</td>
<td>mkfs.xfs</td>
</tr>
<tr>
<td>File system check</td>
<td>e2fsck</td>
<td>xfs_repair</td>
</tr>
<tr>
<td>Resizing a file system</td>
<td>resize2fs</td>
<td>xfs_growfs</td>
</tr>
<tr>
<td>Save an image of a file system</td>
<td>e2image</td>
<td>xfs_metadump and xfs_mdrestore</td>
</tr>
<tr>
<td>Label or tune a file system</td>
<td>tune2fs</td>
<td>xfs_admin</td>
</tr>
<tr>
<td>Backup a file system</td>
<td>dump and restore</td>
<td>xfsdump and xfsrestore</td>
</tr>
</tbody>
</table>
<h2 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quota</td>
<td>quota</td>
<td>xfs_quota</td>
</tr>
<tr>
<td>File mapping</td>
<td>filefrag</td>
<td>xfs_bmap</td>
</tr>
</tbody>
</table>
<p>文件系统之间更多的参数和功能的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems" target="_blank" rel="external">Comparison of file systems</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph luminous新命令探索]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/ceph-luminous%E6%96%B0%E5%91%BD%E4%BB%A4%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>在luminous版本中有好多新命令，来逐一探索一下。<br><a id="more"></a></p>
<h2 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h2><p>这个命令之前就说过了，这个来个对比吧。</p>
<p>luminous版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   10 pools, 192 pgs</div><div class="line">    objects: 251 objects, 10685 bytes</div><div class="line">    usage:   9156 MB used, 41538 MB / 50694 MB avail</div><div class="line">    pgs:     192 active+clean</div></pre></td></tr></table></figure></p>
<p>kraken版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;test0=172.20.2.235:6789/0,test1=172.20.2.236:6789/0,test2=172.20.2.237:6789/0&#125;</div><div class="line">            election epoch 8, quorum 0,1,2 test0,test1,test2</div><div class="line">        mgr active: test2 standbys: test1, test0</div><div class="line">     osdmap e28: 6 osds: 6 up, 6 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v11414: 320 pgs, 2 pools, 149 MB data, 68 objects</div><div class="line">            609 MB used, 30044 MB / 30653 MB avail</div><div class="line">                 320 active+clean</div></pre></td></tr></table></figure></p>
<h2 id="CEPH-OSD"><a href="#CEPH-OSD" class="headerlink" title="CEPH OSD"></a>CEPH OSD</h2><h3 id="ceph-osd-ls-tree"><a href="#ceph-osd-ls-tree" class="headerlink" title="ceph osd ls-tree"></a>ceph osd ls-tree</h3><p>功能：</p>
<p>将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd ls-tree &lt;name&gt;</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ceph osd ls-tree default</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd ls-tree default~ssd</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-add-rm-noout-noin-nodown-noup"><a href="#ceph-osd-add-rm-noout-noin-nodown-noup" class="headerlink" title="ceph osd {add, rm} - {noout, noin, nodown, noup}"></a>ceph osd {add, rm} - {noout, noin, nodown, noup}</h3><p>功能：</p>
<p>允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd &#123;add, rm&#125;-&#123;noout, noin, nodown, noup&#125; &lt;ids&gt; [&lt;ids&gt;...]</div></pre></td></tr></table></figure>
<p>意义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mark osd(s) &lt;id&gt; [&lt;id&gt;...] as &#123;noout, noin, nodown, noup&#125;, or use &lt;all|any|*&gt; to mark all osds as &#123;noout, noin, nodown, noup&#125;</div><div class="line">allow osd(s) &lt;id&gt; [&lt;id&gt;...] to be marked &#123;out, in, down, up&#125; (if they are currently marked as noout, noin, nodown, noup),can use &lt;all|any|*&gt; to automatically filter out all nodown osds</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd add-noout 1 4</div><div class="line"># ceph osd rm-noout 1 4</div><div class="line"># ceph osd add-noout all</div><div class="line"># ceph osd rm-noout any</div></pre></td></tr></table></figure>
<p>查看某一个osd的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># ceph osd dump 1</div><div class="line">epoch 1</div><div class="line">fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">created 2017-06-29 15:34:07.310885</div><div class="line">modified 2017-06-29 15:34:07.310885</div><div class="line">flags sortbitwise</div><div class="line">crush_version 1</div><div class="line">full_ratio 0.95</div><div class="line">backfillfull_ratio 0.9</div><div class="line">nearfull_ratio 0.85</div><div class="line">require_min_compat_client jewel</div><div class="line">min_compat_client jewel</div><div class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</div><div class="line">max_osd 0</div></pre></td></tr></table></figure>
<blockquote>
<p>这里其实并不会显示标记</p>
</blockquote>
<p><strong>原先的标记命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd &#123;set, unset&#125; &#123;noout, noin, nodown, noup&#125;</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-crush-swap-bucket"><a href="#ceph-osd-crush-swap-bucket" class="headerlink" title="ceph osd crush swap-bucket"></a>ceph osd crush swap-bucket</h3><p>功能：</p>
<p>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush swap-bucket &lt;source&gt; &lt;dest&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swap existing bucket contents from (orphan) bucket &lt;source&gt; and &lt;target&gt;</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-destroy"><a href="#ceph-osd-destroy" class="headerlink" title="ceph osd destroy"></a>ceph osd destroy</h3><p>功能：</p>
<p>将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。简单来说</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd destroy &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mark osd as being destroyed. Keeps the ID intact (allowing reuse), but removes cephx keys,config-key data and lockbox keys, rendering data permanently unreadable.</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ceph osd destroy 1</div><div class="line">Error EPERM: Are you SURE? This will mean real, permanent data loss, as well as cephx and lockbox keys. Pass --yes-i-really-mean-it if you really do.</div><div class="line"></div><div class="line"># ceph osd destroy 1 --yes-i-really-mean-it</div><div class="line">Error EBUSY: osd.1 is not `down`.</div><div class="line"></div><div class="line"># ceph osd down 1</div><div class="line">marked down osd.1.</div></pre></td></tr></table></figure>
<blockquote>
<p>这里有个奇怪的现象，执行 ceph osd down 发现osd 还是 up的状态，一直无果，最终还是停掉进程使其 down</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl stop ceph-osd@1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd destroy 1 --yes-i-really-mean-it</div><div class="line">destroyed osd.1</div></pre></td></tr></table></figure>
<p>此时，osd.1 还在集群中，只不过已经清理了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd stat</div><div class="line">6 osds: 5 up, 5 in</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line"> -1 0.05699 root default</div><div class="line"> -2 0.01900     host luminous0</div><div class="line">  1 0.00999         osd.1             down        0          1.00000</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-purge"><a href="#ceph-osd-purge" class="headerlink" title="ceph osd purge"></a>ceph osd purge</h3><p>功能：</p>
<p>将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osd purge &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">purge all osd data from the monitors. Combines `osd destroy`, `osd rm`, and `osd crush rm`</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd purge 1 --yes-i-really-mean-it</div><div class="line">purged osd.1</div></pre></td></tr></table></figure>
<p>此时发现osd已经不再集群中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd stat</div><div class="line">5 osds: 5 up, 5 in</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">-1 0.04799 root default</div><div class="line"> -2 0.00999     host luminous0</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="ceph-osd-rewightn"><a href="#ceph-osd-rewightn" class="headerlink" title="ceph osd rewightn"></a>ceph osd rewightn</h3><blockquote>
<p>该命令没试验成功！！</p>
</blockquote>
<p>功能：</p>
<p>在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code>命令。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd reweightn &lt;weights&gt;</div></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div></pre></td></tr></table></figure>
<p>单个osd的rewight命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph osd reweight &lt;osdname (id|osd.id)&gt; &lt;float[0.0-1.0]&gt;</div><div class="line">explain: reweight osd to 0.0 &lt; &lt;weight&gt; &lt; 1.0</div></pre></td></tr></table></figure>
<p>我当前osd状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line"> -1 0.05699 root default</div><div class="line"> -2 0.01900     host luminous0</div><div class="line">  1 0.00999         osd.1               up  1.00000          1.00000</div><div class="line">  5 0.00999         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01900     host luminous2</div><div class="line">  0 0.00999         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00999         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01900     host luminous1</div><div class="line">  2 0.00999         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00999         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph osd reweightn &#123;5:0.02, 4:0.03, 2:0.01&#125;</div><div class="line">Invalid command:  unused arguments: [u&apos;4:0.03,&apos;, u&apos;2:0.01&#125;&apos;]</div><div class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div><div class="line">Error EINVAL: invalid command</div><div class="line"></div><div class="line"># ceph osd reweightn 5:0.02</div><div class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;5:0.02&apos;</div><div class="line"></div><div class="line"># ceph osd reweightn &#123;5:0.02&#125;</div><div class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;&#123;5:0.02&#125;&apos;</div><div class="line"></div><div class="line"># ceph osd reweightn osd.5  0.02</div><div class="line">Invalid command:  unused arguments: [u&apos;0.02&apos;]</div><div class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</div><div class="line">Error EINVAL: invalid command</div></pre></td></tr></table></figure>
<blockquote>
<p>该命令好像有问题，没有get到正确的姿势，有知道的请指正</p>
</blockquote>
<h2 id="ceph-log-last-n"><a href="#ceph-log-last-n" class="headerlink" title="ceph log last [n]"></a>ceph log last [n]</h2><p>输出集群日志的最后 n 行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph log last 10</div><div class="line">2017-06-30 17:13:14.216738 osd.3 osd.3 172.20.2.244:6804/38283 4 : cluster [INF] 0.d scrub ok</div><div class="line">2017-06-30 17:14:32.906853 osd.1 osd.1 172.20.2.243:6801/43997 5 : cluster [INF] 0.f scrub starts</div><div class="line">2017-06-30 17:14:32.908231 osd.1 osd.1 172.20.2.243:6801/43997 6 : cluster [INF] 0.f scrub ok</div><div class="line">2017-06-30 17:26:28.012607 osd.4 osd.4 172.20.2.245:6804/38814 5 : cluster [INF] 6.6 scrub starts</div><div class="line">2017-06-30 17:26:28.017546 osd.4 osd.4 172.20.2.245:6804/38814 6 : cluster [INF] 6.6 scrub ok</div><div class="line">2017-06-30 17:28:13.016525 osd.5 osd.5 172.20.2.243:6805/45058 3 : cluster [INF] 0.28 scrub starts</div><div class="line">2017-06-30 17:28:13.017914 osd.5 osd.5 172.20.2.243:6805/45058 4 : cluster [INF] 0.28 scrub ok</div><div class="line">2017-06-30 17:28:13.026468 osd.4 osd.4 172.20.2.245:6804/38814 7 : cluster [INF] 0.33 deep-scrub starts</div><div class="line">2017-06-30 17:28:13.027690 osd.4 osd.4 172.20.2.245:6804/38814 8 : cluster [INF] 0.33 deep-scrub ok</div><div class="line">2017-06-30 17:32:53.687436 mon.luminous0 mon.0 172.20.2.243:6789/0 357 : audit [INF] from=&apos;client.? 172.20.2.243:0/3812708038&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;log last&quot;, &quot;num&quot;: 5&#125;]: dispatch</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是显示集群的最近 n 条日志，不是某一个日志文件里的，比如 <code>/var/log/ceph/ceph.log</code> 等。</p>
</blockquote>
<p>这对调试比较有用，不用去打开日志查看了</p>
<h2 id="ceph-features"><a href="#ceph-features" class="headerlink" title="ceph features"></a>ceph features</h2><p>查询所有连接的守护进程和客户端的支持特性和版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># ceph features</div><div class="line">&#123;</div><div class="line">    &quot;mon&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 14</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;mds&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 1</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;osd&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 6</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;client&quot;: &#123;</div><div class="line">        &quot;group&quot;: &#123;</div><div class="line">            &quot;features&quot;: 1152323339925389307,</div><div class="line">            &quot;release&quot;: &quot;luminous&quot;,</div><div class="line">            &quot;num&quot;: 2</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ceph-mgr-dump"><a href="#ceph-mgr-dump" class="headerlink" title="ceph mgr dump"></a>ceph mgr dump</h2><p>dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ceph mgr dump</div><div class="line">&#123;</div><div class="line">    &quot;epoch&quot;: 15,</div><div class="line">    &quot;active_gid&quot;: 34310,</div><div class="line">    &quot;active_name&quot;: &quot;luminous0&quot;,</div><div class="line">    &quot;active_addr&quot;: &quot;172.20.2.243:6800/71321&quot;,</div><div class="line">    &quot;available&quot;: true,</div><div class="line">    &quot;standbys&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ceph-config-key"><a href="#ceph-config-key" class="headerlink" title="ceph config-key"></a>ceph config-key</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config-key del &lt;key&gt;						delete &lt;key&gt;</div><div class="line">config-key dump 							dump keys and values</div><div class="line">config-key exists &lt;key&gt;						check for &lt;key&gt;&apos;s existence</div><div class="line">config-key get &lt;key&gt; 						get &lt;key&gt;</div><div class="line">config-key list 							list keys</div><div class="line">config-key put &lt;key&gt; &#123;&lt;val&gt;&#125;				put &lt;key&gt;, value &lt;val&gt;</div><div class="line">config-key rm &lt;key&gt; 						rm &lt;key&gt;</div></pre></td></tr></table></figure>
<p>比如，dump出config-key entries及其内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph config-key dump</div><div class="line">&#123;</div><div class="line">    &quot;initial_mon_keyring&quot;: &quot;AQDfMxVZAAAAABAAA1za9TC3Z2kmEdlVZL6gGQ==&quot;,</div><div class="line">    &quot;mgr/dashboard/server_addr&quot;: &quot;172.20.2.243&quot;,</div><div class="line">    &quot;mgr/dashboard/server_port&quot;: &quot;7000&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>list，只dump出key，不包含value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph config-key list</div><div class="line">[</div><div class="line">    &quot;initial_mon_keyring&quot;,</div><div class="line">    &quot;mgr/dashboard/server_addr&quot;,</div><div class="line">    &quot;mgr/dashboard/server_port&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="ceph-mon-feature-list"><a href="#ceph-mon-feature-list" class="headerlink" title="ceph mon feature list"></a>ceph mon feature list</h2><p>列出MonMap中记录的monitor功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ceph mon feature list</div><div class="line">all features</div><div class="line">	supported: [kraken,luminous]</div><div class="line">	persistent: [kraken,luminous]</div><div class="line">on current monmap (epoch 1)</div><div class="line">	persistent: [kraken,luminous]</div><div class="line">	required: [kraken,luminous]</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous新功能之crush class]]></title>
      <url>http://xiaqunfeng.cc/2017/07/04/ceph-Luminous%E6%96%B0%E5%8A%9F%E8%83%BD%E4%B9%8Bcrush-class/</url>
      <content type="html"><![CDATA[<p>cursh class为新增的管理设备类的功能，可以将特定一组设备指定为类，创建rule的时候直接指定class即可，以前也可以实现该功能，只不过需要编辑crushmap，手动添加class。该功能只需要命令行就可以实现。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集群情况和上一篇文章一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   7 pools, 112 pgs</div><div class="line">    objects: 240 objects, 3359 bytes</div><div class="line">    usage:   9245 MB used, 51587 MB / 60833 MB avail</div><div class="line">    pgs:     112 active+clean</div></pre></td></tr></table></figure>
<h2 id="关于之前的crush"><a href="#关于之前的crush" class="headerlink" title="关于之前的crush"></a>关于之前的crush</h2><h3 id="完全手动管理crush"><a href="#完全手动管理crush" class="headerlink" title="完全手动管理crush"></a>完全手动管理crush</h3><p>1、在 <code>ceph.conf</code> 配置中将挂钩关掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">osd_crush_update_on_start = false</div></pre></td></tr></table></figure>
<p>2、部署OSD</p>
<p>3、手动创建所有的 CRUSH buckets</p>
<p>4、手动在每个 buckets 中放置 OSD</p>
<p>每当新加入、移除一个节点，或者将OSD从一个 host 移到另一个 host 时，也必须手动更改 CRUSH map。</p>
<h3 id="CEPH-CRUSH-LOCATION-挂钩"><a href="#CEPH-CRUSH-LOCATION-挂钩" class="headerlink" title="CEPH-CRUSH-LOCATION 挂钩"></a>CEPH-CRUSH-LOCATION 挂钩</h3><p>定义 osd_crush_location_hook，它可以让你定义一个路径去执行脚本，允许你自动处理以上过程。</p>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myhook --cluster &lt;cluster_name&gt; --id &lt;id&gt; --type osd</div></pre></td></tr></table></figure>
<p>集群名通常是 ceph ， id 是守护进程标识符（ OSD 号）。</p>
<h2 id="CRUSH-devices-class"><a href="#CRUSH-devices-class" class="headerlink" title="CRUSH devices class"></a>CRUSH devices class</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这么做的目的是为ceph不同类型的设备（HDD,SSD,NVMe）提供一个合理的默认，以便用户不必自己手动编辑指定。这相当于给磁盘组一个统一的class标签，根据class创建rule，然后根据role创建pool，整个操作不需要手动修改crushmap。</p>
<h3 id="创建两个-class"><a href="#创建两个-class" class="headerlink" title="创建两个 class"></a>创建两个 class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush class ls</div><div class="line">[]</div><div class="line"># ceph osd crush class create hdd</div><div class="line">created class hdd with id 0 to crush map</div><div class="line"># ceph osd crush class create ssd</div><div class="line">created class ssd with id 1 to crush map</div><div class="line"># ceph osd crush class ls</div><div class="line">[</div><div class="line">    &quot;hdd&quot;,</div><div class="line">    &quot;ssd&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>根据class，可以对osd进行以下两种操作：</p>
<p>1、部署OSD时指定 class，比如，指定部署磁盘所在的 OSD 到指定 class 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-disk prepare --crush-device-class &lt;class&gt; /dev/XXX</div></pre></td></tr></table></figure>
<p>2、将现有 osd 加入到指定 class 中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd crush set-device-class osd.&lt;id&gt; &lt;class&gt;</div></pre></td></tr></table></figure>
<p><strong> 以下对第二种操作进行实验，也是使用最多的。</strong></p>
<h3 id="当前OSD-分布"><a href="#当前OSD-分布" class="headerlink" title="当前OSD 分布"></a>当前OSD 分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME          UP/DOWN REWEIGHT PRIMARY-AFFINITY</div><div class="line">-1 0.05814 root default</div><div class="line">-2 0.01938     host luminous0</div><div class="line"> 1 0.00969         osd.1           up  1.00000          1.00000</div><div class="line"> 5 0.00969         osd.5           up  1.00000          1.00000</div><div class="line">-3 0.01938     host luminous2</div><div class="line"> 0 0.00969         osd.0           up  1.00000          1.00000</div><div class="line"> 4 0.00969         osd.4           up  1.00000          1.00000</div><div class="line">-4 0.01938     host luminous1</div><div class="line"> 2 0.00969         osd.2           up  1.00000          1.00000</div><div class="line"> 3 0.00969         osd.3           up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="为class添加osd"><a href="#为class添加osd" class="headerlink" title="为class添加osd"></a>为class添加osd</h3><p>将0、1、2分到hdd class，3、4、5分到ssd class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># for i in 0 1 2; do ceph osd crush set-device-class osd.$i hdd; done</div><div class="line">set-device-class item id 3 name &apos;osd.0&apos; device_class hdd</div><div class="line">set-device-class item id 4 name &apos;osd.1&apos; device_class hdd</div><div class="line">set-device-class item id 5 name &apos;osd.2&apos; device_class hdd</div><div class="line"># for i in 3 4 5; do ceph osd crush set-device-class osd.$i ssd; done</div><div class="line">set-device-class item id 3 name &apos;osd.3&apos; device_class ssd</div><div class="line">set-device-class item id 4 name &apos;osd.4&apos; device_class ssd</div><div class="line">set-device-class item id 5 name &apos;osd.5&apos; device_class ssd</div></pre></td></tr></table></figure>
<h3 id="再查看osd分布"><a href="#再查看osd分布" class="headerlink" title="再查看osd分布"></a>再查看osd分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID  WEIGHT  TYPE NAME              UP/DOWN REWEIGHT PRIMARY-AFFINITY</div><div class="line">-12 0.02907 root default~ssd</div><div class="line"> -9 0.00969     host luminous0~ssd</div><div class="line">  5 0.00969         osd.5               up  1.00000          1.00000</div><div class="line">-10 0.00969     host luminous2~ssd</div><div class="line">  4 0.00969         osd.4               up  1.00000          1.00000</div><div class="line">-11 0.00969     host luminous1~ssd</div><div class="line">  3 0.00969         osd.3               up  1.00000          1.00000</div><div class="line"> -8 0.02907 root default~hdd</div><div class="line"> -5 0.00969     host luminous0~hdd</div><div class="line">  1 0.00969         osd.1               up  1.00000          1.00000</div><div class="line"> -6 0.00969     host luminous2~hdd</div><div class="line">  0 0.00969         osd.0               up  1.00000          1.00000</div><div class="line"> -7 0.00969     host luminous1~hdd</div><div class="line">  2 0.00969         osd.2               up  1.00000          1.00000</div><div class="line"> -1 0.05814 root default</div><div class="line"> -2 0.01938     host luminous0</div><div class="line">  1 0.00969         osd.1               up  1.00000          1.00000</div><div class="line">  5 0.00969         osd.5               up  1.00000          1.00000</div><div class="line"> -3 0.01938     host luminous2</div><div class="line">  0 0.00969         osd.0               up  1.00000          1.00000</div><div class="line">  4 0.00969         osd.4               up  1.00000          1.00000</div><div class="line"> -4 0.01938     host luminous1</div><div class="line">  2 0.00969         osd.2               up  1.00000          1.00000</div><div class="line">  3 0.00969         osd.3               up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="创建rule"><a href="#创建rule" class="headerlink" title="创建rule"></a>创建rule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule create-simple hdd-rule default~ssd host firstn</div><div class="line">Invalid command:  invalid chars ~ in default~ssd</div><div class="line">osd crush rule create-simple &lt;name&gt; &lt;root&gt; &lt;type&gt; &#123;firstn|indep&#125; :  create crush rule &lt;name&gt; to start from &lt;root&gt;, replicate across buckets of type &lt;type&gt;, using a choose mode of &lt;firstn|indep&gt; (default firstn; indep best for erasure pools)</div><div class="line">Error EINVAL: invalid command</div></pre></td></tr></table></figure>
<p>这里出现错误，我在想，是不是 class name 不用带上 <code>default~</code> 这个符号，于是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule create-simple hdd-rule ssd host firstn</div><div class="line">Error ENOENT: root item ssd does not exist</div></pre></td></tr></table></figure>
<p>依然出错，这是个<a href="http://tracker.ceph.com/issues/20446" target="_blank" rel="external">bug</a>，还在 <a href="https://github.com/ceph/ceph/pull/16027" target="_blank" rel="external">merge 中</a></p>
<blockquote>
<p>先跳过这个直接创建rule关联class的命令，后续BUG修复了再来实验</p>
</blockquote>
<h3 id="手动来创建rule"><a href="#手动来创建rule" class="headerlink" title="手动来创建rule"></a>手动来创建rule</h3><p>首先查看当前rule的状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule ls</div><div class="line">[</div><div class="line">    &quot;replicated_rule&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>只有一个默认的rule</p>
<p><strong> 第一步：获取crushmap </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd getcrushmap -o c1</div><div class="line">11</div></pre></td></tr></table></figure>
<p><strong>第二步：反编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># crushtool -d c1 -o c2.txt</div></pre></td></tr></table></figure>
<p>编辑crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim c2.txt</div></pre></td></tr></table></figure>
<p>在 <code># rule</code> 那一栏 <code>replicated_rule</code> 的后面添加 <code>hdd_rule</code> 和 <code>ssd_rule</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># rules</div><div class="line">rule replicated_rule &#123;</div><div class="line">        ruleset 0</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default</div><div class="line">        step chooseleaf firstn 0 type host</div><div class="line">        step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line">rule hdd_rule &#123;</div><div class="line">        ruleset 1</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default class hdd</div><div class="line">        step chooseleaf firstn 0 type osd</div><div class="line">        step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line">rule ssd_rule &#123;</div><div class="line">        ruleset 2</div><div class="line">        type replicated</div><div class="line">        min_size 1</div><div class="line">        max_size 10</div><div class="line">        step take default class ssd</div><div class="line">        step chooseleaf firstn 0 type osd</div><div class="line">        step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>第三步：编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># crushtool -c c2.txt -o c1.new</div></pre></td></tr></table></figure>
<p><strong>第四步：注入crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd setcrushmap -i c1.new</div><div class="line">12</div></pre></td></tr></table></figure>
<p>此时，查看rule</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph osd crush rule ls</div><div class="line">[</div><div class="line">    &quot;replicated_rule&quot;,</div><div class="line">    &quot;hdd_rule&quot;,</div><div class="line">    &quot;ssd_rule&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>有了新创建的两个rule</p>
<h2 id="测试一下，rule-绑定-class是否成功"><a href="#测试一下，rule-绑定-class是否成功" class="headerlink" title="测试一下，rule 绑定 class是否成功"></a>测试一下，rule 绑定 class是否成功</h2><p>1、在 ssd_rule 上创建一个 pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd pool create testpool 64 64 ssd_rule</div><div class="line">pool &apos;testpool&apos; created</div></pre></td></tr></table></figure>
<p>2、写一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rados -p testpool put object1 c2.txt</div></pre></td></tr></table></figure>
<p>3、查看对象的osdmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd map testpool object1</div><div class="line">osdmap e46 pool &apos;testpool&apos; (7) object &apos;object1&apos; -&gt; pg 7.bac5debc (7.3c) -&gt; up ([5,3,4], p5) acting ([5,3,4], p5)</div></pre></td></tr></table></figure>
<p>发现对象确实只写在 ssd class 所对应的 3个OSD（osd.3 osd.4 osd.5）上，rule绑定成功。</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous dashboard初探]]></title>
      <url>http://xiaqunfeng.cc/2017/06/29/ceph-Luminous%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>体验ceph luminous，并初步探测ceph luminous的相关功能，这里先来看看官方标配的仪表盘长啥样。<br><a id="more"></a></p>
<p>就冲这句话：Ceph now has a simple, built-in web-based dashboard for monitoring<br>cluster status，来一探究竟。</p>
<h2 id="Luminous集群"><a href="#Luminous集群" class="headerlink" title="Luminous集群"></a>Luminous集群</h2><p><strong>物理环境</strong></p>
<p>3个 host ，每个 host 含有 2 个OSD</p>
<p><strong>查看ceph版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph -v</div><div class="line">ceph version 12.1.0 (262617c9f16c55e863693258061c5b25dea5b086) luminous (dev)</div></pre></td></tr></table></figure>
<h3 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h3><p>查看集群状态，这里发现 <code>ceph -s</code> 信息和之前的不一样。（更多新的命令后续探索后奉上）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">  cluster:</div><div class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">    health: HEALTH_OK</div><div class="line"></div><div class="line">  services:</div><div class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</div><div class="line">    mgr: luminous0(active)</div><div class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</div><div class="line">    osd: 6 osds: 6 up, 6 in</div><div class="line"></div><div class="line">  data:</div><div class="line">    pools:   7 pools, 112 pgs</div><div class="line">    objects: 208 objects, 3359 bytes</div><div class="line">    usage:   6341 MB used, 54492 MB / 60833 MB avail</div><div class="line">    pgs:     112 active+clean</div></pre></td></tr></table></figure>
<p>这里我在机器 luminous0 上还部署了 mgr 和 mds。</p>
<blockquote>
<p>注意：mgr是高可用的，如果配置多个的话，会有standbys。我这里只配了一个 mgr，所以就只有active，没有standby。访问的时候，务必使用 active 进程所在节点的 IP ！！</p>
</blockquote>
<h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><h3 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h3><p>在所有运行了 ceph-mgr 守护进程的机器上编辑ceph配置文件 <code>/etc/ceph/ceph.conf</code> ，以启用 dashboard。</p>
<p>添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mgr]</div><div class="line">mgr_modules = dashboard</div></pre></td></tr></table></figure>
<p>注意：不要重启 ceph-mgr 进程，还有其他的配置要做。</p>
<h3 id="配置IP和端口"><a href="#配置IP和端口" class="headerlink" title="配置IP和端口"></a>配置IP和端口</h3><p>服务器地址和可选端口必须配置为 config-key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph config-key put mgr/dashboard/server_addr 172.20.2.243</div><div class="line">set mgr/dashboard/server_addr</div></pre></td></tr></table></figure>
<p>查看，发现<strong>默认端口是 7000</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># netstat -antpl | grep ceph-mgr | grep LISTEN</div><div class="line">tcp        0      0 0.0.0.0:6800            0.0.0.0:*               LISTEN      57645/ceph-mgr</div><div class="line">tcp        0      0 172.20.2.243:7000       0.0.0.0:*               LISTEN      57645/ceph-mgr</div></pre></td></tr></table></figure>
<p>当然，可以改为指定端口号，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph config-key put mgr/dashboard/server_port 8888</div></pre></td></tr></table></figure>
<h3 id="重启ceph-mgr"><a href="#重启ceph-mgr" class="headerlink" title="重启ceph-mgr"></a>重启ceph-mgr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># systemctl restart ceph-mgr@luminous0</div></pre></td></tr></table></figure>
<p>这时候就可以访问了。</p>
<h3 id="访问界面"><a href="#访问界面" class="headerlink" title="访问界面"></a>访问界面</h3><p><strong>1、主界面</strong>（Cluster health）</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-0.jpg" alt="dashboard"></p>
<p><strong>2、Servers界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-2.jpg" alt="servers"></p>
<p><strong>3、cephfs界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-1.jpg" alt="ceph-fs"></p>
<h2 id="使用后感想"><a href="#使用后感想" class="headerlink" title="使用后感想"></a>使用后感想</h2><p>1、这仅仅只是一个展示的界面，不能进行相关操作</p>
<p>2、关于 MONITORS 和 OSDS 的信息不能详细展开，更不能看到每台机器的情况</p>
<p>3、比起ceph周边的监控软件：calamari、VSM、inkscope、grafana等，相去甚远，当然，可以简单展示基本信息，还是不错的。</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph v12.1.0 Luminous RC released]]></title>
      <url>http://xiaqunfeng.cc/2017/06/28/Ceph-v12-1-0-Luminous-RC-released/</url>
      <content type="html"><![CDATA[<p>ceph L 版本终于出了一个候选release版本。来看看都有哪些新功能吧。<br><a id="more"></a></p>
<p>本文翻译自官网：<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/" target="_blank" rel="external">v12.1.0 Luminous RC released</a></p>
<p>Github：<a href="https://github.com/ceph/ceph/tree/luminous" target="_blank" rel="external">https://github.com/ceph/ceph/tree/luminous</a></p>
<h2 id="v12-1-0-Luminous-RC-released"><a href="#v12-1-0-Luminous-RC-released" class="headerlink" title="v12.1.0 Luminous RC released"></a>v12.1.0 Luminous RC released</h2><p>这是Luminous的第一个候选版本，下一个长期的稳定release。</p>
<p>Ceph Luminous将是下一个长期的稳定release系列的基础。 自Kraken（v11.2.z）和jewel（v10.2.z）以来，发生了重大的变化。</p>
<h2 id="Major-Changes-from-Kraken"><a href="#Major-Changes-from-Kraken" class="headerlink" title="Major Changes from Kraken"></a>Major Changes from Kraken</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>Ceph目前拥有一个简单的、内置的基于Web的仪表板，用于监控群集状态。</p>
<h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><p><strong>BlueStore</strong></p>
<ul>
<li>ceph-osd的新后端存储BlueStore已经稳定，并且是新建OSD的默认设置。 BlueStore通过直接管理物理磁盘（HDD或SSD）而不使用XFS之类的中间文件系统来管理存储在每个OSD上的数据，这提供了更好的性能和特性。</li>
<li>BlueStore对于通过ceph存储的数据支持完整数据和元数据校验。</li>
<li>BlueStore支持zlib、snappy或LZ4的在线压缩。（Ceph还支持zstd进行RGW压缩，但由于性能原因，不推荐BlueStore使用zstd）。<br>EC pools现在完全支持覆盖写，允许它们与RBD和CephFS一起使用。<a href="http://ceph.com/releases/rados/operations/erasure-code/#erasure-coding-with-overwrites" target="_blank" rel="external">Read more about EC overwrites**</a></li>
</ul>
<p><strong>ceph-mgr</strong></p>
<ul>
<li>ceph-mgr是一个新的进程，它是任何Ceph部署所必须的一部分。虽然当ceph-mgr停止时，可以继续下发IO，但是度量不会刷新，并且某些与度量相关的请求（如：ceph df）可能会阻塞。为了可靠性，我们建议部署ceph-mgr的多个实例。查看这里的注释<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/#id1" target="_blank" rel="external"><code>Upgrading</code>_</a> </li>
<li>ceph-mgr进程包括一个基于REST的管理API。 API仍然处于实验阶段，并有一定的限制，但未来将成为Ceph基于API管理的基础。</li>
</ul>
<p>集群的总体可扩展性有所提高。我们已经成功测试了多达10,000个OSD节点的集群。</p>
<ul>
<li>目前，每个OSD都具有与其相关联的设备类（例如，hdd或ssd），允许CRUSH规则将数据简单地映射到系统中的设备的子集。通常不需要手动编写CRUSH规则或手动编辑CRUSH。</li>
<li>现在可以优化CRUSH权重，以保持OSD之间数据的近乎完美的分布。</li>
<li>还有一个新的upmap异常处理机制，允许单个PG移动以实现完美的分布（这需要luminous的客户端）。</li>
<li>目前每个OSD可以根据后端设备是HDD还是SSD来调整其默认配置。一般不需要手动调整。</li>
<li>mclock QoS排队算法原型现在是可用的；</li>
<li>现在有一种 backoff 机制，可以防止OSD出现对当前不能处理IO的对象或PG的请求出现过载。</li>
<li>简化了OSD更换过程，并且更加鲁棒。</li>
<li>您可以使用 <code>ceph features</code> 来查询所有连接的守护进程和客户端的支持特性和版本。</li>
<li>您可以配置你想要最旧的Ceph客户端版本，并通过 <code>ceph osd set-require-min-compat-client</code> 命令连接到集群，Ceph将阻止您启用会破坏与这些客户端兼容性的特性。</li>
<li>一些 <code>sleep</code> 的设置，包括 <code>osd_recovery_sleep</code>，<code>osd_snap_trim_sleep</code> 和 <code>osd_scrub_sleep</code> 已经被重新实现，并且可以有效地工作。（这些在某些情况下用于解决问题，限制后台工作。）</li>
</ul>
<p><strong>RGW:</strong></p>
<ul>
<li>ElasticSearch支持的RGW元数据搜索现在通过RGW本身支持最终用户请求服务，并且还支持自定义元数据字段。查询语言是一组RESTful API，用户可以通过其元数据来搜索对象。还添加了允许自定义元数据字段控制的新API。</li>
<li>RGW支持动态存储桶索引分片（bucket index sharding）。随着桶中的对象数量的增加，RGW将自动重新构建桶索引。不需要用户干预或桶大小容量规划。</li>
<li>RGW引入了上传对象的服务器端加密，用于管理加密密钥的三个选项有：自动加密（仅推荐用于测试设置），客户提供的类似于Amazon SSE-C规范的密钥，以及通过使用外部密钥管理服务 （OpenstackBarbician）类似于Amazon SSE-KMS规范。</li>
<li>RGW具有初步的类似AWS的存储桶策略API支持。现在，策略是一种表达一系列新授权概念的方式。未来，这将成为附加身份验证功能的基础，例如STS和组策略等。</li>
<li>RGW通过使用rados命名空间合并了几个元数据索引池。</li>
</ul>
<p><strong>RBD:</strong></p>
<ul>
<li>RBD目前通过<code>rbd create</code>新的<code>--data-pool</code>选项，对EC pools有全面稳定的支持。</li>
<li>RBD镜像的rbd-mirror守护进程现在是高可用的。我们建议部署rbd-mirror的多个实例来实现可靠性。</li>
<li>在创建集群期间，不再自动创建默认的 <code>rbd</code> 存储池。另外，当没有指定池时，rbd CLI 使用的默认池的名称可以通过新的 <code>rbd default pool = &lt;pool name&gt;</code> 配置选项来覆盖。</li>
<li>通过新的 <code>rbd trash</code>  CLI命令初步支持延迟 image 删除。images，即使是由克隆主动使用的镜像，也可以移动到垃圾桶，并在以后删除。</li>
<li>新的管理池级别的命令 <code>rbd mirror pool promote</code> 和 <code>rbd mirror pool demote</code>可以批量提升/降级一个pool内所有的mirrored images。</li>
<li>mirroring 现在可以通过 <code>rbd mirroring replay delay = &lt;seconds&gt;</code> 配置选项支持可选择的配置复制延迟。</li>
<li>当对象map 特性启用时，可以提升丢弃处理功能。</li>
<li>rbd CLI <code>import</code> 和 <code>copy</code> 命令现在可以检测稀疏并保留稀疏区域。</li>
<li>snapshots现在将包含创建时间戳。</li>
</ul>
<p><strong>CephFS:</strong></p>
<ul>
<li>现在，多个活动的MDS守护进程是稳定的。活动的MDS服务器的数量可以基于活动的CephFS文件系统进行上下调整。</li>
<li>CephFS目录分片现在是稳定的，并且在新的文件系统上默认启用。要使其在现有的文件系统上启动，使用命令 <code>ceph fs set&lt;fs_name&gt; allow_dirfrags</code>。大的或非常繁忙的目录被分割并（可能）自动分布在多个MDS守护进程中。</li>
<li>在自动负载均衡不需要和无效的情况下，目录子树可以明确固定到特定的MDS守护进程。</li>
</ul>
<p><strong>Miscellaneous:</strong> </p>
<p>Debian Stretch现在正在构建版本包。我们现在构建的发行版包括： </p>
<ul>
<li>CentOS 7 (x86_64and aarch64)</li>
<li>Debian 8 Jessie(x86_64)</li>
<li>Debian 9 Stretch(x86_64)</li>
<li>Ubuntu 16.04 Xenial(x86_64 and aarch64)</li>
<li>Ubuntu 14.04Trusty (x86_64)</li>
</ul>
<p>注意 QA 仅限于 CentOS 和 Ubuntu (xenialand trusty).</p>
<p><strong>CLI 变化</strong></p>
<ul>
<li><code>ceph -s</code> 或者 <code>ceph status</code> 命令焕然一新。</li>
<li><code>ceph {osd，mds，mon} versions</code> 总结了运行中守护进程的版本。</li>
<li><code>ceph {osd，mds，mon} count-metadata &lt;property&gt;</code> 类似地列出通过 <code>ceph {osd，mds，mon} metadata</code> 命令可见的任何其他守护进程元数据。</li>
<li><code>ceph features</code> 总结了连接的客户端和守护进程的特性和版本。</li>
<li><code>ceph osd require-osd-release &lt;release&gt;</code> 替换旧的<code>require_RELEASE_osds</code> flags。</li>
<li><code>ceph osd pg-upmap</code>，<code>ceph osdrm-pg-upmap</code>，<code>ceph osd pg-upmap-items</code>，<code>ceph osdrm-pg-upmap-items</code>可以明确地管理upmap项目。</li>
<li><code>ceph osd getcrushmap</code>在stderr上返回一个crush map版本号，如果版本匹配，<code>ceph osd setcrushmap [version]</code> 将只会注入更新的crush map。这允许crush map进行离线更新，然后重新注入到群集中，而不用担心颠覆性的变化（例如，通过其他管理员新添加和修改osds）。</li>
<li><code>ceph osd create</code> 已被 <code>ceph osd new</code> 所替换。大多数用户应该使用像 <code>ceph-disk</code> 这样面向用户的工具来隐藏这个。</li>
<li><code>ceph osd destroy</code> 将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。</li>
<li><code>ceph osd purge</code> 将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</li>
<li><code>ceph osd ls-tree &lt;name&gt;</code> 将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。例如，<code>ceph osd down</code> ，<code>ceph osd ls-tree rack1</code>。</li>
<li><code>ceph osd {add，rm} - {noout，noin，nodown，noup}</code> 允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</li>
<li><code>ceph log last [n]</code> 将输出集群日志的最后n行。</li>
<li><code>ceph mgr dump</code> 将dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程。</li>
<li><code>ceph osd crush swap-bucket &lt;src&gt; &lt;dest&gt;</code>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</li>
<li><code>ceph osd set-require-min-compat-client &lt;release&gt;</code> 可以配置支持群集的最旧的客户端版本。其他更改，如CRUSH可调参数，如果违反此设置，将会失败并显示错误。如果当前连接到集群的客户端版本比指定版本还老旧，则更改此设置也将失败。</li>
<li><code>ceph config-key dump</code> dump出config-key entries及其内容。（已有的 <code>ceph config-key ls</code> 仅dump密钥名称，而不是值。）</li>
<li><code>ceph osd set-{full，nearfull，backfillfull}-ratio</code> 将集群范围的比例设置为各种全阈值（例如：当集群拒绝IO时，当集群警告接近满时，当OSD延迟PG重新平衡到本身时）。</li>
<li><code>ceph osd reweightn</code> 将在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code> 命令。</li>
<li><code>ceph crush class {create,rm,ls}</code> 管理新的CRUSH设备类功能。 <code>ceph crush set-device-class &lt;osd&gt; &lt;class&gt;</code> 将为特定设备设置class。</li>
<li><code>ceph mon feature list</code> 将列出MonMap中记录的monitor功能。<code>ceph mon feature set</code> 将设置一个可选功能（这些功能尚未存在）。</li>
</ul>
<h2 id="Major-Changes-from-Jewel"><a href="#Major-Changes-from-Jewel" class="headerlink" title="Major Changes from Jewel"></a>Major Changes from Jewel</h2><p><strong>RADOS</strong></p>
<ul>
<li>我们现在默认使用AsyncMessenger（ms type = async），而不是传统的SimpleMessenger。 最明显的区别是，我们现在使用固定大小的线程池进行网络连接（而不是使用SimpleMessenger每个socket两个线程）。</li>
<li>现在几乎可以马上检测到一些OSD故障，而之前的心跳超时（默认为20秒）必须过期。 当host保持up状态，但ceph-osd进程不再运行的故障出现时，可以防止IO长时间阻塞。</li>
<li>编码OSDMaps的大小已经减少了。</li>
<li>当recovery或rebalancing进行时，OSD现在会静止scrubbing。</li>
</ul>
<p><strong>RGW</strong></p>
<ul>
<li>RGW现在支持 S3 多部分对象部分复制（multipart object copy-part）API。</li>
<li>现在离线resharding一个现有的bucket是可能的。离线resharding bucket当前需要所有到这个指定bucket的IO（特别是writes）是静止的。（为了自动在线resharding，看上面Luminous的新特性）</li>
<li>RGW现在支持对对象的数据压缩。</li>
<li>Civetweb版本已经更新到1.8。</li>
<li>支持Swift静态网站API（之前的版本就已经支持S3）</li>
<li>S3 bucket生命周期 API 已添加。注意当前只支持对象到期。</li>
<li>支持用户自定义搜索过滤器已添加到 LDAP 认证实现中。</li>
<li>对NFS版本3的支持已添加到RGW NFS网关</li>
<li>已经为librgw创建了一个Python绑定</li>
</ul>
<p><strong>RBD</strong></p>
<ul>
<li>rbd-mirror守护进程现在支持从主image到非主image复制动态image特征更新和image元数据密钥/值对。</li>
<li>Image快照的数量可以可选地限制在可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<p><strong>CephFS</strong></p>
<ul>
<li>libcephfs函数定义已更改，以启用适当的uid / gid控件。library版本已经增加，以反映界面的变化。</li>
<li>standby replay MDS守护程序现在在执行删除的工作负载上消耗更少的内存。</li>
<li>Scrub 现在修复回溯，通常使用 <code>damage ls</code> 发现错误。</li>
<li>新 <code>pg_files</code> 子命令<code>cephfs-data-scan</code>可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性警告 <code>failing to respond to cache pressure</code> 已被修复。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wget批量下载http目录及文件]]></title>
      <url>http://xiaqunfeng.cc/2017/06/23/wget%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDhttp%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>有时候看到好的镜像，想保存下来，不可能一个个通过url手动来下载，这时候就需要批量下载了。<br><a id="more"></a></p>
<p>举个例子，我要下载的地址和内容如下：<br><img src="http://oow6unnib.bkt.clouddn.com/wget-http.jpg" alt="wget-http"></p>
<h2 id="得到页面的index-html"><a href="#得到页面的index-html" class="headerlink" title="得到页面的index.html"></a>得到页面的index.html</h2><p>我就在 <code>/root</code> 目录下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -m http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/</div></pre></td></tr></table></figure>
<p>得到<code>index.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># cat /root/mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/index.html</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;&lt;title&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/title&gt;&lt;/head&gt;</div><div class="line">&lt;body bgcolor=&quot;white&quot;&gt;</div><div class="line">&lt;h1&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a href=&quot;../&quot;&gt;../&lt;/a&gt;</div><div class="line">&lt;a href=&quot;repodata/&quot;&gt;repodata/&lt;/a&gt;                                          11-Apr-2017 03:06       -</div><div class="line">&lt;a href=&quot;ceph-10.1.0-0.el7.src.rpm&quot;&gt;ceph-10.1.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</div><div class="line">&lt;a href=&quot;ceph-10.1.1-0.el7.src.rpm&quot;&gt;ceph-10.1.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.1.2-0.el7.src.rpm&quot;&gt;ceph-10.1.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.0-0.el7.src.rpm&quot;&gt;ceph-10.2.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.1-0.el7.src.rpm&quot;&gt;ceph-10.2.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.2-0.el7.src.rpm&quot;&gt;ceph-10.2.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</div><div class="line">&lt;a href=&quot;ceph-10.2.3-0.el7.src.rpm&quot;&gt;ceph-10.2.3-0.el7.src.rpm&lt;/a&gt;                          17-Oct-2016 20:29      9M</div><div class="line">&lt;a href=&quot;ceph-10.2.4-0.el7.src.rpm&quot;&gt;ceph-10.2.4-0.el7.src.rpm&lt;/a&gt;                          07-Dec-2016 05:39     10M</div><div class="line">&lt;a href=&quot;ceph-10.2.5-0.el7.src.rpm&quot;&gt;ceph-10.2.5-0.el7.src.rpm&lt;/a&gt;                          05-Jan-2017 02:49     10M</div><div class="line">&lt;a href=&quot;ceph-10.2.6-0.el7.src.rpm&quot;&gt;ceph-10.2.6-0.el7.src.rpm&lt;/a&gt;                          08-Mar-2017 21:55     11M</div><div class="line">&lt;a href=&quot;ceph-10.2.7-0.el7.src.rpm&quot;&gt;ceph-10.2.7-0.el7.src.rpm&lt;/a&gt;                          11-Apr-2017 02:53     11M</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.29-0.src.rpm&quot;&gt;ceph-deploy-1.5.29-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.30-0.src.rpm&quot;&gt;ceph-deploy-1.5.30-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.31-0.src.rpm&quot;&gt;ceph-deploy-1.5.31-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.32-0.src.rpm&quot;&gt;ceph-deploy-1.5.32-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.33-0.src.rpm&quot;&gt;ceph-deploy-1.5.33-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.34-0.src.rpm&quot;&gt;ceph-deploy-1.5.34-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     94K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.35-0.src.rpm&quot;&gt;ceph-deploy-1.5.35-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.36-0.src.rpm&quot;&gt;ceph-deploy-1.5.36-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-deploy-1.5.37-0.src.rpm&quot;&gt;ceph-deploy-1.5.37-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</div><div class="line">&lt;a href=&quot;ceph-release-1-1.el7.src.rpm&quot;&gt;ceph-release-1-1.el7.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53    4186</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.5-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.5-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.6-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.6-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;a href=&quot;radosgw-agent-1.2.7-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.7-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</div><div class="line">&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h2><p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -nc -B http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/ -F -nH --cut-dirs=3 -i index.html</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nc</td>
<td>下载时跳过已经存在的文件</td>
</tr>
<tr>
<td>-B</td>
<td>使用 -F -i 文件选项时，在相对链接前添加指定的 URL</td>
</tr>
<tr>
<td>-nH</td>
<td>不创建主机名目录</td>
</tr>
<tr>
<td>-i</td>
<td>下载从指定文件中找到的 URL</td>
</tr>
<tr>
<td>-v</td>
<td>显示信息</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
<tr>
<td>-l</td>
<td>最大递归深度(inf 或 0 表示无限)</td>
</tr>
<tr>
<td>-F</td>
<td>以 HTML 方式处理输入文件</td>
</tr>
<tr>
<td>–cut-dir=num</td>
<td>忽略远程目录中指定数目的目录层</td>
</tr>
<tr>
<td>-E</td>
<td>将所有 MIME 类型为 text/html 的文件都加上 .html 扩展文件名</td>
</tr>
</tbody>
</table>
<p>更多关于参数的问题详见：<a href="http://jiaxl.blog.51cto.com/3064605/1191196" target="_blank" rel="external">wget参数介绍</a></p>
<p>然后就开始下载，直至完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">FINISHED --2017-06-23 18:11:54--</div><div class="line">Total wall clock time: 7m 31s</div><div class="line">Downloaded: 24 files, 103M in 7m 29s (234 KB/s)</div></pre></td></tr></table></figure></p>
<p>下载完成后列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># ll</div><div class="line">总用量 105264</div><div class="line">-rw-r--r--. 1 root root  8894228 6月  15 2016 ceph-10.1.0-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8942739 6月  15 2016 ceph-10.1.1-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8961123 6月  15 2016 ceph-10.1.2-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8967492 6月  15 2016 ceph-10.2.0-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8996472 6月  15 2016 ceph-10.2.1-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  8876099 6月  15 2016 ceph-10.2.2-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root  9044336 10月 17 2016 ceph-10.2.3-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 10849625 12月  7 2016 ceph-10.2.4-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 10795514 1月   5 02:49 ceph-10.2.5-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 11215646 3月   8 21:55 ceph-10.2.6-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root 11245006 4月  11 02:53 ceph-10.2.7-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92710 4月  11 02:53 ceph-deploy-1.5.29-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92915 4月  11 02:53 ceph-deploy-1.5.30-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    92953 4月  11 02:53 ceph-deploy-1.5.31-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    93493 4月  11 02:53 ceph-deploy-1.5.32-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    93323 4月  11 02:53 ceph-deploy-1.5.33-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    96664 4月  11 02:53 ceph-deploy-1.5.34-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    97010 4月  11 02:53 ceph-deploy-1.5.35-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    96998 4月  11 02:53 ceph-deploy-1.5.36-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root    97146 4月  11 02:53 ceph-deploy-1.5.37-0.src.rpm</div><div class="line">-rw-r--r--. 1 root root     4186 4月  11 02:53 ceph-release-1-1.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root     3189 6月  23 18:01 index.html</div><div class="line">-rw-r--r--. 1 root root    30175 4月  11 02:53 radosgw-agent-1.2.5-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    29980 4月  11 02:53 radosgw-agent-1.2.6-0.el7.src.rpm</div><div class="line">-rw-r--r--. 1 root root    30044 4月  11 02:53 radosgw-agent-1.2.7-0.el7.src.rpm</div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公有云和私有云的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/%E5%85%AC%E6%9C%89%E4%BA%91%E5%92%8C%E7%A7%81%E6%9C%89%E4%BA%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>介绍了一下公有云和私有云的区别，以及该如何选择。<br><a id="more"></a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/public-private-cloud.jpg" alt="public-private-cloud"></p>
<h2 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h2><p>这是一个可以存在于公司的托管数据中心的云主机解决方案，所有信息都在专用防火墙后面。一般来说，公司已经选择为其数据中心付出了相当大的代价，并仍然希望使用其已建立的基础设施。这是一个主要的优势，也是私有云与公共云的辩论在这个特定主题上如此激烈的一个重要原因。</p>
<p>然而，私有云的一个重大问题是维护、更新和整体管理数据中心所需的资源属于公司本身。这是在选择私有云时通常不能正确计算的费用。维护包括：一旦旧的服务器被不堪重负或过期，必须购买新的服务器，并通过公司本身来整合最新的技术。</p>
<p>当然，由于私有云的资源基本上与系统外的任何人都不共享，因此维护安全性要容易得多，这可能是选择公有云与私有云时的决定因素。</p>
<h2 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h2><p>公有云是在其网站上托管大量企业、个人和组织的公共云。公有云管理系统提供的最大优势是，企业或组织无需负责，由主办公司接管。你的所有数据都由提供商存储在他们的数据中心，并负责管理和更新。</p>
<p>这样做的优势是相当大的，因为这显著的降低了存储信息的成本。这对于没有广泛且已到位的基础设施的公司也是有利的。此外，降低了测试和推出新产品的交付时间。</p>
<p>然而，与私有云系统相比最大的缺点是缺乏安全性。这就是为什么许多企业正在讨论对公有、私有云计算的倾向，即使意味着更大的费用，也会倾向于安全。虽然公共云系统确实具有广泛的安全性，事实上，由于增加的公司数量是相当大的担忧，所以系统的任何攻击，违规或崩溃都会更大。</p>
<p>应该注意的是，每个公司的数据都是分开的，尽管过去几年的头条新闻中，公有云系统的安全漏洞也比较少见。这就是为什么在公有云 vs 私有云的辩论中，答案往往会归结为公司的需求和预算。</p>
]]></content>
      
        
        <tags>
            
            <tag> cloud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 7下操纵ceph进程]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/centos-7%E4%B8%8B%E6%93%8D%E7%BA%B5ceph%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>分享一个以前的笔记。官网给的通过<code>/etc/init.d/ceph</code>stop、start等命令在centos7下不行，service命令也是不行的。现在都使用原生的 systemd 来管理ceph进程。<br><a id="more"></a></p>
<h2 id="操作集群"><a href="#操作集群" class="headerlink" title="操作集群"></a>操作集群</h2><p>在<a href="http://docs.ceph.org.cn/rados/operations/operating/" target="_blank" rel="external">官方文档</a>中给出了几种操作方法：</p>
<p><strong>1、用 UPSTART 控制 CEPH</strong></p>
<p>用 ceph-deploy 把 Ceph Cuttlefish 及更高版部署到 Ubuntu 之后，你可以用基于事件的 Upstart来启动、关闭 Ceph 节点上的守护进程。 Upstart 不要求你在配置文件里定义守护进程例程。</p>
<p><strong>2、通过 SYSVINIT 机制运行 CEPH</strong></p>
<p>在 CentOS 、 Redhat 、 Fedora 和 SLES 发行版上可以通过传统的 sysvinit 运行 Ceph ， Debian/Ubuntu 的较老的版本也可以用此方法。</p>
<p><strong>3、把 CEPH 当服务运行</strong></p>
<p>如果你是用 ceph-deploy 部署 Argonaut 或 Bobtail 的，那么 Ceph 可以作为服务运行（还可以用 sysvinit ）。</p>
<h2 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h2><p>但是，现在所有支持 systemd 的发行版（ CentOS 7 、 Fedora 、 Debian Jessie 8.x 、 SUSE ）都用原生的 systemd 文件来管理 ceph 守护进程，不再使用原来的 sysvinit 脚本了。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph.target       # start all daemons</div><div class="line">sudo systemctl status ceph-osd@12      # check status of osd.12</div></pre></td></tr></table></figure>
<p>罗列节点上 Ceph 的 systemd unit 用此命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl status ceph\*.service ceph\*.target</div></pre></td></tr></table></figure>
<h3 id="启动所有守护进程"><a href="#启动所有守护进程" class="headerlink" title="启动所有守护进程"></a>启动所有守护进程</h3><p>要启动一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph.target</div></pre></td></tr></table></figure>
<h3 id="停止所有守护进程"><a href="#停止所有守护进程" class="headerlink" title="停止所有守护进程"></a>停止所有守护进程</h3><p>要停止一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph\*.service ceph\*.target</div></pre></td></tr></table></figure>
<h3 id="按类型启动所有守护进程"><a href="#按类型启动所有守护进程" class="headerlink" title="按类型启动所有守护进程"></a>按类型启动所有守护进程</h3><p>要启动一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd.target</div><div class="line">sudo systemctl start ceph-mon.target</div><div class="line">sudo systemctl start ceph-mds.target</div></pre></td></tr></table></figure>
<h3 id="按类型停止所有守护进程"><a href="#按类型停止所有守护进程" class="headerlink" title="按类型停止所有守护进程"></a>按类型停止所有守护进程</h3><p>要停止一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-mon\*.service ceph-mon.target</div><div class="line">sudo systemctl stop ceph-osd\*.service ceph-osd.target</div><div class="line">sudo systemctl stop ceph-mds\*.service ceph-mds.target</div></pre></td></tr></table></figure>
<h3 id="启动单个进程"><a href="#启动单个进程" class="headerlink" title="启动单个进程"></a>启动单个进程</h3><p>要启动某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd@&#123;id&#125;</div><div class="line">sudo systemctl start ceph-mon@&#123;hostname&#125;</div><div class="line">sudo systemctl start ceph-mds@&#123;hostname&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start ceph-osd@1</div><div class="line">sudo systemctl start ceph-mon@ceph-server</div><div class="line">sudo systemctl start ceph-mds@ceph-server</div></pre></td></tr></table></figure>
<h3 id="停止单个进程"><a href="#停止单个进程" class="headerlink" title="停止单个进程"></a>停止单个进程</h3><p>要停止某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-osd@&#123;id&#125;</div><div class="line">sudo systemctl stop ceph-mon@&#123;hostname&#125;</div><div class="line">sudo systemctl stop ceph-mds@&#123;hostname&#125;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo systemctl stop ceph-osd@1</div><div class="line">sudo systemctl stop ceph-mon@ceph-server</div><div class="line">sudo systemctl stop ceph-mds@ceph-server</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim移动光标]]></title>
      <url>http://xiaqunfeng.cc/2017/06/15/vim%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>平常的基本编辑环境都是vim，因此总结了一些光标移动的命令，可以提高效率，使vim用起来不显得那么笨重。<br><a id="more"></a></p>
<h2 id="光标方向"><a href="#光标方向" class="headerlink" title="光标方向"></a>光标方向</h2><p>上下左右：<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code></p>
<p>支持数字前缀，比如<code>10j</code>可以向下移动10行</p>
<p><code>ctrl + o</code>返回上一个光标位置</p>
<p><code>ctrl + i</code>跳到下一个光标位置</p>
<h2 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h2><p><code>w</code>移动光标到下一个单词的词首</p>
<p><code>b</code>移动光标到上一个单词的词首</p>
<p><code>e</code>移动光标到光标所在单词的结尾</p>
<p><code>ge</code>移动光标到上一个单词的结尾</p>
<p>支持数字前缀，比如<code>4w</code>可以向后移动4个单词</p>
<p>以上单词的分割标准是：空格、特殊符号</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">raw: sudo apt-get -y install ceph</div></pre></td></tr></table></figure>
<p>这里 <code>:</code>  <code>-</code> 以及空格，都是分割符号</p>
<p><code>W</code>, <code>B</code>, <code>E</code> 功能同上，只不过它分隔单词的标准是空格，所以可以跳的更远，更方便，用的比较多。</p>
<h2 id="屏幕移动"><a href="#屏幕移动" class="headerlink" title="屏幕移动"></a>屏幕移动</h2><p><code>H</code>移动到屏幕的首行</p>
<p><code>L</code>到屏幕尾行</p>
<p><code>M</code>到屏幕中间</p>
<p><code>ctrl + f</code>向下翻页</p>
<p><code>ctrl + b</code>向上翻页</p>
<p><code>ctrl + e</code>逐行下滚</p>
<p><code>ctrl + y</code>逐行上滚</p>
<h2 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h2><p><code>^</code>到行首</p>
<p><code>$</code>到行尾</p>
<p><code>gg</code>移到文件首行</p>
<p><code>G</code>移到文件尾行</p>
<p><code>zt</code>置顶当前行</p>
<p><code>zz</code>将当前行移到屏幕中部</p>
<p><code>zb</code>将当前行移到底部</p>
<p>拷贝一行：<code>^y$</code>，也可以直接 <code>yy</code></p>
<p>拷贝整个文件：<code>ggyG</code></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Map RBD Devices on NBD]]></title>
      <url>http://xiaqunfeng.cc/2017/06/07/Map-RBD-Devices-on-NBD/</url>
      <content type="html"><![CDATA[<p>jewel及以后的版本支持rbd-nbd的特性，在需要map支持较多特性的rbd image时，可以使用此方法。<br><a id="more"></a></p>
<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>前一篇文章中说到在map特性比较丰富的rbd设备时，内核不支持，所以出现如如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># rbd nbd map rbd/image-1</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div></pre></td></tr></table></figure>
<p>所以行不通，于是寻求其他解决方案。</p>
<p>幸运的是，jewel及以后版本中，RBD支持将RBD image map为本地nbd设备，通过<code>rbd nbd map</code>命令即可映射为本地nbd设备。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>安装 rbd-nbd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rbd-nbd -y</div></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd nbd map rbd/image-1</div><div class="line">/dev/nbd0</div></pre></td></tr></table></figure>
<p>成功！</p>
<p>这时就可以格式化并挂载来使用该设备了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mkfs.xfs -f /dev/nbd0</div><div class="line"># mkdir /mnt/nbd0</div><div class="line"># mount -noatime /dev/nbd0 /mnt/nbd0</div><div class="line"># lsblk</div><div class="line">...</div><div class="line">nbd0    43:0    0    1G  0 disk /mnt/nbd0</div></pre></td></tr></table></figure>
<p>查看已映射的nbd设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd-nbd list-mapped</div><div class="line">/dev/nbd0</div></pre></td></tr></table></figure>
<blockquote>
<p>查看已挂载的rbd设备的命令是：rbd showmapped</p>
</blockquote>
<p>那么，什么是nbd设备？</p>
<h2 id="NBD"><a href="#NBD" class="headerlink" title="NBD"></a>NBD</h2><p><strong>NBD</strong>(Network Block Device)让你可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。NBD是一个内核模块，大部分Linux发行版都包含它。</p>
<h3 id="和RBD比较"><a href="#和RBD比较" class="headerlink" title="和RBD比较"></a>和RBD比较</h3><p>ceph jewel版本中有一个特性，RBD的NBD驱动，它允许librbd对外提供一个内核级别的RBD。</p>
<p>与RBD内核驱动程序相比，NBD有许多优点：</p>
<ul>
<li>RBD-KO开发和特性的添加必须要经过稳定的内核</li>
<li>RBD-KO开发慢于librbd，如果要与librbd开发保持同步，需要时间和努力</li>
<li>NBD已经很好地集成到内核多年，是大多数现今的内核的一部分</li>
</ul>
<p>RBD-NBD依靠librbd的用户空间实现，该实现通过使用强大和完善的NBD（网络块设备）内核模块已经非常稳定。</p>
<p>参考：<a href="http://www.sebastien-han.fr/blog/2016/04/04/ceph-jewel-preview-map-rbd-devices-on-nbd/" target="_blank" rel="external">Ceph Jewel Preview: map RBD devices on NBD</a></p>
<h3 id="和NFS的区别"><a href="#和NFS的区别" class="headerlink" title="和NFS的区别"></a>和NFS的区别</h3><ul>
<li>NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式</li>
<li>NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用</li>
</ul>
<h2 id="RBD-NBD"><a href="#RBD-NBD" class="headerlink" title="RBD-NBD"></a>RBD-NBD</h2><p><strong>rbd-nbd</strong> 是个 RADOS 块设备（ rbd ）映像的客户端，与 rbd 内核模块类似。它可以把一个 rbd 映像映射为 nbd （ Network Block Device，网络块设备）设备，这样就可以当常规的本地块设备使用了。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rbd-nbd [-c conf] [–nbds_max limit] [–read-only] [–device nbd device] map image-spec | snap-spec</div><div class="line">rbd-nbd unmap nbd device</div><div class="line">rbd-nbd list-mapped</div></pre></td></tr></table></figure>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p>-c ceph.conf</p>
<p>指定 ceph.conf 配置文件，而不是用默认的 /etc/ceph/ceph.conf 来确定启动时需要的 monitor 地址。</p>
</li>
</ul>
<ul>
<li><p>–nbds_max <em>limit</em></p>
<p>载入 NBD 内核模块时覆盖其参数，用于限制 nbd 设备的数量。</p>
</li>
</ul>
<h3 id="映像名和快照名规则"><a href="#映像名和快照名规则" class="headerlink" title="映像名和快照名规则"></a>映像名和快照名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">image-spec is [pool-name]/image-name</div><div class="line">snap-spec is [pool-name]/image-name@snap-name</div></pre></td></tr></table></figure>
<h2 id="ceph-rbd"><a href="#ceph-rbd" class="headerlink" title="ceph rbd"></a>ceph rbd</h2><p>使用Ceph的块存储有两种路径：</p>
<p>一种是利用QEMU走librbd路径，另一种是使用kernel module，走kernel的路径，两种途径的接口实现不完全相同。就目前来说，前者是目前更稳定的途径，也是Ceph所有应用场景中最广泛使用的。</p>
<ul>
<li>librbd是用户态的，主要为虚拟机提供块存储设备，kvm对接的就是librbd</li>
<li>kernel rbd是内核态的，主要为Host提供块设备支持，内核直接与osd交互，性能优于用户态</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph rbd map failed]]></title>
      <url>http://xiaqunfeng.cc/2017/06/06/ceph-rbd-map-failed/</url>
      <content type="html"><![CDATA[<p>探索 kernel RBD map 失败的问题。<br><a id="more"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>搭完 rbd mirror后，想通过client往image里写一些数据，所以在client端map rbd设备，结果失败了。</p>
<blockquote>
<p>rbd mirror的image 需要两个属性：exclusive-lock, journaling</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="查看rbd-image-info"><a href="#查看rbd-image-info" class="headerlink" title="查看rbd image info"></a>查看rbd image info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd/image-1</div><div class="line">rbd image &apos;image-1&apos;:</div><div class="line">	size 1024 MB in 256 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.108b238e1f29</div><div class="line">	format: 2</div><div class="line">	features: exclusive-lock, journaling</div><div class="line">	flags:</div><div class="line">	journal: 108b238e1f29</div><div class="line">	mirroring state: enabled</div><div class="line">	mirroring global id: c603d9dc-6f8d-49e0-ab68-5944d348e527</div><div class="line">	mirroring primary: true</div></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/image-1</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div><div class="line">rbd: map failed: (6) No such device or address</div></pre></td></tr></table></figure>
<p>然后dmesg看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># dmesg | tail</div><div class="line">[   64.808315] rbd: loaded (major 251)</div><div class="line">[   64.818369] libceph: mon2 172.20.2.160:6789 session established</div><div class="line">[   64.819187] libceph: client14167 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">[   64.836328] rbd: image image-1: image uses unsupported features: 0x40</div><div class="line">[  443.658569] libceph: mon1 172.20.2.161:6789 session established</div><div class="line">[  443.659143] libceph: client4313 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</div><div class="line">[  443.683178] rbd: rbd0: capacity 10737418240 features 0x1</div><div class="line">[  978.502132] rbd: image image-1: image uses unsupported features: 0x40</div></pre></td></tr></table></figure>
<h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p><strong>image uses unsupported features: 0x40</strong></p>
<p>不支持特性 0x40 = 64，也就是不支持特性 <strong>journaling</strong></p>
<h2 id="关于内核支持的特性分析"><a href="#关于内核支持的特性分析" class="headerlink" title="关于内核支持的特性分析"></a>关于内核支持的特性分析</h2><p>查看内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">3.10.0-327.el7.x86_64</div></pre></td></tr></table></figure>
<p>根据查阅资料和实践，发现：</p>
<ul>
<li>CentOS的3.10内核仅支持其中的layering 和 exclusive-lock，其他feature概不支持</li>
<li>内核4.6仍然只支持：layering、exclusive-lock和 striping 属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd/test-map</div><div class="line">rbd image &apos;test-map&apos;:</div><div class="line">	size 512 MB in 128 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.10ca238e1f29</div><div class="line">	format: 2</div><div class="line">	features: layering, exclusive-lock</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/test-map</div><div class="line">/dev/rbd1</div></pre></td></tr></table></figure>
<p>此时可以map成功。</p>
<h2 id="RBD特性解析"><a href="#RBD特性解析" class="headerlink" title="RBD特性解析"></a>RBD特性解析</h2><h3 id="特性一览表"><a href="#特性一览表" class="headerlink" title="特性一览表"></a>特性一览表</h3><p>RBD支持的特性，及具体BIT值的计算如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
<th>BIT码</th>
</tr>
</thead>
<tbody>
<tr>
<td>layering</td>
<td>支持分层</td>
<td>1</td>
</tr>
<tr>
<td>striping</td>
<td>支持条带化 v2</td>
<td>2</td>
</tr>
<tr>
<td>exclusive-lock</td>
<td>支持独占锁</td>
<td>4</td>
</tr>
<tr>
<td>object-map</td>
<td>支持对象映射（依赖 exclusive-lock ）</td>
<td>8</td>
</tr>
<tr>
<td>fast-diff</td>
<td>快速计算差异（依赖 object-map ）</td>
<td>16</td>
</tr>
<tr>
<td>deep-flatten</td>
<td>支持快照扁平化操作</td>
<td>32</td>
</tr>
<tr>
<td>journaling</td>
<td>支持记录 IO 操作（依赖独占锁）</td>
<td>64</td>
</tr>
</tbody>
</table>
<h3 id="ceph-kraken版本默认属性值"><a href="#ceph-kraken版本默认属性值" class="headerlink" title="ceph kraken版本默认属性值"></a>ceph kraken版本默认属性值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --show-config|grep rbd|grep features</div><div class="line">rbd_default_features = 61</div></pre></td></tr></table></figure>
<p>为啥是61？我们创建一个默认配置的rbd看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># rbd create test-feature --size 64</div><div class="line"># rbd info rbd/test-feature</div><div class="line">rbd image &apos;test-feature&apos;:</div><div class="line">	size 65536 kB in 16 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.107d238e1f29</div><div class="line">	format: 2</div><div class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<p><strong>1+4+8+16+32 = 61</strong></p>
<p>就是说除了特性：striping 和 journaling 外都开启了。</p>
<h3 id="控制属性"><a href="#控制属性" class="headerlink" title="控制属性"></a>控制属性</h3><p>有三种方法来开启需要的特性</p>
<p>1、在创建image时，通过 <code>--image-feature</code> 来指定需要开启的特性</p>
<p>2、对已存在的image可以通过如下命令开启和关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd feature enable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</div><div class="line">rbd feature disable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</div></pre></td></tr></table></figure>
<p>3、当然，每次通过enable和disable来不是很便捷，可以通过修改配置文件来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/ceph/ceph.conf</div><div class="line">...</div><div class="line">rbd_default_features = 1</div><div class="line">...</div></pre></td></tr></table></figure>
<p>具体该设为多少可以通过上面BIT值查表计算得出。</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph mon时钟偏移问题]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/ceph-mon%E6%97%B6%E9%92%9F%E5%81%8F%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>之前记录的关于时钟漂移的解决过程和心得，这里分享一下。<br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>查看集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_WARN</div><div class="line">            clock skew detected on mon.xs734</div><div class="line">            Monitor clock skew detected</div><div class="line">...</div></pre></td></tr></table></figure>
<p>根据提示，发现这是一个明显的时钟漂移的问题</p>
<h2 id="配置NTP"><a href="#配置NTP" class="headerlink" title="配置NTP"></a>配置NTP</h2><p>第一反应就是ntp同步，配置ntp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install ntp ntpdate -y</div><div class="line">ntpdate pool.ntp.org</div><div class="line">systemctl restart ntpdate.service</div><div class="line">systemctl restart ntpd.service</div><div class="line">systemctl enable ntpdate.service</div><div class="line">systemctl enable ntpd.service</div></pre></td></tr></table></figure>
<blockquote>
<p>每台机器上重复如上过程</p>
</blockquote>
<p>此时，查看集群的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># for x in xs732 xs733 xs734; do ssh $x &apos;date&apos;; done</div><div class="line">Thu May 05 17:51:26 CST 2017</div><div class="line">Thu May 05 17:51:27 CST 2017</div><div class="line">Thu May 05 17:51:27 CST 2017</div></pre></td></tr></table></figure>
<p>说明时间基本已经同步了。<strong>一般情况下问题就已经解决了，但这里还有问题。</strong></p>
<h2 id="进一步跟踪集群状态"><a href="#进一步跟踪集群状态" class="headerlink" title="进一步跟踪集群状态"></a>进一步跟踪集群状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_WARN</div><div class="line">            clock skew detected on mon.xs734</div><div class="line">            Monitor clock skew detected</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这时候问题来了，发现集群还是处于 WARN 的状态，进一步看问题出在哪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph -w</div><div class="line">...</div><div class="line">2017-05-26 10:27:14.325856 mon.0 [WRN] mon.2 10.34.57.27:6789/0 clock skew 0.0556591s &gt; max 0.05s</div><div class="line">2017-05-26 10:27:44.292273 mon.0 [INF] HEALTH_WARN; clock skew detected on mon.xs733, mon.xs734; Monitor clock skew detected</div></pre></td></tr></table></figure>
<p><strong>问题所在：0.0556591s &gt; max 0.05s 漂移的时间略大于默认的0.05秒</strong></p>
<blockquote>
<p>很少出现这种大于0.05秒的情况</p>
</blockquote>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><p>在 <code>/etc/ceph/ceph.conf</code> 中添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mon]</div><div class="line">mon_clock_drift_allowed = 0.10</div><div class="line">mon clock drift warn backoff = 10</div></pre></td></tr></table></figure>
<blockquote>
<p>亲测，参数名称要不要下划线都可以</p>
</blockquote>
<p>改完后将配置推到集群所有的机器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf config push xs732 xs733 xs734</div></pre></td></tr></table></figure>
<h3 id="关于这两个参数"><a href="#关于这两个参数" class="headerlink" title="关于这两个参数"></a>关于这两个参数</h3><p>mon clock drift allowed</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>监视器间允许的时钟漂移量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>.050</td>
</tr>
</tbody>
</table>
<p>mon clock drift warn backoff</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>时钟偏移警告的退避指数。</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>链接：<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/" target="_blank" rel="external">http://docs.ceph.org.cn/rados/configuration/mon-config-ref/</a></p>
<h3 id="查看此时运行的ceph配置"><a href="#查看此时运行的ceph配置" class="headerlink" title="查看此时运行的ceph配置"></a>查看此时运行的ceph配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</div><div class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.05&quot;,</div><div class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;5&quot;,</div><div class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</div></pre></td></tr></table></figure>
<p>发现还是默认的 0.05 和 5，说明更改的配置根本没生效。</p>
<h3 id="重启monitor"><a href="#重启monitor" class="headerlink" title="重启monitor"></a>重启monitor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart ceph-mon@xs732.service</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，每台机器上都重启一下</p>
</blockquote>
<p>然后再查看，发现生效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</div><div class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.10&quot;,</div><div class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;10&quot;,</div><div class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</div></pre></td></tr></table></figure>
<p>再次查看ceph集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;xs732=10.34.57.25:6789/0,xs733=10.34.57.26:6789/0,xs734=10.34.57.27:6789/0&#125;</div><div class="line">            election epoch 12, quorum 0,1,2 xs732,xs733,xs734</div><div class="line">        mgr active: xs733 standbys: xs734, xs732</div><div class="line">     osdmap e50: 9 osds: 9 up, 9 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v113: 256 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            46397 MB used, 4423 GB / 4469 GB avail</div><div class="line">                 256 active+clean</div></pre></td></tr></table></figure>
<p>OK，问题解决！</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPG key retrieval failure]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/GPG-key-retrieval-failure/</url>
      <content type="html"><![CDATA[<p>在centos 7.31611上遇到的问题，记录一下解决方法，并附下载链接。<br><a id="more"></a></p>
<h2 id="我的epel源"><a href="#我的epel源" class="headerlink" title="我的epel源"></a>我的epel源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># cat /etc/yum.repos.d</div><div class="line">[epel]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line">[epel-debuginfo]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div><div class="line"></div><div class="line">[epel-source]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</div><div class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>更新yum源的时候出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line"></div><div class="line">GPG key retrieval failed: [Errno 14] curl#37 - &quot;Couldn&apos;t open file /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7&quot;</div></pre></td></tr></table></figure>
<p>查看一下，确实没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@ceph0:~# ls /etc/pki/rpm-gpg/</div><div class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-ZABBIX</div></pre></td></tr></table></figure>
<h2 id="网上解决方案"><a href="#网上解决方案" class="headerlink" title="网上解决方案"></a>网上解决方案</h2><p>这是个bug，没啥好的办法</p>
<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1237057" target="_blank" rel="external">https://bugzilla.redhat.com/show_bug.cgi?id=1237057</a></p>
<h2 id="原因-amp-解决尝试"><a href="#原因-amp-解决尝试" class="headerlink" title="原因&amp;解决尝试"></a>原因&amp;解决尝试</h2><p>看了下输出，就是缺少 <code>RPM-GPG-KEY-EPEL-7</code> 嘛，补上是不是就可以了呢？</p>
<p>带着这个疑问，实践一下：</p>
<p>1、在原先成功的机器上，查看是否有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@ceph3 yum.repos.d]# ls /etc/pki/rpm-gpg/</div><div class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-SIG-Virtualization  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-EPEL-7</div></pre></td></tr></table></figure>
<p>发现果然有</p>
<p>2、将 <code>RPM-GPG-KEY-EPEL-7</code> 拷贝到现在的机器上</p>
<p>3、这时再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install epel-release -y</div></pre></td></tr></table></figure>
<p>可以成功，问题解决！</p>
<p align="center"><strong>附上<code>RPM-GPG-KEY-EPEL-7</code>下载链接，给有需要的人</strong></p>

<p align="center"><a href="http://oow6unnib.bkt.clouddn.com/RPM-GPG-KEY-EPEL-7" target="_blank" rel="external">点此下载</a></p>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># sudo rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line">Retrieving https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line">curl: (7) Failed connect to dl.fedoraproject.org:443; Connection refused</div><div class="line">error: skipping https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm - transfer failed</div><div class="line">You have new mail in /var/spool/mail/root</div></pre></td></tr></table></figure>
<p>这个问题的原因是网站无法访问</p>
]]></content>
      
        
        <tags>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上实现vim的markdown预览]]></title>
      <url>http://xiaqunfeng.cc/2017/05/25/mac%E4%B8%8A%E5%AE%9E%E7%8E%B0vim%E7%9A%84markdown%E9%A2%84%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>有时候在vim下创建了一个markdown文件，比如 <code>README.md</code> ，因为不能实时预览，所以要离开vim，用编辑器去编辑，比较麻烦。所以这里配置使能在vim编辑器上预览markdown文件。<br><a id="more"></a></p>
<p>这里分享两个插件</p>
<h2 id="vim-instant-markdown"><a href="#vim-instant-markdown" class="headerlink" title="vim-instant-markdown"></a><strong>vim-instant-markdown</strong></h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>github：<a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="external">https://github.com/suan/vim-instant-markdown</a></p>
<p>下载zip文件，解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls vim-instant-markdown-master/</div><div class="line">CHANGELOG.md README.md    after</div></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>注意：需要依赖 node.js 和 npm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install npm</div><div class="line">sudo npm -g install instant-markdown-d</div></pre></td></tr></table></figure>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -pv ~/.vim/after/ftplugin/markdown/</div><div class="line">sudo cp after/ftplugin/markdown/instant-markdown.vim ~/.vim/after/ftplugin/markdown/</div></pre></td></tr></table></figure>
<p>注意：保证在 <code>~/.vimrc</code> 中 <code>filetype plugin on</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filetype plugin indent on     &quot; required!</div></pre></td></tr></table></figure>
<blockquote>
<p>一般是on的，特别是之前配置过vim插件的时候，已经打开了。</p>
</blockquote>
<h2 id="markdown-preview-vim"><a href="#markdown-preview-vim" class="headerlink" title="markdown-preview.vim"></a><strong>markdown-preview.vim</strong></h2><p>Github：<a href="https://github.com/iamcco/markdown-preview.vim" target="_blank" rel="external">https://github.com/iamcco/markdown-preview.vim</a></p>
<p>相比较上面一种方法，这种比较轻量级，推荐此方法。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>第一步：在 <code>~/.vimrc</code> 中的插件部分添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug &apos;iamcco/markdown-preview.vim&apos;</div></pre></td></tr></table></figure>
<p>第二步：安装插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo vim		# 或者：sudo mvim</div><div class="line">:BundleInstall</div></pre></td></tr></table></figure>
<h3 id="设置chrome为预览浏览器"><a href="#设置chrome为预览浏览器" class="headerlink" title="设置chrome为预览浏览器"></a>设置chrome为预览浏览器</h3><p>在 <code>~/.vimrc</code> 的末尾添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let g:mkdp_path_to_chrome = &quot;open -a Google\\ Chrome&quot;</div></pre></td></tr></table></figure>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>在编辑markdown的vim界面上敲如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:MarkdownPreview</div></pre></td></tr></table></figure>
<p>这时候就会在浏览器中出现markdown的预览界面</p>
<h3 id="退出预览"><a href="#退出预览" class="headerlink" title="退出预览"></a>退出预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:MarkdownPreviewStop</div></pre></td></tr></table></figure>
<p>文件退出vim编辑的时候也会自动关闭和退出预览。</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>如果不是用mac自带的bash，而是自己装的zsh，需要注意以下两点：</p>
<p>1、保证在安装 instant-markdown-d 的时候添加了选项 <code>npm -g install</code></p>
<p>2、在 <code>~/.vimrc</code> 的末尾添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set shell=bash\ -i</div></pre></td></tr></table></figure>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>第二种方法较第一种比较轻量级，而且不需要依赖node.js，不需要下载外部依赖，只需要支持python2/3就可以了，同时支持滚动。</p>
<p>这种配置在配合 mvim + hexo + markdown 的时候特别爽，可以实时显示，都省了先执行<code>hexo s</code>，然后登陆<code>localhost:4000</code> 去查看了。</p>
<p>本篇博客的实时预览截图如下：（可以看到，端口为9183）<br><img src="http://oow6unnib.bkt.clouddn.com/markdown-preview.png" alt="markdown-preview"></p>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph日志迁移]]></title>
      <url>http://xiaqunfeng.cc/2017/05/23/ceph%E6%97%A5%E5%BF%97%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>将ceph日志从默认的位置移动到SSD的一个分区，比较常用。<br><a id="more"></a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、停止osd</p>
<p>2、将该osd的日志下盘</p>
<p>3、移除原有日志</p>
<p>4、将osd的日志软链到SSD的分区</p>
<p>5、创建新的journal</p>
<p>6、启动osd</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>系统：centos 7.3</p>
<p>以 osd 0 、/dev/sdb1 为例，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># stop osd</div><div class="line">systemctl stop ceph-osd@0</div><div class="line"></div><div class="line"># flush journal</div><div class="line">ceph-osd --flush-journal -i 0</div><div class="line"></div><div class="line"># remove old journal</div><div class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal</div><div class="line"></div><div class="line"># create symlink to partition</div><div class="line">ln -s /dev/sdb1 /var/lib/ceph/osd/ceph-0/journal</div><div class="line"></div><div class="line"># create new journal</div><div class="line">ceph-osd --mkjournal -i 0</div><div class="line"></div><div class="line"># start osd</div><div class="line">systemctl start ceph-osd@0</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>确认日志和磁盘分区的权限，如果不是ceph，会出现访问失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-0/journal</div><div class="line">chown -R ceph:ceph /dev/sdb1</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cpu拓扑及ceph使用时的优化]]></title>
      <url>http://xiaqunfeng.cc/2017/05/11/cpu%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>先将在ceph层面的调优，再介绍cpu的拓扑结构。<br><a id="more"></a></p>
<h2 id="ceph优化之CPU"><a href="#ceph优化之CPU" class="headerlink" title="ceph优化之CPU"></a>ceph优化之CPU</h2><p>NUMA的思路就是讲内存和CPU分割成多个区域，每个区域叫node，然后将node高速互联。node内CPU与内存的访问速度快于访问其他node的内存，NUMA可能会在某些情况下影响ceph-osd。</p>
<p>ceph目前未对NUMA架构的内存做过多优化，在日常使用过程中，通常为 2~4 颗CPU，这时候选择SMP架构的内存在效率上会高一些，如果条件允许，可以通过进程绑定的方法，在保证CPU能尽可能访问自身内存的前提下，使用NUMA架构。</p>
<h3 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h3><p><strong>通过BIOS关闭NUMA。</strong></p>
<ul>
<li>在os层numa关闭时，打开bios层的numa会影响性能，QPS会下降15-30%。</li>
<li>在bios层面numa关闭时，无论os层面的numa是否打开，都不会影响性能。</li>
</ul>
<p>通过命令判断bios层是否开启numa：</p>
<p>1、开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># grep -i numa /var/log/dmesg</div><div class="line">[    0.000000] NUMA: Initialized distance table, cnt=2</div><div class="line">[    0.000000] NUMA: Node 0 [mem 0x00000000-0x7fffffff] + [mem 0x100000000-0x47fffffff] -&gt; [mem 0x00000000-0x47fffffff]</div><div class="line">[    0.000000] Enabling automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl</div><div class="line">[    0.593086] pci_bus 0000:00: on NUMA node 0</div><div class="line">[    0.598672] pci_bus 0000:80: on NUMA node 1</div></pre></td></tr></table></figure>
<p>2、未开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep -i numa /var/log/dmesg</div><div class="line">[    0.000000] No NUMA configuration found</div></pre></td></tr></table></figure>
<p>查看机器的NUMA拓扑结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># numastat</div><div class="line">                           node0           node1</div><div class="line">numa_hit             83549806562     18182486371</div><div class="line">numa_miss               54084897     15540366583</div><div class="line">numa_foreign         15540366583        54084897</div><div class="line">interleave_hit             14109           14168</div><div class="line">local_node           83549670098     18182734455</div><div class="line">other_node              54221361     15540118499</div></pre></td></tr></table></figure>
<p>当发现numa_miss数值比较高时，说明需要对分配策略进行调整。例如将指定进程关联绑定到指定的CPU上，从而提高内存命中率。</p>
<p>在运行程序的时候使用<code>numactl</code> <code>-m</code>和<code>-physcpubind</code>就能制定将这个程序运行在哪个cpu和哪个memory中。</p>
<p>numa的陷阱：当你的服务器还有内存的时候，发现它已经在开始使用swap了，甚至已经导致机器出现停滞的现象。这个就有可能是由于numa的限制，如果一个进程限制它只能使用自己的numa节点的内存，那么当自身numa node内存使用光之后，就不会去使用其他numa node的内存了，会开始使用swap，甚至更糟的情况，机器没有设置swap的时候，可能会直接死机。所以可以使用<code>numactl --interleave=all</code>来取消numa node的限制。</p>
<p>根据具体业务决定NUMA的使用：</p>
<ul>
<li>如果你的程序是会占用大规模内存的，你大多应该选择关闭numa node的限制（或从硬件关闭numa）。因为这个时候你的程序很有几率会碰到numa陷阱。</li>
<li>如果你的程序并不占用大内存，而是要求更快的程序运行时间。你大多应该选择限制只访问本numa node的方法来进行处理。</li>
</ul>
<h3 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h3><p>通过cgroup将ceph-osd进程与某一个 CPU core 以及同一个 node下的内存进行绑定。</p>
<p>绑定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mkdir -p /dys/fs/cgroup/cpuset/ceph</div><div class="line"># cup number : 0,1,2,3 = 0-3</div><div class="line">echo 0,4 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.cpus</div><div class="line"># NUMA node</div><div class="line">echo 0 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.mems</div><div class="line">osd-pid-list=$(ps aux | grep osd | grep -v grep | awk &apos;&#123;print $2&#125;&apos;)</div><div class="line">for osd-pid in $(osd-pid-list)</div><div class="line">do</div><div class="line">    echo $(osd-pid) &gt; /sys/fs/cgroup/cpuset/ceph/cgroup.procs</div><div class="line">done</div></pre></td></tr></table></figure>
<p>注意的问题：</p>
<p>· 防止进程跨CPU核心迁移，以更好的利用缓存；</p>
<p>· 防止进程跨物理CPU迁移，以更好的利用内存和缓存；</p>
<p>· Ceph进程和其他进程会互相抢占资源，使用Cgroups做好隔离措施；</p>
<p>· 为Ceph进程预留足够多的CPU和内存资源，防止影响性能或产生OOM。尤其是高性能环境中并不能完全满足Ceph进程的开销，在高性能场景（全SSD）下，每个OSD进程可能需要高达6GHz的CPU和4GB以上的内存。</p>
<h2 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h2><p>cpu相关的信息都在 <code>/proc/cpuinfo</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># lscpu</div><div class="line">Architecture:          x86_64</div><div class="line">CPU op-mode(s):        32-bit, 64-bit</div><div class="line">Byte Order:            Little Endian</div><div class="line">CPU(s):                32</div><div class="line">On-line CPU(s) list:   0-31</div><div class="line">Thread(s) per core:    2</div><div class="line">Core(s) per socket:    8</div><div class="line">座：                 2</div><div class="line">NUMA 节点：         2</div><div class="line">厂商 ID：           GenuineIntel</div><div class="line">CPU 系列：          6</div><div class="line">型号：              63</div><div class="line">型号名称：        Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz</div><div class="line">步进：              2</div><div class="line">CPU MHz：             1200.585</div><div class="line">BogoMIPS：            4800.30</div><div class="line">虚拟化：           VT-x</div><div class="line">L1d 缓存：          32K</div><div class="line">L1i 缓存：          32K</div><div class="line">L2 缓存：           256K</div><div class="line">L3 缓存：           20480K</div><div class="line">NUMA 节点0 CPU：    0-7,16-23</div><div class="line">NUMA 节点1 CPU：    8-15,24-31</div></pre></td></tr></table></figure>
<p>两种不同的CPU硬件体系架构：</p>
<ul>
<li>NUMA（Non-Uniform Memory Access，非一致性内存访问）</li>
<li>SMP（Symmetric Multi-Processor，对称多处理器系统）</li>
</ul>
<p>SMP的主要特征是共享，所有的CPU共享使用全部资源，例如内存、总线和I/O，多个CPU对称工作，彼此之间没有主次之分，平等地访问共享的资源，这样势必引入资源的竞争问题，且如果内存访问达到瓶颈的时候，性能就不能随之增加。每个CPU通过总线访问内存，当CPU数量不断增加以后，总线的压力不断增加，导致CPU的处理能力大大降低。</p>
<p>NUMA技术将CPU划分成不同的组（Node)，每个Node由多个CPU组成，并且有独立的本地内存、I/O等资源。Node之间通过互联模块连接和沟通，因此除了本地内存外，每个CPU仍可以访问远端Node的内存，不过效率会比访问本地内存差一些，我们用Node之间的距离（Distance，抽象的概念）来定义各个Node之间互访资源的开销。</p>
<p>NUMA架构旨在超越SMP架构的可扩展性限制。 使用代表对称多处理的SMP，所有存储器访问都被发布到相同的共享存储器总线。 这对于相对较少数量的CPU来说可行，但是当您有数十个甚至数百个CPU竞争访问共享内存总线时，会出现共享总线的问题。 NUMA通过限制任何一个存储器总线上的CPU数量以及通过高速互连连接各个节点来减轻这些瓶颈。</p>
<p>在NUMA盒上，访问非本地内存的成本很高。 如果您运行的是不支持NUMA的软件，那么它不会小心节点正在托管刚刚分配的内存，并没有利用NUMA架构的优势。 根据实施情况和平台，这种处罚可以忽略不计，压倒一切。</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>如果你只知道CPU这么一个概念，那么是无法理解CPU的拓扑的。事实上，在NUMA架构下，CPU的概念从大到小依次是：Node、Socket、Core、Processor。</p>
<p>随着多核技术的发展，我们将多个CPU封装在一起，这个封装一般被称为Socket（插槽的意思，也有人称之为Packet），而Socket中的每个核心被称为Core。为了进一步提升CPU的处理能力，Intel又引入了HT（Hyper-Threading，超线程)的技术，一个Core打开HT之后，在OS看来就是两个核，当然这个核是逻辑上的概念，所以也被称为Logical Processor，本文简称为Processor。</p>
<p>综上所述，一个NUMA Node可以有一个或者多个Socket，一个多核Socket显然包含多个Core，一个Core如果打开HT则变成两个Logical Processor。Logical processor只是OS内部看到的，实际上两个Processor还是位于同一个Core上，所以频繁的调度仍可能导致资源竞争，影响性能。</p>
<p>NUMA相关的策略</p>
<p>1、每个进程（或线程）都会从父进程继承NUMA策略，并分配有一个优先node。如果NUMA策略允许的话，进程可以调用其他node上的资源。</p>
<p>2、NUMA的CPU分配策略有cpunodebind、physcpubind。cpunodebind规定进程运行在某几个node之上，而physcpubind可以更加精细地规定运行在哪些核上。</p>
<p>3、NUMA的内存分配策略有localalloc、preferred、membind、interleave。</p>
<p>localalloc规定进程从当前node上请求分配内存；</p>
<p>而preferred比较宽松地指定了一个推荐的node来获取内存，如果被推荐的node上没有足够内存，进程可以尝试别的node。</p>
<p>membind可以指定若干个node，进程只能从这些指定的node上请求分配内存。</p>
<p>interleave规定进程从指定的若干个node上以RR（Round Robin 轮询调度）算法交织地请求分配内存。</p>
<p>因为NUMA默认的内存分配策略是优先在进程所在CPU的本地内存中分配，会导致CPU节点之间内存分配不均衡，当某个CPU节点的内存不足时，会导致swap产生，而不是从远程节点分配内存。这就是所谓的swap insanity 现象。</p>
<h2 id="查看CPU拓扑"><a href="#查看CPU拓扑" class="headerlink" title="查看CPU拓扑"></a>查看CPU拓扑</h2><p><strong>Node -&gt; Socket -&gt; Core -&gt; Processor</strong></p>
<h3 id="查看Numa-Node"><a href="#查看Numa-Node" class="headerlink" title="查看Numa Node"></a>查看Numa Node</h3><p>安装numactl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install numactl -y</div></pre></td></tr></table></figure>
<p>numactl是设定进程NUMA策略的命令行工具，也可以用来查看当前的Nuwa node：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># numactl --hardware</div><div class="line">available: 2 nodes (0-1)</div><div class="line">node 0 cpus: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">node 0 size: 16263 MB</div><div class="line">node 0 free: 168 MB</div><div class="line">node 1 cpus: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div><div class="line">node 1 size: 16384 MB</div><div class="line">node 1 free: 263 MB</div><div class="line">node distances:</div><div class="line">node   0   1</div><div class="line">  0:  10  21</div><div class="line">  1:  21  10</div></pre></td></tr></table></figure>
<h3 id="查看socket"><a href="#查看socket" class="headerlink" title="查看socket"></a>查看socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line"> 0</div><div class="line"> 1</div><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</div><div class="line">2</div></pre></td></tr></table></figure>
<p>查看每个socket对应几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2&#125;&apos; | sort | uniq -c</div><div class="line">     16  0</div><div class="line">     16  1</div></pre></td></tr></table></figure>
<p>查看socket对应哪几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># awk -F: &apos;&#123;</div><div class="line">&gt;     if ($1 ~ /processor/) &#123;</div><div class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</div><div class="line">&gt;         p_id=$2;</div><div class="line">&gt;     &#125; else if ($1 ~ /physical id/)&#123;</div><div class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</div><div class="line">&gt;         s_id=$2;</div><div class="line">&gt;         arr[s_id]=arr[s_id] &quot; &quot; p_id</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; END&#123;</div><div class="line">&gt;     for (i in arr)</div><div class="line">&gt;         print arr[i];</div><div class="line">&gt; &#125;&apos; /proc/cpuinfo | cut -c2-</div><div class="line">0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div></pre></td></tr></table></figure>
<h3 id="查看core"><a href="#查看core" class="headerlink" title="查看core"></a>查看core</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># cat /proc/cpuinfo | grep &apos;core&apos;  | sort -u</div><div class="line">core id		: 0</div><div class="line">core id		: 1</div><div class="line">core id		: 2</div><div class="line">core id		: 3</div><div class="line">core id		: 4</div><div class="line">core id		: 5</div><div class="line">core id		: 6</div><div class="line">core id		: 7</div><div class="line">cpu cores	: 8</div></pre></td></tr></table></figure>
<h3 id="查看processor"><a href="#查看processor" class="headerlink" title="查看processor"></a>查看processor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep &apos;processor&apos; /proc/cpuinfo | wc -l</div><div class="line">32</div></pre></td></tr></table></figure>
<p>每个socket中有几个processor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># grep &apos;siblings&apos; /proc/cpuinfo | sort -u</div><div class="line">siblings	: 16</div></pre></td></tr></table></figure>
<h2 id="所有CPU拓扑信息"><a href="#所有CPU拓扑信息" class="headerlink" title="所有CPU拓扑信息"></a>所有CPU拓扑信息</h2><p>shell脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"># cat cpu-topology.sh</div><div class="line">#!/bin/bash</div><div class="line"># Simple print cpu topology</div><div class="line"></div><div class="line">function get_nr_processor()</div><div class="line">&#123;</div><div class="line">    grep &apos;^processor&apos; /proc/cpuinfo | wc -l</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_socket()</div><div class="line">&#123;</div><div class="line">    grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_siblings()</div><div class="line">&#123;</div><div class="line">    grep &apos;siblings&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function get_nr_cores_of_socket()</div><div class="line">&#123;</div><div class="line">    grep &apos;cpu cores&apos; /proc/cpuinfo | awk -F: &apos;&#123;</div><div class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">echo &apos;===== CPU Topology Table =====&apos;</div><div class="line">echo</div><div class="line"></div><div class="line">echo &apos;+--------------+---------+-----------+&apos;</div><div class="line">echo &apos;| Processor ID | Core ID | Socket ID |&apos;</div><div class="line">echo &apos;+--------------+---------+-----------+&apos;</div><div class="line"></div><div class="line">while read line; do</div><div class="line">    if [ -z &quot;$line&quot; ]; then</div><div class="line">        printf &apos;| %-12s | %-7s | %-9s |\n&apos; $p_id $c_id $s_id</div><div class="line">        echo &apos;+--------------+---------+-----------+&apos;</div><div class="line">        continue</div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^processor&quot;; then</div><div class="line">        p_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^core id&quot;; then</div><div class="line">        c_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line"></div><div class="line">    if echo &quot;$line&quot; | grep -q &quot;^physical id&quot;; then</div><div class="line">        s_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </div><div class="line">    fi</div><div class="line">done &lt; /proc/cpuinfo</div><div class="line"></div><div class="line">echo</div><div class="line"></div><div class="line">awk -F: &apos;&#123; </div><div class="line">    if ($1 ~ /processor/) &#123;</div><div class="line">        gsub(/ /,&quot;&quot;,$2);</div><div class="line">        p_id=$2;</div><div class="line">    &#125; else if ($1 ~ /physical id/)&#123;</div><div class="line">        gsub(/ /,&quot;&quot;,$2);</div><div class="line">        s_id=$2;</div><div class="line">        arr[s_id]=arr[s_id] &quot; &quot; p_id</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">END&#123;</div><div class="line">    for (i in arr) </div><div class="line">        printf &quot;Socket %s:%s\n&quot;, i, arr[i];</div><div class="line">&#125;&apos; /proc/cpuinfo</div><div class="line"></div><div class="line">echo</div><div class="line">echo &apos;===== CPU Info Summary =====&apos;</div><div class="line">echo</div><div class="line"></div><div class="line">nr_processor=`get_nr_processor`</div><div class="line">echo &quot;Logical processors: $nr_processor&quot;</div><div class="line"></div><div class="line">nr_socket=`get_nr_socket`</div><div class="line">echo &quot;Physical socket: $nr_socket&quot;</div><div class="line"></div><div class="line">nr_siblings=`get_nr_siblings`</div><div class="line">echo &quot;Siblings in one socket: $nr_siblings&quot;</div><div class="line"></div><div class="line">nr_cores=`get_nr_cores_of_socket`</div><div class="line">echo &quot;Cores in one socket: $nr_cores&quot;</div><div class="line"></div><div class="line">let nr_cores*=nr_socket</div><div class="line">echo &quot;Cores in total: $nr_cores&quot;</div><div class="line"></div><div class="line">if [ &quot;$nr_cores&quot; = &quot;$nr_processor&quot; ]; then</div><div class="line">    echo &quot;Hyper-Threading: off&quot;</div><div class="line">else</div><div class="line">    echo &quot;Hyper-Threading: on&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">echo</div><div class="line">echo &apos;===== END =====&apos;</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"># sh cpu-topology.sh</div><div class="line">===== CPU Topology Table =====</div><div class="line"></div><div class="line">+--------------+---------+-----------+</div><div class="line">| Processor ID | Core ID | Socket ID |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 0            | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 1            | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 2            | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 3            | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 4            | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 5            | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 6            | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 7            | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 8            | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 9            | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 10           | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 11           | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 12           | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 13           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 14           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 15           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 16           | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 17           | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 18           | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 19           | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 20           | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 21           | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 22           | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 23           | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 24           | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 25           | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 26           | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 27           | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 28           | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 29           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 30           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 31           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line"></div><div class="line">Socket 0: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</div><div class="line">Socket 1: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</div><div class="line"></div><div class="line">===== CPU Info Summary =====</div><div class="line"></div><div class="line">Logical processors: 32</div><div class="line">Physical socket: 2</div><div class="line">Siblings in one socket:  16</div><div class="line">Cores in one socket:  8</div><div class="line">Cores in total: 16</div><div class="line">Hyper-Threading: on</div><div class="line"></div><div class="line">===== END =====</div></pre></td></tr></table></figure>
<h2 id="工具hwloc"><a href="#工具hwloc" class="headerlink" title="工具hwloc"></a>工具hwloc</h2><p>hwloc可以显示CPU拓扑，比较方面地查看CPU各级缓存以及各个核、物理CPU之间，可以共享哪一级别的CPU cache。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"># hwloc-ls</div><div class="line">Machine (94GB total)</div><div class="line">  NUMANode L#0 (P#0 47GB)</div><div class="line">    Package L#0 + L3 L#0 (20MB)</div><div class="line">      L2 L#0 (256KB) + L1d L#0 (32KB) + L1i L#0 (32KB) + Core L#0</div><div class="line">        PU L#0 (P#0)</div><div class="line">        PU L#1 (P#16)</div><div class="line">      L2 L#1 (256KB) + L1d L#1 (32KB) + L1i L#1 (32KB) + Core L#1</div><div class="line">        PU L#2 (P#1)</div><div class="line">        PU L#3 (P#17)</div><div class="line">      L2 L#2 (256KB) + L1d L#2 (32KB) + L1i L#2 (32KB) + Core L#2</div><div class="line">        PU L#4 (P#2)</div><div class="line">        PU L#5 (P#18)</div><div class="line">      L2 L#3 (256KB) + L1d L#3 (32KB) + L1i L#3 (32KB) + Core L#3</div><div class="line">        PU L#6 (P#3)</div><div class="line">        PU L#7 (P#19)</div><div class="line">      L2 L#4 (256KB) + L1d L#4 (32KB) + L1i L#4 (32KB) + Core L#4</div><div class="line">        PU L#8 (P#4)</div><div class="line">        PU L#9 (P#20)</div><div class="line">      L2 L#5 (256KB) + L1d L#5 (32KB) + L1i L#5 (32KB) + Core L#5</div><div class="line">        PU L#10 (P#5)</div><div class="line">        PU L#11 (P#21)</div><div class="line">      L2 L#6 (256KB) + L1d L#6 (32KB) + L1i L#6 (32KB) + Core L#6</div><div class="line">        PU L#12 (P#6)</div><div class="line">        PU L#13 (P#22)</div><div class="line">      L2 L#7 (256KB) + L1d L#7 (32KB) + L1i L#7 (32KB) + Core L#7</div><div class="line">        PU L#14 (P#7)</div><div class="line">        PU L#15 (P#23)</div><div class="line">    HostBridge L#0</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#0 &quot;enp1s0f0&quot;</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#1 &quot;enp1s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#2 &quot;enp4s0f0&quot;</div><div class="line">        PCI 8086:1521</div><div class="line">          Net L#3 &quot;enp4s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 1000:0097</div><div class="line">          Block(Disk) L#4 &quot;sda&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#5 &quot;enp8s0f0&quot;</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#6 &quot;enp8s0f1&quot;</div><div class="line">      PCIBridge</div><div class="line">        PCIBridge</div><div class="line">          PCI 1a03:2000</div><div class="line">            GPU L#7 &quot;card0&quot;</div><div class="line">            GPU L#8 &quot;controlD64&quot;</div><div class="line">  NUMANode L#1 (P#1 47GB)</div><div class="line">    Package L#1 + L3 L#1 (20MB)</div><div class="line">      L2 L#8 (256KB) + L1d L#8 (32KB) + L1i L#8 (32KB) + Core L#8</div><div class="line">        PU L#16 (P#8)</div><div class="line">        PU L#17 (P#24)</div><div class="line">      L2 L#9 (256KB) + L1d L#9 (32KB) + L1i L#9 (32KB) + Core L#9</div><div class="line">        PU L#18 (P#9)</div><div class="line">        PU L#19 (P#25)</div><div class="line">      L2 L#10 (256KB) + L1d L#10 (32KB) + L1i L#10 (32KB) + Core L#10</div><div class="line">        PU L#20 (P#10)</div><div class="line">        PU L#21 (P#26)</div><div class="line">      L2 L#11 (256KB) + L1d L#11 (32KB) + L1i L#11 (32KB) + Core L#11</div><div class="line">        PU L#22 (P#11)</div><div class="line">        PU L#23 (P#27)</div><div class="line">      L2 L#12 (256KB) + L1d L#12 (32KB) + L1i L#12 (32KB) + Core L#12</div><div class="line">        PU L#24 (P#12)</div><div class="line">        PU L#25 (P#28)</div><div class="line">      L2 L#13 (256KB) + L1d L#13 (32KB) + L1i L#13 (32KB) + Core L#13</div><div class="line">        PU L#26 (P#13)</div><div class="line">        PU L#27 (P#29)</div><div class="line">      L2 L#14 (256KB) + L1d L#14 (32KB) + L1i L#14 (32KB) + Core L#14</div><div class="line">        PU L#28 (P#14)</div><div class="line">        PU L#29 (P#30)</div><div class="line">      L2 L#15 (256KB) + L1d L#15 (32KB) + L1i L#15 (32KB) + Core L#15</div><div class="line">        PU L#30 (P#15)</div><div class="line">        PU L#31 (P#31)</div><div class="line">    HostBridge L#7</div><div class="line">      PCIBridge</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#9 &quot;enp132s0f0&quot;</div><div class="line">        PCI 8086:10fb</div><div class="line">          Net L#10 &quot;enp132s0f1&quot;</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div><div class="line">  Misc(MemoryModule)</div></pre></td></tr></table></figure>
<p>如果是桌面环境，则会弹窗一个窗口：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hwloc.png" alt="hwloc"></p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[firewalld和iptables]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/firewalld%E5%92%8Ciptables/</url>
      <content type="html"><![CDATA[<p>centos7上关于打开和关闭防火墙及端口略有区别，记录之~<br><a id="more"></a><br>Centos升级到7之后，使用firewalld代替了原来的iptables，控制Linuxs的端口。firewalld是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。</p>
<h2 id="防火墙的设置"><a href="#防火墙的设置" class="headerlink" title="防火墙的设置"></a>防火墙的设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl stop firewalld 		# 停止firewall</div><div class="line">systemctl disable firewalld 	# 禁止firewall开机启动</div><div class="line">systemctl start firewalld 		# 开启防火墙</div></pre></td></tr></table></figure>
<h2 id="端口操作"><a href="#端口操作" class="headerlink" title="端口操作"></a>端口操作</h2><p>查看已开放的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># firewall-cmd --list-ports</div><div class="line">6789/tcp 6800-7100/tcp</div></pre></td></tr></table></figure>
<p>开启端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</div></pre></td></tr></table></figure>
<p>命令含义：<br>–zone #作用域<br>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent   #永久生效，没有此参数重启后失效</p>
<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure>
<p>查询9200端口是否打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --query-port=9200/tcp</div></pre></td></tr></table></figure>
<h2 id="使用iptables"><a href="#使用iptables" class="headerlink" title="使用iptables"></a>使用iptables</h2><p>如果你要改用iptables的话，需要安装iptables服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install iptables-services</div><div class="line">sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables</div><div class="line">sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[S.M.A.R.T--磁盘健康状态监测工具]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/S-M-A-R-T-%E7%A3%81%E7%9B%98%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>介绍磁盘状态监测工具：S.M.A.R.T。<br><a id="more"></a></p>
<h2 id="S-M-A-R-T"><a href="#S-M-A-R-T" class="headerlink" title="S.M.A.R.T."></a>S.M.A.R.T.</h2><p><strong>S.M.A.R.T.</strong>，全称为“Self-Monitoring Analysis and Reporting Technology”，即“自我监测、分析及报告技术”，是一种自动的硬盘状态检测与预警系统和规范。通过在硬盘硬件内的检测指令对硬盘的硬件如磁头、盘片、马达、电路的运行情况进行监控、记录并与厂商所设定的预设安全值进行比较，若监控情况将或已超出预设安全值的安全范围，就可以通过主机的监控硬件或软件自动向用户作出警告并进行轻微的自动修复，以提前保障硬盘数据的安全。</p>
<p>软件包 <strong>smartmontools</strong> 它通过使用自我监控(Self-Monitoring)、分析(Analysis)和报告(Reporting)三种技术（缩写为S.M.A.R.T或SMART）来管理和监控存储硬件。如今大部分的ATA/SATA、SCSI/SAS和固态硬盘都搭载内置的SMART系统。SMART的目的是监控硬盘的可靠性、预测磁盘故障和执行各种类型的磁盘自检。smartmontools由smartctl和smartd两部分工具程序组成，它们一起为Linux平台提供对磁盘退化和故障的高级警告。</p>
<blockquote>
<p>文章内容大部分为转载，硬盘信息和配置部分为自己实验所得。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install smartmontools</div></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">smartctl -a  &lt;device&gt;    		显示硬盘所有SMART信息。</div><div class="line">smartctl -i &lt;device&gt;   			显示硬盘model number, serial number,是否开启SMART等信息。</div><div class="line">smartctl -s on &lt;device&gt;    		如果没有打开SMART技术，使用该命令打开SMART技术。</div><div class="line">smartctl -t short &lt;device&gt;    	后台检测硬盘，消耗时间短</div><div class="line">smartctl -t long &lt;device&gt;      	后台检测硬盘，消耗时间长</div><div class="line">smartctl -C -t short &lt;device&gt; 	前台检测硬盘，消耗时间短</div><div class="line">smartctl -C -t long &lt;device&gt;  	前台检测硬盘，消耗时间长</div><div class="line">smartctl -X &lt;device&gt;  			中断后台检测硬盘。</div><div class="line">smartctl -l selftest &lt;device&gt;  	显示硬盘检测日志。</div><div class="line">smartctl -l error &lt;device&gt; 		显示硬盘错误汇总。</div></pre></td></tr></table></figure>
<p>列出和系统相连的硬盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /dev | grep -E &apos;sd|hd&apos;</div></pre></td></tr></table></figure>
<h2 id="显示出某个指定硬盘的信息"><a href="#显示出某个指定硬盘的信息" class="headerlink" title="显示出某个指定硬盘的信息"></a>显示出某个指定硬盘的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># smartctl --info /dev/sdc</div><div class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</div><div class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</div><div class="line"></div><div class="line">=== START OF INFORMATION SECTION ===</div><div class="line">Device Model:     TOSHIBA MG03ACA400</div><div class="line">Serial Number:    565BK4CXF</div><div class="line">LU WWN Device Id: 5 000039 70bc0043a</div><div class="line">Firmware Version: FL1A</div><div class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</div><div class="line">Sector Size:      512 bytes logical/physical</div><div class="line">Rotation Rate:    7200 rpm</div><div class="line">Device is:        Not in smartctl database [for details use: -P showall]</div><div class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</div><div class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</div><div class="line">Local Time is:    Sun May  7 15:10:58 2017 CST</div><div class="line">SMART support is: Available - device has SMART capability.</div><div class="line">SMART support is: Enabled</div></pre></td></tr></table></figure>
<h2 id="检测某个硬盘的健康状况"><a href="#检测某个硬盘的健康状况" class="headerlink" title="检测某个硬盘的健康状况"></a>检测某个硬盘的健康状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"># smartctl -s on -a /dev/sdc</div><div class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</div><div class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</div><div class="line"></div><div class="line">=== START OF INFORMATION SECTION ===</div><div class="line">Device Model:     TOSHIBA MG03ACA400</div><div class="line">Serial Number:    565BK4CXF</div><div class="line">LU WWN Device Id: 5 000039 70bc0043a</div><div class="line">Firmware Version: FL1A</div><div class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</div><div class="line">Sector Size:      512 bytes logical/physical</div><div class="line">Rotation Rate:    7200 rpm</div><div class="line">Device is:        Not in smartctl database [for details use: -P showall]</div><div class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</div><div class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</div><div class="line">Local Time is:    Sun May  7 15:12:44 2017 CST</div><div class="line">SMART support is: Available - device has SMART capability.</div><div class="line">SMART support is: Enabled</div><div class="line"></div><div class="line">=== START OF ENABLE/DISABLE COMMANDS SECTION ===</div><div class="line">SMART Enabled.</div><div class="line"></div><div class="line">=== START OF READ SMART DATA SECTION ===</div><div class="line">SMART overall-health self-assessment test result: PASSED</div><div class="line"></div><div class="line">General SMART Values:</div><div class="line">Offline data collection status:  (0x82)	Offline data collection activity</div><div class="line">					was completed without error.</div><div class="line">					Auto Offline Data Collection: Enabled.</div><div class="line">Self-test execution status:      (   0)	The previous self-test routine completed</div><div class="line">					without error or no self-test has ever</div><div class="line">					been run.</div><div class="line">Total time to complete Offline</div><div class="line">data collection: 		(  120) seconds.</div><div class="line">Offline data collection</div><div class="line">capabilities: 			 (0x5b) SMART execute Offline immediate.</div><div class="line">					Auto Offline data collection on/off support.</div><div class="line">					Suspend Offline collection upon new</div><div class="line">					command.</div><div class="line">					Offline surface scan supported.</div><div class="line">					Self-test supported.</div><div class="line">					No Conveyance Self-test supported.</div><div class="line">					Selective Self-test supported.</div><div class="line">SMART capabilities:            (0x0003)	Saves SMART data before entering</div><div class="line">					power-saving mode.</div><div class="line">					Supports SMART auto save timer.</div><div class="line">Error logging capability:        (0x01)	Error logging supported.</div><div class="line">					General Purpose Logging supported.</div><div class="line">Short self-test routine</div><div class="line">recommended polling time: 	 (   2) minutes.</div><div class="line">Extended self-test routine</div><div class="line">recommended polling time: 	 ( 616) minutes.</div><div class="line">SCT capabilities: 	       (0x003d)	SCT Status supported.</div><div class="line">					SCT Error Recovery Control supported.</div><div class="line">					SCT Feature Control supported.</div><div class="line">					SCT Data Table supported.</div><div class="line"></div><div class="line">SMART Attributes Data Structure revision number: 16</div><div class="line">Vendor Specific SMART Attributes with Thresholds:</div><div class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</div><div class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</div><div class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</div><div class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</div><div class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</div><div class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</div><div class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</div><div class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</div><div class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</div><div class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</div><div class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</div><div class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</div><div class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</div><div class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</div><div class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</div><div class="line"></div><div class="line">SMART Error Log Version: 1</div><div class="line">No Errors Logged</div><div class="line"></div><div class="line">SMART Self-test log structure revision number 1</div><div class="line">No self-tests have been logged.  [To run self-tests, use: smartctl -t]</div><div class="line"></div><div class="line"></div><div class="line">SMART Selective self-test log data structure revision number 1</div><div class="line"> SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS</div><div class="line">    1        0        0  Not_testing</div><div class="line">    2        0        0  Not_testing</div><div class="line">    3        0        0  Not_testing</div><div class="line">    4        0        0  Not_testing</div><div class="line">    5        0        0  Not_testing</div><div class="line">Selective self-test flags (0x0):</div><div class="line">  After scanning selected spans, do NOT read-scan remainder of disk.</div><div class="line">If Selective self-test is pending on power-up, resume after 0 minute delay.</div></pre></td></tr></table></figure>
<p>其中，”READ SMART DATA”部分显示出硬盘的整体健康状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">=== START OF READ SMART DATA SECTION ===</div><div class="line">SMART overall-health self-assessment test result: PASSED</div></pre></td></tr></table></figure>
<h2 id="SMART属性表"><a href="#SMART属性表" class="headerlink" title="SMART属性表"></a>SMART属性表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</div><div class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</div><div class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</div><div class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</div><div class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</div><div class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</div><div class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</div><div class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</div><div class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</div><div class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</div><div class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</div><div class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</div><div class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</div><div class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</div><div class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</div><div class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</div><div class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</div><div class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</div><div class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</div></pre></td></tr></table></figure>
<p>SMART属性表列出了制造商在硬盘中定义好的属性值，以及这些属性相关的故障阈值。这个表由驱动固件自动生成和更新。</p>
<ul>
<li><strong>ID</strong>：属性ID，通常是一个1到255之间的十进制或十六进制的数字。</li>
<li><strong>ATTRIBUTE_NAME</strong>：硬盘制造商定义的属性名。</li>
<li><strong>FLAG</strong>：属性操作标志（可以忽略）。</li>
<li><strong>VALUE</strong>：这是表格中最重要的信息之一，代表给定属性的标准化值，在1到253之间。253意味着最好情况，1意味着最坏情况。取决于属性和制造商，初始化VALUE可以被设置成100或200.</li>
<li><strong>WORST</strong>：所记录的最小VALUE。</li>
<li><strong>THRESH</strong>：在报告硬盘FAILED状态前，WORST可以允许的最小值。</li>
<li><strong>TYPE</strong>：属性的类型（Pre-fail或Old<em>age）。Pre-fail类型的属性可被看成一个关键属性，表示参与磁盘的整体SMART健康评估（PASSED/FAILED）。如果任何Pre-fail类型的属性故障，那么可视为磁盘将要发生故障。另一方面，Old</em>age类型的属性可被看成一个非关键的属性（如正常的磁盘磨损），表示不会使磁盘本身发生故障。</li>
<li><strong>UPDATED</strong>：表示属性的更新频率。Offline代表磁盘上执行离线测试的时间。</li>
<li><strong>WHEN_FAILED</strong>：如果VALUE小于等于THRESH，会被设置成“FAILING_NOW”；如果WORST小于等于THRESH会被设置成“In_the_past”；如果都不是，会被设置成“-”。在“FAILING_NOW”情况下，需要尽快备份重要文件，特别是属性是Pre-fail类型时。“In_the_past”代表属性已经故障了，但在运行测试的时候没问题。“-”代表这个属性从没故障过。</li>
<li><strong>RAW_VALUE</strong>：制造商定义的原始值，从VALUE派生。</li>
</ul>
<h2 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h2><p>编辑smartctl的配置文件(/etc/default/smartmontools)以便在系统启动时启动smartd，并以秒为单位指定间隔时间（如7200 = 2小时）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start_smartd=yes</div><div class="line">smartd_opts=&quot;--interval=7200&quot;</div></pre></td></tr></table></figure>
<p>编辑smartd的配置文件，添加以下行内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># vim /etc/smartmontools/smartd</div><div class="line">smartd.conf        smartd_warning.d/  smartd_warning.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda -m myemail@mydomain.com -M test</div></pre></td></tr></table></figure>
<p><strong>-m </strong>：指定发送测试报告到某个电子邮件地址。这里可以是系统用户比如root，或者如果服务器已经配置成发送电子邮件到系统外部，则是类似于<a href="mailto:myemail@mydomain.com" target="_blank" rel="external">myemail@mydomain.com</a>的邮件地址。</p>
<p><strong>-M </strong>：指定发送邮件报告的期望类型。</p>
<ul>
<li><strong>once</strong>：为检测到的每种磁盘问题只发送一封警告邮件。</li>
<li><strong>daily</strong>：为检测到的每种磁盘问题每隔一天发送一封额外的警告提醒邮件。</li>
<li><strong>diminishing</strong>：为检测到的每种问题发送一封额外的警告提醒邮件，开始是每隔一天，然后每隔两天，每隔四天，以此类推。每个间隔是前一次间隔的2倍。</li>
<li><strong>test</strong>：只要smartd一启动，立即发送一封测试邮件。</li>
<li><strong>exec PATH</strong>：取代默认的邮件命令，运行PATH路径下的可执行文件。PATH必须指向一个可执行的二进制文件或脚本。当检测到一个问题时，可以指定执行一个期望的动作（闪烁控制台、关闭系统等等）。</li>
</ul>
<p>保存改动并重启smartd。</p>
<p>可以使用“-s”标志和形如“T/MM/DD/d/HH”的正则表达式按照想要的调度方案执行测试，其中：</p>
<p>正则表达式中的T代表测试的类型：</p>
<ul>
<li>L：长测试</li>
<li>S：短测试</li>
<li>C：传输测试（仅限ATA）</li>
<li>O：离线测试（仅限ATA）</li>
</ul>
<p>其它的字符代表测试执行的日期和时间：</p>
<ul>
<li>MM是一年中的月份。</li>
<li>DD是一月中的天份。</li>
<li>HH是一天中的小时。</li>
<li>d是一个星期中的某天（从1=周一到7=周日）。</li>
<li>MM、DD和HH使用两位十进制数字表示。</li>
</ul>
<p>在上述表达中的小圆点表示所有可能的值。形如’(A|B|C)’在圆括号里的表达式表示三个可能值A、B和C中的任意一个。形如[1-5]在方括号中的表达式表示1到5的范围（包含5）.</p>
<p>例如，想要在每个工作日的下午一点为所有的磁盘执行一次长测试，在/etc/smartd.conf中添加如下行内容。确保编辑完重启smartd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEVICESCAN -s (L/../../[1-5]/13)</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/S.M.A.R.T" target="_blank" rel="external">https://zh.wikipedia.org/wiki/S.M.A.R.T</a>.</p>
<p><a href="https://linux.cn/article-4461-1.html" target="_blank" rel="external">使用 smartmontools 查看硬盘的健康状态</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2配色--zsh & oh-my-zsh]]></title>
      <url>http://xiaqunfeng.cc/2017/05/04/iterm2%E9%85%8D%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>给iterm2进行配色，炫酷一点。<br><a id="more"></a></p>
<h3 id="Solarized"><a href="#Solarized" class="headerlink" title="Solarized"></a>Solarized</h3><p>目前网络上最流行的配色解决方案：<a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">Solarized</a></p>
<p>Solarized Dark 官方网站: <a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">http://ethanschoonover.com/solarized</a></p>
<p>Solarized Dark github 地址: <a href="https://github.com/altercation/solarized" target="_blank" rel="external">https://github.com/altercation/solarized</a></p>
<p>下载下来后会看到琳琅满目的配色解决方案，其中有一个目录 <code>iterm2-colors-solarized</code> 是为 iterm2 准备的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ls iterm2-colors-solarized/</div><div class="line">.md</div><div class="line">Solarized Dark.itermcolors</div><div class="line">Solarized Light.itermcolors</div></pre></td></tr></table></figure>
<p>进入目录能看到 3个文件 (1个 md说明文件,2个配色文件) </p>
<p>我们使用其中一个 Solarized Dark.itermcolors</p>
<p>然后 preferences -&gt; colors -&gt; import 即可。</p>
<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>众所周知在Unix/Linux系统下是存在很多不同的shell，常见的就有bash, csh，ksh，zsh等等。在Linux和MAC OS系统中，默认使用的是bash。这里介绍功能更加强大的 <strong>zsh</strong>。</p>
<p>1、通过homebrew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install zsh</div></pre></td></tr></table></figure>
<p>2、将zsh设置成系统默认shell，以代替bash</p>
<p>用编辑器打开<code>/etc/shells</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/zsh</div></pre></td></tr></table></figure>
<p> 在终端中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /usr/local/bin/zsh</div></pre></td></tr></table></figure>
<p>然后重新启动iTerm2，zsh就已经被配置成默认的shell了。</p>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p>github：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh</a></p>
<p>1、安装</p>
<p> <strong>on-my-zsh</strong>的安装支持自动和手动，为了省去麻烦，我建议优先使用自动，如果要使用手动安装，请查看安装说明。这里只说一下自动安装。 在终端里，如果你有<code>curl</code>，则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L http://install.ohmyz.sh | sh</div></pre></td></tr></table></figure>
<p>如果你使用<code>wget</code>,则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate http://install.ohmyz.sh -O - | sh</div></pre></td></tr></table></figure>
<p>这样oh-my-zsh就安装完成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">~/.oh-my-zsh  master ✔                                                              1d</div><div class="line">▶ ls</div><div class="line">CONTRIBUTING.md cache           log             templates</div><div class="line">LICENSE.txt     custom          oh-my-zsh.sh    themes</div><div class="line">README.md       lib             plugins         tools</div></pre></td></tr></table></figure>
<p>2、配置</p>
<p>zsh的配置在<code>~/.zshrc</code>下面这</p>
<p>主题的配置</p>
<p>在<code>~/.oh-my-zsh/themes</code>存在各式各样的主题文件，每个主题可以通过：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a> 进行查看。选好样式后，</p>
<p>在<code>.zshrc</code>中的 <code>ZSH_THEME</code>设置成你所选用的主题，重启iTerm2，就可以看到相应的效果。我这里用的 <strong>avit</strong>。上面哪个oh-my-zsh 文件夹目录的列表就是用的这个主题。</p>
<p>如果使用agnoster主题的话还需要装字体包，如下：</p>
<p><a href="https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher" target="_blank" rel="external">https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher</a></p>
<p><a href="https://github.com/powerline/fonts" target="_blank" rel="external">https://github.com/powerline/fonts</a></p>
<h3 id="更多的配色方案"><a href="#更多的配色方案" class="headerlink" title="更多的配色方案"></a>更多的配色方案</h3><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="external">https://github.com/mbadolato/iTerm2-Color-Schemes</a></p>
<p>可以根据自己的喜好来选择主题了。</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</div><div class="line">echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc</div><div class="line">source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</div></pre></td></tr></table></figure>
<p>在 .zshrc 尾部添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(zsh-syntax-highlighting)</div></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.zshrc</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx使用和配置]]></title>
      <url>http://xiaqunfeng.cc/2017/05/03/nginx%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>简单介绍nginx，特别是反向代理和负载均衡部分，并用通过实战加深理解。<br><a id="more"></a></p>
<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<p>架设服务器均衡负载方式有多种，Nginx、LVS、HAProxy+Keepalived是目前使用最广泛的三种方案。其中Keepalived+HAProxy是一个高可用性方案。</p>
<p>nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。</p>
<ul>
<li>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</li>
<li>多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。基本的网络事件，在worker进程中处理。</li>
</ul>
<p>nginx模块一般被分成三大类：handler、filter和upstream。</p>
<p>使用<code>Nginx</code>的方法就是写配置文件，配置文件能完全控制<code>Nginx</code>，使<code>Nginx</code>按照我们的需求进行运行。</p>
<blockquote>
<p>关于nginx的配置文件，需要深入了解和使用的可以去学习一下。</p>
</blockquote>
<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>OS: CentOS 7.3</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nginx -y</div></pre></td></tr></table></figure>
<p>关闭防火墙和selinux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># systemctl stop firewalld</div><div class="line"># systemctl disable firewalld</div><div class="line"></div><div class="line"># setenforce 0</div><div class="line">setenforce: SELinux is disabled</div><div class="line"># getenforce</div><div class="line">Disabled</div></pre></td></tr></table></figure>
<p>添加至服务列表，开机自动启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># chkconfig --add nginx</div><div class="line"># chkconfig nginx on </div><div class="line"># chkconfig nginx --list</div></pre></td></tr></table></figure>
<p>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service nginx start</div><div class="line">Redirecting to /bin/systemctl start  nginx.service</div></pre></td></tr></table></figure>
<p>查看端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># netstat -ntlp | grep :80</div><div class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      16858/nginx: master</div><div class="line">tcp6       0      0 :::80                   :::*                    LISTEN      16858/nginx: master</div></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost" target="_blank" rel="external">http://localhost</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-welcome.png" alt="nginx-welcome"></p>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx -s reload</div><div class="line">或者</div><div class="line">service nginx restart</div></pre></td></tr></table></figure>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>1、代理</p>
<p>所谓代理，就是在客户端和服务端之间强行添加了一层，用来实现流量转发的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+----------------+         +---------------+        +--------------+</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |  http   |               | http   |              |</div><div class="line">|    client      &lt;---------&gt;    proxy      &lt;--------&gt;   server     |</div><div class="line">|                |  https  |               | https  |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">|                |         |               |        |              |</div><div class="line">+----------------+         +---------------+        +--------------+</div></pre></td></tr></table></figure>
<p>2、正向代理</p>
<p>用于代理客户端。</p>
<p>比如：我是一个用户，我访问不了某网站（例如google），但是我能访问一个代理服务器，这个代理服务器能访问google，于是我先连上代理服务器，告诉他我需要访问google的内容，代理服务器去取回来，然后返回给我。自此，一次正向代理顺利完成。</p>
<p>3、反向代理</p>
<p>用来代理服务端。</p>
<p>依然拿google举例，网站每秒钟要处理很多请求，如果仅仅让一台单一的服务器处理，肯定应付不过来。所以采用多台服务器来处理这些请求，减少每台服务器的压力。但是多个服务器那就产生了多个Server，我的一个<code>google.com</code>就不能解析到这些服务器上，而且用多个二级域名比如<code>server1.google.com</code>，<code>server2.google.com</code>等等也给用户造成了使用上的不便，通过反向代理可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+-------------+                                             |      |                   |</div><div class="line">|             +----------+                                  |      |                   |</div><div class="line">|  client 1   |          |                                  |      +-------------------+</div><div class="line">|             |          |                                  |</div><div class="line">+-------------+          |                                  |</div><div class="line">                         |         +------------------+     |      +-------------------+</div><div class="line">                         |         |                  |     |      |                   |</div><div class="line">+-------------+          |         |                  |     |      |   server 2        |</div><div class="line">|             |          |         |                  +------------&gt;                   |</div><div class="line">|  clent 2    +--------------------&gt;  reverse proxy   |     |      |                   |</div><div class="line">|             |          |         |                  |     |      +-------------------+</div><div class="line">+-------------+          |         |                  |     |</div><div class="line">                         |         |                  |     |               .</div><div class="line">      .                  |         |                  |     |               .</div><div class="line">      .                  |         +------------------+     |               .</div><div class="line">      .                  |                                  |</div><div class="line">                         |                                  |      +--------------------+</div><div class="line">+-------------+          |                                  |      |                    |</div><div class="line">|             |          |                                  |      |   server m         |</div><div class="line">|  client n   +----------+                                  +------&gt;                    |</div><div class="line">|             |                                                    |                    |</div><div class="line">+-------------+                                                    +--------------------+</div></pre></td></tr></table></figure>
<p> 结论就是，客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>
<p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>
<p>代理模块的指令有很多我这里只讲解重要的proxy_pass，这个模块可以转发请求到其他的服务器。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>一台机器装有Nginx，两台测试机装httpd</p>
<h4 id="测试机httpd配置"><a href="#测试机httpd配置" class="headerlink" title="测试机httpd配置"></a>测试机httpd配置</h4><p>1、安装httpd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install httpd -y</div></pre></td></tr></table></figure>
<p>2、提供页面测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ceph0机器</div><div class="line">echo &quot;&lt;h1&gt;ceph0.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</div><div class="line"># ceph1机器</div><div class="line">echo &quot;&lt;h1&gt;ceph1.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</div></pre></td></tr></table></figure>
<p>3、启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service httpd start</div></pre></td></tr></table></figure>
<p>如果启动失败的话注意查看是否80端口被占用</p>
<p>4、web上登录ceph0和ceph1机器IP查看</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph0.png" alt="ceph0"></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph1.png" alt="ceph1"></p>
<p>注意：Nginx和httpd都监听在80端口，https监听在443端口</p>
<p>如果要修改httpd的监听端口的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf/httpd.conf</div><div class="line">...</div><div class="line">Listen 80		# 修改这一行</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="nginx配置和测试"><a href="#nginx配置和测试" class="headerlink" title="nginx配置和测试"></a>nginx配置和测试</h4><p>设置配置文件，设置完后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># cat /etc/nginx/conf.d/test.conf</div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://123.59.204.185:80;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx -t</div><div class="line">nginx -s reload</div><div class="line">service nginx restart</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>去ceph0机器上查看日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@ceph0 ~]# tail /var/log/httpd/access_log</div><div class="line">180.168.57.238 - - [03/May/2017:10:27:17 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</div><div class="line">123.59.185.23 - - [03/May/2017:11:25:30 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</div><div class="line">123.59.185.23 - - [03/May/2017:11:29:40 +0800] &quot;GET / HTTP/1.0&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</div></pre></td></tr></table></figure>
<p>注意这里 HTTP/1.1和HTTP/1.0的区别</p>
<p>proxy_pass模块可以转发请求到其他的服务器。nginx为浏览器发送HTTP/1.1，为后端服务器发送HTTP/1.0。</p>
<p>HTTP/1.0无法使用keepalive（后端服务器将为每个请求创建并且删除连接），这样浏览器就可以为浏览器处理keepalive。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>upstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>Nginx的负载均衡模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方调度算法。  </p>
<ul>
<li>轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight 指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。（一般电子商务网站用的比较多）</li>
<li>fair。这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li>url_hash。此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li>
</ul>
<blockquote>
<p>在 ip_hash 策略中，用于进行 hash 运算的 key，是 client 的 C 类 IP 地址（C 类 IP 地址就是范围在 192.0.0.0 到 223.255.255.255 之间，前三段号码表示子网，第四段号码为本地主机的 IP 地址类别）。这样的方式保证一个 client 每次请求都将到达同一个 backend。当然，如果所 hash 到的 backend 当前不可用，则请求会被转移到其他 backend。</p>
</blockquote>
<h3 id="upstream-支持的状态参数"><a href="#upstream-支持的状态参数" class="headerlink" title="upstream 支持的状态参数"></a>upstream 支持的状态参数</h3><p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：      </p>
<ul>
<li>down，表示当前的server暂时不参与负载均衡。</li>
<li>weight 默认为1。weight越大，负载的权重就越大。</li>
<li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li>
<li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li>
<li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<blockquote>
<p>注，当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>
<p>如果负载均衡把请求分配到backup服务器上，就不能能访问到期望的页面了。</p>
<p>weight和 ip_hash是不同的策略。</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80 weight=1 max_fails=2 fial_timeout=2;</div><div class="line">    server 123.59.204.193:80 down;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>server 185的权重为1，当请求失败的次数为2时，返回错误，并暂停服务2秒。</p>
<p>Server 193 down了，不会被访问到。</p>
<h3 id="配置负载均衡服务器"><a href="#配置负载均衡服务器" class="headerlink" title="配置负载均衡服务器"></a>配置负载均衡服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># cat conf.d/test.conf</div><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80;</div><div class="line">    server 123.59.204.193:80;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    server_name itest.com;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://itest;</div><div class="line">#        proxy_set_header  X-Real-IP  $remote_addr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@nginx]# curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</div><div class="line">[root@nginx]# curl 127.0.0.1:8000</div><div class="line">&lt;h1&gt;ceph1.test.com&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>百分之50的概率读取到一台机器</p>
<p>注，upstream是定义在server{ }之外的，不能定义在server{ }内部。定义好upstream之后，用proxy_pass引用一下即可。</p>
<h2 id="备份服务器"><a href="#备份服务器" class="headerlink" title="备份服务器"></a>备份服务器</h2><p>配置nginx文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># cat /etc/nginx/conf.d/test.conf</div><div class="line">upstream itest &#123;</div><div class="line">    server 123.59.204.185:80;</div><div class="line">    server 123.59.204.193:80;</div><div class="line">    server 127.0.0.1:8000 backup;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 8000;</div><div class="line">    server_name itest.com;</div><div class="line">    root /root/errorpage;</div><div class="line">    index index.html;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://itest;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件夹和index文件的建立</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># mkdir /root/errorpage</div><div class="line"># cat index.html</div><div class="line">&lt;h1&gt;Sorry, all ceph node is down! Please try again later!&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>另外两台机器上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service httpd stop</div></pre></td></tr></table></figure>
<p>然后再访问的话就会访问到备份服务器，输出index.html的内容。</p>
<p>附一个关于nginx的好系列文章：<a href="http://blog.csdn.net/poechant/article/details/7213546" target="_blank" rel="external">高性能Web服务器Nginx的配置与部署研究</a></p>
<p>有空学习，mark之。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2快捷键的使用]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>mac下终端神器iterm2，非常的好用，极大提高了效率，这里将自己使用过的快捷键总结如下。<br><a id="more"></a></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>新建tab：⌘ + t</p>
<p>切换 tab：    ⌘+←, ⌘+→</p>
<p>​            ⌘+{, ⌘+}</p>
<p>​            ⌘ + Num</p>
<p>切换全屏：⌘ + enter</p>
<p>关闭tab：⌘ + w</p>
<h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p>
<p>切换Tab中的pane：⌘ + [ / ]</p>
<p>按方向切换 pane：⌘+Option+方向键</p>
<p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p>
<p>关闭panel：⌘ + w</p>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>智能查找，支持正则查找：⌘+f</p>
<p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p>
<p>自动填充：⌘ + ； 命令补全提示 </p>
<p>打开最近目录： ⌘ + alt + /</p>
<p>窗口太多，快速定位到光标所在位置：⌘ + / </p>
<p>鼠标所在行高亮显示： ⌘ + alt + ； </p>
<p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p>
<p>⌘+Shift+h弹出历史记录窗口</p>
<p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p>
<p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p>
<h2 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h2><p>可以拖拽选中的字符串</p>
<p>可以点击 url：调用默认浏览器访问该网址</p>
<p>可以点击文件：调用默认程序打开文件</p>
<p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p>
<p>点击文件夹：在 finder 中打开该文件夹</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>设置标记：⌘ + shift + m </p>
<p>跳转到上个标记：⌘ + shift + j</p>
<p>多个标记切换：⌘ + shift + arrow(上下)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>置空屏幕: clear </p>
<p>​        ctrl + l </p>
<p>​        ⌘ + k</p>
<p>清空屏幕: command + k/r</p>
<p>字体调大:  command + +</p>
<p>字体调小:  command + -</p>
<p>清除当前行：ctrl + u</p>
<p>到行首：ctrl + a</p>
<p>到行尾：ctrl + e</p>
<p>从光标处删至字首/尾：ctrl + w / k</p>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VSM部署]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/VSM%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>本文介在已有ceph集群机器上部署VSM的过程，涵盖centos和ubuntu两种系统。<br><a id="more"></a></p>
<h2 id="VSM-Virtual-Storage-Manager"><a href="#VSM-Virtual-Storage-Manager" class="headerlink" title="VSM - Virtual Storage Manager"></a>VSM - Virtual Storage Manager</h2><p>最新发布的release版本为2.1，pre-release版本为2.2，已不再更新和维护（因为负责人<a href="mailto:yaguang.wang@intel.com" target="_blank" rel="external">yaguang.wang@intel.com</a> or <a href="mailto:ferber.dan@intel.com" target="_blank" rel="external">ferber.dan@intel.com</a>已经从intel离职了）。</p>
<p>从2.1版本开始，VSM支持在已有ceph集群上部署，正是因为这个原因，才开始尝试部署VSM。</p>
<p>VSM 2.1的代码组件分为四个：</p>
<ul>
<li>vsm-dashboard：VSM的管理与监控web界面</li>
<li>python-vsmclient：调用restapi的client</li>
<li>vsm：VSM的核心组件（包括api、scheduler、conductor、agent等）</li>
<li>vsm-deploy：ceph部署工具</li>
</ul>
<p>代码基于Python语言，使用了wsgi、django等技术框架。</p>
<p>Git主页：<br><a href="https://github.com/01org/virtual-storage-manager" target="_blank" rel="external">https://github.com/01org/virtual-storage-manager</a></p>
<p>vsm-dependencies：<br><a href="https://github.com/01org/vsm-dependencies" target="_blank" rel="external">https://github.com/01org/vsm-dependencies</a></p>
<p>VSM系统有两个角色，一个是vsm-controller，另外一个是vsm-agent：</p>
<ul>
<li>vsm-agent部署在ceph节点上</li>
<li>vsm-controller部署在单独的任意节点（也可以部署在ceph节点上）</li>
</ul>
<p>架构图如下：<img src="http://oow6unnib.bkt.clouddn.com/vsm-architecture.png" alt="vsm-architecture"></p>
<h2 id="centos上部署"><a href="#centos上部署" class="headerlink" title="centos上部署"></a>centos上部署</h2><p>OS：CentOS 7.2</p>
<p>VSM：v2.1 released</p>
<p>4台机器，一个作为controller，三台ceph集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">172.20.2.76     ceph0</div><div class="line">172.20.2.77     ceph1</div><div class="line">172.20.2.79     ceph2</div><div class="line">172.20.2.81     controller</div></pre></td></tr></table></figure>
<p>1、从controller机器上设置到ceph集群机器和自己的免密登录</p>
<p>2、关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># systemctl disable firewalld</div><div class="line"># systemctl stop firewalld</div></pre></td></tr></table></figure>
<p>3、关闭selinux</p>
<p>临时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setenforce 0</div></pre></td></tr></table></figure>
<p>永久</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat /etc/selinux/config | grep -v &quot;#&quot;</div><div class="line"></div><div class="line">SELINUX=disabled</div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure>
<h3 id="下载VSM："><a href="#下载VSM：" class="headerlink" title="下载VSM："></a>下载VSM：</h3><p>在controller机器上执行如下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336_centos7.tar.gz</div><div class="line"># tar -zxvf 2.1.0-336_centos7.tar.gz</div><div class="line"># cd 2.1.0-336</div><div class="line"># ls</div><div class="line">CHANGELOG.md   INSTALL.pdf  manifest      RELEASE       vsm-dep-repo</div><div class="line">CHANGELOG.pdf  installrc    NOTICE        rpms.lst      vsm-dep.repo</div><div class="line">get_pass.sh    install.sh   prov_node.sh  uninstall.sh  vsmrepo</div><div class="line">INSTALL.md     LICENSE      README.md     VERSION       vsm.repo</div></pre></td></tr></table></figure>
<h3 id="配置文件installrc"><a href="#配置文件installrc" class="headerlink" title="配置文件installrc"></a>配置文件installrc</h3><p>设置控制节点和代理节点的地址，设置完如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># cat installrc | egrep -v &quot;#|^$&quot;</div><div class="line">AGENT_ADDRESS_LIST=&quot;172.20.2.76 172.20.2.77 172.20.2.79&quot;</div><div class="line">CONTROLLER_ADDRESS=&quot;172.20.2.81&quot;</div></pre></td></tr></table></figure>
<h3 id="配置manifest"><a href="#配置manifest" class="headerlink" title="配置manifest"></a>配置manifest</h3><p>在文件夹manifest中，分别创建以管理IP地址命名的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ls manifest/</div><div class="line">172.20.2.76  172.20.2.79  cluster.manifest.sample</div><div class="line">172.20.2.77  172.20.2.81  server.manifest.sample</div></pre></td></tr></table></figure>
<p>将cluster.manifest.sample 文件复制到 172.20.2.81/cluster.manifest，编辑改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[management_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[100.64.0.22ceph_public_addr]</div><div class="line">172.20.2.0/24</div><div class="line"></div><div class="line">[ceph_cluster_addr]</div><div class="line">172.20.2.0/24</div></pre></td></tr></table></figure>
<p>将server.manifest.sample 文件复制到 76、77、79文件夹下，重命名为server.manifest，改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[vsm_controller_ip]</div><div class="line">172.20.2.81</div></pre></td></tr></table></figure>
<p>注：这里添加磁盘部分不用处理，因为是在已有ceph的集群上安装的。</p>
<p>manifest文件夹目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># tree</div><div class="line">.</div><div class="line">├── 172.20.2.76</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.77</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.79</div><div class="line">│   └── server.manifest</div><div class="line">├── 172.20.2.81</div><div class="line">│   └── cluster.manifest</div><div class="line">├── cluster.manifest.sample</div><div class="line">└── server.manifest.sample</div></pre></td></tr></table></figure>
<h3 id="添加epel源"><a href="#添加epel源" class="headerlink" title="添加epel源"></a>添加epel源</h3><p>在ceph集群机器上添加epel源，一般在安装ceph集群的时候就应该已经添加了，如果没有添加的话这里加一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./install.sh -u cephuser -v 2.1 --check-dependence-package</div></pre></td></tr></table></figure>
<p>安装完成后，调用get_pass.sh提取管理密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ./get_pass.sh</div><div class="line">24195bcbce558aa7bd2c</div></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录VSM仪表盘，地址：<a href="https://172.20.2.81:dashboard/vsm" target="_blank" rel="external">https://172.20.2.81:dashboard/vsm</a></p>
<p>用户名：admin</p>
<p>密码：24195bcbce558aa7bd2c</p>
<p>进入后界面如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/vsm-start.png" alt="vsm"></p>
<blockquote>
<p>注意：是https，不是http</p>
</blockquote>
<h2 id="ubuntu上部署"><a href="#ubuntu上部署" class="headerlink" title="ubuntu上部署"></a>ubuntu上部署</h2><p>OS：ubuntu 14.04</p>
<p>安装方法和centos上基本类似，不一样的地方有：</p>
<p>1、下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336-ubuntu14.tar.gz</div></pre></td></tr></table></figure>
<p>2、不需要添加epel源</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于在非ceph集群集群上安装并创建ceph集群后续有空补充。</p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令清单]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<p>转载的文章，里面git命令应有尽有，包含所有常用命令，mark之。<br><a id="more"></a></p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; # 在当前目录新建一个Git代码库</div><div class="line">&gt; $ git init</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个目录，将其初始化为Git代码库</div><div class="line">&gt; $ git init [project-name]</div><div class="line">&gt;</div><div class="line">&gt; # 下载一个项目和它的整个代码历史</div><div class="line">&gt; $ git clone [url]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示当前的Git配置</div><div class="line">&gt; $ git config --list</div><div class="line">&gt;</div><div class="line">&gt; # 编辑Git配置文件</div><div class="line">&gt; $ git config -e [--global]</div><div class="line">&gt;</div><div class="line">&gt; # 设置提交代码时的用户信息</div><div class="line">&gt; $ git config [--global] user.name &quot;[name]&quot;</div><div class="line">&gt; $ git config [--global] user.email &quot;[email address]&quot;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; # 添加指定文件到暂存区</div><div class="line">&gt; $ git add [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 添加指定目录到暂存区，包括子目录</div><div class="line">&gt; $ git add [dir]</div><div class="line">&gt;</div><div class="line">&gt; # 添加当前目录的所有文件到暂存区</div><div class="line">&gt; $ git add .</div><div class="line">&gt;</div><div class="line">&gt; # 添加每个变化前，都会要求确认</div><div class="line">&gt; # 对于同一个文件的多处变化，可以实现分次提交</div><div class="line">&gt; $ git add -p</div><div class="line">&gt;</div><div class="line">&gt; # 删除工作区文件，并且将这次删除放入暂存区</div><div class="line">&gt; $ git rm [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt; # 停止追踪指定文件，但该文件会保留在工作区</div><div class="line">&gt; $ git rm --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 改名文件，并且将这个改名放入暂存区</div><div class="line">&gt; $ git mv [file-original] [file-renamed]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; # 提交暂存区到仓库区</div><div class="line">&gt; $ git commit -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交暂存区的指定文件到仓库区</div><div class="line">&gt; $ git commit [file1] [file2] ... -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 提交工作区自上次commit之后的变化，直接到仓库区</div><div class="line">&gt; $ git commit -a</div><div class="line">&gt;</div><div class="line">&gt; # 提交时显示所有diff信息</div><div class="line">&gt; $ git commit -v</div><div class="line">&gt;</div><div class="line">&gt; # 使用一次新的commit，替代上一次提交</div><div class="line">&gt; # 如果代码没有任何新变化，则用来改写上一次commit的提交信息</div><div class="line">&gt; $ git commit --amend -m [message]</div><div class="line">&gt;</div><div class="line">&gt; # 重做上一次commit，并包括指定文件的新变化</div><div class="line">&gt; $ git commit --amend [file1] [file2] ...</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有本地分支</div><div class="line">&gt; $ git branch</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有远程分支</div><div class="line">&gt; $ git branch -r</div><div class="line">&gt;</div><div class="line">&gt; # 列出所有本地分支和远程分支</div><div class="line">&gt; $ git branch -a</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，但依然停留在当前分支</div><div class="line">&gt; $ git branch [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，并切换到该分支</div><div class="line">&gt; $ git checkout -b [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向指定commit</div><div class="line">&gt; $ git branch [branch] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，与指定的远程分支建立追踪关系</div><div class="line">&gt; $ git branch --track [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到指定分支，并更新工作区</div><div class="line">&gt; $ git checkout [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 切换到上一个分支</div><div class="line">&gt; $ git checkout -</div><div class="line">&gt;</div><div class="line">&gt; # 建立追踪关系，在现有分支与指定的远程分支之间</div><div class="line">&gt; $ git branch --set-upstream [branch] [remote-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 合并指定分支到当前分支</div><div class="line">&gt; $ git merge [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 选择一个commit，合并进当前分支</div><div class="line">&gt; $ git cherry-pick [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除分支</div><div class="line">&gt; $ git branch -d [branch-name]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程分支</div><div class="line">&gt; $ git push origin --delete [branch-name]</div><div class="line">&gt; $ git branch -dr [remote/branch]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt; # 列出所有tag</div><div class="line">&gt; $ git tag</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在当前commit</div><div class="line">&gt; $ git tag [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个tag在指定commit</div><div class="line">&gt; $ git tag [tag] [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 删除本地tag</div><div class="line">&gt; $ git tag -d [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 删除远程tag</div><div class="line">&gt; $ git push origin :refs/tags/[tagName]</div><div class="line">&gt;</div><div class="line">&gt; # 查看tag信息</div><div class="line">&gt; $ git show [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交指定tag</div><div class="line">&gt; $ git push [remote] [tag]</div><div class="line">&gt;</div><div class="line">&gt; # 提交所有tag</div><div class="line">&gt; $ git push [remote] --tags</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个分支，指向某个tag</div><div class="line">&gt; $ git checkout -b [branch] [tag]</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">&gt; # 显示有变更的文件</div><div class="line">&gt; $ git status</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的版本历史</div><div class="line">&gt; $ git log</div><div class="line">&gt;</div><div class="line">&gt; # 显示commit历史，以及每次commit发生变更的文件</div><div class="line">&gt; $ git log --stat</div><div class="line">&gt;</div><div class="line">&gt; # 搜索提交历史，根据关键词</div><div class="line">&gt; $ git log -S [keyword]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，每个commit占据一行</div><div class="line">&gt; $ git log [tag] HEAD --pretty=format:%s</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</div><div class="line">&gt; $ git log [tag] HEAD --grep feature</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个文件的版本历史，包括文件改名</div><div class="line">&gt; $ git log --follow [file]</div><div class="line">&gt; $ git whatchanged [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件相关的每一次diff</div><div class="line">&gt; $ git log -p [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示过去5次提交</div><div class="line">&gt; $ git log -5 --pretty --oneline</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有提交过的用户，按提交次数排序</div><div class="line">&gt; $ git shortlog -sn</div><div class="line">&gt;</div><div class="line">&gt; # 显示指定文件是什么人在什么时间修改过</div><div class="line">&gt; $ git blame [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和工作区的差异</div><div class="line">&gt; $ git diff</div><div class="line">&gt;</div><div class="line">&gt; # 显示暂存区和上一个commit的差异</div><div class="line">&gt; $ git diff --cached [file]</div><div class="line">&gt;</div><div class="line">&gt; # 显示工作区与当前分支最新commit之间的差异</div><div class="line">&gt; $ git diff HEAD</div><div class="line">&gt;</div><div class="line">&gt; # 显示两次提交之间的差异</div><div class="line">&gt; $ git diff [first-branch]...[second-branch]</div><div class="line">&gt;</div><div class="line">&gt; # 显示今天你写了多少行代码</div><div class="line">&gt; $ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交的元数据和内容变化</div><div class="line">&gt; $ git show [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交发生变化的文件</div><div class="line">&gt; $ git show --name-only [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 显示某次提交时，某个文件的内容</div><div class="line">&gt; $ git show [commit]:[filename]</div><div class="line">&gt;</div><div class="line">&gt; # 显示当前分支的最近几次提交</div><div class="line">&gt; $ git reflog</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; # 下载远程仓库的所有变动</div><div class="line">&gt; $ git fetch [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 显示所有远程仓库</div><div class="line">&gt; $ git remote -v</div><div class="line">&gt;</div><div class="line">&gt; # 显示某个远程仓库的信息</div><div class="line">&gt; $ git remote show [remote]</div><div class="line">&gt;</div><div class="line">&gt; # 增加一个新的远程仓库，并命名</div><div class="line">&gt; $ git remote add [shortname] [url]</div><div class="line">&gt;</div><div class="line">&gt; # 取回远程仓库的变化，并与本地分支合并</div><div class="line">&gt; $ git pull [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 上传本地指定分支到远程仓库</div><div class="line">&gt; $ git push [remote] [branch]</div><div class="line">&gt;</div><div class="line">&gt; # 强行推送当前分支到远程仓库，即使有冲突</div><div class="line">&gt; $ git push [remote] --force</div><div class="line">&gt;</div><div class="line">&gt; # 推送所有分支到远程仓库</div><div class="line">&gt; $ git push [remote] --all</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&gt; # 恢复暂存区的指定文件到工作区</div><div class="line">&gt; $ git checkout [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复某个commit的指定文件到暂存区和工作区</div><div class="line">&gt; $ git checkout [commit] [file]</div><div class="line">&gt;</div><div class="line">&gt; # 恢复暂存区的所有文件到工作区</div><div class="line">&gt; $ git checkout .</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</div><div class="line">&gt; $ git reset [file]</div><div class="line">&gt;</div><div class="line">&gt; # 重置暂存区与工作区，与上一次commit保持一致</div><div class="line">&gt; $ git reset --hard</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</div><div class="line">&gt; $ git reset [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">&gt; $ git reset --hard [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class="line">&gt; $ git reset --keep [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 新建一个commit，用来撤销指定commit</div><div class="line">&gt; # 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class="line">&gt; $ git revert [commit]</div><div class="line">&gt;</div><div class="line">&gt; # 暂时将未提交的变化移除，稍后再移入</div><div class="line">&gt; $ git stash</div><div class="line">&gt; $ git stash pop</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; # 生成一个可供发布的压缩包</div><div class="line">&gt; $ git archive</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>（完）</p>
<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">常用 Git 命令清单</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解socket编程]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/%E7%90%86%E8%A7%A3socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>理解socket编程的思想，介绍各个函数及其作用，文末有一个server和client的代码，可直接运行。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本地进程通信</strong></p>
<p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p><strong>网络进程通信</strong></p>
<p>但是网络中进程之间如何通信？</p>
<p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p>
<p>TCP/IP协议族已经帮我们解决了这个问题：</p>
<ul>
<li>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机</li>
<li>传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</li>
</ul>
<p>这样利用三元组<strong>（ip地址，协议，端口）</strong>就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<h2 id="socket基本操作"><a href="#socket基本操作" class="headerlink" title="socket基本操作"></a>socket基本操作</h2><h3 id="1、socket-函数"><a href="#1、socket-函数" class="headerlink" title="1、socket()函数"></a>1、socket()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的<strong>打开</strong>操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符</strong>（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，<strong>AF_INET</strong>、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，<strong>SOCK_STREAM</strong>、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，<strong>IPPROTO_TCP</strong>、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li>
</ul>
<p>当我们调用<strong>socket()</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h3 id="2、bind-函数"><a href="#2、bind-函数" class="headerlink" title="2、bind()函数"></a>2、bind()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># ipv4</div><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div><div class="line"># ipv6对应的是： </div><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line"># Unix域对应的是： </div><div class="line">#define UNIX_PATH_MAX    108</div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
</blockquote>
<h3 id="3、listen-函数"><a href="#3、listen-函数" class="headerlink" title="3、listen()函数"></a>3、listen()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int listen(int sockfd, int backlog);</div></pre></td></tr></table></figure>
<p>两个参数</p>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>backlog：相应socket可以排队的最大连接个数</li>
</ul>
<p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<h3 id="4、connect-函数"><a href="#4、connect-函数" class="headerlink" title="4、connect()函数"></a>4、connect()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>addr：服务器的socket地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<p>客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h3 id="5、accept-函数"><a href="#5、accept-函数" class="headerlink" title="5、accept()函数"></a>5、accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p>
<p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p>
<p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</div></pre></td></tr></table></figure>
<ul>
<li>sockfd：服务器的socket描述字</li>
<li>addr：指向struct sockaddr *的指针，用于返回客户端的协议地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<blockquote>
<p>服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
</blockquote>
<h3 id="6、网络I-O"><a href="#6、网络I-O" class="headerlink" title="6、网络I/O"></a>6、网络I/O</h3><p>服务端：socket、bind、listen、accept</p>
<p>客户端：socket、connect</p>
<p>至此服务器与客户已经建立好连接，可以调用网络I/O进行读写操作，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure>
<p>recvmsg()/sendmsg()这两个函数是最通用的I/O函数。各函数需要对应的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">                      const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
<h3 id="7、close-函数"><a href="#7、close-函数" class="headerlink" title="7、close()函数"></a>7、close()函数</h3><p>服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int close(int fd);</div></pre></td></tr></table></figure>
<blockquote>
<p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
</blockquote>
<p>以上参考了这篇文章：<a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="external">Linux Socket编程（不限Linux）</a>，写的很不错。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">// server.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"></div><div class="line">#define SERVER_PORT    	6666 </div><div class="line">#define BUFFER_SIZE 	1024</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    // server的socket地址结构server_addr,三元组(地址,协议,端口)</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr)); //把一段内存区的内容全部设置为0</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line"></div><div class="line">    // socket描述符</div><div class="line">    int server_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( server_socket &lt; 0)</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Create Socket Failed!&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 给socket 描述符绑定一个地址，地址是我们上面定义好的</div><div class="line">    if( bind(server_socket,(struct sockaddr*)&amp;server_addr,sizeof(server_addr)))</div><div class="line">    &#123;</div><div class="line">        printf(&quot;Server Bind Port : %d Failed!&quot;, SERVER_PORT); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    // 监听这个socket, 第二个参数是排队的最大连接数</div><div class="line">    if ( listen(server_socket, 10) )</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server Listen Failed!&quot;); </div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    while (1) </div><div class="line">    &#123;   </div><div class="line">        // 定义客户端的socket地址结构client_addr</div><div class="line">        struct sockaddr_in client_addr;</div><div class="line">        socklen_t len = sizeof(client_addr);</div><div class="line"></div><div class="line">        // 如果没有连接请求,就等待到有连接请求--这是accept函数的特性</div><div class="line">        // accept函数返回一个新的socket,这个socket(new_server_socket)用于同连接到的客户的通信，代表了服务器和客户端之间的一个通信通道</div><div class="line">        // accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中</div><div class="line">        int new_server_socket = accept(server_socket,(struct sockaddr*)&amp;client_addr,&amp;len);</div><div class="line">        if ( new_server_socket &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Accept Failed!\n&quot;);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        char buffer[BUFFER_SIZE];</div><div class="line">        bzero(buffer, BUFFER_SIZE);</div><div class="line">        // 接收从客户端来的请求</div><div class="line">        len = recv(new_server_socket,buffer,BUFFER_SIZE,0);</div><div class="line">        if (len &lt; 0)</div><div class="line">        &#123;</div><div class="line">            printf(&quot;Server Recieve Data Failed!\n&quot;);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        buffer[len] = &apos;\0&apos;;</div><div class="line">        printf(&quot;recv msg from client: %s\n&quot;, buffer);</div><div class="line">        close(new_server_socket);</div><div class="line">    &#125;</div><div class="line">    close(server_socket);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端：socket() -&gt; connect() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// client.c</div><div class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</div><div class="line">#include &lt;sys/types.h&gt;    	// socket</div><div class="line">#include &lt;sys/socket.h&gt;    	// socket</div><div class="line">#include &lt;stdio.h&gt;        	// printf</div><div class="line">#include &lt;stdlib.h&gt;        	// exit</div><div class="line">#include &lt;string.h&gt;        	// bzero</div><div class="line"> </div><div class="line">#define SERVER_PORT 6666 </div><div class="line">#define BUFFER_SIZE 1024</div><div class="line"> </div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    if (argc != 2)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Usage: ./%s ServerIPAddress\n&quot;,argv[0]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //创建socket描述符</div><div class="line">    int client_socket = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">    if( client_socket &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Create Socket Failed!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    //设置server的地址，三元组</div><div class="line">    struct sockaddr_in server_addr;</div><div class="line">    bzero(&amp;server_addr,sizeof(server_addr));</div><div class="line">    server_addr.sin_family = AF_INET;</div><div class="line">    server_addr.sin_port = htons(SERVER_PORT);</div><div class="line">    if(inet_aton(argv[1],&amp;server_addr.sin_addr) == 0) //服务器的IP地址来自程序的参数</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Server IP Address Error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    //向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接</div><div class="line">    if(connect(client_socket,(struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0)</div><div class="line">    &#123;   </div><div class="line">        printf(&quot;Can Not Connect To %s!\n&quot;,argv[1]);</div><div class="line">        exit(1);</div><div class="line">    &#125;   </div><div class="line">    printf(&quot;send msg to server!\n&quot;);</div><div class="line">    char sendline[BUFFER_SIZE];</div><div class="line">    fgets(sendline, BUFFER_SIZE, stdin);</div><div class="line"></div><div class="line">	// 向服务器发送数据</div><div class="line">    if (send(client_socket, sendline, strlen(sendline), 0) &lt; 0)&#123;</div><div class="line">        printf(&quot;send msg error!\n&quot;);</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(client_socket);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gcc server.c -o s</div><div class="line">gcc client.c -o c</div><div class="line"></div><div class="line"># ./s</div><div class="line">recv msg from client: hello socket</div><div class="line"></div><div class="line"># ./c 127.0.0.1</div><div class="line">send msg to server!</div><div class="line">hello socket     		// 交互输入</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cow和row快照机制的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/cow%E5%92%8Crow%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>很清晰的讲解快照两种模式cow和row的区别。<br><a id="more"></a></p>
<p>所谓快照，是指某数据集在某一时刻一个完全可用的拷贝。也叫即时拷贝。注意是一个完全可用的。如果是在window环境下，则要结合VSS 机制，把应用程序的buffer,文件系统的buffer,操作系统的buffer全部刷向磁盘后，再做快照。﻿</p>
<p>当前快照有两种实现，分别是COW（Copy on first write） 和ROW(Redirect on first write).﻿﻿﻿</p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、读取第8个物理块﻿</li>
<li>3、新读取的第8个物理块数据写入到第9个物理块。﻿</li>
<li>4、更新快照卷map,指向第9个物理块﻿</li>
<li>5、更新第8个物理块﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/cow.jpg" alt="COW"></p>
<p>从上面可以看出，本来写一个物理块，变成了1读3写。﻿</p>
<p>COW 优点：﻿</p>
<p>1、原始卷物理块连续。没有碎片。﻿</p>
<p>COW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成1读3写。﻿﻿﻿</p>
<h2 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h2><p>对ROW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、数据写入到第9个物理块。﻿</li>
<li>3、更新原始卷map,指向第9个物理块﻿﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/row.jpg" alt="ROW"></p>
<p>从上面可以看出，本来写一个物理块，变成了2写。﻿</p>
<p>ROW 优点：﻿</p>
<p>1、性能比COW 好。﻿</p>
<p>ROW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成2写。﻿</p>
<p>2、原始卷物理块不连续。没、有碎片。</p>
<blockquote>
<p>本文为转载，原始链接未找到</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(5、6、7)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/Machine-Learning-Yearning-5%E3%80%816/</url>
      <content type="html"><![CDATA[<p>第5、6、7三章，主要讲开发集和测试集，包括选型、大小、比例等。<br><a id="more"></a></p>
<p>Setting up development and test sets</p>
<p>设置开发和测试集</p>
<h2 id="Chapter-5、Your-development-and-test-sets"><a href="#Chapter-5、Your-development-and-test-sets" class="headerlink" title="Chapter 5、Your development and test sets"></a>Chapter 5、Your development and test sets</h2><p><strong>您的开发和测试集</strong><br>​    让我们回到我们早期猫图片的那个例子：你运行一个移动app，用户正在上传很多不同事物的图片到该app中。你想自动找到猫的图片。<br>​    您的团队通过从不同网站上下载猫（positive examples，正样本）和非猫（negative examples，负样本）的图获得一个大的训练集。 他们将数据集按照比例70％/ 30％分成训练集/测试集。 使用这些数据，他们构建了一个在训练集和测试集上都表现很好的的猫检测器。<br>​    但是当你将这个分类器部署到移动app时，你发现表现真的很糟糕！</p>
<p><img src="http://img.blog.csdn.net/20161209012152300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<p>​    发生了什么？<br>​    您发现用户上传的图片与您构建训练集的网站图片有所不同：用户上传的照片使用手机拍摄，这些照片往往分辨率较低，比较模糊，并且采光不好。 由于您的训练集/测试集是由网站图片构建的，您的算法没有很好的兼顾到你所关心的智能手机图片的实际分布。<br>​    在大数据的时代之前，在机器学习中使用随机的70％/ 30％来分割训练集和测试集是常见的规则。 这种做法可以工作，但在越来越多的应用程序，如训练集的分布（上面例子中的网站图像）不同于你最终关心的分布（手机图像），这是一个坏主意。</p>
<p>​    我们通常定义：</p>
<ul>
<li>训练集 - 学习算法运行在这上面。</li>
<li>Dev（开发）集 - 用于调整参数，选择特征，以及对学习算法做出其他决定。 有时也称为维持交叉验证集(hold-out cross validation set)。</li>
<li>测试集 - 用于评估算法的性能，但不要做出关于使用什么学习算法或参数的任何决定。</li>
</ul>
<p>​    你定义一个开发集和测试集，你的团队会尝试很多想法，如不同的学习算法参数，看看什么是最好的。 开发集和测试集能够使你的团队快速看到你的算法做得有多好。</p>
<p>​    换句话说，开发和测试集的目的是指导你的团队对机器学习系统进行最重要的更改。<br>​    所以，你应该做如下事情：</p>
<ul>
<li>选择开发和测试集，以反映您期望在未来获得的数据，并希望做好。</li>
</ul>
<p>​    换句话说，您的测试集不应该只是可用数据的30％这么简单，特别是如果您期望您的未来数据（移动app图片）在性质上与您的训练集（网站图像）不同时。</p>
<p>​    如果您尚未启动移动app，可能还没有任何用户，因此可能无法获取准确反映您未来需要做的更好的数据。 但你可能仍然尝试去靠近它。 例如，请你的朋友拍一些手机图片，并发送给你。 一旦app启动后，您可以使用实际的用户数据更新您的开发集/测试集。<br>​    如果你真的没有任何方法来获得接近你期望的未来数据，也许你可以从使用网站图像开始。 但是你应该意识到这将导致系统不能一般化的很好的风险。<br>​    我们需要判断去决定多少投资开发好的开发集和测试集。 但是不要假定你的训练分布与你的测试分布是一样的。 尝试选择反映您最终想要表现良好的测试样本，而不是训练遇到的任何数据。</p>
<h2 id="Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution"><a href="#Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution" class="headerlink" title="Chapter 6、Your dev and test sets should come from the same distribution"></a>Chapter 6、Your dev and test sets should come from the same distribution</h2><p><strong>你的开发集和测试集应该来自相同的分布</strong></p>
<p>根据您最大的市场，将猫应用图片数据分为四个区域：（i）美国，（ii）中国，（iii）印度和（iv）其他。要想出一个开发集和一个测试集，我们可以随机分配这两个区域到开发集，另外两个到测试集，对吧？ 比如美国和印度在开发集; 中国和其他在测试集。</p>
<p><img src="http://img.blog.csdn.net/20161209022552344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>​    一旦定义了开发集和测试集，您的团队将专注于提高开发集的性能。 因此，开发集应该反映你最想提高的任务：在所有四个地区都要做得很好，而不只是两个。<br>​    开发集和测试集的不同分布带来的第二个问题：有一个机会，你的团队将构建一些在开发集件上工作得很好，只是发现它在测试集上做得不好。 我曾经在很多失望和白费的努力中看到这个结果。 避免让这些发生在你身上。<br>​    例如，假设您的团队开发的系统在开发集上工作的很好，但在测试集上并不如意。 如果你的开发集和测试集合来自相同的分布，那么你会有一个非常明确的诊断哪里出错了：你在开发集上过拟合(overfit)了。显而易见的方法是去获得更多的开发集数据。</p>
<p>​    但是如果开发集和测试集来自不同的分布，那么你的选择是不清晰的。几方面可能会出错：</p>
<ul>
<li>1、在开发集上过拟合。</li>
<li>2、测试集比开发集更难。所以你的算法可能做的和预期一样好，因此没有进一步的重大改进的可能了。</li>
<li>3、测试集不一定更难，但只是和开发集不同。所以在开发集上表现很好但并不能在测试集上表现一样。这种情况下，之前很多提高开发集性能的努力可能都白费了。</li>
</ul>
<p>​    在机器学习应用程序上工作是很艰难的。具有不匹配的开发和测试集引入了关于是否改进开发集分布也提高测试集性能额外的不确定性。具有不匹配的开发和测试集，使得更难找出什么是有效和无效的努力，因此使得更难以确定工作的优先级。<br>​    如果你面临的是第三方基准测试 问题，他们的创建者可能会指定开发集和测试集来自不同的分布。相比开发和测试集来自同一分布，此时运气，而不是技术，将对这样的基准的性能有更大的影响。开发一个在一个分布上训练的很好同时能够很好的推广到另一个分布中的学习算法是一个重要的研究问题。但是如果你的目标是在一个特定的机器学习应用中取得进展，而不是研究进展，我建议尝试选择开发集和测试集从相同的分布。这将使您的团队更有效率。</p>
<h2 id="Chapter-7、How-large-do-the-dev-test-sets-need-to-be"><a href="#Chapter-7、How-large-do-the-dev-test-sets-need-to-be" class="headerlink" title="Chapter 7、How large do the dev/test sets need to be?"></a>Chapter 7、How large do the dev/test sets need to be?</h2><p><strong>开发集/测试集需要多大？</strong></p>
<p>​    开发集应该足够大，以检测您尝试的算法之间的差异。例如，如果分类器A具有90.0％的准确度，分类器B具有90.1％的准确度，那么100个样本的开发集将不能检测出这0.1％的差异。与我看到的其他机器学习问题相比，100个样本的开发集太小了。常见的开发集的大小在1,000到10,000个样本之间。有10,000个样本，你将有很好的机会检测到这0.1％的提升。[2]<br>​    对于成熟和重要的应用，例如广告，网络搜索和产品建议 - 我也看到了很多团队，甚至为提升0.01％积极努力，因为它对公司的利润有直接影响。在这种情况下，开发集可以远大于10,000，以便检测出更小的提升。<br>​    测试集的大小应该多大？它应该足够大，使得对系统的整体性能有一个高的信心。一个流行的启发式方法是将30％的数据用于测试集。当你有适量的样本，比如100到10,000的样本，它会工作的很好。但在大数据的时代，我们现在有机器学习问题，有时会超过十亿个样本，分配给开发集/测试集的比例一直在缩小，即使开发集 /测试集中的样本绝对数量一直在增长。除了需要评估算法的性能之外，没有必要提供过大的开发集/测试集。</p>
<p>——————————</p>
<p>[2]. 在理论上，我们可以测试算法的变化是否对开发集产生统计上显着的差异。 在实践中，大多数团队不会为此困扰（除非他们出版学术研究论文），我通常没法发现统计意义的测试对测量临时进展是有用的。</p>
]]></content>
      
        
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(3、4)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/03/Machine-Learning-Yearning-3%E3%80%814/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，第三章：预备知识和注释；第四章：规模驱使机器学习前进。<br><a id="more"></a></p>
<h2 id="Chapter-3、Prerequisites-and-Notation"><a href="#Chapter-3、Prerequisites-and-Notation" class="headerlink" title="Chapter 3、Prerequisites and Notation"></a>Chapter 3、Prerequisites and Notation</h2><p><strong>预备知识和注释</strong><br>​    如果你有学习过机器学习课程，比如我在Coursera上的的机器学习MOOC，或者如果你有应用监督学习的经验，你也将能够理解这段文字。<br>​    我假设你熟悉监督学习（supervised learning）：使用标记的训练样本（x，y）去学习一个从x映射到y的函数。 监督学习算法包括线性回归（linear regression），逻辑回归（logistic regression）和神经网络（neural networks）。 机器学习的形式有很多，但是现如今大部分机器学习的实用价值来自于监督学习。<br>​    我将经常提到神经网络（也称为“deep learning”）。你只需要遵循本问对它是什么有一个基本的理解就可以了。<br>​    如果您不熟悉这里提到的概念，请观看在Coursera上前三周 机器学习视频课程<a href="http://ml-class.org" target="_blank" rel="external">http://ml-class.org</a></p>
<p><img src="http://img.blog.csdn.net/20161208234928384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Chapter-4、Scale-drives-machine-learning-progress"><a href="#Chapter-4、Scale-drives-machine-learning-progress" class="headerlink" title="Chapter 4、Scale drives machine learning progress"></a>Chapter 4、Scale drives machine learning progress</h2><p><strong>规模驱使机器学习前进</strong></p>
<p>深度学习（神经网络）的许多想法已经存在几十年了。 为什么这些想法现在才火起来？<br>最近得以进步的最大驱动因素有两个：</p>
<ul>
<li>数据可用性。 人们现在在数字设备（笔记本电脑，移动设备）上花费更多的时间。这些活动产生大量的数据，我们可以使用这些数据来训练和反馈我们的学习算法。</li>
<li>计算尺度。 我们几年前才开始能够训练足够大的神经网络，以利用我们现在拥有的巨大的数据集。</li>
</ul>
<p>具体来说，即使你积累了更多的数据，通常传统学习算法（如逻辑回归）的性能表现“平稳”。这意味着它的学习曲线“平坦”，即使你给它更多的数据，算法也不会再有提升效果。</p>
<p><img src="http://img.blog.csdn.net/20161209001935676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这就好像传统的算法不知道如何处理我们现在拥有的所有数据。<br>如果你在同一个监督学习任务上训练一个小的神经网络（NN），你可能会获得略好一点的性能：</p>
<p><img src="http://img.blog.csdn.net/20161209002633511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里，“小的神经网络”是指仅具有少量隐藏单位/层/参数的神经网络。 最后，如果你训练越来越大的神经网络，你可以获得更好的性能：[1]</p>
<p><img src="http://img.blog.csdn.net/20161209003804359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>因此，当你做到下面两点的时候你会获得最佳的性能（i）训练一个非常大的神经网络，使其在上面的绿色曲线上; （ii）有大量的数据。<br>许多其他细节，如神经网络架构也很重要，这里已经有很多创新。 但是现在提高算法性能的更可靠的方法之一仍然是（i）训练更大的网络和（ii）获得更多的数据。<br>如何完成（i）和（ii）的方法是极其复杂的。 这本书将详细讨论细节。 我们将从对传统学习算法和神经网络都有用的一般策略开始，并建立构建深度学习系统所需的最先进策略。</p>
<p>[1]这个图表展示了NN在小数据集下做得更好。这种效果不如NNs在大数据集中表现良好的效果一致。 在小数据系统中，取决于特征是如何手工设计的，传统算法可能做的很好，也可能做得并不好。 例如，如果你有20个训练样本，那么使用逻辑回归还是神经网络可能并不重要; 手工特征的选择将比算法的选择产生更大的影响。 但如果你有100万的样本，我更倾向于神经网络。</p>
]]></content>
      
        
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(开篇、1、2)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/02/Machine-Learning-Yearning-%E5%BC%80%E7%AF%87%E3%80%811%E3%80%812/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，翻译过来，这里是开篇、第一章和第二章的内容。<br><a id="more"></a></p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>网上搜了一下，发现已经有一些翻译后的资料了，我这里就是边学习边翻译记录，主要作为给自己的学习笔记吧，并不冲突。</p>
<p>官网：<a href="http://www.mlyearning.org/" target="_blank" rel="external">http://www.mlyearning.org/</a></p>
<p>这里可以留下你的邮箱，当有更新的时候会发到你的邮箱（好像我关注后就没发过）。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这本书的目的是教你如何做组织一个机器学习项目所需的大量的决定。 你将学习：</p>
<ul>
<li>如何建立你的开发和测试集</li>
<li>基本错误分析</li>
<li>如何使用偏差和方差来决定该做什么</li>
<li>学习曲线</li>
<li>将学习算法与人类水平的表现进行比较</li>
<li>调试推理算法</li>
<li>什么时候应该和不应该使用端到端的深度学习</li>
<li>按部进行错误分析</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>当前更新了14章，下载如下：</p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_01.pdf" target="_blank" rel="external">1-12章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_02.pdf" target="_blank" rel="external">13章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_03.pdf" target="_blank" rel="external">14章</a></p>
<h3 id="章节名称"><a href="#章节名称" class="headerlink" title="章节名称"></a>章节名称</h3><p>Chapter 1、Why Machine Learning Strategy<br>Chapter 2、How to use this book to help your team<br>Chapter 4、Prerequisites and Notation<br>Chapter 5、Scale drives machine learning progress<br>Chapter 6、Your development and test sets<br>Chapter 7、Your dev and test sets should come from the same distribution<br>Chapter 8、How large do the dev/test sets need to be?<br>Chapter 9、Establish a single-number evaluation metric for your team to optimize<br>Chapter 10、Optimizingandsatisficingmetrics<br>Chapter 11、Having a dev set and metric speeds up iterations<br>Chapter 12、When to change dev/test sets and metrics<br>Chapter 13、Takeaways: Setting up development and test sets<br>Chapter 14、Build your first system quickly, then iterate<br>Chapter 15、Error analysis: Look at dev set examples to evaluate ideas<br>Chapter 16、Evaluate multiple ideas in parallel during error analysis </p>
<p>（待添加）                </p>
<h2 id="Chapter-1、Why-Machine-Learning-Strategy"><a href="#Chapter-1、Why-Machine-Learning-Strategy" class="headerlink" title="Chapter 1、Why Machine Learning Strategy"></a>Chapter 1、Why Machine Learning Strategy</h2><p>为什么是机器学习策略</p>
<p>机器学习是无数重要应用程序的基础，包括网页搜索，电子邮件反垃圾邮件，语音识别，产品推荐等。我假设你或你的团队正在一个机器学习应用程序，并且你想要快速进步。那么这本书将帮助到你。</p>
<p>示例：构建一个cat图片启动</p>
<p>假设你正在建立一个创业公司，将为猫爱好者提供一个无尽的猫图片流。并使用神经网络建立一个计算机视觉系统，以检测图片中的猫。</p>
<p><img src="http://img.blog.csdn.net/20161208213001211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但悲剧的是，你的学习算法的准确性还不够好。你面临着提高猫检测算法的巨大压力。你该怎么做？</p>
<p>您的团队有很多想法，例如：</p>
<p>•获取更多的数据：收集更多的猫的照片</p>
<p>•收集更多样化的培训集。例如，猫在不寻常的位置的图片;猫不寻常的着色;各种相机设置下拍摄出的猫图; ….</p>
<p>•通过运行更多的梯度下降迭代来增加算法的训练时间</p>
<p>•尝试更大的神经网络，具有更多的层/隐藏单位/参数</p>
<p>•尝试更小的神经网络。</p>
<p>•尝试添加正则化（例如L2正则化）</p>
<p>•改变神经网络架构（激活功能，隐藏单位数等）</p>
<p>•…</p>
<p>在这些可能的方向中，如果选择的好，你将会建立领先的猫图片平台，并带领公司走向成功。如果选择 不好，可能会浪费几个月的时间。你该怎么做？</p>
<p>这本书会告诉你怎么做。大多数机器学习问题留下的线索告诉你什么是有用的的尝试，什么是没用的尝试。学会阅读这些线索会节省你几个月甚至几年的开发时间。</p>
<h2 id="Chapter-2、How-to-use-this-book-to-help-your-team"><a href="#Chapter-2、How-to-use-this-book-to-help-your-team" class="headerlink" title="Chapter 2、How to use this book to help your team"></a>Chapter 2、How to use this book to help your team</h2><p>如何使用这本书来帮助你的团队<br>阅读完本书后，您将对如何设置机器学习项目的技术方向有深入的了解。<br>但是你的队友可能不明白你为什么要推荐一个特定的方向。 也许你希望你的团队定义一个单数评估指标，但他们不相信。 你如何说服他们？<br>这就是为什么我把章节短：所以，你可以打印出来，让你的队友只读你需要他们知道的那一两页。<br>优先级上的一些改变会对您的团队的生产力产生巨大的影响。 通过帮助您的团队进行一些这样的改变，我希望您可以成为您的团队的超级英雄！</p>
<p><img src="http://img.blog.csdn.net/20161208232515575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
      
        
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[异步IO]]></title>
      <url>http://xiaqunfeng.cc/2017/03/01/%E5%BC%82%E6%AD%A5IO/</url>
      <content type="html"><![CDATA[<p>介绍了AIO，以及四种IO模型。<br><a id="more"></a></p>
<p>Linux® 中最常用的输入/输出（I/O）模型是同步 I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是很好的一种解决方案，因为调用应用程序在等待 I/O 请求完成时不需要使用任何中央处理单元（CPU）。但是在某些情况中，I/O 请求可能需要与其他进程产生交叠。可移植操作系统接口（POSIX）异步 I/O（AIO）应用程序接口（API）就提供了这种功能。在本文中，我们将对这个 API 概要进行介绍，并来了解一下如何使用它。</p>
<h2 id="AIO-简介"><a href="#AIO-简介" class="headerlink" title="AIO 简介"></a>AIO 简介</h2><p>Linux 异步 I/O 是 Linux 内核中提供的一个相当新的增强。它是 2.6 版本内核的一个标准特性，但是我们在 2.4 版本内核的补丁中也可以找到它。AIO 背后的基本思想是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。</p>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>在深入介绍 AIO API 之前，让我们先来探索一下 Linux 上可以使用的不同 I/O 模型。这并不是一个详尽的介绍，但是我们将试图介绍最常用的一些模型来解释它们与异步 I/O 之间的区别。图 1 给出了同步和异步模型，以及阻塞和非阻塞的模型。</p>
<p align="center">图 1. 基本 Linux I/O 模型的简单矩阵</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure1.gif" alt="基本 Linux I/O 模型的简单矩阵"></p>
<p>每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。</p>
<h3 id="同步阻塞-I-O"><a href="#同步阻塞-I-O" class="headerlink" title="同步阻塞 I/O"></a>同步阻塞 I/O</h3><h2 id="I-O-密集型与-CPU-密集型进程的比较"><a href="#I-O-密集型与-CPU-密集型进程的比较" class="headerlink" title="I/O 密集型与 CPU 密集型进程的比较"></a>I/O 密集型与 CPU 密集型进程的比较</h2><p>I/O 密集型进程所执行的 I/O 操作比执行的处理操作更多。CPU 密集型的进程所执行的处理操作比 I/O 操作更多。Linux 2.6 的调度器实际上更加偏爱 I/O 密集型的进程，因为它们通常会发起一个 I/O 操作，然后进行阻塞，这就意味着其他工作都可以在两者之间有效地交错进行。</p>
<p>最常用的一个模型是同步阻塞 I/O 模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>图 2 给出了传统的阻塞 I/O 模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用 <code>read</code> 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（<code>read</code> 调用返回）。</p>
<p align="center">图 2. 同步阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure2.gif" alt="同步阻塞 I/O 模型的典型流程"></p>
<p>从应用程序的角度来说，<code>read</code> 调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。</p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I/O"></a>同步非阻塞 I/O</h3><p>同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，<code>read</code>操作可能会返回一个错误代码，说明这个命令不能立即满足（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>），如图 3 所示。</p>
<p align="center">图 3. 同步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure3.gif" alt="同步非阻塞 I/O 模型的典型流程"></p>
<p>非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图 3 所示的一样，这个方法可以引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 <code>read</code> 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。</p>
<h3 id="异步阻塞-I-O"><a href="#异步阻塞-I-O" class="headerlink" title="异步阻塞 I/O"></a>异步阻塞 I/O</h3><p>另外一个阻塞解决方案是带有阻塞通知的非阻塞 I/O。在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 <code>select</code> 系统调用来确定一个 I/O 描述符何时有操作。使 <code>select</code> 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。</p>
<p align="center">图 4. 异步阻塞 I/O 模型的典型流程 (select)</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure4.gif" alt="异步阻塞 I/O 模型的典型流程"></p>
<p><code>select</code> 调用的主要问题是它的效率不是非常高。尽管这是异步通知使用的一种方便模型，但是对于高性能的 I/O 操作来说不建议使用。</p>
<h3 id="异步非阻塞-I-O（AIO）"><a href="#异步非阻塞-I-O（AIO）" class="headerlink" title="异步非阻塞 I/O（AIO）"></a>异步非阻塞 I/O（AIO）</h3><p>最后，异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 <code>read</code> 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 <code>read</code> 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p align="center">图 5. 异步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure5.gif" alt="异步非阻塞 I/O 模型的典型流程"></p>
<p>在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。</p>
<h2 id="异步-I-O-的动机"><a href="#异步-I-O-的动机" class="headerlink" title="异步 I/O 的动机"></a>异步 I/O 的动机</h2><p>从前面 I/O 模型的分类中，我们可以看出 AIO 的动机。这种阻塞模型需要在 I/O 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 I/O 操作。同步非阻塞模型允许处理和 I/O 操作重叠进行，但是这需要应用程序根据重现的规则来检查 I/O 操作的状态。这样就剩下异步非阻塞 I/O 了，它允许处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。</p>
<p>除了需要阻塞之外，<code>select</code> 函数所提供的功能（异步阻塞 I/O）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 I/O 调用进行阻塞。</p>
<h2 id="Linux-上的-AIO-简介"><a href="#Linux-上的-AIO-简介" class="headerlink" title="Linux 上的 AIO 简介"></a>Linux 上的 AIO 简介</h2><p>本节将探索 Linux 的异步 I/O 模型，从而帮助我们理解如何在应用程序中使用这种技术。</p>
<p>在传统的 I/O 模型中，有一个使用惟一句柄标识的 I/O 通道。在 UNIX® 中，这些句柄是文件描述符（这对等同于文件、管道、套接字等等）。在阻塞 I/O 中，我们发起了一次传输操作，当传输操作完成或发生错误时，系统调用就会返回。</p>
<h2 id="Linux-上的-AIO"><a href="#Linux-上的-AIO" class="headerlink" title="Linux 上的 AIO"></a>Linux 上的 AIO</h2><p>AIO 在 2.5 版本的内核中首次出现，现在已经是 2.6 版本的产品内核的一个标准特性了。</p>
<p>在异步非阻塞 I/O 中，我们可以同时发起多个传输操作。这需要每个传输操作都有惟一的上下文，这样我们才能在它们完成时区分到底是哪个传输操作完成了。在 AIO 中，这是一个 <code>aiocb</code>（AIO I/O Control Block）结构。这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。在产生 I/O （称为完成）通知时，<code>aiocb</code> 结构就被用来惟一标识所完成的 I/O 操作。这个 API 的展示显示了如何使用它。</p>
<p>本文为转载文章, 原文链接：<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bluestore调研]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/Bluestore%E8%B0%83%E7%A0%94/</url>
      <content type="html"><![CDATA[<p>这是之前关注bluestore时写的调研文章，主要介绍了bluestore的架构、存储模型、IO、元数据等，以及优势。现在ceph已经出到K版本了，虽然未在生产中实践，但已经可用。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Ceph是一种软件定义存储解决方案，因此Ceph的主要目标是保障存储数据的安全。为了达到数据安全的目的，我们需要原子特性。目前没有一种文件存储系统能够提供写和更新操作的原子特性（Btrfs拥有原子特性的事务, 这是人们为了解决上述问题作出的尝试，但事实上并不成功）。</p>
<p>​    Ceph开发者不得不探索其他的解决方案。这个解决方案就是大家非常熟悉的Ceph日志。ceph后端的存储引擎目前使用的是filestore，写采用的是WAL的方式，但是写前记录日志这种技术有一个主要缺陷就是它把你的硬盘性能降低到原来的二分之一（仅当日志和OSD数据共享同一个硬盘时），因为filestore在写数据前需要先写journal，所以有一倍的写放大。</p>
<p>​    同时filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑。bluestore的初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="bluestore架构图"></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>RocksDB</td>
<td>存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）</td>
</tr>
<tr>
<td>BlueRocksEnv</td>
<td>与RocksDB交互的接口</td>
</tr>
<tr>
<td>BlueFS</td>
<td>小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备</td>
</tr>
<tr>
<td>HDD</td>
<td>物理块设备，存储实际的数据</td>
</tr>
</tbody>
</table>
<p>​    rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（<em>rocksdb默认的Env是PosixEnv，直接对接本地文件系统</em>）。</p>
<p>​    BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p>
<p>​    为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（<em>BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备</em>）。</p>
<p>​    bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。</p>
<blockquote>
<p>读：目前块设备的读操作是同步的；</p>
<p>写：由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 </p>
</blockquote>
<p>​    Ceph数据对象(真正的‘数据’)直接被写入块物理设备。因为是直接管理裸设备，所以需要分配器（Allocator）来进行裸设备的空间管理。OSD附带的数据对象元数据被存储到键值数据库RocksDB中。</p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png" alt="bluestore存储模型"></p>
<p>这里把一个硬盘分了两个分区：</p>
<ol>
<li>第一个迷你小分区使用了XFS或ext4文件系统。它存储了Ceph文件（像初始系统描述符，状态，id，fsid，钥匙串等），和RocksDB文件(RocksDB元数据和预写式日志)。</li>
<li>第二个分区是没有文件系统的原始分区。</li>
</ol>
<p>​        每一个组件都可以存储在一个不同的物理设备上。在这张图中，RocksDB的预写式日志和数据可以被存储在不同的物理设备也可以存储在迷你小分区上。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>​    数据结构onode 保存了BlueStore中一个对象的数据结构，这是一个常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。一个onode里会存在多个lextent（逻辑的数据块），用一个map来记录。lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。blob和pextent是多对多的关系。</p>
<p>​    数据结构Enode定义了一个共享的extent，也就是这段数据被多个对象共享，一个对象的onode里保存一个enode数据结构，记录该对象被共享的extent。</p>
<h2 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h2><p>​    到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在执行写操作时，首先就会根据最小分配单位min_alloc_size进行判断，并按照min_alloc_size进行拆分，从而将I/O分为对齐和非对齐的。落到某一个min_alloc_size区间的写I/O执行非对齐写，min_alloc_size整数倍的写I/O执行对齐写。</p>
<p><strong>整块写（对齐写）</strong></p>
<p>​    也就是对齐到min_alloc_size的写请求，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍。如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。（PS:回收这部分还没看）</p>
<p><strong>部分写（非对齐写）</strong></p>
<p>​    在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p>
<p>1、没有找到可以复用的blob，新生成blob</p>
<p>​    在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操，然后再把对齐后的offset和len作为lextent，进而放到blob里。之所以需要进行补零操作是因为采用Direct I/O的方式写盘要求偏移和缓冲区都对齐的。</p>
<p>2、找到可以复用的blob</p>
<p>​    先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p>
<p><em>a) 直接写在blob未使用的空间上</em></p>
<p>​    这种情况下直接新生成lextent放到blob里。</p>
<p><em>b) 覆盖写的情况</em></p>
<p>​    通过WAL写到rocksdb。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p>
<p><strong>优点</strong></p>
<p>​    对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p>
<p>​    对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RocksDB相比LevelDB的新特性]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/RocksDB%E7%9B%B8%E6%AF%94LevelDB%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>如题，具体列举了RocksDB中相比LevelDB的一些新特性。<br><a id="more"></a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>多线程压缩</li>
<li>多线程memtable插入</li>
<li>减少DB互斥体保持</li>
<li>优化的基于级别的压缩风格和通用压缩风格</li>
<li>前缀bloom过滤器</li>
<li>Memtable布隆过滤器</li>
<li>覆盖整个SST文件的单个布过滤器</li>
<li>写锁优化</li>
<li>改进<code>Iter :: Prev（）</code>性能</li>
<li>在SkipList搜索期间，较少的比较器调用</li>
<li>使用巨大的页面分配memtable内存</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>列簇（column families）</li>
<li>事务和WriteBatchWithIndex</li>
<li>备份和检查点</li>
<li>合并操作</li>
<li>压缩过滤器</li>
<li>RocksDB Java</li>
<li>手动压缩与自动压缩并行运行</li>
<li>持久化缓存</li>
<li>批量加载</li>
<li>前向迭代器/尾部迭代器</li>
<li>单个删除</li>
<li>范围删除文件</li>
<li>引脚迭代器key/value</li>
</ul>
<h2 id="替换的数据结构和格式"><a href="#替换的数据结构和格式" class="headerlink" title="替换的数据结构和格式"></a>替换的数据结构和格式</h2><ul>
<li>仅用于内存使用情况的纯表格式</li>
<li>基于向量和基于哈希的memtable格式</li>
<li>基于时钟的缓存（即将推出）</li>
<li>可插拔信息日志</li>
<li>使用blob注释事务日志写入（用于副本）</li>
</ul>
<h2 id="可调性"><a href="#可调性" class="headerlink" title="可调性"></a>可调性</h2><ul>
<li>速率限制</li>
<li>可调减速和停止阈值</li>
<li>保持所有文件打开的选项</li>
<li>将所有索引和bloom过滤器块保留在块缓存中的选项</li>
<li>多种WAL恢复模式</li>
<li>Fadvise提示用于预读和避免在OS页面缓存中缓存</li>
<li>用于在内存中固定L0文件的索引和bloom过滤器的选项</li>
<li>更多压缩类型：zlib，lz4，zstd</li>
<li>压缩字典</li>
<li>校验类型：xxhash</li>
<li>每级的不同级别尺寸乘法器和压缩类型</li>
</ul>
<h2 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h2><ul>
<li>统计</li>
<li>Thread-local分析</li>
<li>命令行工具中的更多命令</li>
<li>用户定义的表属性</li>
<li>事件侦听器</li>
<li>更多数据库属性</li>
<li>动态选项更改</li>
<li>从字符串或映射获取选项</li>
<li>选项文件的持久性选项</li>
</ul>
<p>英文原文链接：<a href="https://github.com/facebook/rocksdb/wiki/Features-Not-in-LevelDB" target="_blank" rel="external">Features Not in LevelDB</a></p>
]]></content>
      
        
        <tags>
            
            <tag> rocksdb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kernel modules (简体中文)]]></title>
      <url>http://xiaqunfeng.cc/2017/02/20/Kernel%20modules%20(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/</url>
      <content type="html"><![CDATA[<p>介绍了内核模块的相关操作。加载、查看info、卸载、配置等……<br><a id="more"></a></p>
<p>相关文章</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Boot_Debugging" target="_blank" rel="external">Boot Debugging</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernels_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernels (简体中文)</a>)</li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">Kernel parameters (简体中文)</a>)</li>
</ul>
<p><strong>翻译状态： </strong>本文是英文页面 <a href="https://wiki.archlinux.org/index.php/Kernel_modules" target="_blank" rel="external">Kernel_modules</a> 的<a href="https://wiki.archlinux.org/index.php/ArchWiki_Translation_Team_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">翻译</a>)，最后翻译时间：2013-07-06，点击<a href="https://wiki.archlinux.org/index.php?title=Kernel_modules&amp;diff=0&amp;oldid=264846" target="_blank" rel="external">这里</a>可以查看翻译后英文页面的改动。</p>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module" target="_blank" rel="external">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<blockquote>
<p>本文为转载文章，原文链接见文末</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>要创建内核模块，请阅读<a href="http://tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="external">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<p>模块保存在 <code>/lib/modules/*kernel_release*</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意: </strong>模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>显示当前装入的内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lsmod</div></pre></td></tr></table></figure>
<p>显示模块信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modinfo module_name</div></pre></td></tr></table></figure>
<p>显示所有模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | less</div></pre></td></tr></table></figure>
<p>显示某个模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe -c | grep module_name</div></pre></td></tr></table></figure>
<p>显示一个装入模块使用的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systool -v -m module_name</div></pre></td></tr></table></figure>
<p>显示模块的依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ modprobe --show-depends module_name</div></pre></td></tr></table></figure>
<h2 id="手动加载卸载"><a href="#手动加载卸载" class="headerlink" title="手动加载卸载"></a>手动加载卸载</h2><p>控制内核模块载入/移除的命令是<a href="https://www.archlinux.org/packages/?name=kmod" target="_blank" rel="external">kmod</a> 软件包提供的, 要手动装入模块的话，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe module_name</div></pre></td></tr></table></figure>
<p>如果要移除一个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># modprobe -r module_name</div></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rmmod module_name</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/index.php/Udev" target="_blank" rel="external">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<h3 id="开机加载"><a href="#开机加载" class="headerlink" title="开机加载"></a>开机加载</h3><p>systemd 读取 <code>/etc/modules-load.d/</code> 中的配置加载额外的内核模块。配置文件名称通常为 <code>/etc/modules-load.d/.conf</code>。格式很简单，一行一个要读取的模块名，而空行以及第一个非空格字符为<code>#</code>或<code>;</code>的行会被忽略，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modules-load.d/virtio-net.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Load virtio-net.ko at boot</div><div class="line">virtio-net</div></pre></td></tr></table></figure>
<p>另见<code>man 5 modules-load.d</code>。</p>
<h3 id="配置内核模块参数"><a href="#配置内核模块参数" class="headerlink" title="配置内核模块参数"></a>配置内核模块参数</h3><h3 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用 /etc/modprobe.d/中的文件"></a>使用 /etc/modprobe.d/中的文件</h3><p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myfilename.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">options modname parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/thinkfan.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># On thinkpads, this lets the thinkfan daemon control fan speed</div><div class="line">options thinkpad_acpi fan_control=1</div></pre></td></tr></table></figure>
<p><strong>注意: </strong>如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio.conf" target="_blank" rel="external">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h3 id="使用内核命令行"><a href="#使用内核命令行" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>, <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)的内核行加入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modname.parametername=parametercontents</div></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thinkpad_acpi.fan_control=1</div></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/myalias.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Lets you use &apos;mymod&apos; in MODULES, instead of &apos;really_long_module_name&apos;</div><div class="line">alias mymod really_long_module_name</div></pre></td></tr></table></figure>
<p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/modprobe.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Prevent autoload of bluetooth</div><div class="line">alias net-pf-31 off</div><div class="line"></div><div class="line"># Prevent autoload of ipv6</div><div class="line">alias net-pf-10 off</div></pre></td></tr></table></figure>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><h3 id="禁用内核模块"><a href="#禁用内核模块" class="headerlink" title="禁用内核模块"></a>禁用内核模块</h3><p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs" target="_blank" rel="external">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d/modprobe.conf</code> 中将它们加入黑名单。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果要禁用这些模块，记得在配置完成后,将<code>.conf</code>文件加入<code>/etc/mkinitcpio.conf</code> 的 FILES 部分，然后重新生成 initramfs。</p>
<h3 id="使用-etc-modprobe-d-中的文件-1"><a href="#使用-etc-modprobe-d-中的文件-1" class="headerlink" title="使用 /etc/modprobe.d/ 中的文件"></a>使用 /etc/modprobe.d/ 中的文件</h3><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/nobeep.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Do not load the pcspkr module on boot</div><div class="line">blacklist pcspkr</div></pre></td></tr></table></figure>
<p><strong>注意: </strong><code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，直接返回导入失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/modprobe.d/blacklist.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">install MODULE /bin/false</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p>
<h3 id="使用内核命令行-1"><a href="#使用内核命令行-1" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>同样可以通过内核命令行(位于 <a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="external">GRUB</a>、<a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="external">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="external">Syslinux</a>)禁用模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe.blacklist=modname1,modname2,modname3</div></pre></td></tr></table></figure>
<p>当某个模块导致系统无法启动时，可以使用此方法禁用模块。</p>
<p>参阅<a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="external">Kernel parameters</a>.</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="显示所有内核参数的脚本"><a href="#显示所有内核参数的脚本" class="headerlink" title="显示所有内核参数的脚本"></a>显示所有内核参数的脚本</h3><p>下面的 bash 脚本可以显示当前装入模块、模块参数及当前参数的数值。它使用 <code>/proc/modules</code> 获取当前装入模块的列表，然后用 modinfo 获取模块的描述和模块的参数，最后访问 sysfs 文件系统获得当前模块名和参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function aa_mod_parameters () </div><div class="line">&#123; </div><div class="line">    N=/dev/null;</div><div class="line">    C=`tput op` O=$(echo -en &quot;\n`tput setaf 2`&gt;&gt;&gt; `tput op`&quot;);</div><div class="line">    for mod in $(cat /proc/modules|cut -d&quot; &quot; -f1);</div><div class="line">    do</div><div class="line">        md=/sys/module/$mod/parameters;</div><div class="line">        [[ ! -d $md ]] &amp;&amp; continue;</div><div class="line">        m=$mod;</div><div class="line">        d=`modinfo -d $m 2&gt;$N | tr &quot;\n&quot; &quot;\t&quot;`;</div><div class="line">        echo -en &quot;$O$m$C&quot;;</div><div class="line">        [[ $&#123;#d&#125; -gt 0 ]] &amp;&amp; echo -n &quot; - $d&quot;;</div><div class="line">        echo;</div><div class="line">        for mc in $(cd $md; echo *);</div><div class="line">        do</div><div class="line">            de=`modinfo -p $mod 2&gt;$N | grep ^$mc 2&gt;$N|sed &quot;s/^$mc=//&quot; 2&gt;$N`;</div><div class="line">            echo -en &quot;\t$mc=`cat $md/$mc 2&gt;$N`&quot;;</div><div class="line">            [[ $&#123;#de&#125; -gt 1 ]] &amp;&amp; echo -en &quot; - $de&quot;;</div><div class="line">            echo;</div><div class="line">        done;</div><div class="line">    done</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># aa_mod_parameters</div><div class="line">&gt;&gt;&gt; ehci_hcd - USB 2.0 &apos;Enhanced&apos; Host Controller (EHCI) Driver</div><div class="line">        hird=0 - hird:host initiated resume duration, +1 for each 75us (int)</div><div class="line">        ignore_oc=N - ignore_oc:ignore bogus hardware overcurrent indications (bool)</div><div class="line">        log2_irq_thresh=0 - log2_irq_thresh:log2 IRQ latency, 1-64 microframes (int)</div><div class="line">        park=0 - park:park setting; 1-3 back-to-back async packets (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; processor - ACPI Processor Driver</div><div class="line">        ignore_ppc=-1 - ignore_ppc:If the frequency of your machine gets wronglylimited by BIOS, this should help (int)</div><div class="line">        ignore_tpc=0 - ignore_tpc:Disable broken BIOS _TPC throttling support (int)</div><div class="line">        latency_factor=2 - latency_factor: (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; usb_storage - USB Mass Storage driver for Linux</div><div class="line">        delay_use=1 - delay_use:seconds to delay before using a new device (uint)</div><div class="line">        option_zero_cd=1 - option_zero_cd:ZeroCD mode (1=Force Modem (default), 2=Allow CD-Rom (uint)</div><div class="line">        quirks= - quirks:supplemental list of device IDs and their quirks (string)</div><div class="line">        swi_tru_install=1 - swi_tru_install:TRU-Install mode (1=Full Logic (def), 2=Force CD-Rom, 3=Force Modem) (uint)</div><div class="line"></div><div class="line">&gt;&gt;&gt; video - ACPI Video Driver</div><div class="line">        allow_duplicates=N - allow_duplicates: (bool)</div><div class="line">        brightness_switch_enabled=Y - brightness_switch_enabled: (bool)</div><div class="line">        use_bios_initial_backlight=Y - use_bios_initial_backlight: (bool)</div></pre></td></tr></table></figure>
<p>原文链接：<a href="https://wiki.archlinux.org/index.php/Kernel_modules_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="external">kernel modules</a>)</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——pgrep和pkill]]></title>
      <url>http://xiaqunfeng.cc/2017/02/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94pgrep%E5%92%8Cpkill/</url>
      <content type="html"><![CDATA[<p>通过程序名来查询进程PID的命令pgrep，以及对应的杀进程命令pkill。<br><a id="more"></a></p>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><p>在linux中查看进程信息，经常要用到<code>pa auxf</code>，具体到某个进程的时候，又需进行grep管道。如：<code>ps auxf|grep java|grep -v grep</code> ，即然这么长，可以不可以简化呢？当然可以，如果还是使用ps命令的话，可以改为<code>ps auxf|grep jav[a]</code>，这样就不用排除自身了。不过感觉命令还是长了点，能不能再简点，可以，使用<code>pgrep java</code>，不过此时得出的只是pid 。</p>
<p>pgrep是linux中常用的通过 <strong>程序名</strong> 来查询进程PID信息的命令。</p>
<p>pgrep命令相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep KeyWord</div></pre></td></tr></table></figure>
<p>注：pgrep命令查找的的是程序名，不包括其参数。如果参数里包括查找的keyword，而程序名中不包括，所则使用pgrep命令无法查到该进程。这时可以使用<code>ps -aux|grep keyword</code>命令。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep [options] &lt;pattern&gt;</div></pre></td></tr></table></figure>
<p>默认只显示PID，可以加选项来显示更多信息</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>通过命令 <code>pgrep --help</code> 获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line"> -d, --delimiter &lt;string&gt;  specify output delimiter</div><div class="line"> -l, --list-name           list PID and process name</div><div class="line"> -v, --inverse             negates the matching</div><div class="line"> -w, --lightweight         list all TID</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div></pre></td></tr></table></figure>
<p>翻译和解释如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>定义输出的多个进程之间的分隔符（默认使用换行符）</td>
</tr>
<tr>
<td>-l</td>
<td>列出pid 和 进程名</td>
</tr>
<tr>
<td>-v</td>
<td>否定匹配，即列出除了查找的进程以外的其他进程</td>
</tr>
<tr>
<td>-w</td>
<td>列出所有的TID</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配到的所有进程数量</td>
</tr>
<tr>
<td>-f</td>
<td>用进程全名去匹配</td>
</tr>
<tr>
<td>-g</td>
<td>匹配列出的进程组ID</td>
</tr>
<tr>
<td>-G</td>
<td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td>
</tr>
<tr>
<td>-n</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td>
</tr>
<tr>
<td>-o</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td>
</tr>
<tr>
<td>-P</td>
<td>根据父进程PID，找出所有子进程的pid</td>
</tr>
<tr>
<td>-s</td>
<td>匹配会话ID</td>
</tr>
<tr>
<td>-t</td>
<td>通过控制终端匹配</td>
</tr>
<tr>
<td>-u</td>
<td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td>
</tr>
<tr>
<td>-U</td>
<td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td>
</tr>
<tr>
<td>-x</td>
<td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td>
</tr>
<tr>
<td>-F</td>
<td>从文件中读取PID</td>
</tr>
<tr>
<td>-L</td>
<td>如果PID文件未锁定，则失败</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="列出要查找的进程"><a href="#列出要查找的进程" class="headerlink" title="列出要查找的进程"></a>列出要查找的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep ceph</div><div class="line">1478 [ceph-msgr]</div><div class="line">4682 [ceph-watch-noti]</div><div class="line">7058 /usr/bin/ceph-mon</div><div class="line">9371 /usr/bin/ceph-osd</div></pre></td></tr></table></figure>
<h4 id="自定义输出进程间分隔符"><a href="#自定义输出进程间分隔符" class="headerlink" title="自定义输出进程间分隔符"></a>自定义输出进程间分隔符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -d , ceph</div><div class="line">1478 ceph-msgr,4682 ceph-watch-noti,7058 ceph-mon,9371 ceph-osd</div><div class="line"># pgrep -l -d ... ceph</div><div class="line">1478 ceph-msgr...4682 ceph-watch-noti...7058 ceph-mon...9371 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="否定匹配"><a href="#否定匹配" class="headerlink" title="否定匹配"></a>否定匹配</h4><p>列出所有进程名中不包含 ceph 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -v ceph</div><div class="line">...</div><div class="line">4046 scst_mgmtd</div><div class="line">5408 kworker/2:1H</div><div class="line">6402 bioset</div><div class="line">6403 rbd00_0</div><div class="line">8734 rbd01_0</div><div class="line">8739 xfsalloc</div><div class="line">8741 xfs_mru_cache</div><div class="line">9153 xfs-buf/vdb1</div><div class="line">9154 xfs-data/vdb1</div><div class="line">9155 xfs-conv/vdb1</div><div class="line">9156 xfs-cil/vdb1</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="列出所有TID"><a href="#列出所有TID" class="headerlink" title="列出所有TID"></a>列出所有TID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -w ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">7062 ceph-mon</div><div class="line">7063 ceph-mon</div><div class="line">...</div><div class="line">6661 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line">9373 ceph-osd</div><div class="line">9374 ceph-osd</div><div class="line">...</div><div class="line">9702 ceph-osd</div><div class="line">27446 ceph-osd</div></pre></td></tr></table></figure>
<h4 id="统计匹配到的进程数"><a href="#统计匹配到的进程数" class="headerlink" title="统计匹配到的进程数"></a>统计匹配到的进程数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -c ceph</div><div class="line">4</div></pre></td></tr></table></figure>
<h4 id="匹配全名"><a href="#匹配全名" class="headerlink" title="匹配全名"></a>匹配全名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -f ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>感觉并没有什么卵用</p>
<h4 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h4><p>//TODO</p>
<h4 id="查找最新和最旧进程"><a href="#查找最新和最旧进程" class="headerlink" title="查找最新和最旧进程"></a>查找最新和最旧进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div></pre></td></tr></table></figure>
<p>查找最新(newest)、最后启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -n ceph</div><div class="line">4682 ceph-watch-noti</div></pre></td></tr></table></figure>
<p>查找最旧(oldest)、最早启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -o ceph</div><div class="line">7058 ceph-mon</div></pre></td></tr></table></figure>
<blockquote>
<p>注：进程号越大，并不一定意味着进程的启动时间越晚、进程越新</p>
</blockquote>
<h4 id="显示所有父进程的子进程"><a href="#显示所有父进程的子进程" class="headerlink" title="显示所有父进程的子进程"></a>显示所有父进程的子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># pgrep -P 2380</div><div class="line">2381</div><div class="line">2382</div><div class="line">2383</div><div class="line">2384</div><div class="line">2385</div></pre></td></tr></table></figure>
<h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># pgrep -l ceph</div><div class="line">1478 ceph-msgr</div><div class="line">4682 ceph-watch-noti</div><div class="line">7058 ceph-mon</div><div class="line">9371 ceph-osd</div><div class="line"># pgrep -x ceph</div><div class="line"># pgrep -x ceph-osd</div><div class="line">9371</div></pre></td></tr></table></figure>
<h4 id="从文件中读取PID"><a href="#从文件中读取PID" class="headerlink" title="从文件中读取PID"></a>从文件中读取PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat pid-file.txt </div><div class="line">1478</div><div class="line">7051</div><div class="line">2222</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># pgrep -l -F pid-file.txt </div><div class="line">1478 ceph-msgr</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>PID和TID的区别</p>
<p>pid是进程标识符，tid是线程标识符。</p>
<p>内核不会在它们之间做出真正的区分：线程就像进程一样，但它们与同一组的其他实例共享一些东西（内存，fds …）。</p>
<p>因此，tid实际上是内核（线程）中可调度对象的标识符，而pid是共享内存和fds（进程）的可调度对象组的标识符。当一个进程只有一个线程，pid和tid总是相同的。 所以任何使用tid的函数都会自动使用pid。</p>
<p>值得注意的是，许多函数/系统调用/命令行实用程序记录使用pid实际上使用tids。 但如果效果是过程范围的，你就不会注意到差异。</p>
<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>与 <code>pgrep</code> 使用方法基本类似，不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># pkill --help</div><div class="line"></div><div class="line">Usage:</div><div class="line"> pkill [options] &lt;pattern&gt;</div><div class="line"></div><div class="line">Options:</div><div class="line"> -&lt;sig&gt;, --signal &lt;sig&gt;    signal to send (either number or name)</div><div class="line"> -e, --echo                display what is killed</div><div class="line"> -c, --count               count of matching processes</div><div class="line"> -f, --full                use full process name to match</div><div class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</div><div class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</div><div class="line"> -n, --newest              select most recently started</div><div class="line"> -o, --oldest              select least recently started</div><div class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</div><div class="line"> -s, --session &lt;sid,...&gt;   match session IDs</div><div class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</div><div class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</div><div class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</div><div class="line"> -x, --exact               match exactly with the command name</div><div class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</div><div class="line"> -L, --logpidfile          fail if PID file is not locked</div><div class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</div><div class="line">                           namespace as &lt;pid&gt;</div><div class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</div><div class="line">                           the --ns option.</div><div class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</div><div class="line"></div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see pgrep(1).</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——strace]]></title>
      <url>http://xiaqunfeng.cc/2017/02/16/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94strace/</url>
      <content type="html"><![CDATA[<p>strace命令，用来查看运行程序的系统调用，统计每个系统调用的时间。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<p>我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。 </p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">usage: strace [-CdffhiqrtttTvVxxy] [-I n] [-e expr]...</div><div class="line">              [-a column] [-o file] [-s strsize] [-P path]...</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div><div class="line">   or: strace -c[df] [-I n] [-e expr]... [-O overhead] [-S sortby]</div><div class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</div></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</div><div class="line">-d 输出strace关于标准错误的调试信息.</div><div class="line">-f 跟踪由fork调用所产生的子进程.</div><div class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</div><div class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</div><div class="line">-h 输出简要的帮助信息.</div><div class="line">-i 输出系统调用的入口指针.</div><div class="line">-q 禁止输出关于脱离的消息.</div><div class="line">-r 打印出相对时间关于,,每一个系统调用.</div><div class="line">-t 在输出中的每一行前加上时间信息.</div><div class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</div><div class="line">-ttt 微秒级输出,以秒了表示时间.</div><div class="line">-T 显示每一调用所耗的时间.</div><div class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</div><div class="line">-V 输出strace的版本信息.</div><div class="line">-x 以十六进制形式输出非标准字符串</div><div class="line">-xx 所有字符串以十六进制形式输出.</div><div class="line">-a column</div><div class="line">设置返回值的输出位置.默认 为40.</div><div class="line">-e expr</div><div class="line">指定一个表达式,用来控制如何跟踪.格式如下:</div><div class="line">[qualifier=][!]value1[,value2]...</div><div class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</div><div class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</div><div class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</div><div class="line">-e trace=set</div><div class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</div><div class="line">-e trace=file</div><div class="line">只跟踪有关文件操作的系统调用.</div><div class="line">-e trace=process</div><div class="line">只跟踪有关进程控制的系统调用.</div><div class="line">-e trace=network</div><div class="line">跟踪与网络有关的所有系统调用.</div><div class="line">-e strace=signal</div><div class="line">跟踪所有与系统信号有关的 系统调用</div><div class="line">-e trace=ipc</div><div class="line">跟踪所有与进程通讯有关的系统调用</div><div class="line">-e abbrev=set</div><div class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</div><div class="line">-e raw=set</div><div class="line">将指 定的系统调用的参数以十六进制显示.</div><div class="line">-e signal=set</div><div class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</div><div class="line">-e read=set</div><div class="line">输出从指定文件中读出 的数据.例如:</div><div class="line">-e read=3,5</div><div class="line">-e write=set</div><div class="line">输出写入到指定文件中的数据.</div><div class="line">-o filename</div><div class="line">将strace的输出写入文件filename</div><div class="line">-p pid</div><div class="line">跟踪指定的进程pid.</div><div class="line">-s strsize</div><div class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</div><div class="line">-u username</div><div class="line">以username 的UID和GID执行被跟踪的命令</div></pre></td></tr></table></figure>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p>先用一个程序当例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#cat test.c </div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main() </div><div class="line">&#123; </div><div class="line">	int a; </div><div class="line">	scanf(&quot;%d&quot;, &amp;a); </div><div class="line">	printf(&quot;%09d\n&quot;, a); </div><div class="line">	return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译：<code>gcc -o test test.c</code> 得到可执行文件 test</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># strace ./test </div><div class="line">execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 20 vars */]) = 0</div><div class="line">brk(0)                                  = 0x9fa000</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a68a000</div><div class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=30643, ...&#125;) = 0</div><div class="line">mmap(NULL, 30643, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb60a682000</div><div class="line">close(3)                                = 0</div><div class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;..., 832) = 832</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1840928, ...&#125;) = 0</div><div class="line">mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb60a0a5000</div><div class="line">mprotect(0x7fb60a25f000, 2097152, PROT_NONE) = 0</div><div class="line">mmap(0x7fb60a45f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fb60a45f000</div><div class="line">mmap(0x7fb60a465000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb60a465000</div><div class="line">close(3)                                = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a681000</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a67f000</div><div class="line">arch_prctl(ARCH_SET_FS, 0x7fb60a67f740) = 0</div><div class="line">mprotect(0x7fb60a45f000, 16384, PROT_READ) = 0</div><div class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</div><div class="line">mprotect(0x7fb60a68c000, 4096, PROT_READ) = 0</div><div class="line">munmap(0x7fb60a682000, 30643)           = 0</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a689000</div><div class="line">read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)                  = 4</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a688000</div><div class="line">write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)             = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<ul>
<li>从trace结构可以看到，系统首先调用execve开始一个新的进行</li>
<li>接着进行些环境的初始化操作</li>
<li>最后停顿在”read(0,”上面，这也就是执行到了我们的scanf函数，等待我们输入数字</li>
<li>输入完100之后，再调用write函数将格式化后的数值”0000000100″输出到屏幕</li>
<li>最后调用exit_group退出进行，完成整个程序的执行过程</li>
</ul>
<p>如果在执行的过程中，进程 <code>test</code> 被kill掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd8d880a000</div><div class="line">read(0, 0x7fd8d880a000, 1024)           = ? ERESTARTSYS (To be restarted if SA_RESTART is set)</div><div class="line">--- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=1161, si_uid=0&#125; ---</div><div class="line">+++ killed by SIGTERM +++</div></pre></td></tr></table></figure>
<p>告诉你test进程”+++ killed by SIGTERM +++”</p>
<h3 id="系统调用统计"><a href="#系统调用统计" class="headerlink" title="系统调用统计"></a>系统调用统计</h3><p>使用参数 <code>-c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># strace -c ./test </div><div class="line">99</div><div class="line">000000099</div><div class="line">% time     seconds  usecs/call     calls    errors syscall</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">  0.00    0.000000           0         2           read</div><div class="line">  0.00    0.000000           0         1           write</div><div class="line">  0.00    0.000000           0         2           open</div><div class="line">  0.00    0.000000           0         2           close</div><div class="line">  0.00    0.000000           0         4           fstat</div><div class="line">  0.00    0.000000           0         9           mmap</div><div class="line">  0.00    0.000000           0         4           mprotect</div><div class="line">  0.00    0.000000           0         1           munmap</div><div class="line">  0.00    0.000000           0         1           brk</div><div class="line">  0.00    0.000000           0         3         3 access</div><div class="line">  0.00    0.000000           0         1           execve</div><div class="line">  0.00    0.000000           0         1           arch_prctl</div><div class="line">------ ----------- ----------- --------- --------- ----------------</div><div class="line">100.00    0.000000                    31         3 total</div></pre></td></tr></table></figure>
<p>很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。这里太快了，都是0。</p>
<h3 id="追踪现有进程"><a href="#追踪现有进程" class="headerlink" title="追踪现有进程"></a>追踪现有进程</h3><p>参数<code>-p</code> ，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -p pid</div></pre></td></tr></table></figure>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>使用参数<code>-o</code> 将strace的结果输出到文件中，如果不指定-o参数的话，默认的输出设备是STDERR，也就是说使用”-o filename”和” 2&gt;filename”的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 这两个命令都是将strace结果输出到文件test.txt中 </div><div class="line">strace -c -o test.txt ./test </div><div class="line">strace -c ./test 2&gt;test.txt</div></pre></td></tr></table></figure>
<h3 id="系统调用计时"><a href="#系统调用计时" class="headerlink" title="系统调用计时"></a>系统调用计时</h3><p>使用参数 <code>-T</code> 将每个系统调用所花费的时间打印出来，每个调用的时间花销现在在调用行最右边的尖括号里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000013&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31135000 &lt;0.000015&gt;</div><div class="line">read(0, 54</div><div class="line">&quot;54\n&quot;, 1024)                   = 3 &lt;9.354830&gt;</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000012&gt;</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31134000 &lt;0.000013&gt;</div><div class="line">write(1, &quot;000000054\n&quot;, 10000000054</div><div class="line">)             = 10 &lt;0.000010&gt;</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<p>使用参数 <code>-t</code> 输出结果精确到秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:21:20 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)         = 4</div><div class="line">20:21:24 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:21:24 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa926d0b000</div><div class="line">20:21:24 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">)    = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-tt</code> 输出结果精确到微秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">20:24:52.063615 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024)  = 4</div><div class="line">20:24:54.031118 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">20:24:54.031167 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2dc4bd3000</div><div class="line">20:24:54.031210 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<p>使用参数 <code>-ttt</code> 输出结果精确到微秒，而且时间表示为unix时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1487247731.103542 read(0, 100</div><div class="line">&quot;100\n&quot;, 1024) = 4</div><div class="line">1487247887.084673 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">1487247887.084717 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22beb1f000</div><div class="line">1487247887.084812 write(1, &quot;000000100\n&quot;, 10000000100</div><div class="line">) = 10</div></pre></td></tr></table></figure>
<h3 id="截断输出"><a href="#截断输出" class="headerlink" title="截断输出"></a>截断输出</h3><p><code>-s</code> 参数用于指定trace结果的每一行输出的字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># strace -s 3 ./test </div><div class="line">...</div><div class="line">read(0, 1024</div><div class="line">&quot;102&quot;..., 1024)                 = 5</div><div class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</div><div class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdeeb74a000</div><div class="line">write(1, &quot;000&quot;..., 10000001024</div><div class="line">)                  = 10</div><div class="line">exit_group(0)                           = ?</div><div class="line">+++ exited with 0 +++</div></pre></td></tr></table></figure>
<h3 id="跟踪服务程序"><a href="#跟踪服务程序" class="headerlink" title="跟踪服务程序"></a>跟踪服务程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -o output.txt -T -tt -e trace=all -p 28979</div></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h3 id="跟踪可执行程序"><a href="#跟踪可执行程序" class="headerlink" title="跟踪可执行程序"></a>跟踪可执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strace -f -F -o ~/straceout.txt myserver</div></pre></td></tr></table></figure>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>参考资料：</p>
<p><a href="http://man.linuxde.net/strace" target="_blank" rel="external">strace命令</a></p>
<p><a href="http://huoding.com/2013/10/06/288" target="_blank" rel="external">通过Strace定位故障原因</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取每个osd的PG数]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%AAosd%E7%9A%84PG%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个shell脚本，用于获取ceph集群中每个osd的PG数，同时分别统计每个pool上的PG数信息。<br><a id="more"></a></p>
<h2 id="Ceph集群信息"><a href="#Ceph集群信息" class="headerlink" title="Ceph集群信息"></a>Ceph集群信息</h2><p><strong>pool信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd lspools</div><div class="line">0 rbd,1 testpool,</div></pre></td></tr></table></figure>
<p><strong>osd信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.54538 root default                                      </div><div class="line">-2 0.18179     host jewel0                                   </div><div class="line"> 0 0.18179         osd.0        up  1.00000          1.00000 </div><div class="line">-3 0.18179     host jewel1                                   </div><div class="line"> 1 0.18179         osd.1        up  1.00000          1.00000 </div><div class="line">-4 0.18179     host jewel2                                   </div><div class="line"> 2 0.18179         osd.2        up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h2 id="脚本执行结果展示"><a href="#脚本执行结果展示" class="headerlink" title="脚本执行结果展示"></a>脚本执行结果展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># sh pg-per-osd.sh </div><div class="line">dumped all in format plain</div><div class="line"></div><div class="line">pool :	0	1	| SUM </div><div class="line">--------------------------------</div><div class="line">osd.0	64	128	| 192</div><div class="line">osd.1	64	128	| 192</div><div class="line">osd.2	64	128	| 192</div><div class="line">--------------------------------</div><div class="line">SUM :	192	384</div></pre></td></tr></table></figure>
<p>每行显示单个OSD在每个pool中的PG数详情</p>
<p>每列显示单个pool中每个OSD的PG数详情</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># cat pg-per-osd.sh</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">ceph pg dump | awk &apos;</div><div class="line"> /^pg_stat/ &#123; col=1; while($col!=&quot;up&quot;) &#123;col++&#125;; col++ &#125;</div><div class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</div><div class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</div><div class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</div><div class="line">&#125;</div><div class="line">END &#123;</div><div class="line"> printf(&quot;\n&quot;);</div><div class="line"> printf(&quot;pool :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,i); printf(&quot;| SUM \n&quot;);</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> for (i in osdlist) &#123; printf(&quot;osd.%i\t&quot;, i); sum=0;</div><div class="line">   for (j in poollist) &#123; printf(&quot;%i\t&quot;, array[i,j]); sum+=array[i,j]; sumpool[j]+=array[i,j] &#125;; printf(&quot;| %i\n&quot;,sum) &#125;</div><div class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</div><div class="line"> printf(&quot;SUM :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,sumpool[i]); printf(&quot;|\n&quot;);</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RBD 相关操作]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/RBD-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要有两点：一、创建RBD设备用于测试；二、RBD相关其他操作。<br><a id="more"></a></p>
<p>查看系统和内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># lsb_release -a</div><div class="line">No LSB modules are available.</div><div class="line">Distributor ID:	Ubuntu</div><div class="line">Description:	Ubuntu 14.04.4 LTS</div><div class="line">Release:	14.04</div><div class="line">Codename:	trusty</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uname -r</div><div class="line">4.2.0-27-generic</div></pre></td></tr></table></figure>
<h2 id="创建RBD设备"><a href="#创建RBD设备" class="headerlink" title="创建RBD设备"></a>创建RBD设备</h2><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>1、<code>--image-format format-id</code></p>
<p>选择用哪个对象布局，默认为 2 。</p>
<ul>
<li>format 1 - 新建 rbd 映像时使用最初的格式。此格式兼容所有版本的 librbd 和内核模块，但是不支持较新的功能，像克隆。</li>
<li>format 2 - 使用第二版 rbd 格式， librbd 和 3.11 版以上内核模块才支持（除非是分拆的模块）。此格式增加了克隆支持，使得扩展更容易，还允许以后增加新功能。</li>
</ul>
<p>注意： <code>--image-format 1</code> 已不被支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-f1 --size 10G --image-format 1 --image-feature layering </div><div class="line">rbd: image format 1 is deprecated</div><div class="line">rbd: features not allowed with format 1; use --image-format 2</div></pre></td></tr></table></figure>
<p>2、<code>--image-feature   feature</code></p>
<p>选项指定使用特性，不用全部开启。如果仅需要使用快照等特性，开启layering即可。</p>
<ul>
<li>layering: 支持分层</li>
<li>striping: 支持条带化 v2</li>
<li>exclusive-lock: 支持独占锁</li>
<li>object-map: 支持对象映射（依赖 exclusive-lock ）</li>
<li>fast-diff: 快速计算差异（依赖 object-map ）</li>
<li>deep-flatten: 支持快照扁平化操作</li>
<li>journaling: 支持记录 IO 操作（依赖独占锁）</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>这里 <code>--image-format 2</code> 可以省略掉（命令如下），因为默认值就是 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create rbd-blue --size 20G --image-feature layering</div></pre></td></tr></table></figure>
<p>查看创建的RBD信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-blue</div><div class="line">rbd image &apos;rbd-blue&apos;:</div><div class="line">	size 20480 MB in 5120 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.105774b0dc51</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags:</div></pre></td></tr></table></figure>
<h2 id="映射块设备"><a href="#映射块设备" class="headerlink" title="映射块设备"></a>映射块设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-blue</div><div class="line">/dev/rbd0</div></pre></td></tr></table></figure>
<p>查看映射后信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped </div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># fdisk -l /dev/rbd0</div><div class="line"># mkfs.xfs /dev/rbd0</div></pre></td></tr></table></figure>
<h3 id="创建文件夹并挂载"><a href="#创建文件夹并挂载" class="headerlink" title="创建文件夹并挂载"></a>创建文件夹并挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># mkdir /mnt/ceph-disk1</div><div class="line"># mount /dev/rbd0 /mnt/ceph-disk1</div><div class="line"></div><div class="line"># df -h /mnt/ceph-disk1/</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/rbd0        20G   33M   20G   1% /mnt/ceph-disk1</div></pre></td></tr></table></figure>
<blockquote>
<p>此时，RBD设备已准备就绪，可以对RBD块设备进行测试了。</p>
</blockquote>
<h2 id="块设备其他操作"><a href="#块设备其他操作" class="headerlink" title="块设备其他操作"></a>块设备其他操作</h2><h3 id="罗列块设备映像"><a href="#罗列块设备映像" class="headerlink" title="罗列块设备映像"></a>罗列块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd ls &#123;poolname&#125;	# poolname默认是rbd，可省略</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># rbd ls</div><div class="line">rbd-blue</div><div class="line">rbd-tmp</div><div class="line">rbd-tmp1</div></pre></td></tr></table></figure>
<h3 id="检索镜像信息"><a href="#检索镜像信息" class="headerlink" title="检索镜像信息"></a>检索镜像信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;pool-name&#125;/&#123;image-name&#125;</div></pre></td></tr></table></figure>
<p>如果没有创建其他rbd的话，可以将命令简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd info &#123;image-name&#125;</div></pre></td></tr></table></figure>
<h3 id="调整块设备映像大小"><a href="#调整块设备映像大小" class="headerlink" title="调整块设备映像大小"></a>调整块设备映像大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rbd resize --size 2048 rbd-blue (to increase)</div><div class="line">rbd resize --size 2048 rbd-blue --allow-shrink (to decrease)</div></pre></td></tr></table></figure>
<h3 id="删除块设备映像"><a href="#删除块设备映像" class="headerlink" title="删除块设备映像"></a>删除块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rbd rm &#123;pool-name&#125;/&#123;image-name&#125;	# 默认pool是rbd，可省略&#123;pool-name&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在删除前需要umap映像</p>
</blockquote>
<h4 id="正确删除过程"><a href="#正确删除过程" class="headerlink" title="正确删除过程"></a><strong>正确删除过程</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd showmapped</div><div class="line">id pool image    snap device    </div><div class="line">0  rbd  rbd-blue -    /dev/rbd0 </div><div class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </div><div class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd unmap /dev/rbd2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">Removing image: 100% complete...done.</div></pre></td></tr></table></figure>
<p>注意：命令 <code>service rbdmap stop</code> 并不管用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service rbdmap stop</div><div class="line">stop: Job failed while stopping</div></pre></td></tr></table></figure>
<h4 id="不unmap的删除"><a href="#不unmap的删除" class="headerlink" title="不unmap的删除"></a><strong>不unmap的删除</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd rm rbd-tmp1</div><div class="line">2017-02-08 11:17:47.700190 7f4ba6977000 -1 librbd: image has watchers - not removing</div><div class="line">Removing image: 0% complete...failed.</div><div class="line">rbd: error: image still has watchers</div><div class="line">This means the image is still open or the client using it crashed. Try again after closing/unmapping it or waiting 30s for the crashed client to timeout.</div></pre></td></tr></table></figure>
<p>提示image正在被使用。如果想查看谁正在使用的话，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># rbd info rbd-tmp1</div><div class="line">rbd image &apos;rbd-tmp1&apos;:</div><div class="line">	size 10240 MB in 2560 objects</div><div class="line">	order 22 (4096 kB objects)</div><div class="line">	block_name_prefix: rbd_data.104c2ae8944a</div><div class="line">	format: 2</div><div class="line">	features: layering</div><div class="line">	flags: </div><div class="line"></div><div class="line"># rados -p rbd listwatchers rbd_header.104c2ae8944a</div><div class="line">watcher=172.20.1.151:0/1839598827 client.4186 cookie=3</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面这种方式创建RBD在map的时候会失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rbd create --size 10240 rbd-test</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># rbd map rbd/rbd-test</div><div class="line">rbd: sysfs write failed</div><div class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</div><div class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</div><div class="line">rbd: map failed: (6) No such device or address</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Kraken release版本上测试Ceph BlueStore]]></title>
      <url>http://xiaqunfeng.cc/2017/02/07/%E5%9C%A8Kraken-release%E7%89%88%E6%9C%AC%E4%B8%8A%E6%B5%8B%E8%AF%95Ceph-BlueStore/</url>
      <content type="html"><![CDATA[<p>前面写了一篇文章《ceph升级到kraken版本》，在升级后的集群上重新部署OSD遇到一些问题。这里在干净的kraken环境下部署bluestore，用来测试一下性能。本文记录部署过程及遇到的问题和解决方法。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ceph版本Kraken（11.2.0）已经发布，发行说明告诉我们，用于OSD的新的BlueStore后端现在可用。</p>
<h2 id="bluestore"><a href="#bluestore" class="headerlink" title="bluestore"></a>bluestore</h2><p>OSD的当前后端是FileStore，它主要使用XFS文件系统来存储它的数据。 为了克服XFS和POSIX的一些限制，所以开发了BlueStore后端。</p>
<p>由于校验和压缩它将提供更多的性能（主要是写）和数据安全。</p>
<p>鼓励用户从Kraken发行版本开始，使用非生产和非关键数据集来测试BlueStore，并向社区报告。</p>
<h2 id="部署BlueStore"><a href="#部署BlueStore" class="headerlink" title="部署BlueStore"></a>部署BlueStore</h2><p>要使用BlueStore部署OSD，您可以使用<code>-bluestore</code>标志来使用ceph-deploy。</p>
<p>我创建了一个简单的测试集群，有三个机器：alpha，bravo和charlie。</p>
<p>每个机器将运行一个ceph-mon和ceph-osd进程。</p>
<p>这是我用来部署集群的ceph-deploy命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph-deploy new alpha bravo charlie</div><div class="line">ceph-deploy mon create alpha bravo charlie</div></pre></td></tr></table></figure>
<p>现在，编辑当前目录中的ceph.conf文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[osd]</div><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>有了这个设置我们允许使用BlueStore，我们现在可以部署我们的OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf osd create --bluestore alpha:sdb bravo:sdb charlie:sdb</div></pre></td></tr></table></figure>
<h2 id="运行Bluestore"><a href="#运行Bluestore" class="headerlink" title="运行Bluestore"></a>运行Bluestore</h2><p>这个微小的集群如何使用BlueStore运行三个OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph -s</div><div class="line">    cluster c824e460-2f09-4994-8b2f-108aedc52d19</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;alpha=[2001:db8::100]:6789/0,bravo=[2001:db8::101]:6789/0,charlie=[2001:db8::102]:6789/0&#125;</div><div class="line">            election epoch 14, quorum 0,1,2 alpha,bravo,charlie</div><div class="line">        mgr active: charlie standbys: alpha, bravo</div><div class="line">     osdmap e14: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v24: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            43356 kB used, 30374 MB / 30416 MB avail</div><div class="line">                  64 active+clean</div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 0.02907 root default                                       </div><div class="line">-2 0.00969     host alpha                                     </div><div class="line"> 0 0.00969         osd.0         up  1.00000          1.00000 </div><div class="line">-3 0.00969     host bravo                                     </div><div class="line"> 1 0.00969         osd.1         up  1.00000          1.00000 </div><div class="line">-4 0.00969     host charlie                                   </div><div class="line"> 2 0.00969         osd.2         up  1.00000          1.00000 </div><div class="line">root@alpha:~#</div></pre></td></tr></table></figure>
<p>在alpha我看到osd.0只有一个小分区的一点配置，其余的由BlueStore使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# df -h /var/lib/ceph/osd/ceph-0</div><div class="line">Filesystem      Size  Used Avail Use% Mounted on</div><div class="line">/dev/sdb1        97M  5.4M   92M   6% /var/lib/ceph/osd/ceph-0</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# lsblk </div><div class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</div><div class="line">sda      8:0    0    8G  0 disk </div><div class="line">├─sda1   8:1    0  7.5G  0 part /</div><div class="line">├─sda2   8:2    0    1K  0 part </div><div class="line">└─sda5   8:5    0  510M  0 part [SWAP]</div><div class="line">sdb      8:16   0   10G  0 disk </div><div class="line">├─sdb1   8:17   0  100M  0 part /var/lib/ceph/osd/ceph-0</div><div class="line">└─sdb2   8:18   0  9.9G  0 part </div><div class="line">sdc      8:32   0   10G  0 disk</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@alpha:~# cat /var/lib/ceph/osd/ceph-0/type</div><div class="line">bluestore</div></pre></td></tr></table></figure>
<p>OSD应该像运行FileStore的OSD一样工作，但它们应该运行得更好。</p>
<blockquote>
<p>以上内容翻译自：<a href="https://blog.widodh.nl/2017/01/testing-ceph-bluestore-with-the-kraken-release/" target="_blank" rel="external">Testing Ceph BlueStore with the Kraken release</a>。亲测可以成功，觉得很好就不放自己的配置，直接翻译过来了。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>问题1</strong>、<code>ceph -s</code>的时候出现告警：<code>WARNING: the following dangerous and experimental features are enabled: bluestore</code></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">2017-02-07 10:10:34.266900 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">2017-02-07 10:10:34.271112 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</div><div class="line">    cluster 7e9423ea-95f8-42d1-ae2d-7a384d68dea7</div><div class="line">     health HEALTH_OK</div><div class="line">     monmap e2: 3 mons at &#123;blue0=172.20.1.151:6789/0,blue1=172.20.1.152:6789/0,blue2=172.20.1.153:6789/0&#125;</div><div class="line">            election epoch 6, quorum 0,1,2 blue0,blue1,blue2</div><div class="line">        mgr no daemons active </div><div class="line">     osdmap e15: 3 osds: 3 up, 3 in</div><div class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</div><div class="line">      pgmap v34: 64 pgs, 1 pools, 0 bytes data, 0 objects</div><div class="line">            49092 kB used, 599 GB / 599 GB avail</div><div class="line">                  64 active+clean</div></pre></td></tr></table></figure>
<p>查了资料，无果，有些认为是<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2016-April/009059.html" target="_blank" rel="external">内核版本的问题</a>，然而并不对。</p>
<p>真正原因是在添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</div></pre></td></tr></table></figure>
<p>的时候忘记在前面加上：<code>[osd]</code></p>
<p><strong>问题2</strong>、从jewel版本上升级到kraken版本，然后再通过上述方法创建OSD并不成功</p>
<p><strong>问题3</strong>、创建mon的时候出现error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy --overwrite-conf mon create-initial</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用户态和内核态]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
      <content type="html"><![CDATA[<p>以前整理的小知识点，关于用户态和内核态的解释。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内核态与用户态是操作系统的两种运行级别，intel cpu提供Ring0-Ring3三种级别的运行模式。Ring0级别最高，Ring3最低。</p>
<p>所以当CPU处于内核态，可以随意进入用户态。当CPU处于用户态，只能通过中断的方式进入内核态。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。</p>
<h2 id="cpu的四种状态"><a href="#cpu的四种状态" class="headerlink" title="cpu的四种状态"></a>cpu的四种状态</h2><p>在一台运行 Linux 的计算机中，CPU 在任何时候只会有如下四种状态：</p>
<ol>
<li>在处理一个硬中断。</li>
<li>在处理一个软中断，如 softirq、tasklet 和 bh。</li>
<li>运行于内核态，但有进程上下文，即与一个进程相关。</li>
<li>运行一个用户态进程。</li>
</ol>
<p>其中，【1】、【2】和【3】是运行于内核空间的，而【4】是在用户空间。其中除了【4】，其他状态只可以被在其之上的状态抢占。比如，软中断只可以被硬中断抢占。</p>
<h2 id="linux下详解"><a href="#linux下详解" class="headerlink" title="linux下详解"></a>linux下详解</h2><p>Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。</p>
<p>Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。</p>
<p>用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。</p>
<p>这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph升级到kraken版本]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/ceph%E5%8D%87%E7%BA%A7%E5%88%B0kraken%E7%89%88%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>记录从jewel版本升级到kraken版本的过程，其中重启mon和osd部分官网上的命令并不凑效，这里纠正并记录之。<br><a id="more"></a></p>
<h2 id="1、在Jewel集群上设置sortbitwise标志"><a href="#1、在Jewel集群上设置sortbitwise标志" class="headerlink" title="1、在Jewel集群上设置sortbitwise标志"></a>1、在Jewel集群上设置sortbitwise标志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph osd set sortbitwise</div></pre></td></tr></table></figure>
<h2 id="2、添加安装源"><a href="#2、添加安装源" class="headerlink" title="2、添加安装源"></a>2、添加安装源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo deb https://download.ceph.com/debian-kraken/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</div></pre></td></tr></table></figure>
<p><strong>设置环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-kraken</div></pre></td></tr></table></figure>
<h2 id="3、升级软件包"><a href="#3、升级软件包" class="headerlink" title="3、升级软件包"></a>3、升级软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-deploy install --release kraken ceph-0 ceph-1 ceph-2</div></pre></td></tr></table></figure>
<p>此时，ceph已升级到 11.2.0 版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph --version</div><div class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div></pre></td></tr></table></figure>
<p>但是，osd和mon的版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-1: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line">mon.ceph-2: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="4、在各节点上重启相关ceph守护进程"><a href="#4、在各节点上重启相关ceph守护进程" class="headerlink" title="4、在各节点上重启相关ceph守护进程"></a>4、在各节点上重启相关ceph守护进程</h2><p>安装官网上的命令操作是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-1 sudo /etc/init.d/ceph -a restart</div><div class="line">ssh ceph-2 sudo /etc/init.d/ceph -a restart</div></pre></td></tr></table></figure>
<p>然而，查看 mon 的进程号发现并没有重启，所以版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ps aux | grep ceph-osd</div><div class="line"># ps aux | grep ceph-mon</div></pre></td></tr></table></figure>
<p><strong>正确的重启命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 重启mon</div><div class="line">restart ceph-mon-all</div><div class="line">ssh ceph-1 restart ceph-mon-all</div><div class="line">ssh ceph-2 restart ceph-mon-all</div><div class="line"></div><div class="line"># 重启osd</div><div class="line">restart ceph-osd-all</div><div class="line">ssh ceph-1 restart ceph-osd-all</div><div class="line">ssh ceph-2 restart ceph-osd-all</div></pre></td></tr></table></figure>
<p>也可以单独重启某一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># restart ceph-mon id=ceph-0</div><div class="line">ceph-mon (ceph/ceph-0) start/running, process 23629</div><div class="line"></div><div class="line"># restart ceph-osd id=0</div><div class="line">ceph-osd (ceph/0) start/running, process 23700</div></pre></td></tr></table></figure>
<p>查看最新mon和osd版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ceph tell mon.* version</div><div class="line">mon.ceph-0: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-1: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line">mon.ceph-2: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</div><div class="line"></div><div class="line"># ceph tell osd.* version</div><div class="line">osd.0: &#123;</div><div class="line">    &quot;version&quot;: &quot;ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)&quot;</div><div class="line">&#125;</div><div class="line">...省略</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行 <code>ceph -s</code> 的时候，出现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ceph -s</div><div class="line">    cluster 7251c881-bb25-4c36-9be1-653f66c69e1c</div><div class="line">     health HEALTH_WARN</div><div class="line">            all OSDs are running kraken or later but the &apos;require_kraken_osds&apos; osdmap flag is not set</div><div class="line">...省略</div></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ceph osd set require_kraken_osds</div><div class="line">require_kraken_osds is set</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dm-cache vs Bcache]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Dm-cache-vs-Bcache/</url>
      <content type="html"><![CDATA[<p>前面一篇文章介绍了flashcache和cache tier，并进行了对比，其实flashcache的原理和dm-cache是类似的。这里就介绍下dm-cache和bcache，这两种策略均已在linux内核中。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代硬盘驱动器（HDD）已经走了很长的路。他们旋转得越来越快;与过去的HDD相比具有更高的存储密度和更低的错误率，但是它们和其前身一样，仍然被视为性能瓶颈。随着时间的推移，我们已经看到了许多缓存方案来提高性能;有一些块缓存解决方案在磁盘驱动器（磁盘或存储控制器）或使用主机系统内存的文件系统级缓存解决方案附近使用某种类型的缓存。随着企业级的可接受性，大而经济的闪存存储技术的可用性，使用固态驱动器（SSD）的块缓存解决方案作为性能增强解决方案。使用基于SSD的块缓存，我们可以寻找SSD速度和HDD容量 - 快速，大而且实惠。</p>
<p>在块缓存解决方案中，概念上，将逻辑设备呈现给文件系统（或多个应用），而不是实际目的地HDD（或其它目的地块设备，例如iSCSI LUN），其中数据意在被存储。因此呈现的逻辑设备与原始设备具有相同的大小物理设备，而用于高速缓存的SSD可以跨越逻辑设备映射。</p>
<p>Linux开源社区有多个通用的块级缓存解决方案，其中包括bcache，dm-cache和flashcache。 Linux内核社区将内核3.9中的dm-cache上游和内核3.10中的bcache合并。虽然flashcache未在上游合并，但在某些生产环境中已经使用了一段时间。</p>
<h2 id="dm-cache"><a href="#dm-cache" class="headerlink" title="dm-cache"></a>dm-cache</h2><p>又叫 Device Mapper Cache。dm-cache是设备映射器目标，首先提交到kernel-3.9。它使用针对基于闪存的SSD进行优化的I / O调度和缓存管理技术。设备映射程序目标（dmcache）重新使用精简资源调配库中使用的元数据库。write-back和writethrough都由dm-cache支持，write-back是默认模式。</p>
<p>由dm-cache创建的虚拟缓存设备使用源设备（Origin device）、缓存设备（Cache device）和元数据设备（Metadata dev）这三个物理设备来构建。结构如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/dm-cache.png" alt="dm-cache"></p>
<p>源设备是实际（较慢）目的存储设备。</p>
<p>高速缓存设备是用于临时存储用户数据的较快设备。</p>
<p>元数据设备记录块布局，它们的dirty flags和其他内部数据所需的策略。</p>
<h2 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h2><p>bcache首先提交到kernel-3.10。它围绕基于闪存的SSD的独特特性设计，并使用混合btree/log结构来跟踪缓存的区域。它旨在不惜一切代价（at all cost）避免随机写。 bcache顺序填充一个擦除块，然后在重新使用之前发出一个丢弃（缓存数据可以是桶上的任意一个扇区。bcache最大程度上减少了随机写的代价，它按顺序填充一个桶，重新使用时只需将桶设置为无效）。支持write-through和write-back高速缓存。write-back默认关闭，但可以在运行时任意打开和关闭。</p>
<p>通过后端设备（backing device）和缓存设备（caching device）来创建虚拟的bcache 设备，如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/bcache.png" alt="bcache"></p>
<p>后端设备是实际（较慢）目的存储设备，而高速缓存设备是更快的设备。后备设备必须格式化为bcache 块设备；现有的格式化分区不能与bcache一起使用。（可以尝试 blocks to-bcache进行就地转换）。</p>
<p>默认状态下bcache不缓存顺序IO，只缓存随机读写。为避免随机写，bcache将随机写转换为顺序写，首先写到SSD，然后回写缓存使用SSD缓存大量的写，最后将写有序写到磁盘或者阵列上。</p>
<p>SSD的特点就是随机IO速度很快，而对于大块顺序IO的提升却并不大。bcache会检测顺序IO并忽略；还会对每一个任务记录动态的平均IO大小，当平均IO大小超过截止值时该任务后面的IO将会被忽略，这样就可以透传备份或者大文件拷贝。</p>
<h2 id="Dm-cache-vs-Bcache"><a href="#Dm-cache-vs-Bcache" class="headerlink" title="Dm-cache vs Bcache"></a>Dm-cache vs Bcache</h2><p>与 dm-cache 实现的的分级存储不同，bcache 更像一个传统的缓存。它可以用来存储任何 extents，甚至是是一个扇区，而 dm-cache 只能对整块数据进行缓存。</p>
<p>dm-cache方案假设缓存设备总是存在，bcache 并不要求 cache 设备一直都在。 </p>
<p>bcache 已经在实际产品中使用了，所以它有机会去碰到这些疑难场景，并可以处理这些缓存设备无法工作的情形。</p>
<p>dm-cache 确实还有很多事情要做。起初，它是进行 cache 和原始设备的并行 IO，但最终不得不回到顺序 IO。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flashcache vs Cache tier]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Flashcache-vs-Cache-tier/</url>
      <content type="html"><![CDATA[<p>使用SSD作为缓存来提高性能有多种方法，文章前言里会介绍，主要有bcache、dm-cache、flashcache、cache tier等，本文比较两种在ceph中的常用方案：flashcache 和 cache tier。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的HDD具备大容量的优势，但是性能相对偏低，尤其是随机IO性能，经常成为系统的性能瓶颈，在虚拟机化环境下表现的更明显，因为虚拟化场景会加剧IO随机化。相比HDD，SSD具有高性能的优势，尤其在随机IO这方面，优势非常明显，但是SSD的硬件成本比较高。</p>
<p>目前业界在结合HDD的大容量和SSD的高性能方面做了一些优化，基本思路是使用SSD作为HDD的cache。计算机领域，cache的思想无处不在，比如CPU的L1、L2 cache，raid card上的cache，TLB cache等。关于SSD作为HDD的cache的优化方案，主要有Linux bcache，Linux dm-cache，Facebook flashcache，btier，IBM flashcache等。</p>
<h2 id="flashcache"><a href="#flashcache" class="headerlink" title="flashcache"></a>flashcache</h2><p>flashcache 是 facebook 开源的 ssd 存储产品，它基于内核的 devicemapper 机制，允许将 ssd 设备映射为机械存储设备的缓存，堆叠成为一个虚拟设备供用户读写，从而在一定程度上兼顾 ssd 的高速与机械存储设备的高容量，更加经济高效地支撑线上业务。</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/flashcache.png" alt="flashcache"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Device Mapper层，对外服务体现方式是块设备，无需修改应用。</p>
<p>确保内核已启用 DeviceMapper，编译内核模块并安装之后：</p>
<ul>
<li>创建缓存设备: flashcache_wt_create /dev/cachedev /dev/sda1 /dev/hda1</li>
<li>删除缓存设备: dmsetup remove cachedev </li>
</ul>
<p>使用者需要注意建立缓存设备之后，就不应该再对 /dev/sda1 和 /dev/hda1 两个设备直接读写了。</p>
<p>用户操作接口是映射之后的虚拟设备，即/dev/mapper/*下面的设备，如cachedev，而不是基设备</p>
<h3 id="缓存的组织"><a href="#缓存的组织" class="headerlink" title="缓存的组织"></a>缓存的组织</h3><p>flashcache是建立在Linux devicemapper之上的，由devicemapper在SSD和backing HDD之上创建了一个逻辑的mapped device，用户使用的就是这个mapped device。</p>
<p>flashcache把cache（SSD）按照哈希的方式进行结构化管理，flashcache 中缓存的盘块的默认大小为 4kb，按照多路组相连的形式组织缓存块，每组含有 512 个缓存块，简单按照取模分组。缓存的查找，就是对后端设备块号取模得到组号，然后凭偏移遍历组中的缓存块。具体管理方式可以参考小结末参考资料。</p>
<p>虽然数据会被写入 ssd 设备，但缓存的组织信息一律保存在内存中，即 cache_c 对象。它里面保存了基本的配置选项、统计信息、对两个设备的引用、每个缓存块的相关信息(cache, cache_state)、 以及缓存组中 FIFO 数组(虽然名字叫做 LRU)的下标。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>flashcache 支持三种缓存策略：</p>
<ul>
<li>writethrough：disk write会在cache中保留一份，但同时也会把数据write到backing disk中，直到write backing disk完成才会返回。</li>
<li>writearound：disk write会bypass cache，直接写到backing disk中，disk read会把从backing disk中读取的数据在cache中缓存。</li>
<li>writeback：write首先会写到cache中，然后更新metadata中得dirty bit，数据并不会立即同步到backing disk中。</li>
</ul>
<p>针对writethrough和writearound，disk read首先根据目的sector找到对应的cache set，然后查找有没有相应的block，如果找到了，也就是cache hit，则直接从cache中读取，如果没有找到，就从backing disk中读取数据，同时也在cache中进行缓存。</p>
<h3 id="数据调度"><a href="#数据调度" class="headerlink" title="数据调度"></a>数据调度</h3><p>DM层request送往flashcache，并将读写请求按照目标设备的blocksize进行划分，切割成blocksize大小的bio。</p>
<p><strong>读</strong></p>
<p>接收到bio，首先，根据bio-&gt;bi_sector，即硬盘的扇区号，得到SSD上的set；</p>
<p>其次，在set内查找是否命中，如果命中，则将硬盘的扇区号转换为SSD的扇区号，然后将此bio向SSD提交，进行读取；</p>
<p>如果未命中，则首先向硬盘驱动提交bio，从硬盘读数据，读取完成后，由回调函数启动回写SSD操作，将bio的扇区号转换为SSD的=扇区号，然后向SSD驱动程序提交，将硬盘读取的数据写入SSD。</p>
<p><strong>写</strong></p>
<p>同文件系统页缓冲，并不直接写入硬盘，而是写入SSD，同时，保持一个阀值，一般为20%，在脏块数目达到此数值时，写回磁盘。</p>
<p>另外：如果<strong>IO size小于blocksize</strong>，flashcache则不会缓存该IO，而是先查找cache中有没有overlap的脏数据：</p>
<p>如果有的话，就先刷脏数据，然后再把刚才从devicemapper传来的IO写到backing disk上</p>
<p>如果没有脏数据，则直接写到backing disk上，这也就是为什么当使用fio测试小于4KB的随机IO时，flashcache几乎没有效果。</p>
<p>部分参考资料：</p>
<p><a href="http://mogu.io/Facebook_flashcache-81" target="_blank" rel="external">Facebook flashcache介绍与使用</a></p>
<p><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/flashcache-introduction?lang=en" target="_blank" rel="external">flashcache 简介</a></p>
<p><a href="http://blog.csdn.net/kidd_3/article/category/905673" target="_blank" rel="external">其他flashcache资料</a></p>
<h2 id="cache-tier"><a href="#cache-tier" class="headerlink" title="cache tier"></a>cache tier</h2><p>缓存分层通过将一部分数据存到缓存层，给ceph客户端提供更好的IO性能。通常是在更快的磁盘上创建存储池，如SSD/NVMe。数据最终被透明的写入常规的存储池中，它们由副本或纠删码类型的存储池所构建。</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/cache%20tier.png" alt="cache tier"></p>
<p>缓存层代理自动处理缓存层和后端存储之间的数据迁移，对客户端透明，管理员可以配置迁移进行的方式。</p>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>缓存分层主要有两种模式：writeback 和 read-only。如果是write-back模式，那么该cache pool 既是read tier ，又是 write tier； 如果只是read only 模式，那么实际上，cache pool 只是 read tier，没有write tier。</p>
<h3 id="writeback模式"><a href="#writeback模式" class="headerlink" title="writeback模式"></a>writeback模式</h3><p>客户端写数据到缓存层后立刻收到确认回复。基于配置的flush/evict策略，数据从缓存层迁移到存储层，最后缓存分层代理从缓存层中将数据删除。</p>
<p>当读操作在缓存中miss的时候</p>
<p>1、返回client结果为cache miss，重新向存储层发起读请求。</p>
<p>2、cache层向存储层发起读请求，返回client的同时缓存一份在cache层</p>
<p>写操作在缓存中miss的时候</p>
<p>直接向存储层写，然后逐级返回，并不将数据缓存在cache层</p>
<p>这种模式适合大量修改数据的场景。</p>
<h3 id="read-only模式"><a href="#read-only模式" class="headerlink" title="read-only模式"></a>read-only模式</h3><p>缓存层只服务于客户端的读操作。当读请求在缓存层中miss的时候，从存储层中读上来，并设置一个expire时间，过期自动被删除。cache层可以设置为单副本，极大减少缓存空间占用率。写操作直接写到后端的存储层。</p>
<p>这种模式适合一次写入多次读取的场景。</p>
<h2 id="Flashcache-vs-Cache-tier"><a href="#Flashcache-vs-Cache-tier" class="headerlink" title="Flashcache vs Cache tier"></a>Flashcache vs Cache tier</h2><p>flashcache将缓存在块层的东西，而缓存池将缓存对象层的东西。 在每种情况下都有潜在的优点和缺点。 一些初始猜测：</p>
<p><strong>flashcache</strong></p>
<ul>
<li>[x] 所有缓存对一个节点是本地的，更少的开销（包括网络）。</li>
<li>[x] 在许多对象访问和大量热的inodes / dentries的情况下可以做得更好</li>
<li>无法仅为高速缓存定义不同的 副本/ EC 策略。</li>
<li>缓存写入是非原子的</li>
</ul>
<p><strong>Ceph cache tier</strong></p>
<ul>
<li>[x] 潜在可以做的事情，如副本缓存和EC存冷数据。</li>
<li>[x] 更安全</li>
<li>更多的网络开销，可能会有更多的CPU开销。</li>
<li>需要更长的时间才能将内容缓存</li>
</ul>
<p>参考资料：<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2014-March/037861.html" target="_blank" rel="external"> OSD + FlashCache vs. Cache Pool for RBD</a></p>
<p><strong>关于成本</strong></p>
<p>高速缓存中的数据总是硬盘驱动器上的数据的第二个副本。 缓存的故障很少产生数据丢失，只是性能损失，因为一切都需要从机械驱动器提供，直到缓存可以被替换。</p>
<p> SSD层可能是自动分层系统中唯一的数据副本，不能容忍SSD层的故障，因此这些系统必须通过使用类似RAID的数据保护方案在冗余配置中设置SSD层。 不得不购买额外的SSD来支持类似RAID的功能，使已经高价的技术更加昂贵。</p>
<p><strong>关于读</strong></p>
<p>在大多数情况下，两个选项之间的read 性能应该大致相同。 大多数情况下，read 性能的效率将取决于缓存设备提升数据的效率和可定制性。 目标应该是确保正确的数据在正确的时间存在缓存中。缓存和自动分层需要在关于他们缓存什么和什么时候缓存需要变得更加聪明。</p>
<p><strong>终上所述</strong></p>
<p>从用户的角度来看，如果适当的冗余存在，缓存或分层没有显着的优势，因此不应该单独选择基于闪存的存储系统。 IT规划人员可能想要调查其他因素，例如将某些数据集固定到闪存层或缓存区，以及与环境或应用程序集成的能力。</p>
<p>参考资料：（这两篇文章是同一个作者）</p>
<p><a href="http://www.networkcomputing.com/storage/ssd-options-tier-vs-cache/1267262167" target="_blank" rel="external">SSD Options: Tier Vs. Cache</a></p>
<p><a href="http://searchsolidstatestorage.techtarget.com/tip/Tiering-vs-caching-in-flash-based-storage-systems" target="_blank" rel="external">Tiering vs. caching in flash-based storage systems</a></p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 

]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——parted]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94parted/</url>
      <content type="html"><![CDATA[<p>一直用parted命令来进行磁盘分区，这里学习一下总结一下。顺带对比一下MBR和GPT两种分区表，以及parted命令和fdisk命令的区别。<br><a id="more"></a></p>
<h2 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h2><p>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区（包含随意数目的逻辑分区）。</p>
<p>GPT：GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。GPT的分区信息是在分区中，而MBR在主引导扇区。</p>
<p>与MBR分区方式相比，具有如下优点：</p>
<ul>
<li>突破MBR 4个主分区限制，每个磁盘最多支持128个主分区。</li>
<li>支持大于2T的分区，最大卷可达18EB。</li>
</ul>
<h2 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h2><ul>
<li><strong>主分区</strong>又叫主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘。一个硬盘的主分区也就是包含操作系统启动所必需的文件和数据的硬盘分区，要在硬盘上安装操作系统，则该硬盘必须得有一个主分区。</li>
<li><strong>扩展分区</strong>不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。</li>
<li><strong>逻辑分区</strong>也相当于一个逻辑磁盘，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中。</li>
</ul>
<p>MBR模式分区只能划分四个分区，现在GPT分区至少可以划分128个主分区，未来很有可能将不存在扩展分区和逻辑分区的概念。</p>
<h2 id="parted和fdisk"><a href="#parted和fdisk" class="headerlink" title="parted和fdisk"></a>parted和fdisk</h2><p>parted命令可以划分单个分区大于2T的GPT格式的分区，也可以划分普通的MBR分区，并且允许调整分区的大小。</p>
<p>fdisk命令对于大于2T的分区无法划分，所以用fdisk无法看到parted划分的GPT格式的分区。</p>
<p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p>
<h2 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h2><p>Parted 命令分为两种模式：命令行模式和交互模式</p>
<p> 1、命令行模式：<code>parted [option] device [command]</code> ，该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用，比如利用脚本批量执行命令。</p>
<p> 2、交互模式：<code>parted [option] device</code>类似于使用<code>fdisk /dev/xxx</code>，这种适合当个操作。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><h4 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<p>parted有个不提示用户参数选项，就是通过这个选项来实现非交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-s, --script</div><div class="line">              never prompts for user intervention</div></pre></td></tr></table></figure>
<h4 id="2、添加分区"><a href="#2、添加分区" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb mklabel gpt			# 定义分区表格式</div><div class="line"># parted -s /dev/vdb mkpart primary ext4 1 10G		# 划分主分区</div><div class="line"># parted -s /dev/vdb mkpart logic 10G 20G		# 划分逻辑分区</div><div class="line"># parted -s /dev/vdb mkpart logic ext3 20G 40G</div><div class="line"># parted -s /dev/vdb mkpart entended 40G 100%		# 划分扩展分区，100%表示使用剩余所有空间</div><div class="line"></div><div class="line"># parted -s /dev/vdb p					# 查看分区详情</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          logic</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div><div class="line"> 4      40.0GB  107GB   67.4GB               entended</div></pre></td></tr></table></figure>
<p>查看分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">├─vdb2 253:18   0   9.3G  0 part </div><div class="line">├─vdb3 253:19   0  18.6G  0 part </div><div class="line">└─vdb4 253:18   0  62.8G  0 part</div></pre></td></tr></table></figure>
<h4 id="3、删除分区"><a href="#3、删除分区" class="headerlink" title="3、删除分区"></a>3、删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># parted -s /dev/vdb rm 2</div><div class="line"></div><div class="line"># parted -s /dev/vdb p</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name     Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</div><div class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</div></pre></td></tr></table></figure>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h4 id="1、初始状态-1"><a href="#1、初始状态-1" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk</div></pre></td></tr></table></figure>
<h4 id="2、添加分区-1"><a href="#2、添加分区-1" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><p>针对盘 vdb 开始分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># parted /dev/vdb</div><div class="line">GNU Parted 2.3</div><div class="line">Using /dev/vdb</div><div class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</div><div class="line">(parted)mklabel gpt 				# 定义分区表格式</div><div class="line">...</div><div class="line">(parted) mkpart p1      			# 创建第一个分区，名称为p1                                                  </div><div class="line">File system type?  [ext2]? ext4     		# 定义分区格式                                      </div><div class="line">Start? 1 					# 定义分区的起始位置（单位支持K,M,G,T）                                                              </div><div class="line">End? 10G      					# 定义分区的结束为止(单位支持K,M,G,T)                                                            </div><div class="line">(parted) print     				# 查看当前分区情况                                                       </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"></div><div class="line">(parted) mkpart part2                                                    </div><div class="line">File system type?  [ext2]? ext3                                           </div><div class="line">Start? 10G                                                                </div><div class="line">End? 20G                                                                  </div><div class="line">(parted) p					# print可以简写成“p“                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB               p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB               part2</div><div class="line"></div><div class="line">(parted) quit					# 退出。quit可以简写为”q“ </div><div class="line">Information: You may need to update /etc/fstab.</div></pre></td></tr></table></figure>
<h4 id="3、设置文件系统"><a href="#3、设置文件系统" class="headerlink" title="3、设置文件系统"></a>3、设置文件系统</h4><p>不知道为啥，print的时候不现实文件系统格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># mkfs.ext4 /dev/vdb1</div><div class="line"># mkfs.xfs /dev/vdb2</div></pre></td></tr></table></figure>
<p>再查看文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(parted) print                                                            </div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name   Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div><div class="line"> 2      10.0GB  20.0GB  9999MB  xfs          part2</div></pre></td></tr></table></figure>
<p>发现分区的 File system 变成了 ext4 和 xfs。所以，还是通过命令的方式来定义文件系统格式。</p>
<p>查看一下分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># lsblk</div><div class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</div><div class="line">sr0     11:0    1   436K  0 rom  </div><div class="line">vda    253:0    0    20G  0 disk </div><div class="line">├─vda1 253:1    0     2M  0 part </div><div class="line">├─vda2 253:2    0   476M  0 part /boot</div><div class="line">└─vda3 253:3    0  19.5G  0 part /</div><div class="line">vdb    253:16   0   100G  0 disk </div><div class="line">├─vdb1 253:17   0   9.3G  0 part </div><div class="line">└─vdb2 253:18   0   9.3G  0 part</div></pre></td></tr></table></figure>
<h4 id="4、删除分区"><a href="#4、删除分区" class="headerlink" title="4、删除分区"></a>4、删除分区</h4><p>删除分区 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(parted) rm                                                             </div><div class="line">Partition number? 2  </div><div class="line"></div><div class="line"># 或者直接</div><div class="line">(parted) rm 2    </div><div class="line"></div><div class="line">(parted) print</div><div class="line">Model: Virtio Block Device (virtblk)</div><div class="line">Disk /dev/vdb: 107GB</div><div class="line">Sector size (logical/physical): 512B/512B</div><div class="line">Partition Table: gpt</div><div class="line"></div><div class="line">Number  Start   End     Size    File system  Name  Flags</div><div class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</div></pre></td></tr></table></figure>
<h4 id="5、修改分区大小"><a href="#5、修改分区大小" class="headerlink" title="5、修改分区大小"></a>5、修改分区大小</h4><p>暂时不支持改变分区的大小（resize操作），针对有无文件系统报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># none</div><div class="line">Error: Could not detect file system.  </div><div class="line"></div><div class="line"># ext4，ext3</div><div class="line">Error: File system has an incompatible feature enabled.  Compatible       </div><div class="line">features are has_journal, dir_index, filetype, sparse_super and large_file.</div><div class="line">Use tune2fs or debugfs to remove features.</div><div class="line"></div><div class="line"># xfs</div><div class="line">No Implementation: Support for opening xfs file systems is not implemented</div><div class="line">yet.</div></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[认识SSD]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/%E8%AE%A4%E8%AF%86SSD/</url>
      <content type="html"><![CDATA[<p>SSD越来越火，性能提升比较快，成本也有所下降，是未来的方向和主流，这里认识和学习一下SSD相关知识，以便更好的理解和应用SSD的特性。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>固态硬盘（Solid State Disk）用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。<br>一块SSD，<strong>核心部件</strong>是一颗控制器和多颗Flash颗粒，一般还会有一些内存和超级电容。</p>
<pre><code>--&gt;控制器主要作用是提供高效的手段来访问这些Flash颗粒。
--&gt;内存的作用主要是表项管理和读写CACHE。
--&gt;超级电容的作用是在异常下电时保证关键数据不丢失。
</code></pre><p>而<strong>Flash颗粒</strong>是SSD最重要的器件，其相关特性决定了SSD的实现方式。</p>
<h2 id="FLASH颗粒"><a href="#FLASH颗粒" class="headerlink" title="FLASH颗粒"></a>FLASH颗粒</h2><h3 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h3><blockquote>
<p>闪存是一种不挥发性（ Non-Volatile ）内存，在没有电流供应的条件下也能够长久地保持数据，其存储特性相当于硬盘，这项特性正是闪存得以成为各类便携型数字设备的存储介质的基础。</p>
</blockquote>
<p>Flash颗粒是SSD最重要的器件，其相关特性决定了SSD的实现方式。目前业界主要有两种类型的Flash技术：NOR（Intel开发）和NAND（东芝开发）。由于这两种技术在如下方面的一些差异：</p>
<pre><code>--&gt;NOR的读取速度略快于NAND；
--&gt;NOR的写入速度远低于NAND；
--&gt;NOR的擦除速度远低于NAND；
--&gt;的擦写次数约为NAND的1/10；
--&gt;的单元尺寸约为NAND的2倍；
</code></pre><p>导致1~16M的闪存市场主要采用NOR颗粒（主要用于保存嵌入式设备的程序），而<strong>更大容量的数据存储（例如SSD）则主要选择NAND颗粒</strong>。</p>
<h3 id="SLC和MLC"><a href="#SLC和MLC" class="headerlink" title="SLC和MLC"></a>SLC和MLC</h3><p>NAND FLASH芯片，flash颗粒有两种类型：SLC和MLC</p>
<p>SLC：Single Level Cell，每个存储单元均只能存储1个bit的数据。只包含0和1两个电压符。<br>MLC：Multi Level Cell，每个存储单元能够存储2个bit或者更多bit的数据。包含四个电压符（00,01,10,11）。</p>
<p><strong>SLC和MLC的比较：</strong><br>MLC容量比SLC大，且价格便宜。<br>但在性能、使用寿命和稳定性上：<br>1、SLC更简单可靠；<br>2、SLC读取和写入的速度都比MLC更快；<br>3、SLC比MLC更耐用，MLC每单元可擦除1w次，而SLC可擦除10w次。</p>
<p>一般而言，<strong>SLC主要用于企业级市场</strong>，MLC主要用于消费级市场。下表显示了SLC和MLC两种Flash颗粒的一些性能指标：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>SLC</th>
<th>MLC</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机读</td>
<td>25us</td>
<td>50us</td>
</tr>
<tr>
<td>擦除</td>
<td>2ms</td>
<td>2ms</td>
</tr>
<tr>
<td>编程</td>
<td>250us</td>
<td>900us</td>
</tr>
<tr>
<td>擦除次数</td>
<td>100k</td>
<td>10k</td>
</tr>
</tbody>
</table>
<h2 id="SSD的内部逻辑划分"><a href="#SSD的内部逻辑划分" class="headerlink" title="SSD的内部逻辑划分"></a>SSD的内部逻辑划分</h2><p>一颗NAND Flash颗粒，其内部被划分为若干block，每个block又包含若干page。page的大小一般为2k/4k/8k（同一颗Flash颗粒内的page大小是固定且相同的）。</p>
<p>Flash的一个特点是：不能对任意bit位进行0/1互转，只能按照一定的颗粒度进行擦除和编程操作；</p>
<pre><code>--&gt;擦除 —— 颗粒度为block，是将指定block中所有的bit位全部设置为1；
--&gt;编程 —— 颗粒度为page，是将指定page中指定的bit位设置为0；
</code></pre><p>因此，对SSD进行写的操作实际上对需要写的Page所在的Block全部完成“擦除”(全部bit位置1)后，才能对指定的Page进行“编程”(部分bit位置0)。PS：实际上SSD硬盘在出厂时，厂商都会把所有Block完成擦除操作。</p>
<h2 id="SSD的表项管理"><a href="#SSD的表项管理" class="headerlink" title="SSD的表项管理"></a>SSD的表项管理</h2><p>  每一个IO读写都是下发给一个地址，这个地址称为LBA(Logic Block Address)，其真正对应在磁盘上的地址称为PBA(Physical Block Address)，和传统机械硬盘中LBA到PBA的映射通过磁轨、磁道、扇区来进行唯一对应不同的是，<strong>SSD的LBA到PBA</strong>的映射通过一张<strong>映射表</strong>来记录。<br>&emsp;&emsp;LBA的粒度是扇区，而Flash颗粒的擦粒度是block，写粒度是page，均为扇区的若干倍，在这种条件下，如果仍以扇区为粒度进行映射，虽然理论上可行，但是显然是增加实现难度和性能的.<br>&emsp;&emsp;同时，如果强制以扇区为粒度进行映射，会导致所需要的映射表空间超过物理内存的限制，这就直接决定了不可能以扇区为粒度进行映射。<br>&emsp;&emsp;即使以page为粒度进行映射，也可能存在物理内存不够用的情况（现在正在使用的SSD盘即属于这种情况），所以需要以更大一些的粒度进行管理。<br>&emsp;&emsp;这个粒度成为”<strong>小块(Sub Block)</strong>“,是SSD进行擦除和编程的最小单位。每个block中，均包含多个sub block；每个sub block，由多个page组成；每个sub block，可能的状态包括：有效、垃圾、空白：</p>
<pre><code>--&gt;有效：该小块中的数据正在被引用；
--&gt;垃圾：该小块中的数据没有被引用；
--&gt;空白：该小块可用于写入新的数据；
</code></pre><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>&emsp;&emsp;SSD的写要先进行整个Block的擦除，然后才能对指定的Sub Block进行编程。实际上，如果某一个写操作需要修改一个Sub Block的内容，是无法直接进行修改的，而是写到一个新的Sub Block中，把该LBA的映射指向新的这个Sub Block，同时把原来数据所在的Sub Block标记为“垃圾”。<br>  这样，随着SSD使用时间的越来越长，新的未被编程过的Sub Block越来越少，后面新的写请求则只能重新擦除所有Sub Block均为垃圾的Block才能再次写入，这样必然会造成写操作的性能降低，因此，在SSD内部引入了一个重要的机制——垃圾回收（Garbage Collection），用以提升SSD长期写入操作的性能。</p>
<p><strong>垃圾回收的工作：</strong></p>
<pre><code>--&gt;找出合适的block
--&gt;将该block中的有效小块迁移到别的地方，同时更改映射表
--&gt;将该block擦除，并放入空白块表
</code></pre><p>&emsp;&emsp;所谓“最合适进行回收的block”，是指这个block的垃圾小块足够多、有效/空白小块足够少。<br>&emsp;&emsp;垃圾回收算法是否高效，与该SSD的性能有很强的联系。</p>
<h2 id="SSD的磨损均衡"><a href="#SSD的磨损均衡" class="headerlink" title="SSD的磨损均衡"></a>SSD的磨损均衡</h2><p>  上面说过，每个Flash颗粒中Block的可擦除次数是有限制的，如果颗粒中的某些Block很快达到了擦除次数上限，而其他大部分都几乎没有被擦除过，则会很快的造成整个SSD失效。而磨损均衡（Wear Leveling）则是通过各种手段，保证整个SSD所有的block的擦除次数是相近的从而延长SSD的使用寿命。</p>
<p>磨损均衡分为  <strong>动态磨损均衡</strong>  和  <strong>静态磨损均衡</strong>：</p>
<blockquote>
<p>动态磨损均衡，是指在外部力量的驱动下，自然完成磨损均衡。这里外部力量，包括写IO和垃圾回收。<br>静态磨损均衡，是指磨损均衡功能模块主动地查找那些长时间没有变化的数据，将这些数据搬移到其他位置，以便释放出擦除次数较少的block，使其投入到擦除/编程的循环之中。</p>
</blockquote>
<h2 id="SSD使用寿命计算举例"><a href="#SSD使用寿命计算举例" class="headerlink" title="SSD使用寿命计算举例"></a>SSD使用寿命计算举例</h2><p>&emsp;&emsp;虽然一个block擦写次数只有100k（SLC），但是因为动态映射、磨损均衡等机制的存在，使得SSD的寿命远不止写入100k个IO。<br>计算SSD寿命的方式，一般是先确认一个block在其生命周期内能够写入多少数据量，再乘以该SSD具有的block数量，再除以一个估计的写入带宽，最后得到寿命值。<br>&emsp;&emsp;以我司（<strong>你们猜o(^▽^)o</strong>）自研的100G SLC SSD为例，16片Flash颗粒，每片颗粒拥有32k个block，每个block拥有64个4k的page，每个block可以被擦除100k次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">16 x (32 x 1024) x 64 x (4 x 1024) x 100000 = 12500 TB</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;12500 TB，这是当所有block同时达到擦除次数上限时，可以写入的数据总量。<br>按照用户平均每秒钟写入10MB的数据进行计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(12500 x 1024 x 1024) / (10 x 60 x 60 x 24 x 365.25) = 41.5 年</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;41.5年，这是在10MB/s的压力下、持续不断地向SSD写入数据的使用寿命。<br>&emsp;&emsp;考虑到其他一些因素的影响，一块SLC SSD的使用寿命，10年是可以保证的。</p>
<h2 id="SSD和传统磁盘的对比"><a href="#SSD和传统磁盘的对比" class="headerlink" title="SSD和传统磁盘的对比"></a>SSD和传统磁盘的对比</h2><p>&emsp;&emsp;SSD与传统磁盘相比:<br>&emsp;&emsp;第一是没有机械装置;<br>&emsp;&emsp;第二是由磁介质改为了电介质。<br>&emsp;&emsp;在SSD内部有一个FTL(Flash Transalation Layer)，它相当于磁盘中的控制器，主要功能就是作地址映射，将flash memory的物理地址映射为磁盘的LBA逻辑地址，并提供给OS作透明访问。</p>
<h3 id="读方面"><a href="#读方面" class="headerlink" title="读方面"></a>读方面</h3><p><strong>随机读</strong><br>  SSD没有传统磁盘的寻道时间和延迟时间，所以SSD可以提供非常高的随机读取能力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<p><strong>连续读</strong><br>  SSD连续读的能力相比普通磁盘优势并不明显。传统磁盘连续读，并不需要寻道时间：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<h3 id="写方面"><a href="#写方面" class="headerlink" title="写方面"></a>写方面</h3><p>  Page为最小的读写单位，Block为最小的擦除/编程单位，其中1个Page为4KB，1个Block由256个Page组成，1个Plane由2048个Block组成，2个Plane组成1个Die，也就是最小的芯片(4GB)</p>
<p>&emsp;&emsp;向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元（page）的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入。SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。因为这个特性，引入<strong>“写放大”</strong>的概念。</p>
<p>&emsp;&emsp;比如你想改写4K的数据，必须首先将整个擦除块（1024KB）中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了1024KB的数据，写入放大系数是256。写入放大最好的情况是1，就是不存在放大的情况。</p>
<p>&emsp;&emsp;在<strong>长时间写入</strong>后，MLC随机写IO下降得非常厉害，而<strong>SLC表现则比较稳定</strong>，可以稳定在3000 IOPS，而MLC随机写IOPS甚至降低到300。</p>
<p>&emsp;&emsp;当某个单元长时间被反复擦写时（比如Oracle redo），不仅会造成写入的性能问题，而且会大大缩短SSD的使用寿命。所以，引入磨损均衡算法（wear leveling）。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力<br>！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph — V11.2.0 KRAKEN(译)]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/Ceph-KRAKEN(V11.2.0)/</url>
      <content type="html"><![CDATA[<p>ceph的版本出到K了，针对bluestore又有了新的优化，并进行了一定的压力和故障测试，当然还有其他的特性，针对Jewel版本有较多改动。当前还没有什么中文资料，<a href="http://docs.ceph.org.cn/" target="_blank" rel="external">ceph中文社区</a>中关于V11.2.0还没有更新进去，所以闲暇之余翻译了一下，也给大家节省时间。<br><a id="more"></a></p>
<p>英文原文链接：<a href="http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken" target="_blank" rel="external">http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken</a></p>
<h2 id="V11-2-0-KRAKEN"><a href="#V11-2-0-KRAKEN" class="headerlink" title="V11.2.0 KRAKEN"></a>V11.2.0 KRAKEN</h2><p>这是Kraken系列的第一个release版本。它适用于生产部署，并将维护到下一个稳定的版本Luminous，将在2017年春季完成。</p>
<h2 id="对比JEWEL版本的主要变化"><a href="#对比JEWEL版本的主要变化" class="headerlink" title="对比JEWEL版本的主要变化"></a>对比JEWEL版本的主要变化</h2><h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><ul>
<li>新的BlueStore 后端现在有一个稳定的磁盘格式，并通过了我们的故障和压力测试。尽管该后端仍被标记为实验性的，但我们鼓励用户使用非生产集群和非关键数据集进行尝试。</li>
<li>RADOS现在已经对EC-pool上的覆盖写（overwrites）进行了实验性支持。因为磁盘格式和实现尚未完成，所以必须启用特殊pool选项才能测试新功能。在群集上启用此选项将永久禁止该群集升级到将来的版本。</li>
<li>我们现在默认使用AsyncMessenger（ms type = async）而不是传统的SimpleMessenger。最明显的区别是，我们现在使用固定大小的线程池用于网络连接（而不是使用SimpleMessenger的每个套接字两个线程）。</li>
<li>现在一些OSD的故障几乎可以立即检测到，而先前心跳超时（默认为20秒）必须到期。这可以防止IO在主机保持启动但ceph-osd进程不再运行的故障情况下长时间阻塞。</li>
<li>有一个新的ceph-mgr守护进程。它目前与默认监视器并置，并且尚未使用太多，但基本的基础设施现在已到位。</li>
<li>减少了编码OSDMaps的大小。</li>
<li>当恢复（recovery）或重新平衡（rebalanceing）正在进行时，OSD现在停止擦除（scrubbing）。</li>
</ul>
<h3 id="RGW"><a href="#RGW" class="headerlink" title="RGW"></a>RGW</h3><ul>
<li>RGW现在支持一种新的区域类型，可用于通过ElasticSearch进行元数据索引。</li>
<li>RGW现在支持S3复合对象复制部分API。</li>
<li>现在可以重新分割现有的桶。注意，桶重新分片目前需要停止对特定桶的所有IO（特别是写）。</li>
<li>RGW现在支持对象的数据压缩。</li>
<li>Civetweb版本已经升级到1.8。</li>
<li>现在支持Swift静态网站API（以前已经添加了S3支持）。</li>
<li>S3桶生命周期API已添加。注意，目前它只支持对象到期。</li>
<li>支持自定义搜索过滤器已添加到LDAP身份验证实现中。</li>
<li>支持NFS版本3已添加到RGW NFS网关。</li>
<li>为librgw创建了一个Python绑定。</li>
</ul>
<h3 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h3><ul>
<li>RBD现在支持使用新的(实验)覆盖写(overwrite)支持在 EC RADOS pool 中存储images。必须使用新的rbd CLI <code>“-data-pool &lt;ec pool&gt;”</code> 选项来创建images，用以指定EC池存储后端数据对象。尝试在EC池上直接创建image不会成功，因为image的后端元数据仅在副本池上被支持。</li>
<li>rbd-mirror守护进程现在支持从主image复制动态image特征更新和image元数据key/value对到非主image。</li>
<li>image快照的数量可以选择性地限制为可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<h3 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h3><ul>
<li>libcephfs函数的定义已更改为启用适当的uid / gid控制。库版本已增加以反映接口更改。</li>
<li>备用的回放(replay)MDS守护程序现在在执行删除操作的工作负载上消耗更少的内存。</li>
<li>Scrub现在修复backtrace，并用已发现的错误填充损坏ls。</li>
<li>cephfs-data-scan的新的pg_files子命令可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性“未能响应缓存压力”警告已修复。</li>
</ul>
<h2 id="UPGRADING-FROM-JEWEL"><a href="#UPGRADING-FROM-JEWEL" class="headerlink" title="UPGRADING FROM JEWEL"></a>UPGRADING FROM JEWEL</h2><ul>
<li>所有集群必须首先升级到 Jewel 10.2.z，然后升级到 Kraken 11.2.z（或者，最终，Luminous 12.2.z）。</li>
<li>升级到Kraken之前，必须在Jewel集群上设置sortbitwise标志。如果未设置标志，则最新的Jewel（10.2.4+）版本会发出健康警告，因此可能已设置。如果不是，Kraken OSDs将拒绝启动，并将在其日志中打印和错误消息。</li>
<li>您可以按任意顺序升级OSD，监视器和MDS。 RGW守护进程应该最后升级。</li>
<li>升级时，新的ceph-mgr守护进程实例将自动被创建，与任何监视器一起。在Jewel到Kraken和Jewel到Luminous的升级中这将是事实，但在未来高于Luminous版本的升级中可能不是这样。如果你不与他们共置ceph-mon守护进程的话，你当然可以自由创建新的ceph-mgr守护进程实例，并销毁自动创建的实例。</li>
</ul>
<h2 id="BLUESTORE"><a href="#BLUESTORE" class="headerlink" title="BLUESTORE"></a>BLUESTORE</h2><p>BlueStore是一个新的后端，用于管理直接硬盘或SSD上每个OSD存储的数据。与现有的FileStore实现（它利用XFS文件系统将对象存储为文件）不同，BlueStore直接管理底层块设备。实现它自己的文件系统类磁盘结构，专为Ceph OSD工作负载而设计。 BlueStore的主要特点包括：</p>
<ul>
<li>默认情况下启用写入磁盘的所有数据的校验和，所有读取的校验和验证。</li>
<li>内联压缩支持，可以分别通过池属性或客户端提示在每个池或每个对象的基础上启用。</li>
<li>高效日记。与将所有数据写入其日志设备的FileStore不同，BlueStore仅记录元数据和（在某些情况下）小型写入，从而减少其日志的大小和吞吐量要求。与文件存储一样，日志可以与其他数据共存在同一设备上，或者分配在较小的高性能设备（例如，SSD或NVMe设备）上。 BlueStore日志默认只有512 MB。</li>
</ul>
<p>BlueStore磁盘格式预计将继续发展。但是，我们将在OSD中提供支持，以便在升级时迁移到新格式。</p>
<p>为了启用BlueStore，将以下内容添加到ceph.conf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable experimental unrecoverable data corrupting features = bluestore</div></pre></td></tr></table></figure>
<p>要创建一个BlueStore OSD，在OSD创建期间将-bluestore选项传递给ceph-disk或ceph-deploy。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Crushmap学习]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/Crushmap%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>介绍了ceph中crush的优点、原理及作用，同时dump出自己的crushmap内容，进行详细的分解学习。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着大规模分布式存储系统的出现。这些系统必须平衡的分布数据和负载，最大化系统的性能，并要处理系统的扩展和硬件失效。但是简单HASH分布不能有效处理设备数量的变化，导致大量数据迁移。ceph设计了CRUSH，用在分布式对象存储系统上，可以有效映射数据对象到存储设备上(不需要中心设备)。因为大型系统的结构式动态变化的，CRUSH能够处理存储设备的添加和移除，并最小化由于存储设备的的添加和移动而导致的数据迁移。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CRUSH算法，全称 Controlled Replication Under Scalable Hashing。它是一种伪随机的算法，在相同的环境下，它能够在层级结构的存储集群中有效的分布对象的副本。</p>
<p>CRUSH实现了一种伪随机(确定性)的函数，它的参数是object id或object group id，并返回一组存储设备(用于保存object副本)。相似的输入得到的结果之间没有相关性，相同的输入得到的结果是确定的。</p>
<p>CRUSH需要cluster map(描述存储集群的层级结构)、和副本分布策略(rule)就可以根据一个整型的输入得到存放数据的一个设备列表。</p>
<p>CRUSH有两个关键优点：</p>
<ul>
<li>任何组件都可以独立计算出每个object所在的位置(去中心化)。</li>
<li>只需要很少的元数据(cluster map)，只要当删除添加设备时，这些元数据才需要改变。</li>
</ul>
<h2 id="crush的作用"><a href="#crush的作用" class="headerlink" title="crush的作用"></a>crush的作用</h2><p>传统存储的架构体系需要一个MDC（meta data controll），ceph不使用这种架构，而是通过引入CRUSH算法，将数据分布的查询操作变成了计算操作，并且是在client端完成。同时，Crush算法还有效缓解了普通hash算法在处理存储设备增删时带来的数据迁移问题。</p>
<p>ceph允许客户端直接访问OSD守护进程，从而消除集中式查询元数据中心的需求。ceph使用一个monitor集群来保证系统的高可用性。同时采用crush算法来实现去中心化，使用crush算法后，客户端根据需要来计算数据被写到哪里，以及从哪读数据。</p>
<p><strong>ceph集群的一个写操作流程</strong></p>
<p>1、client首先访问ceph monitor获取cluster map的一份副本，共五个map（monitor map，OSD map，MDS map，CRUSH map，PG map），知晓集群的状态和配置；</p>
<p>2、数据被转化为一个或多个对象，每个对象都具有对象名称和存储池名称；</p>
<p>3、以PG数为基数做hash，将对象映射到一个PG钟；</p>
<p>4、根据计算出的PG，再通过CRUSH算法得到存放数据的一组OSD位置（副本个数），第一个是主，后面是从；</p>
<p>5、客户端获得OSD ID，直接和这些OSD通信并存放数据。</p>
<p><strong>注</strong>：所有的这些操作都是在<strong>客户端</strong>完成的，不会影响ceph集群服务器端的性能。</p>
<p><strong>一句话描述</strong></p>
<p>说了半天，一句话说明CRUSH的作用，就是——<strong>根据PG ID得到一个OSD列表</strong>。</p>
<h2 id="crush的工作形式"><a href="#crush的工作形式" class="headerlink" title="crush的工作形式"></a>crush的工作形式</h2><p>CRUSH是基于一张描述当前集群资源状态的map（Crush map）按照一定的规则（rules）得到这个OSD列表的。Ceph将系统的所有硬件资源描述成一个树状结构，然后再基于这个结构按照一定的容错规则生成一个逻辑上的树形结构作为Crush map。数的叶子节点是OSD。</p>
<h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><p>三个节点（ceph1，ceph2，ceph3），每个节点三个OSD，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ceph osd tree</div><div class="line">ID WEIGHT  TYPE NAME      UP/DOWN REWEIGHT PRIMARY-AFFINITY </div><div class="line">-1 1.36345 root default                                     </div><div class="line">-2 0.45448     host ceph1                                   </div><div class="line"> 0 0.09090         osd.0       up  1.00000          1.00000 </div><div class="line"> 1 0.18179         osd.1       up  1.00000          1.00000 </div><div class="line"> 2 0.18179         osd.2       up  1.00000          1.00000 </div><div class="line">-3 0.45448     host ceph2                                   </div><div class="line"> 3 0.09090         osd.3       up  1.00000          1.00000 </div><div class="line"> 4 0.18179         osd.4       up  1.00000          1.00000 </div><div class="line"> 5 0.18179         osd.5       up  1.00000          1.00000 </div><div class="line">-4 0.45448     host ceph3                                   </div><div class="line"> 6 0.09090         osd.6       up  1.00000          1.00000 </div><div class="line"> 7 0.18179         osd.7       up  1.00000          1.00000 </div><div class="line"> 8 0.18179         osd.8       up  1.00000          1.00000</div></pre></td></tr></table></figure>
<h3 id="crushmap内容"><a href="#crushmap内容" class="headerlink" title="crushmap内容"></a>crushmap内容</h3><p>来看一下crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"># begin crush map</div><div class="line">tunable choose_local_tries 0</div><div class="line">tunable choose_local_fallback_tries 0</div><div class="line">tunable choose_total_tries 50</div><div class="line">tunable chooseleaf_descend_once 1</div><div class="line">tunable chooseleaf_vary_r 1</div><div class="line">tunable straw_calc_version 1</div><div class="line"></div><div class="line"># devices</div><div class="line">device 0 osd.0</div><div class="line">device 1 osd.1</div><div class="line">device 2 osd.2</div><div class="line">device 3 osd.3</div><div class="line">device 4 osd.4</div><div class="line">device 5 osd.5</div><div class="line">device 6 osd.6</div><div class="line">device 7 osd.7</div><div class="line">device 8 osd.8</div><div class="line"></div><div class="line"># types</div><div class="line">type 0 osd</div><div class="line">type 1 host</div><div class="line">type 2 chassis</div><div class="line">type 3 rack</div><div class="line">type 4 row</div><div class="line">type 5 pdu</div><div class="line">type 6 pod</div><div class="line">type 7 room</div><div class="line">type 8 datacenter</div><div class="line">type 9 region</div><div class="line">type 10 root</div><div class="line"></div><div class="line"># buckets</div><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph2 &#123;</div><div class="line">	id -3		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.3 weight 0.091</div><div class="line">	item osd.4 weight 0.182</div><div class="line">	item osd.5 weight 0.182</div><div class="line">&#125;</div><div class="line">host ceph3 &#123;</div><div class="line">	id -4		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.6 weight 0.091</div><div class="line">	item osd.7 weight 0.182</div><div class="line">	item osd.8 weight 0.182</div><div class="line">&#125;</div><div class="line">root default &#123;</div><div class="line">	id -1		# do not change unnecessarily</div><div class="line">	# weight 1.363</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item ceph1 weight 0.454</div><div class="line">	item ceph2 weight 0.454</div><div class="line">	item ceph3 weight 0.454</div><div class="line">&#125;</div><div class="line"></div><div class="line"># rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div><div class="line"></div><div class="line"># end crush map</div></pre></td></tr></table></figure>
<h3 id="begin-crush-map"><a href="#begin-crush-map" class="headerlink" title="begin crush map"></a>begin crush map</h3><p>配置参数</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>列出集群的OSD设备</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p>表示buckets的类型 <img src="http://ojet8bprn.bkt.clouddn.com/osdmap.png" alt="osdmap"></p>
<h3 id="Buckets"><a href="#Buckets" class="headerlink" title="Buckets"></a>Buckets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">host ceph1 &#123;</div><div class="line">	id -2		# do not change unnecessarily</div><div class="line">	# weight 0.454</div><div class="line">	alg straw</div><div class="line">	hash 0	# rjenkins1</div><div class="line">	item osd.0 weight 0.091</div><div class="line">	item osd.1 weight 0.182</div><div class="line">	item osd.2 weight 0.182</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的定义是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[bucket-type] [bucket-name] &#123;</div><div class="line">  	id 		[a unique negative numeric ID]</div><div class="line">  	weight	[the relative capacity the item]</div><div class="line">  	alg		[the bucket type: uniform | list | tree | straw | straw2]</div><div class="line">  	hash	[the hash type: 0 by default]</div><div class="line">  	item	[item-name]		weight		[weight]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Bucket-type: bucket的类型，用来指定OSD在CRUSH分层结构中的位置</p>
<p>bucket-name：唯一的bucket名称</p>
<p>id：唯一的ID，用一个负整数表示</p>
<p>weight：OSD的权重，权重越高，说明它的物理存储容量越大。建议1TB存储设备的权重为1.00，500G的权重为0.50。当然这是一个相对值。</p>
<p>alg：bucket类型的算法选择</p>
<blockquote>
<p>见最后bucket的类型</p>
</blockquote>
<p>hash：每个bucket都具有hash算法。目前ceph支持jrenkins1算法，默认hash设置为0使用该算法。</p>
<p>item：bucket里包含的元素，即叶子bucket，及其权重。这里bucket为host，叶子为OSD。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rules</div><div class="line">rule replicated_ruleset &#123;</div><div class="line">	ruleset 0</div><div class="line">	type replicated</div><div class="line">	min_size 1</div><div class="line">	max_size 10</div><div class="line">	step take default</div><div class="line">	step chooseleaf firstn 0 type host</div><div class="line">	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rule [rulename] &#123;</div><div class="line">  	ruleset		[ruleset]</div><div class="line">  	type		[replicated | erasure]</div><div class="line">  	min_size	[min-size]</div><div class="line">  	max_size	[max-size]</div><div class="line">  	step take	[bucket-type]</div><div class="line">  	step		[choose | chooseleaf]	firstn	[num]	type	[bucket-type]</div><div class="line">  	step emit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rulename：定义的规则名称</p>
<p>ruleset：一个整数值，指定这条规则所属的规则集</p>
<p>min_size和max_size用来限定这个rule的使用范围，即当一个pool的副本数小于min_size或者大于max_size的时候不使用这个rule。</p>
<p>step take：选择一个bucket，然后从这个bucket开始往下遍历，找出OSD</p>
<p>choose是从bucket中找出若干个type类型的项</p>
<p>chooseleaf操作是bucket中选出若干个type类型的leaf节点</p>
<blockquote>
<p>如果在一台机器上部署3各OSD，这里就要将type后面的“host”改为“OSD”，否则一直是HEALTH_ERR，因为选择规则是在bucket（host）中选择3个host类型的leaf节点，显然你这里没有，改为OSD的话就刚好。</p>
</blockquote>
<p>firstn后面的数字，表示按照前面规则选出节点的个数。如果是0，就按照副本数选择，如果是正数，就按个数来，如果是负数，就按副本数＋负数得到的值来选。</p>
<p>step emit：它首先弹出当前值，并清空栈。它会被典型的应用于rule结尾，也可以用于组织同一条rule的不同树。</p>
<h2 id="Bucket的类型"><a href="#Bucket的类型" class="headerlink" title="Bucket的类型"></a>Bucket的类型</h2><p>Cluster map由device和bucket组成，它们都有id和权重值。Bucket可以包含任意数量item。item可以都是的devices或者都是buckets。管理员控制存储设备的权重。权重和存储设备的容量有关。Bucket的权重被定义为它所包含所有item的权重之和。CRUSH基于4种不同的bucket type，每种有不同的选择算法。</p>
<p>CRUSH映射算法解决了效率和扩展性这两个矛盾的目标。而且当存储集群发生变化时，可以最小化数据迁移，并重新恢复平衡分布。CRUSH定义了四种具有不同算法的的buckets。每种bucket基于不同的数据结构，并有不同的c(r,x)伪随机选择函数。</p>
<p>不同的bucket有不同的性能和特性：</p>
<ul>
<li>Uniform：适用于具有相同权重的item，而且bucket很少添加删除item。它的查找速度是最快的。</li>
<li>List：它的结构是链表结构，所包含的item可以具有任意的权重。CRUSH从表头开始查找副本的位置，它先得到表头item的权重Wh、剩余链表中所有item的权重之和Ws，然后根据hash(x, r, item)得到一个[0~1]的值v，假如这个值v在[0~Wh/Ws)之中，则副本在表头item中，并返回表头item的id。否者继续遍历剩余的链表。</li>
<li>Tree：链表的查找复杂度是O(n)，决策树的查找复杂度是O(log n)。item是决策树的叶子节点，决策树中的其他节点知道它左右子树的权重，节点的权重等于左右子树的权重之和。CRUSH从root节点开始查找副本的位置，它先得到节点的左子树的权重Wl，得到节点的权重Wn，然后根据hash(x, r, node_id)得到一个[0~1]的值v，假如这个值v在[0~Wl/Wn)中，则副本在左子树中，否者在右子树中。继续遍历节点，直到到达叶子节点。Tree Bucket的关键是当添加删除叶子节点时，决策树中的其他节点的node_id不变。决策树中节点的node_id的标识是根据对二叉树的中序遍历来决定的(node_id不等于item的id，也不等于节点的权重)。</li>
<li>Straw：这种类型让bucket所包含的所有item<strong>公平竞争</strong>(不像list和tree一样需要遍历)。这种算法就像抽签一样，所有的item都有机会被抽中(只有最长的签才能被抽中)。每个签的长度是由length = f(Wi)<em>hash(x, r, i) 决定的，f(Wi)和item的权重有关，i是item的id号。c(r, x) = MAXi(f(Wi) </em> hash(x, r, i))。</li>
<li><strong>Straw2</strong>：它是改进的straw bucket。它会在项目A和B的<strong>权重都没有改变时避免任何数据移动</strong>。例如，增加或删除一个项目C，改变它的权重，数据只会移动到它上面或者从它上面移动到其他地方，而不会在bucket内的其他项目之间出现数据移动。因此，该算法减少了集群发生改变后的数据移动量。这是目前使用最广的bucket类型。（《ceph cookbook》）</li>
</ul>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 


]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph中严重数据不一致性BUG]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/Ceph%E4%B8%AD%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7BUG/</url>
      <content type="html"><![CDATA[<p>目前，块存储服务是Ceph存储中被使用的最普遍的服务之一，通过块存储服务，可以向客户端以使用块设备一样访问Ceph集群。然而，目前在使用块存储服务时，尤其是OpenStack与Ceph对接时，如果没有严格的控制Ceph端的对象大小（使用 &gt;= 8MB对象时），将有可能导致严重的数据不一致情况，该异常由于XFS文件系统本身对Fiemap的支持特性导致的。<br><a id="more"></a></p>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>XFS使用fiemap时，当extents数量大于1364时，通过ioctl的FS_IOC_FIEMAP接口，获取的extents数量上限为1364，导致超出部分extents数据获取不到。这将导致，在开启fiemap时，Ceph集群进行recovery与backfill之后，产生大量数据不一致的情况，也是迄今为止Ceph中影响最大的，最严重的数据不一致BUG。</p>
<p>由于fiemap BUG，碎片化对象在recovery与backfill之后（fiemap 获取不正确的数据），从而使的恢复的对象数据与原对象数据不一致。而恢复后的副本若成为主副本，则可能发生静默读错误，并且如果使用Ceph策略自动修复对象（repair object之后），可能将错误数据覆盖至正确数据，数据将永远损毁。在某些情况下，还会触发对象永远处于inconsistent状态。</p>
<h2 id="复现方式"><a href="#复现方式" class="headerlink" title="复现方式"></a>复现方式</h2><p>初始化大量extents碎片文件test，使其成为一个拥有3999个extents的碎片文件。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/1.png" alt="1"></p>
<p>通过fiemap系统调用，获取这些extents<br><a href="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" target="_blank" rel="external"><img src="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" alt="2"></a><br>编译g++ do_fiemap.cc -o do_fiemap</p>
<p>通过该程序可以打印出可以获取的到fiemap extents, do_fiemap test，通过xfs_bmap test 打印出真正的extents数量后，进行比较。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/3.jpg" alt="3"></p>
<p>可以看到，我们最先写了2000个extents，并通过xfs_bmap获取到了 2000个有内容的extents，但是通过fiemap系统调用，只获取到了1364个有数据的extents，所以在ceph中使用fiemap系统调用在某些情况下导致数据一致性BUG。</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>1）目前，在使用块存储使用场景时，通常情况下，默认使用4MB对象。在无特殊情况下，不用使用大于4MB 对象的RBD 镜像。</p>
<p>2）在I版以后，通过新的系统调用，seek_data, seek_hole，可以避免触发该BUG，防止extents过多时使用fiemap调用产生的问题<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/4.png" alt="4"></p>
<p>这组系统调用，可以让使用者通过while循环，反复的发现文件中的data 与 hole，从而组织出一个文件中真正存在的数据，能够避免产生与fiemap系统调用类似的BUG，又保证了recovery或者clone时候只复制有用数据，而反复的系统调，应该会带来一定性能上的影响，请读者们自行测试。</p>
<p>目前，在I版本以后的ceph中，提供参数filestore_seek_data_hole，来启用该功能。当filestore_seek_data_hole 与 filestore_fiemap同时设置时，只用文件系统支持seek_data_hole，那么就会先通过seek_data_hole方式来获取文件的extents，所以在I版本以后的ceph中，应启用filestore_seek_data_hole功能来替代filestore_fiemap 功能。</p>
<p>3）对于已经使用8MB，16MB 甚至更大对象大小的RBD镜像，请暂时设置禁用Fiemap功能，并等待后续版本修复。</p>
<p>原文链接：<a href="https://www.ustack.com/blog/%E9%98%B2%E7%81%AB%E9%98%B2%E7%9B%97%E9%98%B2bug-%E6%9C%89%E4%BA%91%E5%AD%98%E5%82%A8%E5%9B%A2%E9%98%9F%E5%85%AC%E5%B8%83ceph%E4%B8%AD%E6%9C%80%E4%B8%A5%E9%87%8D%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80/" target="_blank" rel="external">有云存储团队公布Ceph中最严重数据不一致BUG!</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[块存储的世界]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/%E5%9D%97%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>在OpenStack中，存储是非常重要的一块，但是因为其提供方式的不同，即使是专业的工程师也会感到十分困惑。OpenStack的存储主要分为三大类，一是对象    存储服务，Swift解决的问题，二是块设备存储服务，在OpenStack里主要是提供给虚拟机的作为“硬盘”的存储，这里又分为本地块存储和分布式块存储，Cinder项目正    在解决相关的问题；第三类，数据库存储服务，Databases as a Service(DBaaS), 对应AWS里面的RDC，目前是一个正在孵化的项目，Trove，前身是Rackspace开源出&gt;    来的RedDwarf。本文重点介绍块存储服务。<br><a id="more"></a></p>
<blockquote>
<p>转载的文章，原文排版看的心累，链接见文末。</p>
</blockquote>
<p>​    UnitedStack OS的块存储是在OpenStack Cinder框架下开发的，开发过程中，我们对目前主流的块存储服务提供商和开源的块存储软件做了一个简要分析，希望能给从事块存储开发的工程师对于块存储一个全局的认识。        </p>
<p>​    块存储，简单来说就是提供了块设备存储的接口。用户需要把块存储卷附加到虚拟机(或者裸机)上后才可以与其交互。这些卷都是持久的: 它们可以被从运行实例上解除或者重新附加而数据保持完整不变。下面会先介绍常见的单机块设备工具来建立对块存储的初步印象。</p>
<h2 id="单机块存储"><a href="#单机块存储" class="headerlink" title="单机块存储"></a>单机块存储</h2><p>​    首先一个硬盘是一个块设备，内核检测到硬盘然后在/dev/下会看到/dev/sda/。因为我们需要利用一个硬盘来得到不同的分区来做不同的事，通过fdisk工具得到/dev/sda1, /dev/sda2等，这种通过直接写入分区表来规定和切分硬盘,是最死板的分区方式。</p>
<h3 id="LVM-amp-Device-mapper"><a href="#LVM-amp-Device-mapper" class="headerlink" title="LVM &amp; Device-mapper"></a>LVM &amp; Device-mapper</h3><p>​    LVM是一种逻辑卷管理器，通过LVM来对硬盘创建逻辑卷组和得到逻辑卷来完成目的比fdisk方式更加弹性。LVM对于不太熟悉其机制的人看来可能会造成不小的开销，但是相对于LVM对来的易用性其映射机制的负载小的足以忽略(在snapshot的情况会有不小的负载)。</p>
<p>​    LVM在大多数Linux使用者看来非常普通的工具，它同时也是OpenStack块存储项目的一种backend并且是默认的。通过LVM在每个主机创建Volume Group，通过Cinder(OpenStack块存储项目)的调度器可以在任何一个合适的主机(满足容量和其他要求)使用lvcreate创建一个块设备供Nova(OpenStack Computing项目)使用。</p>
<p>​    Device-mapper是一种支持逻辑卷管理的通用设备映射机制，为存储资源管理的块设备驱动提供了一个高度模块化的内核架构。LVM是基于Device-mapper的用户程序实现。</p>
<p>​    Device-mapper在内核中它通过一个模块化的Target Driver插件实现对IO请求的过滤或者重定向工作，当前已经实现的Target Driver插件包括软Raid、软加密、逻辑卷条带、多路径、镜像、快照等。整个 device mapper 机制由两部分组成–内核空间的 device mapper 驱动、用户空间的device mapper 库以及它提供的 dmsetup 工具。内核中主要提供完成这些策略所需要的机制。Device-mapper 用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等等，而具体过滤和重定向 IO 请求的工作由内核中相关代码完成。</p>
<h3 id="SAN-amp-iSCSI"><a href="#SAN-amp-iSCSI" class="headerlink" title="SAN &amp; iSCSI"></a>SAN &amp; iSCSI</h3><p>​    在接触了单机下的逻辑卷管理后，你需要了解<a href="http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C" target="_blank" rel="external">SAN</a>，目前主流的企业级存储方式。</p>
<p>​    大部分SAN使用<a href="http://en.wikipedia.org/wiki/SCSI" target="_blank" rel="external">SCSI</a>协议在服务器和存储设备之间传输和沟通，通过在SCSI之上建立不同镜像层，可以实现存储网络的连接。常见的有<a href="http://zh.wikipedia.org/wiki/ISCSI" target="_blank" rel="external">iSCSI</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_Protocol" target="_blank" rel="external">FCP</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet" target="_blank" rel="external">Fibre Channel over Ethernet</a>等。</p>
<p>​    SAN通常需要在专用存储设备中建立，而iSCSI是基于TCP/IP的SCSI映射，通过iSCSI协议和<a href="http://linux-iscsi.sourceforge.net/" target="_blank" rel="external">Linux iSCSI</a>项目我们可以在常见的PC机上建立SAN存储。。</p>
<p>​    如何建立在PC机上的SAN可以参考<a href="http://linux.vbird.org/linux_server/0460iscsi.php" target="_blank" rel="external">iSCSI建立</a>，这篇文章的iSCSI target管理方式不太方便，通常利用<a href="http://linux-iscsi.org/wiki/Targetcli" target="_blank" rel="external">targetcli</a>管理target是及其方便的。targetcli可以直接建立和管理不同backstone类型的逻辑卷和不同的export方式，如建立ramdisk并且通过iSCSI export非常方便，操作方式见<a href="http://www.youtube.com/watch?v=mKjBsgOlYmE" target="_blank" rel="external">targetcli screencast Part 2 of 3: ISCSI – YouTube</a>。</p>
<h2 id="分布式块存储服务"><a href="#分布式块存储服务" class="headerlink" title="分布式块存储服务"></a>分布式块存储服务</h2><p>​    以上都是我们经常解除的单机下块存储环境，接下来开始本文的正式分享内容，包括公共云技术服务提供的块存储服务，开源的块存储框架和OpenStack目前对块存储的定义和支持情况。</p>
<h3 id="分布式块存储"><a href="#分布式块存储" class="headerlink" title="分布式块存储"></a>分布式块存储</h3><p>​    在面对极具弹性的存储需求和性能要求下，单机或者独立的SAN越来越不能满足企业的需要。如同数据库系统一样，块存储在scale up的瓶颈下也面临着scale out的需要。我们可以用以下几个特点来描述分布式块存储系统的概念:</p>
<ul>
<li>分布式块存储可以为任何物理机或者虚拟机提供持久化的块存储设备</li>
<li>分布式块存储系统管理块设备的创建、删除和attach/deattach。</li>
<li>分布式块存储支持强大的快照功能，快照可以用来恢复或者创建新的块设备</li>
<li>分布式存储系统能够提供不同IO性能要求的块设备</li>
</ul>
<h3 id="Amazon-EBS-amp-阿里云磁盘"><a href="#Amazon-EBS-amp-阿里云磁盘" class="headerlink" title="Amazon EBS &amp; 阿里云磁盘"></a>Amazon EBS &amp; 阿里云磁盘</h3><p>​    Amazon作为领先的IAAS服务商，其API目前是IAAS的事实标准。Amazon EC2目前仍然一骑绝尘，在大多数方面远超其他IAAS服务商。通过Amazon EC2的<a href="http://aws.amazon.com/cn/ec2/" target="_blank" rel="external">产品介绍</a>是快速了解Amazon EC2的捷径。</p>
<p>​    而<a href="http://aws.amazon.com/cn/ebs/" target="_blank" rel="external">EBS</a>是Amazon提供的块存储服务，通过EBS，用户可以随时增删迁移volume和快照操作。</p>
<p>​    Amazon EC2实例可以将根设备数据存储在Amazon EBS或者本地实例存储上。使用 Amazon EBS时，根设备中的数据将独立于实例的生命周期保留下来，使得在停止实例后仍可以重新启动使用，与笔记本电脑关机并在再次需要时重新启动相似。另一方面，本地实例存储仅在实例的生命周期内保留。这是启动实例的一种经济方式，因为数据没有存储到根设备中。</p>
<p>​    Amazon EBS提供两种类型的卷，即标准卷和预配置IOPS卷。它们的性能特点和价格不同，可以根据应用程序的要求和预算定制所需的存储性能。</p>
<p>​    标准卷可为要求有适度或突发式I/O的应用程序提供存储。这些卷平均可以提供大约 100 IOPS，最多可突增至数百 IOPS。标准卷也非常适合用作引导卷，其突发能力可提供快速的实例启动时间(通常十几秒)。</p>
<p>​    预配置 IOPS 卷旨在为数据库等 I/O 密集型随机读写工作负载提供可预计的高性能。创建一个卷时，利用预置 IOPS 为卷确定 IOPS 速率，随之 Amazon EBS 在该卷的生命周期内提供该速率。Amazon EBS 目前支持每预配置 IOPS 卷最多 4000 个IOPS。您可以将多个条带式卷组合在一起，为您的应程程序提供每个Amazon EC2数千IOPS的能力。</p>
<p>​    EBS可以在卷连接和使用期间实时拍摄快照。不过，快照只能捕获已写入Amazon EBS 卷的数据，不包含应用程序或操作系统已在本地缓存的数据。如果需要确保能为实例连接的卷获得一致的快照，需要先彻底地断开卷连接，再发出快照命令，然后重新连接卷。</p>
<p>​    EBS快照目前可以跨regions增量备份，意味着EBS快照时间会大大缩短，从另一面增加了EBS使用的安全性。</p>
<p>​    总的来说，Amazon EBS是目前IAAS服务商最引入注目的服务之一，目前的OpenStack、CloudStack等等其他开源框架都无法提供Amazon EBS对于的如此弹性和强大的服务。了解和使用Amazon EBS是学习IAAS块存储的最好手段。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>​    阿里云是国内的公共云计算服务商，不过这里阿里云目前的块存储服务较于Amazon EBS差的太远，阿里云磁盘目前仅支持在创建云主机的时候绑定云磁盘或者在升级云主机的进行云磁盘扩容，这从根本上就是传统的虚拟主机的特点而不是所谓的“云磁盘”。</p>
<p>从目前的阿里云磁盘的限制:</p>
<ul>
<li>无法快速创建或删除volume，在进行扩容时需要升级云主机才能达到，而升级云主机只有在下月云主机套餐到期时才能生效(想起了中国移动套餐)</li>
<li>一个云主机最多只能绑定3个云磁盘</li>
</ul>
<p>从阿里云磁盘目前的使用分析，阿里云磁盘系统目前还很不成熟，以下是我对阿里云磁盘实现的推测</p>
<ul>
<li>阿里云主机是跟磁盘绑定的，这意味着阿里云的云磁盘是local volume(因此性能还是挺可观的)。如果用户需要扩容、减少都是需要下个月更说明了这点，整个主机在扩容时去调度合适的有足够存储空间的host，然后进行扩容。</li>
<li>阿里云磁盘是分布式块存储系统，但是由于其QoS无法保证和其他资源调度原因无法提供足够的块存储支持。</li>
</ul>
<p>从<a href="http://www.infoq.com/cn/news/2013/06/aliyun-nihao-storage" target="_blank" rel="external">演讲回顾：阿里云存储技术的演进，以及云服务用例最佳实践</a>中了解到阿里云是基于自家的“盘古”系统，那么从实际使用来说，远没达到一般的分布式块存储系统的要求。</p>
<h3 id="Ceph-amp-Sheepdog"><a href="#Ceph-amp-Sheepdog" class="headerlink" title="Ceph &amp; Sheepdog"></a>Ceph &amp; Sheepdog</h3><p><a href="http://ceph.com/" target="_blank" rel="external">Ceph</a>是开源实现的PB级分布式文件系统，通过其分布式对象存储机制为上层提供了文件接口、块存储接口和对象存储接口。<a href="http://www.inktank.com/" target="_blank" rel="external">Inktank</a>是Ceph的主要支持商，也是目前Ceph开源社区的主要力量。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/11.png" alt="1"></p>
<p>​    Ceph目前是OpenStack支持的Backend中一个不错的开源块存储实现系统(即Cinder项目backend driver之一)，其实现分为三个部分: OSD, Monitor, MDS。OSD是底层对象存储系统，Monitor是集群管理系统，MDS是用来支持POSIX文件接口的Metadata Server。从Ceph的原始论文(<a href="http://ceph.newdream.net/papers/weil-thesis.pdf" target="_blank" rel="external">Ceph: Reliable, Scalable, and High-Performance Distributed Storage</a>)来看，Ceph专注于扩展性，高可用性和容错性。Ceph放弃了传统的Metadata查表方式(HDFS)而改用算法(CRUSH)去定位具体的block。</p>
<p>​    利用Ceph提供的RULES可以弹性地制订存储策略和Pool选择，Monitor作为集群管理系统掌握了全部的Cluster Map，Client在没有Map的情况下需要先向Monitor请求得到，然后通过Object id计算相应的OSD Server。</p>
<p>​    Ceph支持传统的POSIX文件接口，因此需要额外的MDS(Meatadata Server)支持文件元信息(Ceph的块存储和对象存储支持不需要MDS服务)。Ceph将Data和Metadata分离到两个服务上，跟传统的分布式系统如Lustre相比可以大大增强扩展性。在小文件读写上，Ceph读写文件会有[RTT*2]，在每次open时，会先去Metadata Server查询一次，然后再去Object Server。除了Open操作外，Ceph在Delete上也有问题，它需要到Metadata Server擦除对应的Metadata，是n(2)复杂度。Ceph在Metadata上并非只有坏处，通过Metadata Server，像目录列表等目录操作为非常快速，远超GlusterFS等其他分布式文件系统的目录或文件元操作。</p>
<p>利用Ceph可以作两种不同类型的“共享存储”支持:</p>
<ol>
<li>利用CephFS作分布式系统，所有虚拟机的块设备直接使用CephFS的命名空间</li>
<li>使用Ceph RBD块设备接口，从Ceph Cluster中导出Volume作为块设备Attach到虚拟机。</li>
</ol>
<p>关于Ceph作为块存储项目的几个问题需要考虑:</p>
<ul>
<li>Ceph在读写上不太稳定（有Btrfs的原因），目前Ceph官方推荐XFS作为底层文件系统</li>
<li>Ceph的扩展性和架构较复杂，如果需要介入Ceph，需要较长时间深入了解</li>
<li>Ceph的部署不够简易，目前Ceph的官方部署工具不太成熟，而对于的Pupet模块或者其他都没有公认的较好实现。</li>
<li>Ceph的稳定性依赖高版本Linux的一些特性，并且Ceph的rbd.ko在高版本中更具稳定性。</li>
</ul>
<h3 id="Sheepdog"><a href="#Sheepdog" class="headerlink" title="Sheepdog"></a>Sheepdog</h3><p>​    <a href="http://www.osrg.net/sheepdog/" target="_blank" rel="external">Sheepdog</a>是另一个分布式块存储系统实现，它与Ceph相比，最大优势就是代码短小好维护和hack的成本很小。Sheepdog也有很多Ceph不支持的特性，比如说Multi-Disk, Cluster-wide Snapshot等。</p>
<p>​    Sheepdog主要有两部分，一个是集群管理，另一个是存储服务。集群管理目前使用Corosync或者Zookper来完成，其存储服务的特点是在Client和存储Host有Cache的实现可以大大减小数据流量。</p>
<p>​    目前Sheepdog只在QEMU端提供Drive，而缺少library支持，这是Sheepdog目前最主要的问题。但是社区已经有相关的Blueprint在讨论这个问题。</p>
<p>了解Sheepdog通过以下链接:</p>
<ul>
<li><a href="http://www.slideshare.net/multics/overview-of-sheepdog" target="_blank" rel="external">Sheepdog Overview</a></li>
<li><a href="http://rdc.taobao.com/blog/cs/?tag=sheepdog" target="_blank" rel="external">Sheepdog 淘宝核心系统团队</a></li>
<li><a href="https://github.com/collie/sheepdog/wiki" target="_blank" rel="external">Sheepdog wiki</a>: Sheepdog的一系列Wiki如同它的代码一样简短出色</li>
</ul>
<p>目前Taobao是Sheepdog主要用户和社区贡献者，国内也有Startup参与Sheepdog的社区开发。</p>
<h3 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h3><p>​    <a href="https://wiki.openstack.org/wiki/Main_Page" target="_blank" rel="external">OpenStack</a>是目前流行的IAAS框架，提供了AWS类似的服务并且兼容其API。OpenStack Nova是计算服务，Swift是对象存储服务，Quantum是网络服务，Glance是镜像服务，Cinder是块存储服务，Keystone是身份认证服务，Horizon是Dashboard，另外还有Heat、Oslo、Ceilometer、Ironic等等项目。</p>
<p>​    <a href="https://wiki.openstack.org/wiki/Cinder" target="_blank" rel="external">Cinder</a>是OpenStack中提供类似于EBS块存储服务的API框架，它并没有实现对块设备的管理和实际服务提供，用来为后端不同的存储结构提供统一的接口与OpenStack进行整合，不同的块设备服务厂商在Cinder中实现其驱动支持。后端的存储可以是DAS，NAS，SAN，对象存储或者分布式文件系统。也就是说，Cinder的块存储数据完整性，可用性保障是由后端存储提供的。在<a href="https://wiki.openstack.org/wiki/CinderSupportMatrix" target="_blank" rel="external">CinderSupportMatrix</a>中可以看到众多存储厂商如NetAPP、IBM、SolidFire、EMC和众多开源块存储系统对Cinder的支持，在这里我们也可以看到OpenStack是非常受欢迎的。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/2.png" alt="2"></p>
<p>​    从上图我们也可以看到，Cinder只是提供了一层抽象，然后通过其后段支持的driver实现来发出命令来得到回应。关于块存储的分配信息以及选项配置等会被保存到OpenStack统一的DB中。</p>
<p>​    目前Cinder项目支持的操作包括创建/删除Volume，创建/删除Snapshot，Clone Volume，将Volume制作成Image或者将Image导出到Volume，备份/恢复Volume和扩展Volume大小，不同的Backend会实现不同程度的操作，但基本的创建Volume和快照操作都是支持的。目前令人振奋的Amazon EBS的QoS机制已经在Cinder社区中得到广泛讨论，在经历近两个月的Patch Review之后，整个QoS机制即将正式进入Cinder项目。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    目前分布式块存储的实现仍然是由Amazon EBS领衔，其卓越稳定的读写性能、强大的增量快照和跨区域块设备迁移，以及令人惊叹的QoS控制都是目前开源或者其他商业实现无法比拟的。</p>
<p>​    不过Amazon EBS始终不是公司私有存储的一部分，作为企业IT成本的重要部分，块存储正在发生改变。EMC在一个月前发布了其ViPR平台，并开放了其接口试图接纳其他厂商和开源实现。Nexenta在颠覆传统的的存储专有硬件，在其上软件实现原来只有专有SDN的能力，让企业客户完全摆脱存储与厂商的绑定。Inktank极力融合OpenStack并推动Ceph在OpenStack社区的影响力都说明了无论是目前的存储厂商还是开源社区都在极力推动整个分布式块存储的发展，存储专有设备的局限性正在进一步弱化了原有企业的存储架构。</p>
<p>​    在分布式块存储和OpenStack之间我们可以打造更巩固的纽带，UnitedStack存储团队在开源存储的基础上，结合本地块存储和分布式块存储的优势，为UnitedStack OS提供一个通用的存储解决方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-1/" target="_blank" rel="external">通用线程: 学习 Linux LVM，第 1 部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-2/" target="_blank" rel="external">通用线程：学习 Linux LVM，第 2部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/" target="_blank" rel="external">Linux 内核中的 Device Mapper 机制</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="external">Ceph：一个 Linux PB 级分布式文件系统</a></li>
<li><a href="http://www.alidata.org/archives/1589" target="_blank" rel="external">分布式文件系统Ceph调研1 – RADOS</a></li>
<li><a href="http://ceph.com/docs/next/architecture/" target="_blank" rel="external">Ceph Architecture</a></li>
<li><a href="http://way4ever.com/?p=375" target="_blank" rel="external">Ceph的现状</a></li>
<li><a href="http://way4ever.com/?p=122" target="_blank" rel="external">ceph的CRUSH数据分布算法介绍</a></li>
<li><a href="http://ceph.com/docs/next/dev/" target="_blank" rel="external">Ceph INTERNAL DEVELOPER DOCUMENTATION</a></li>
<li>原文链接：<a href="https://www.ustack.com/blog/block-storage-overview/" target="_blank" rel="external">块存储的世界</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——uptime]]></title>
      <url>http://xiaqunfeng.cc/2017/01/17/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94uptime/</url>
      <content type="html"><![CDATA[<p>打印系统总共运行了多长时间和系统的平均负载。<br><a id="more"></a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line"> uptime [options]</div><div class="line"></div><div class="line">Options:</div><div class="line"> -p, --pretty   show uptime in pretty format</div><div class="line"> -h, --help     display this help and exit</div><div class="line"> -s, --since    system up since</div><div class="line"> -V, --version  output version information and exit</div><div class="line"></div><div class="line">For more details see uptime(1).</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime</div><div class="line"> 17:40:45 up 1 day,  6:37,  3 users,  load average: 0.27, 0.21, 0.31</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>显示内容</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:40:45</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day,  6:37</td>
<td>主机已运行时间，时间越大，说明机器越稳定</td>
</tr>
<tr>
<td>3 users</td>
<td>用户连接数，是总连接数而不是用户数</td>
</tr>
<tr>
<td>load average: 0.27, 0.21, 0.31</td>
<td>最近1，5，15分钟的系统平均负载</td>
</tr>
</tbody>
</table>
<p><strong>系统平均负载</strong>：在特定时间间隔内运行队列中的平均进程数。</p>
<p><strong>查看CPU内核数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</div><div class="line">4</div></pre></td></tr></table></figure>
<p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
<h3 id="运行时间格式输出"><a href="#运行时间格式输出" class="headerlink" title="运行时间格式输出"></a>运行时间格式输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -p</div><div class="line">up 1 day, 6 hours, 56 minutes</div></pre></td></tr></table></figure>
<h3 id="系统启动的时间"><a href="#系统启动的时间" class="headerlink" title="系统启动的时间"></a>系统启动的时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -s</div><div class="line">2017-01-16 11:03:35</div></pre></td></tr></table></figure>
<h3 id="uptime版本"><a href="#uptime版本" class="headerlink" title="uptime版本"></a>uptime版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># uptime -V</div><div class="line">uptime from procps-ng 3.3.9</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dd磁盘命令小记]]></title>
      <url>http://xiaqunfeng.cc/2017/01/12/dd%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>dd是经常使用的命令了，方便快捷，这里闲来小总结一下，以及怎样测出最真实的写入速度。<br><a id="more"></a></p>
<h2 id="命令的使用"><a href="#命令的使用" class="headerlink" title="命令的使用"></a>命令的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd --help</div><div class="line">Usage: dd [OPERAND]...</div><div class="line">  or:  dd OPTION</div><div class="line">Copy a file, converting and formatting according to the operands.</div><div class="line"></div><div class="line">  bs=BYTES        read and write up to BYTES bytes at a time</div><div class="line">  cbs=BYTES       convert BYTES bytes at a time</div><div class="line">  conv=CONVS      convert the file as per the comma separated symbol list</div><div class="line">  count=N         copy only N input blocks</div><div class="line">  ibs=BYTES       read up to BYTES bytes at a time (default: 512)</div><div class="line">  if=FILE         read from FILE instead of stdin</div><div class="line">  iflag=FLAGS     read as per the comma separated symbol list</div><div class="line">  obs=BYTES       write BYTES bytes at a time (default: 512)</div><div class="line">  of=FILE         write to FILE instead of stdout</div><div class="line">  oflag=FLAGS     write as per the comma separated symbol list</div><div class="line">  seek=N          skip N obs-sized blocks at start of output</div><div class="line">  skip=N          skip N ibs-sized blocks at start of input</div><div class="line">  status=WHICH    WHICH info to suppress outputting to stderr;</div><div class="line">                  &apos;noxfer&apos; suppresses transfer stats, &apos;none&apos; suppresses all</div></pre></td></tr></table></figure>
<p><strong>翻译</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bs</td>
<td>同时设置读写块的大小为 bytes ，可代替 ibs 和 obs</td>
</tr>
<tr>
<td>cbs</td>
<td>一次转换 bytes 个字节，即转换缓冲区大小</td>
</tr>
<tr>
<td>conv</td>
<td>转换参数</td>
</tr>
<tr>
<td>count</td>
<td>复制的块数</td>
</tr>
<tr>
<td>ibs</td>
<td>一次读入 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>if</td>
<td>输入文件 或 设备名称</td>
</tr>
<tr>
<td>iflag</td>
<td>按照逗号来分隔读参数</td>
</tr>
<tr>
<td>obs</td>
<td>一次写 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>of</td>
<td>输出文件 或 设备名称</td>
</tr>
<tr>
<td>oflag</td>
<td>按照逗号来分隔写参数</td>
</tr>
<tr>
<td>seek</td>
<td>从输出文件开头跳过 blocks 个块后再开始复制</td>
</tr>
<tr>
<td>skip</td>
<td>从输入文件开头跳过 blocks 个块后再开始复制</td>
</tr>
</tbody>
</table>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd --version</div></pre></td></tr></table></figure>
<h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><p><strong>两个特殊的设备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/dev/null：伪设备，相当于黑洞，of到该设备不会产生IO</div><div class="line">/dev/zero：伪设备，它只产生空字符流，对它不会产生IO</div></pre></td></tr></table></figure>
<p><strong>1、测试磁盘写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/zero of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO都集中在of文件中，of文件只用于写，相当于测试磁盘的写能力。</p>
<p><strong>2、测试磁盘读能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/dev/null bs=8k count=10000</div></pre></td></tr></table></figure>
<p>IO只发生在/dev/sdb1上，相当于测试磁盘的读能力。</p>
<p><strong>3、测试同时读写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/sdb1 of=/test.a bs=8k count=10000</div></pre></td></tr></table></figure>
<p>一个是物理分区，一个是实际的文件，对它们的读写都会产生IO，如果它们都在一个磁盘中，该命令就相当于测试磁盘的同时读写能力。</p>
<h2 id="几种测试写磁盘的区别"><a href="#几种测试写磁盘的区别" class="headerlink" title="几种测试写磁盘的区别"></a>几种测试写磁盘的区别</h2><p>先给出四种测试方式的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># dd if=/dev/zero of=test bs=1M count=128</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.116559 s, 1.2 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 ; sync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 0.125106 s, 1.1 GB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 1.76802 s, 75.9 MB/s</div><div class="line"></div><div class="line"># dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</div><div class="line">128+0 records in</div><div class="line">128+0 records out</div><div class="line">134217728 bytes (134 MB) copied, 4.91353 s, 27.3 MB/s</div></pre></td></tr></table></figure>
<p>1、<code>dd if=/dev/zero of=test bs=1M count=128</code></p>
<p>没有加任何参数，命令只是单纯地把这128MB的数据读到内存缓冲当中，dd命令完成前并没有让系统真正把文件写到磁盘上。所以得到的是一个超级快的速度。直到dd完成后系统才开始真正往磁盘上写数据,但这个速度你是看不到了。</p>
<p>2、<code>dd if=/dev/zero of=test bs=1M count=128 ; sync</code></p>
<p>这事先后两个独立的命令。当sync命令准备开始往磁盘上真正写入数据的时候，前面dd命令已经把错误的“写入速度”值显示在屏幕上了。所以得到的不是真正的写入速度。</p>
<p><strong>3、<code>dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</code></strong></p>
<p>加入参数 <code>conv=fdatasync</code> 后，dd命令执行到最后会真正执行一次“同步(sync)”操作，所以这时候得到的是读取这128M数据到内存并写入到磁盘上所需的时间，这样算出来的时间才是<strong>比较符合实际</strong>的。这种方式最接近计算机实际操作，所以测出来的数据最有参考价值。</p>
<p>4、<code>dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</code></p>
<p>加入参数 <code>oflag=dsync</code> 后，dd在执行时每次都会进行同步写入操作。这条命令每次读取1M后就要先把这1M写入磁盘，然后再读取下面这1M，一共重复128次。这是最慢的一种方式，因为基本上没有用到写缓存(write cache)。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决calamari无法获取集群hosts信息的BUG]]></title>
      <url>http://xiaqunfeng.cc/2017/01/12/%E8%A7%A3%E5%86%B3calamari%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E9%9B%86%E7%BE%A4hosts%E4%BF%A1%E6%81%AF%E7%9A%84BUG/</url>
      <content type="html"><![CDATA[<p>如题，环境是ubuntu 14.04，解决过程和方法详见正文。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在磨磨的文章中看到这个问题，他是在CentOS上，通过修改 <code>/usr/lib/python2.7/site-packages/salt/master.py</code> 文件，然后重启salt-master和salt-minion服务来解决的，链接在文末。原理类似，可ubuntu上并不能完全照搬。</p>
<h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><blockquote>
<p>这部分的内容为折腾求证的过程，想看解决方法的可以直接跳过！</p>
</blockquote>
<p>在ubuntu上并没有这个文件和路径，通过tab可以看到site开头的只有这几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# vim /usr/lib/python2.7/site</div><div class="line">sitecustomize.py   sitecustomize.pyc  site.py            site.pyc</div></pre></td></tr></table></figure>
<p>我以为可能是系统下包安装的位置不对而已，好，那我就查看一下ubuntu下salt-master的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">root@calamari:~# dpkg -L salt-master</div><div class="line">/.</div><div class="line">/usr</div><div class="line">/usr/share</div><div class="line">/usr/share/man</div><div class="line">/usr/share/man/man1</div><div class="line">/usr/share/man/man1/salt.1.gz</div><div class="line">/usr/share/man/man1/salt-run.1.gz</div><div class="line">/usr/share/man/man1/salt-master.1.gz</div><div class="line">/usr/share/man/man1/salt-key.1.gz</div><div class="line">/usr/share/man/man1/salt-cp.1.gz</div><div class="line">/usr/share/doc</div><div class="line">/usr/share/doc/salt-master</div><div class="line">/usr/share/doc/salt-master/changelog.Debian.gz</div><div class="line">/usr/share/doc/salt-master/NEWS.Debian.gz</div><div class="line">/usr/share/doc/salt-master/copyright</div><div class="line">/usr/bin</div><div class="line">/usr/bin/salt-run</div><div class="line">/usr/bin/salt-master</div><div class="line">/usr/bin/salt-key</div><div class="line">/usr/bin/salt-cp</div><div class="line">/usr/bin/salt</div><div class="line">/lib</div><div class="line">/lib/systemd</div><div class="line">/lib/systemd/system</div><div class="line">/lib/systemd/system/salt-master.service</div><div class="line">/etc</div><div class="line">/etc/init.d</div><div class="line">/etc/init.d/salt-master</div><div class="line">/etc/init</div><div class="line">/etc/init/salt-master.conf</div><div class="line">/etc/salt</div><div class="line">/etc/salt/master</div><div class="line">/etc/salt/master.d</div></pre></td></tr></table></figure>
<p>然后通过 <code>find</code> 命令去 <code>/etc, /usr, /lib</code> 这几个目录下找 <code>master.py</code> ，结果真没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find: `master.py&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>好吧，下面来看问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在calamari的web界面下，查看 MANAGE -&gt; Cluster -&gt;HOSTS 信息，发现啥也没有，如下图所示：<img src="http://ojet8bprn.bkt.clouddn.com/calamari-1.png" alt="calamari-1"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>calamari的salt-master节点在读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/cache/salt/master/minions/&#123;minion-hostname&#125;/data.p</div></pre></td></tr></table></figure>
<p>该文件的时候有权限问题，当前权限为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-rw------- 1 root root 3019 Jan 10 11:06 data.p</div></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改权限为 644 即可，写了个脚本，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for x in 0 1 2</div><div class="line">do</div><div class="line">    chmod 644 /var/cache/salt/master/minions/ceph$x/data.p</div><div class="line">done</div></pre></td></tr></table></figure>
<p>修改完后，再次查看，可以看到hosts的详细信息了<img src="http://ojet8bprn.bkt.clouddn.com/calamari-2.png" alt="calamari-2"></p>
<blockquote>
<p>当然，重启 salt-minion 后又需要在 salt-master 机器上重新执行一遍，<del>~~(&gt;_&lt;)</del>~~，忧伤~</p>
</blockquote>
<p>磨磨的方法：<a href="http://www.zphj1987.com/2017/01/09/calamari-node-info/" target="_blank" rel="external">centos下该问题的解决方法</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下配置邮件发送]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AE%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
      <content type="html"><![CDATA[<p>Linux下发送email有很多种方式，包括sendmail、mailx、mutt、uuencode等等。这里介绍ubuntu下使用mutt和msmtp发送邮件的配置方法。<br><a id="more"></a></p>
<h2 id="软件包的安装"><a href="#软件包的安装" class="headerlink" title="软件包的安装"></a>软件包的安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mutt</div><div class="line">sudo apt-get install msmtp</div></pre></td></tr></table></figure>
<h2 id="文件的配置"><a href="#文件的配置" class="headerlink" title="文件的配置"></a>文件的配置</h2><h3 id="配置-mutt"><a href="#配置-mutt" class="headerlink" title="配置 mutt"></a>配置 mutt</h3><p>,系统全局设置配置文件在 /etc/Muttrc,如果使用某个系统用户，可以在~/.muttc中设置，没有该文件，就自己创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi .muttrc</div><div class="line"></div><div class="line">set sendmail=&quot;/usr/bin/msmtp&quot;</div><div class="line">set use_from=yes</div><div class="line">set realname=&quot;xia&quot;</div><div class="line">set from=abcdefg@126.com</div><div class="line">set envelope_from=yes</div></pre></td></tr></table></figure>
<h3 id="配置msmtp"><a href="#配置msmtp" class="headerlink" title="配置msmtp"></a>配置msmtp</h3><p>创建 ~/.msmtprc 和 ~/.msmtp.log，分别为配置文件和日志文件。</p>
<p><strong>1、创建配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi .msmtprc</div></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">account default</div><div class="line">host smtp.126.com</div><div class="line">from youremailname@126.com</div><div class="line">auth plain</div><div class="line">user youremailname@126.com</div><div class="line">password xxxxxxx</div><div class="line">logfile ~/.msmtp.log</div></pre></td></tr></table></figure>
<p>由于password是明文，所以需要修改此文件的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 .msmtprc</div></pre></td></tr></table></figure>
<p><strong>特别注意</strong>：</p>
<blockquote>
<p>这里的密码填的是你的授权密码，不是登录密码!</p>
</blockquote>
<p><strong>2、创建日志文件 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch ~/.msmtp.log</div></pre></td></tr></table></figure>
<h2 id="邮件发送测试"><a href="#邮件发送测试" class="headerlink" title="邮件发送测试"></a>邮件发送测试</h2><p>查看SMTP服务器是否支持认证的TLS加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># msmtp --host=smtp.126.com --serverinfo</div><div class="line">SMTP server at smtp.126.com (m15-111.126.com [220.181.15.111]), port 25:</div><div class="line">    126.com Anti-spam GT for Coremail System (126com[20140526])</div><div class="line">Capabilities:</div><div class="line">    PIPELINING:</div><div class="line">        Support for command grouping for faster transmission</div><div class="line">    STARTTLS:</div><div class="line">        Support for TLS encryption via the STARTTLS command</div><div class="line">    AUTH:</div><div class="line">        Supported authentication methods:</div><div class="line">        PLAIN LOGIN </div><div class="line">This server might advertise more or other capabilities when TLS is active.</div></pre></td></tr></table></figure>
<p>发送一个简单的邮件测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello world&quot; | mutt -s &quot;title&quot; 12456789@qq.com</div></pre></td></tr></table></figure>
<p>登录QQ邮箱，可以正常收到邮件，成功！</p>
<h2 id="四种发送方式"><a href="#四种发送方式" class="headerlink" title="四种发送方式"></a>四种发送方式</h2><p>1、<strong>带有主题，从文件中读取邮件的正文，并发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mutt -s &quot;hello mutt&quot; user@example.com &lt; message.txt</div></pre></td></tr></table></figure>
<p>2、<strong>通过管道获取 <code>echo</code>命令输出作为邮件内容发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com</div></pre></td></tr></table></figure>
<p>3、<strong>发送带附件的邮件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com -a test.tar.gz</div></pre></td></tr></table></figure>
<p>多个附件的话在每个附件前加上 <code>-a</code> 即可。</p>
<p>4、<strong>发送给多个收件人</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;hello mutt&quot; | mutt -s &quot;Testing muttt&quot; 111111@qq.com,222222@163.com -c 3333333@qq.com -b 44444444@126.com</div></pre></td></tr></table></figure>
<p>多个收件人之间用逗号隔开</p>
<p><strong>抄送</strong>，前面加参数 <code>-c</code> </p>
<p><strong>密送</strong>，前面加参数 <code>-b</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1、出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">msmtp: authentication failed (method PLAIN)</div><div class="line">msmtp: server message: 530 Error: A secure connection is requiered(such as ssl). More information at http://service.mail.qq.com/cgi-bin/help?id=28</div><div class="line">msmtp: could not send mail (account default from /root/.msmtprc)</div><div class="line">Error sending message, child exited 77 (Insufficient permission.).</div><div class="line">Could not send the message.</div></pre></td></tr></table></figure>
<p>原因，没有权限进行操作</p>
<p>解决方法：</p>
<blockquote>
<p>登录网页邮箱，设置开启POP3/SMTP服务、IMAP/SMTP服务</p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="http://www.cnblogs.com/xiazh/archive/2011/04/15/2016966.html" target="_blank" rel="external">ubuntu下使用mutt和msmtp发送邮件的简单配置</a></p>
<p><a href="https://linux.cn/article-5502-1.html" target="_blank" rel="external">4个可以发送电子邮件的命令行工具</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下系统打包]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu%E4%B8%8B%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>介绍在ubuntu下利用remastersys工具给系统打包成 iso 镜像的方法，在其他系统（centos、windows等）下方法类似，不在赘述。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在初始环境下，经过多次反复安装和配置才组建完成的自己需要的环境，其中各种版本问题和依赖较多，安装过程繁杂，为了避免痛苦的安装过程轮回发生，需要给系统打个包，后续使用直接安装即可。</p>
<p>使用工具：Remastersys</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、依赖项的安装"><a href="#1、依赖项的安装" class="headerlink" title="1、依赖项的安装"></a>1、依赖项的安装</h3><p>依赖：<a href="ftp://ftp.gwdg.de/pub/linux/easyvdr/mirror/remastersys/ubuntu/remastersys/remastersys_3.0.4-2_all.deb" target="_blank" rel="external">remastersys_3.0.4-2_all.deb</a>，点击即可下载，也可以自己去去<a href="http://www.filewatcher.com/" target="_blank" rel="external">filewatcher</a>搜索下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install plymouth-x11 </div><div class="line">sudo dpkg -i remastersys_3.0.4-2_all.deb</div></pre></td></tr></table></figure>
<h3 id="2、Remastersys安装"><a href="#2、Remastersys安装" class="headerlink" title="2、Remastersys安装"></a>2、Remastersys安装</h3><p>2.1、添加安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;deb http://www.remastersys.com/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list</div></pre></td></tr></table></figure>
<p>2.2、更新安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo install remastersys</div><div class="line">sudo remastersys</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys  backup|clean|dist  [cdfs|iso]  [filename.iso]</div></pre></td></tr></table></figure>
<p>两种打包方式：backup和dist</p>
<p>backup 是对整个系统完全打包，包含个人文件</p>
<p>dist 方式用做发行，不包含个人文件</p>
<blockquote>
<p>更多使用方法可以参考<a href="http://forum.ubuntu.org.cn/viewtopic.php?t=174719" target="_blank" rel="external">ubuntu论坛</a></p>
</blockquote>
<h3 id="系统打包"><a href="#系统打包" class="headerlink" title="系统打包"></a>系统打包</h3><p>3.1、产生一个只有档案系统的可发布的 livecd/dvd </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist cdfs</div></pre></td></tr></table></figure>
<p>3.2、产生一个可发布其名叫 filename.iso的ISO文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys dist iso filename.iso</div></pre></td></tr></table></figure>
<p>3.3、将产生的iso文件移动到安全的位置(如果不移动会被清除掉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv /home/remastersys/remastersys/filename.iso /root/</div></pre></td></tr></table></figure>
<p>3.4、清除由 remastersys产生的临时文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo remastersys clean</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——history及其优化]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94history%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>没啥好说的，就是查看历史输入的命令。这里引入两个优化点，一是历史记录带时间，二是可以统计汇总不同终端下的命令。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">history [n]</div><div class="line">history [-c]</div><div class="line">history [-raw] histfiles</div></pre></td></tr></table></figure>
<p>参数解释：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数字，列出最近的 n 条命令列表</td>
</tr>
<tr>
<td>-c</td>
<td>将目前的shell中的所有 history 内容全部清除</td>
</tr>
<tr>
<td>-a</td>
<td>将目前新增的history指令新增入 histfiles中，若没有➕histfiles，则预设写入 ~/.bash_history</td>
</tr>
<tr>
<td>-r</td>
<td>将histfiles的内容读到目前这个shell的history记忆中</td>
</tr>
<tr>
<td>-w</td>
<td>将目前的history记忆内容写入histfiles</td>
</tr>
</tbody>
</table>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more, less, tail, head</code> 来使用，其他复杂用法这里不作介绍。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">history | more</div><div class="line">history | tail -4</div></pre></td></tr></table></figure>
<h2 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h2><p><strong>出发点</strong>：在项目中，在不同终端下执行了一系列的命令后，翻不到历史记录，也没有汇总，也不知道每条命令的执行时间，所以需要对该命令进行优化。</p>
<p><strong>优化点</strong></p>
<ul>
<li>历史记录里面每条命令带有时间</li>
<li>所有终端命令都记录到history当中去</li>
</ul>
<blockquote>
<p>命令的汇总限同一个机器下的同一个用户</p>
</blockquote>
<p>注：以下设置方法适用ubuntu，其他系统类似。ubuntu上修改的文件是 <code>/etc/bash.bashrc</code>，mac上修改的文件是 <code>/etc/bashrc</code> 。</p>
<h3 id="添加日期"><a href="#添加日期" class="headerlink" title="添加日期"></a>添加日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</div><div class="line">export HISTTIMEFORMAT</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候，history命令的显示就带有日期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">448  2017-01-11 11:42:01 vim /etc/bash.bashrc </div><div class="line">449  2017-01-11 11:42:45 source /etc/bash.bashrc </div><div class="line">450  2017-01-11 11:40:18 history</div><div class="line">451  2017-01-11 11:41:11 ls</div><div class="line">452  2017-01-11 11:41:12 pwd</div><div class="line">453  2017-01-11 11:41:35 history</div></pre></td></tr></table></figure>
<h3 id="不同终端命令汇总"><a href="#不同终端命令汇总" class="headerlink" title="不同终端命令汇总"></a>不同终端命令汇总</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div><div class="line"># When the shell exits, append to the history file instead of overwriting it</div><div class="line">shopt -s histappend</div><div class="line"></div><div class="line"># After each command, append to the history file and reread it</div><div class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&apos;\n&apos;&#125;history -a; history -c; history -r&quot;</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候就可以看到之前在该机器该用户下的所有命令操作。</p>
<h3 id="调整记录命令长度"><a href="#调整记录命令长度" class="headerlink" title="调整记录命令长度"></a>调整记录命令长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTSIZE=1000	# 该数字自己定</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
<h3 id="剔除连续重复的条目"><a href="#剔除连续重复的条目" class="headerlink" title="剔除连续重复的条目"></a>剔除连续重复的条目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/bash.bashrc</div></pre></td></tr></table></figure>
<p>将 HISTCONTROL 设置为 ignoredups</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Avoid duplicates</div><div class="line">export HISTCONTROL=ignoredups:erasedups</div></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/bash.bashrc</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下利用screen进行屏幕协作]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E4%B8%8B%E5%88%A9%E7%94%A8screen%E8%BF%9B%E8%A1%8C%E5%B1%8F%E5%B9%95%E5%8D%8F%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>Linux本身是支持多终端并行处理的，但是某些时候我们可能需要两个人同时处理同一个终端，比如远程协助定位问题等。screen正好能满足这个需求。<br><a id="more"></a></p>
<h2 id="screen的安装"><a href="#screen的安装" class="headerlink" title="screen的安装"></a>screen的安装</h2><p>debian和ubuntu下安装方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install screen</div></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>假设现在有a和b需要进行屏幕协作。</p>
<blockquote>
<p>他们需要登录同一台服务器/机器</p>
<p>必须使用相同的账户，不同账户之前不能屏幕协作</p>
</blockquote>
<p>第一步：a 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -S zp</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>S</code> 是大写</p>
<p>第二步：b 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">screen -x zp</div></pre></td></tr></table></figure>
<p>这时两边的操作是实时而且同步的。</p>
<h2 id="退出协作"><a href="#退出协作" class="headerlink" title="退出协作"></a>退出协作</h2><p>在任意一个终端上输入命令：<code>exit</code> ，输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[screen is terminating]</div></pre></td></tr></table></figure>
<p>表示退出成功。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——crontab]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/Linux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94crontab/</url>
      <content type="html"><![CDATA[<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>crontab使用格式说明</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/crontab%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.png" alt="crontab格式说明"></p>
<p>如图所示：</p>
<ul>
<li>第1列分钟0～59</li>
<li>第2列小时0～23（0表示子夜）</li>
<li>第3列日1～31</li>
<li>第4列月1～12</li>
<li>第5列星期0～7（0和7表示星期天）</li>
<li>第6列要运行的命令</li>
</ul>
<p><strong>TIPS</strong></p>
<p>每一列之间用空格隔开。</p>
<p>破折号 <code>-</code> 表示一个整数范围。例如：“2-4”表示“2,3,4”。</p>
<p>逗号 <code>,</code> 表示枚举的意思，一个指定的集合。例如：“1,5,8”。</p>
<p>正向斜杠 <code>/</code> 表示间隔频率。例如：“8-20/2”表示从8点到20点每2小时执行一次。</p>
<p><code>/</code> 可以和 <code>*</code> 一起使用。例如<code>*/5</code>，如果用在minute字段，表示每五分钟执行一次。<code>* */1 * * *</code>  表示每一小时执行一次。</p>
<p><strong>命令格式</strong></p>
<p><code>crontab [-u user] file crontab [-u user][ -e | -l | -r ]</code></p>
<h2 id="选项详解"><a href="#选项详解" class="headerlink" title="选项详解"></a>选项详解</h2><ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><p>1、创建crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab yourcron</div></pre></td></tr></table></figure>
<p>2、列出crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>3、编辑crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab -e</div></pre></td></tr></table></figure>
<p>4、删除crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$crontab -r</div></pre></td></tr></table></figure>
<p>5、ubuntu下启动、停止与重启cron</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron start</div><div class="line">$sudo /etc/init.d/cron stop</div><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p>6、清理用户的邮件日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p><code>&gt; /dev/null 2&gt;&amp;1</code> 表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<blockquote>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要</p>
</blockquote>
<h3 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h3><p><strong>一种是新建crontab任务，然后重启cron服务</strong></p>
<p>第一步、创建一个crontab文件</p>
<p>设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。使用vi的话，在$HOME目录下的. profile文件中加入一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EDITOR=vi; export EDITOR</div></pre></td></tr></table></figure>
<p>创建一个比如名为 testcron 的文件，在其中加入自己想要执行的命令，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>把这个新创建的文件作为cron命令的参数，用来创建crontab任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab testcron</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>失败！</strong></p>
<blockquote>
<p>试过多次，不知道为啥这种通过自己创建crontab文件的方式不行，查资料也未果。后续有机会再试试，就暂时先用后一种可用的方法吧。有知道的忘不吝指教。</p>
</blockquote>
<p><strong>另一种是把要执行的命令直接写入 <code>/etc/crontab</code> 中，然后重启cron服务</strong></p>
<p>第一步、直接编辑 /etc/crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/crontab</div><div class="line">添加自己的任务</div><div class="line">* * * * * root sh myjob.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<p><strong>成功！</strong></p>
<p>如果需要停止该任务的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo /etc/init.d/cron stop</div></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实例1：每1分钟执行一次myCommand</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例2：每小时的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 * * * * myCommand</div></pre></td></tr></table></figure>
<p>实例3：在上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * * myCommand</div></pre></td></tr></table></figure>
<p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 */2  *  * myCommand</div></pre></td></tr></table></figure>
<p>实例5：每周一上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,15 8-11 * * 1 myCommand</div></pre></td></tr></table></figure>
<p>实例6：每晚的21:30重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">30 21 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例7：每月1、10、22日的4 : 45重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">45 4 1,10,22 * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例8：每周六、周日的1 : 10重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 1 * * 6,0 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0,30 18-23 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例10：每星期六的晚上11 : 00 pm重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23 * * 6 /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例11：每一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* */1 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<p>实例12：晚上11点到早上7点之间，每隔一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 23-7 * * * /etc/init.d/smb restart</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件中。</p>
<p>2、新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>3、<code>crontab -r</code> 将从Crontab目录（/var/spool/cron）中删除用户的Crontab文件，该用户的所有crontab都将被删除。</p>
<p>4、在crontab中 <code>%</code> 表示换行的意思。使用的时候必须进行转义%。比如经常使用的 <code>date ‘+%Y%m%d’</code> 在crontab里是不会执行的，应该换成 <code>date ‘+\%Y\%m\%d’’</code>。</p>
<p><strong>参考资料</strong>：<a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">crontab 定时任务</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上hexo博客的搭建]]></title>
      <url>http://xiaqunfeng.cc/2017/01/06/hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>​    第一篇hexo博客，介绍了在mac上搭建hexo博客的全过程。包括：准备工作、本地站点的建立、启动和部署站点、创建新文章、发布到github、更换主题 和 绑定域名。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><strong>github</strong></li>
<li><strong>homebrew</strong></li>
<li><strong>node.js 和 npm</strong></li>
<li><strong>hexo</strong></li>
</ol>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>1、github账号</p>
<p>​    这部分略过，没有的话自己注册一个。然后将mac上的公钥添加到github上去。</p>
<p>2、建立仓库</p>
<p>​    严格按照 <code>git用户名</code>.<code>github</code>.<code>io</code> 来命名。我这里就叫：<code>xiaqunfeng.github.io</code> 。</p>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><p>homebrew 是MAC OSX 上面用来安装 或者 卸载软件用的非常方面的一个软件。在终端上执行如下命令即可安装，参考<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>不推荐使用 brew 安装node， 直接从<a href="https://nodejs.org/en/" target="_blank" rel="external">官网</a>下载，然后双击安装。我这里选择的版本是：v6.9.3 LTS。node.js 集成带有npm。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v6.9.3</div><div class="line"></div><div class="line">$ npm -v</div><div class="line">3.10.10</div></pre></td></tr></table></figure>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ hexo -v</div><div class="line">hexo: 3.2.2</div><div class="line">hexo-cli: 1.0.2</div><div class="line">os: Darwin 16.1.0 darwin x64</div><div class="line">http_parser: 2.7.0</div><div class="line">node: 6.9.3</div><div class="line">v8: 5.1.281.89</div><div class="line">uv: 1.9.1</div><div class="line">zlib: 1.2.8</div><div class="line">ares: 1.10.1-DEV</div><div class="line">icu: 57.1</div><div class="line">modules: 48</div><div class="line">openssl: 1.0.2j</div></pre></td></tr></table></figure>
<h2 id="hexo命令行使用"><a href="#hexo命令行使用" class="headerlink" title="hexo命令行使用"></a>hexo命令行使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">常用命令：</div><div class="line">hexo help			#查看帮助</div><div class="line">hexo init 			#初始化一个目录</div><div class="line">hexo new &quot;postName&quot; 		#新建文章</div><div class="line">hexo new page &quot;pageName&quot; 	#新建页面</div><div class="line">hexo generate 			#生成网页，可以在 public 目录查看整个网站的文件</div><div class="line">hexo server 			#本地预览，&apos;Ctrl+C&apos;关闭</div><div class="line">hexo deploy 			#部署.deploy目录</div><div class="line">hexo clean 			#清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</div><div class="line"></div><div class="line">简写：</div><div class="line">hexo n == hexo new</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure>
<h2 id="建立本地站点"><a href="#建立本地站点" class="headerlink" title="建立本地站点"></a>建立本地站点</h2><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。（文件夹不需要提前建好，会自行创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>新建文件夹目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy 		#需要部署的文件</div><div class="line">├── node_modules 	#Hexo插件</div><div class="line">├── public 		#生成的静态网页文件</div><div class="line">├── scaffolds 		#模板</div><div class="line">├── source 		#博客正文和其他源文件</div><div class="line">| ├── _drafts 		#草稿(刚开始没有)</div><div class="line">| └── _posts 		#文章</div><div class="line">├── themes 		#主题</div><div class="line">├── _config.yml 	#全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h2 id="启动站点"><a href="#启动站点" class="headerlink" title="启动站点"></a>启动站点</h2><p>执行 hexo server 启动站点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure>
<p>在浏览器中输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到站点了。</p>
<h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><p>编辑文件 <code>_config.yml</code> ，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repository: https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line">   branch: master</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：冒号后面要留 <strong>空格</strong>！！</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p><strong>方法1</strong>、<code>hexo n</code>创建新文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo n &quot;我的第一篇hexo博客&quot;</div><div class="line">INFO  Created: ~/hexo-blog/source/_posts/我的第一篇hexo博客.md</div></pre></td></tr></table></figure>
<p>然后用编辑器打开编辑即可。</p>
<p><strong>方法2</strong>、直接在 <code>source/_posts</code> 中新建一个md文件，进行编辑</p>
<p>在hexo-blog文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>然后在浏览器中输入<code>http://localhost:4000</code>就可以看到新加的文章了。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>执行 <code>hexo d</code> ，发现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">ERROR Deployer not found: git</div></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div><div class="line">hexo-site@0.0.0 /Users/xiaqunfeng/hexo-blog</div><div class="line">└── hexo-deployer-git@0.2.0</div></pre></td></tr></table></figure>
<p>再执行 <code>hexo d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ hexo d</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">On branch master</div><div class="line">nothing to commit, working tree clean</div><div class="line">Username for &apos;https://github.com&apos;: xiaqunfeng</div><div class="line">Password for &apos;https://xiaqunfeng@github.com&apos;: </div><div class="line">To https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</div><div class="line"> * [new branch]      HEAD -&gt; master</div><div class="line">Branch master set up to track remote branch master from https://github.com/xiaqunfeng/xiaqunfeng.github.io.git.</div><div class="line">INFO  Deploy done: git</div></pre></td></tr></table></figure>
<p>输入github的用户名和密码即可。此时，博客已经完全搭建起来了。</p>
<p>在浏览器中输入：<a href="https://xiaqunfeng.github.io/" target="_blank" rel="external">https://xiaqunfeng.github.io/</a> 即可访问。</p>
<p>预览如下： <img src="http://ojet8bprn.bkt.clouddn.com/hexo-new.png" alt=""></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>自己google一下hexo主题，选一个自己喜欢的，然后git clone下来。比如 Next 主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git</div></pre></td></tr></table></figure>
<p>然后打开_config.yml文件，替换其中的 <code>theme</code> 属性，默认为 <code>landscape</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态页面，生成的内容在public文件夹下</div><div class="line">$ hexo s #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试</div></pre></td></tr></table></figure>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>1、清理之前生成的内容，即public文件。</p>
<p><strong>注意</strong>：这一步必须要，不然有时因为缓存问题，服务器更新不了主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure>
<p>2、生成静态文件并部署到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g #生成静态文件</div><div class="line">$ hexo d #部署到github</div></pre></td></tr></table></figure>
<p>上面两个命令可以合并为一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d -g #在部署前先生成</div></pre></td></tr></table></figure>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><blockquote>
<p>update 2017.06.25。已购买域名，特来补充完善。</p>
</blockquote>
<p>1、购买域名</p>
<p>某乎<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="external">这里</a>有各种推荐，自己可以参考的看看。</p>
<p>godaddy地址: <a href="https://www.godaddy.com/" target="_blank" rel="external">https://www.godaddy.com</a></p>
<p>阿里云域名地址: <a href="http://wanwang.aliyun.com/" target="_blank" rel="external">http://wanwang.aliyun.com</a></p>
<p><strong> 总结 </strong><br>某乎上那些推荐都看了一遍，也琢磨了一下，最后发现，还是阿里云上的比较便宜，然后操作起来也比较方便，于是就在阿里云上买了。</p>
<p>我的域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">www.xiaqunfeng.cc</div></pre></td></tr></table></figure></p>
<p><strong> 关于域名选择 </strong></p>
<p>.com .cn .net .org 这种比较适合网站比较大的，当然，价格也贵一点，.com .cn 还需要网站备案什么的。现在一些其他后缀也很不错，比如 .cc .me .im .pro .top .info 等等，这些资料大家可以自己去查，就不细说了，强烈推荐 .me 和 .cc ，不过 .me 比 .cc贵，特别是买的时间越久或者续费都贵。我的 .cc 16块一年，哈哈，便宜，然后也挺好。</p>
<p>2、域名解析</p>
<p>域名解析-&gt;解析设置-&gt;添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，可以随便填一个，或者两个都填，线路就默认，CNAME记录值填你的github博客网址</p>
<p>我的如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/domain-hexo.jpg" alt="domain"></p>
<p>3、创建<code>CNAME</code>文件</p>
<p>这一步没做的话，打开网址访问不来博客。</p>
<p>在hexo 博客的根目录下source文件夹里创建CNAME文件，里面填上域名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cat CNAME</div><div class="line">xiaqunfeng.cc</div></pre></td></tr></table></figure>
<blockquote>
<p>注：如果里面填的是 www.xiaqunfeng.cc，那以后就只能用它来访问；如果填的是 xiaqunfeng.cc，那以后用 www.xiaqunfeng.cc 和 xiaqunfeng.cc 都可以访问。</p>
</blockquote>
<p>等待生效，一般几分钟就好了，然后就可通过域名浏览你的博客主页了。</p>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://xiaqunfeng.cc/baidu_verify_UL74CvGIA2.html</url>
      <content type="html"><![CDATA[UL74CvGIA2]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://xiaqunfeng.cc/googlea245ce220ad05de3.html</url>
      <content type="html"><![CDATA[google-site-verification: googlea245ce220ad05de3.html]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>http://xiaqunfeng.cc/about/index.html</url>
      <content type="html"><![CDATA[<p align="center"><strong>关注ceph、分布式存储、openstack、容器、机器学习</strong></p>

<blockquote>
<p>本博客为个人学习总结随笔，文中所有命令和代码都经过亲自试验。<br>有文章非特殊标注皆为原创，转载请注明出处。</p>
</blockquote>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果觉得该博客文章对您有所帮助，欢迎小额赞助和鼓励。 </p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://xiaqunfeng.cc/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
