<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[我的2022]]></title>
      <url>http://xiaqunfeng.cc/2022/02/07/my-2022/</url>
      <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="请输入密码" />
    <label for="hbePass">请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="d8d8e18c24e406abcd7197a5d62265b0957aa8e5252fbe9cb954ff60c9fc9b37">a842605e94d043811a4bcf371c5dcf5aec6c78c50a13d19cc311ae28390bdfbb4790862262a314c917c5653a3f4e4d7ff60699cc281dc797287ee9ecacc753ae983d68769d34401d62e87cf489698ca508342e60a70be86834dd5932b8d8841484994a2125fdf273cda298dd3a1d75a19512b3fc2a4c4569205e108c131ae9d8cb6df2483409085ebcf7d33b94450299cea4d31f6ddf214322cd7ef7ded24a243e6cb907d60389ffc296ac4605e752889468788ab59f5b6a72e906b86f13d01207d9faaf66e1a53dd5a485c2dcfb74bd822d32e5a7abbed4f329cda8d2e3555876c80555f88c498a23cfc7d950fd85a72f56d296dc0e8f2359468bd6ff1af0c20f237179053a67d1ad0071bceb642af1c4548166eac95bee20e3b69a4ee07ce87b71d4650673aa55e125af0500c85fae5b0fd78fc7f2a224d67ab9debfe96412239e9c2456043034f56ab281fe74c4713de24d98e40d015e57e2f15576754c9515fd519dcd60f8f74ab964b8182dd7a86dce800b0fac7106f59be901199752bf92c5174689c558a4d4ab36b6b3363e1bb6a076884d06d8c6ed6e11d3bf093825415ebd5ed6cbca517f4d0af8723597f03ee42588722249b9446cb272d9760d83778cadd7f4993132a55dbe7f0f6fbb6f06e2af22d8a0613f36bc55ced3871382fdcfd4a05e0261a8aaa766911ab94210101f9212600271049ec82c599ddfdeeb1f7a2964e2250894f66b021ac2e68bccc9a55354b62f35bbd063c6f67eb26af3ca34293a8e5aac80050e9caddf2a00fa4212e3cc386a640fbc586a78788c28738906288af07e2a14fba804dcdb0cfd7760ffdb6475bfd4afba81b927ce67814a1bac3b7a2f521bd7e01969e1410b3251ac5f841988efb6448373c785a4bbf0f10e424ce99f0c3c27d751bc5e440e8da2edf26711b9512c69b9fd04e9dbcbc0d299e6711673a97603892413bf0ab87483ffc1f96c45903d745328621d8068e9876f0522d29b2eb87e7d5f945ed158a4dbf95321764ea1423abf2a24aa1ee96050db9bbbfe919c385ac415e3294c5d43ae7500b7734a10f0560075ef35f771bc762e8b726d0b7997d1908556b4131b6c784d30cdd0071aead256dde6822fc9f817dbb502a0890abdb1c086684fdad4630d34b6697cac8fb78ac6bda02325eae48a7f5ac6ba1dd2240eb8fee6655ef987f963815725d2198523c77b77d13cf905a39dc7671c9fed9a751903a0c95568442fc7beff4d82c5a585b05ec6d0d65a5c6717de5423c62895640b8aef0059a4b95f6bf49dae0ee15d52c6a88bedde31bc591c479858f3061a0d8925a39ca6b1c289ff799abe40f3571a3b065927fa13bd91f2b37ced1a84c2b1a724ebc0be6f5c54596b0ab58b9c0f5ac7efeb5c4b4eb6b5498f520a3f96be774393c72179586cddb9e73dadea43b5be2dcd166f6b970e3bab18634cbbfc9a1d355afcbafd2fb9851d243fbbabe2791c8abeac367fd7aa190099e1dbd669b17f07092ef5ce0e00455e688ab1c9a3f3d84c1f7b4ee44d85526678e018bae077d2e6393e936e4196df91c10211c3a30b1e0b5804ac91b9ea8145c603acd52fe62ff5ead55591d89237c4dbdee9d93af6e08379f2aef72f19530da781a8e72798356359992448308535dced39dc4f7886361c2290652cdb0f58e186a219685be2efb31359f336de2f8a4e8bba577886fc49916b2c34cc948447475e33d88036bcd9877cc3a82567f22171733936842875d84229ff40ab5258ab40053dff85bf583c21193844c7c111b5464ccbb89a2b6612d83c134a9f4577c07029dda5238d7891fd424601cb3aae64d7ac2aeb849217691ab12130e0a8585582968f66c95154f926ee97c0de43a677534e8e8a1f63a8feab705e58df9fa927777029cf585a114d66d923848218195f691cb27a096cd3d586a91e43117bfc33d27035453689fed79d1df7fde43b026817406772f72e60989fbc5a5f119a1320e0a3bb2945f4669c69fff65ef7412a1e6676da7d253fae860dbc09c07702a7c9a7675a089f25175e432b151b00ff3b0a0fb70bae9ee927900c653758af53f08e381fb77dbbb83602c1bad975419f2013e81fa8427118c24b1ea3e21d067fe2fe82add0c474d428b173ed61b97d358c7dc8dd94cace4d1b7704b0db818496892b64685d88f4e8e8ee7281af53535e1a97423fcd3803e54a87651d90c406999aa6b6d792421176bd6fdd75c280c1160dfc3bb9b7f8468458ff7258b90e23d9a43c168903d2d0f210621d96ba17bb3085ad5397d87213677d0e03408f59ef68ddcdebb0545d268cd090ca498604e31812e22a53ee22ec7f2adf94312bd5805640dd9aecaa7a20cfe0e7a1fe66a2b1313136e75228a0104abcfb4ec9cfc908a807c74ebe282d7cf57c1005bc921f374442fee25957c9a81d3b976f60f42646ce56a0108205424ae307fab52acf20b3e73ca9cbebb584e7b1bed8fd9b7b34448c79c70bfec097bbb0f9fa4bd893f975c5aa94eb2b09913e10a61353086c5f7b91b39dc02376bc0e4680417d5c71d277eb3cc0189ce09981c2aaef44609656aeee3a6bdceea81ca644f48cdde7e9d4989298c00ab2881fc4ff4df69b475fc0cc46a3a525bf60a04898423a21e5063f8f6eade9a0a0918c27be545eda5a2d1fef82b239f6c90be097f6e95de80e7120cd545cfb9ed867cb3e4203daecfcda91fd508fba0be1e774706759a42b9fbae1d27b41897f5f9bff06cf0f4d5720cead93cb009a6c6fb8cb04e03606a208078d1a4ebde1b14fb5cba86fd0783f7dd4de10d5f6c5bac3ed2a575d263ff0b0b5ccf13a43202241c09d2e46132122f32887c83446a3a77f72891153f907e5c09c49344161595323eb02315be88190166ce858a85da99211f10623cf446b04b9a20f1b086f548914d58235c314ea16cfafdfdd78498be38282592be4f3300e48e488a7df083da7c3dacb23cc6a34e6c4149b1bbe614183d20de8c6e73906ae73b429ebfcc2cad9a8c650c2b6e8eae452de38e3e994e6eb2da371aac0d868298c61cd0146b66151dacf952eab0afb2e0c4fd8bfa4117f055f00e02d98b150f7440f0adcfcd4e7007839a2f79d1ca5aa0b57a8b0b9541d1c555a1f242725e01c386e1cc20cca2ed6a4fd808ce5e52832e5adedf395f86b90c4b082e2408a8fbb403b54808d697fe3ae320c0ae548b68942b420e044388ba197f36d999fe6ae1112462f73fe5a4db8528c22c8969e68595ce10a0a2fd976ccf5df1b9d0832111f1d9741617ab5964f4b7945afa87f6981ab4a5c732146b09e5be50a1bd1b4348fc317563de50150ea6eb0fac73d9111609c28ca1a1bb44699ab1e91ac87dbf842cf6fedfd6a9d93dd6f0982723ae337c4249ad7771106d18c3246d1a03310947ecbee80a6206cbe5e9316205fcdb7586f3a85239c6d0cbf76395e2f6a330698f8a28ae03432d02ee917d6d4eb8019077ac556cb5c4f8000098b10aea26ea0c45597f9d4cc2856971cc3008c872e38e9bd381ddf53dddd6d0d14ef15d69ea22021a5d0b3d39e33975ea8ed21adede6f00ae60185700ff573439117e994181b5bc56e96a40e06ee046c324f77c56f81aa4df041919211c36fdf319b53b37e8539a4972bdf024cd39f90783e786e9990369d44677c43757bcad7ec1d85161616c2c08bf93522ab2559a89f736962142310c3831d488f381465a519dd18c0968b5ac5cedac5e4c642aaffc0e00eb2054b96658cf623ba2b8c4826426d5ee1d157e69adee30569efb1236df8d6a32db68fb82d206c640329faf817eabb3734d7651c530c21bed038e87c73bb6439949900fa9e9bbba1e82f40f6aa33a28916b778fc4971958ebfa41a9bebb84afadf79f6b7b5949f1b9e1af373302034986751bd2bd3ff640add6df6f48af839c4cd9b2af441164d06c75bddb8ab66e7f583c22030b0cb2e211ba356fd9ce524c0b976ebecb280ddd0291c6126cf81ef25c38cf42eb6fbb9d7239b7c8760cb47d7e9e0ba12d01bd705fb64ad6bb1134b866d23b2f752fa581af5fbf50b806ba8c19b2e4c261d48cffd1156382768caebfaeece5aafdeb82f07513d0009474069f2785ef319ddb5e19344e5d541876e9561647be8dfb5b568f75ff46f722c3fd5ce69f6c3d4ada9ca4e1f8f41b1506ae3d819c9771d5a3ab973286917f8fba806718437eb3f9bcd57798e16dea47bc8037c18d1397447410a1816ba25a8dc786b7aac89173836c00a1381411fcc8131c346df5eb0e0dbe1954f930cf823d640bed6ee8c8f59ea7af4e6951611a72a664c5f513028eadecb617a9041d58d20819c7b155f03f66a510db7353b99b562edb5b2322dfc7aee7f191396cbbe68523b358ea5ad92b7b3ce3db096be5f725abbff11afd59777f71bdf15e4a0b58a85510226b30f9c9fa73dd03d786a13563f164ac3c902a6a18cfe84a638d7cccff63a49e10ef5ff62b63dcf1ca07c9126173d3369530c24d1b55604c285a1f4fec4c5448679d739e489329a40211f4f7b4bbdb0febb7d0b8afb5a3165fc99ae539490a71c4d58c07ff1fa295edbef3f2def3c1c6142909af722cde0de40ea81ba2a8daceea7eff3549dff31eaa142da431f67e16c3dbba54b0ede805e24db959808ecc198ddda5cfb88dc877cb1118dfb65ce3f27be091fc440330d5ec086a799b33eaf440240d40413a5ffc427be23f134b04cffaf5c95cceaf55bb2372d3dcea0c14166a81b8c9f93ecdfe9abaed0520b096157c2938d99d128ec028e64ae9b23b08968abfa9ef86d64e355ac0c819508cafe9af591e5abd9a1430c51d4bb973481312211e00eddc5411abf5f5bedb86e0d57be4c32553053e0fe4a365fc10acce6c343df9c39f235b4c2905b46aa435750d579220d3bfa07fe463745db386fa4f7c9c29a4c1386d9836d19db2d2e1b173cb17e0e04098634ac8ceb9f1f58c17942134cc95f9414822e8c4f71662212ff46a05320ccf739232e155b92abd2d2dca350bff159912336a3dcf2e0315fc274210577cf093106aebca8ad77107fe1b6948c019feaf820f6f0f7286f14f599c59755124dccb4a84bed654974e3176af7ed516f760f328b87995909d256590fb816f0c477f20a667ca299248ab6bd49f5ec37410065bd3cbbc817556c8ff5467052007e4b81865e6d92aee7a2c5b81ad31034a16af8529cebdfcc2372e5ddfa90e21a84731440ebefc3d44f04563ac85a2cf9d71cd0fe85f7a777a604bf36496288cb7a7e7d291165d3f24b99e3917c15cd59b3136800c0c08b8b10dd5aab73d9c8283335be28909a3c6e81e9aace7cc0f01216cb6929e5b349e4020f62ab9782b3e36391652ab34a83a048676d419924091968b268bd63f96e1d1267131d11a675693b99fc3fc88efe2fa736d131e9f6a783d9cb9914b336defca66e9c1174c2289981d2b50772359de7c0df3a258247c5480319de796e8ba823599a9b3dc99065a114d69d5da7f732e9ae5d20f8235c79d2f8b1892fd73f05876a67b787abe601e59ae9bbe0b879c84cad0d4da9c21189ba136f8e05075a5c4b97b61e1cff47b7191274d41a49bb5eeb8d66d359f15efcd9fdf9983a3a9ebca2064292f31e4384ca7ca6c090970fb4332e91b9ed15f6127d78c21ebcc038b01ffa97af19996c2a4d7a1eb343255f8e3e1d08a21302b27bdf4494957b45014a1de4794a758b6f672ba15c5b2202d971a40548c84683e098c9c8558aa7123a066836ba27b6d86b725f88fd6a349f34863ec4738edc3ae35495e7a28d956c7003d49ab607b994c6b209d70fba309c1dbd99ef89514f42d000754b7d1c027ac88557b1e0cd18b5f61a69eb028295d314c64d4df29c54cff11c8773efb36d8bd62d8c608f7e920fc12b423fc585de1cb3f93a9eb037ef77769b465cc0cae8eb21db031c99ba3b30be8d6aee9a2e1290494a08d66303c68364d49ea57b252bedf7e82635b3faf65b3e676f894f440b5820a3f298fb8178ffae6c3b8a45cb310833f04ed5ebbb5c7462810c4bdd1ab36e90b3efadc6bcea09d52b84e9f77ba25a87597a8c32b2207c3b96a6c2ac3d0a4dc39a27f6ddcce055bb92a55b81fb29586ae7945065d48c52290ec36cf3f34bc193f15dae44527455c41c02ffc4e0558bca9af29fc71171cac9cab9becc9cfec915eb7cf4906e56f3b1171f2a602c0b7770b5f10c09f5909d3f9e703428f58b8bd3038faaac1e329e5a93c02fc18995bcb487b56ccd621658707bd119eca9b1722b0df2f832046a69a69367205ea21f3c0a637947cd8a233a677b4295e3eb4fba249846d2c7f7292dafb3da2af4d934b59b9dc587cf5c1135528dab3fea592489c53f3bdaf1c11d62e27542e5d5829793d6578e44582f2ab45112f12b628f8a45bc40201e053432e4eddbfe1e63ddc0c4ddb7fd12e6a92bd09c3b458acaed5a7d34401dfe65399d3aee3fc34d7a91a5cfef65171822da73c8157d35910e95c7c9c54b2719744e38effb92aa60d308a045ee40db5909f340afd3129b945fd4c9c41f735427ca5460a9b906d00dabc47377a4aa5cb6b7e81800b1f18b2e14de51c1da2068807ce4d5e8f5f1e551f696f38ab5dcfb08ad52469c11ac9b6bc624a85045e534c0db579b21</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Goodbye Shanghai]]></title>
      <url>http://xiaqunfeng.cc/2020/04/25/goodbye-shanghai/</url>
      <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="请输入密码" />
    <label for="hbePass">请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e116be20b6d9f1c9e46c64f289aa8bd91cd5543e960ce7bdf5f3386ee8025df7">02ce6e6bbfad4422e984e850895f678e65155a61a9851ec6045a74e9ab6f16f5d5d89ba7fc8c0a993c8f1d16be543f2673d3da1e79fe34bfd454797bc36eebf3c056b6e402d2aeee1f407c45363d04a480045bcde1bf0bdadceafc216adeaf2dc272e86db289c28bc94515eb3564cf1ae4470583e13e60b3c05a6db42d7b8d171ce5fc23eee9a1ec6202e95a665e4a76ad9d7bb5fb2c01b4441a7019368e5de6d33c8ddec4a89f6be37d0e0bba8a83728e04ea56a916653cdaedc06578572f8317389a12e856f37b034e187758603bf08167fc78f81f85a22d95d88b4f696a0008e3e1099f2461f3785195a7d571006744bbf73ffb7b127c2e9ab1e9cdbb18edaf9ee837810f05857179c1e69a21417158782852e7686067654f0edb9db166f9c916fc5752145ba5e7c2115d1a32c6bf3747dca5e39b73a58591ecfa9246c2d58c7ac9965709366a8870d3778bb18c00b2e2f64a0e26965f673a7806fe6d43b19138efb7dddb03434ff44f3e3315024eb33f53fb809bbc97b70b47989d9f2d965ad60617bd3f11a2f5517ff0712f298fe6c1f238d4513b2424a32a70fe56eeba0b7c84af1d247f4ec77cc39a34e65203474dc0b39f9574c6ac4146175cbf1ae68880aa77213ae3f0324cf8f53dba7978e4116a98b0a851a3bb52f1cd44599a48419ebcb6fa2603859a7021f1095db67e69b6f19467f60fd93739914aced854b3e77c08213ba101f3a384fd28377c5eec3b61e5cf4825feb637c159124345a5cf3545a24607e2ac34fde016fdf731c89d88233c6850de1e81c25e556c099a661630e2d0d54bef2d5e76095d68dde74c6523b4faa3672eabf2f6849cc703d196e3b4daacb37a60e2d35c0d14811de4d0e7dcf4483fb5535a9ca4f47e5db9977f4468d66636375bf69101351b3f1da9d0801adb700c8bf65b7e3dc4c59ede21f3c3769e001b1bed4dc514e53377805b307314d076bc30258e47101c95bd199d673a751dbb3358c071f320d9d1bcf571dc874a3b7af495724380d215d7878eba7ce299990b3aeff52c802a9f122dfb33330490d052b3e9deb5dd6035e029ec33ced91ed73acfcf9088da0e58a2ae5d944fe544a8abdcdd21262cfeef67a11fdf035777923cd157a29e699389155dcc82112beb140c99813a17330943016a5e453ee1841de5a1dc9f9fa5061c60b42f2d58f6776707be658c414bd0af194d2fdc949dae83347d4d8765e09a3c3513c41e049e6eba9e7a4bb0011f45c619b250281533bbe333f25504a97769e7579b706ac8b3f83ba63059f7ca4be6a6907f10cb17e786b3766be85b709a77f8c843b190fd51272a6ebfe0270a65d88f345a7d631e8a08e1484cd6fed96cdaa3d34e738c656db995eaaffe886e193b39d7aadba87c4ff9509515b849919b914c1ca8cd9d55d12f435cf5a99ef10d862dfca1988ef376b97720cc2434782120389578f5a6a47fff01603fab924d41c8035f7dc599dc95b0ee702dfafe486d00e844e1c5d29a0bac19c270dc968d6894fc875b5d2d20ca5e386be50f3a942f3cb6f3d526c2fac790a68a1011407b1b77ebb25fa2c53c34e7d9b9fea7373c97f89b056d0872e03c6824859292e50379df447a73120f506746556ce4745761838d548bdebcf207bf96f6731e7a3c14962a3356142b7d8f153e59378ddd882a8c7596493fddd1a60519f6f2084eeee2d01983dfc6b882b792b5713b6d8f7c1abb386e5aa4ea38f0b8a38cac5ca33c954afaa190a2bb2e19a2ef4f4543d1eefb02c9b726bf6a2e855573b13037f350e3401d2627ccbf533ebce9bd0616c8f342b7cc3ed82569270b840a8a26f195e4f919bfe93af38ee4fa09da0c580774fe70db182ca5316e638eca484e9629c8e35a016764e2cc6dd3b90efe8eed8c7aa85d0a27159db0ef7c7f132f9e76fac3ed1feb8c8568f1bb15aceb5de9d72eb2366874d29a3d788a1a35dd24f18b7c4f733029069fd843847fde9251dbd41100f60e98baf86c3794ff01819b971ae4cae5661de57580750d7284259431f5ae72fe86940c5d6e6f144223c6b01e424d70ba196298cecdd0b63d089ae3d2698e3bf6b58a667942fcf8dfdee50968394164d7f347e4b33c4eaf5149366ccb7f4866ebe21f9656c41fc5e8e6a801d6ecec4419b0d04735d79983d51592e489fe3d61f9c8a427683ba03642245d5dafe1fd0f166ea9609e43afa4981a84c8939eb961d5a47432b7ac6826cbda99ea47e89014f918720907ab254ab57ffec25d921b735ac8e0ad6826c31f9c1fe962983ed40ec2e2988711f99083608e1b62673c2f619802fced8b01a17ea76a17851ac933b18bc59ce90de3a715e9da052973955e3ff08006dd973d60d8bf6418338af4064eb3fc20e1ba80a44fef57a6</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践二十二：jwt]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-22-jwt/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第二十二篇，JWT认证。<br><a id="more"></a></p>
<h2 id="传统session认证"><a href="#传统session认证" class="headerlink" title="传统session认证"></a>传统session认证</h2><p>认证流程</p>
<ul>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证后在当前对话（session）保存相关数据。</li>
<li>服务器向返回sessionId，写入客户端 Cookie。</li>
<li>客户端每次请求，需要通过 Cookie，将 sessionId 回传服务器。</li>
<li>服务器收到 sessionId，验证客户端。</li>
</ul>
<p>问题</p>
<ul>
<li>session保存在服务端，客户端访问高并发时，服务端压力大。</li>
<li>扩展性差，服务器集群，就需要 session 数据共享。</li>
</ul>
<h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><p>JWT(全称：JSON Web Token)，在基于HTTP通信过程中，进行身份认证。</p>
<p>认证流程</p>
<ul>
<li>客户端通过用户名和密码登录服务器；</li>
<li>服务端对客户端身份进行验证；</li>
<li>服务器认证以后，生成一个 JSON 对象，发回客户端；</li>
<li>客户端与服务端通信的时候，都要发回这个 JSON 对象；</li>
<li>服务端解析该JSON对象，获取用户身份；</li>
<li>服务端可以不必存储该JSON（Token）对象，身份信息都可以解析出来。</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>头部（header) 声明类型以及加密算法；</li>
<li>负载（payload) 携带一些用户身份信息；</li>
<li>签名（signature) 签名信息。</li>
</ul>
<h3 id="Header（头部）"><a href="#Header（头部）" class="headerlink" title="Header（头部）"></a>Header（头部）</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；</li>
<li><code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</li>
</ul>
<h3 id="Payload（负载）"><a href="#Payload（负载）" class="headerlink" title="Payload（负载）"></a>Payload（负载）</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<h3 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<ul>
<li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。</li>
<li>然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<blockquote>
<p>参考链接：<a href="https://www.jianshu.com/p/6e4371d74248" target="_blank" rel="noopener">https://www.jianshu.com/p/6e4371d74248</a></p>
</blockquote>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;msg&quot;: &quot;验证成功&quot;,</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6iZEIj3fQ.uEJSJagJf1j7A55Wwr1bGsB5YQoAyz5rbFtF&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，token是用<code>&quot;.&quot;</code>分隔的一个完整的长字符串，由上面提到的三个结构组成。</p>
<h2 id="springboot-jwt"><a href="#springboot-jwt" class="headerlink" title="springboot+jwt"></a>springboot+jwt</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置JWT"><a href="#配置JWT" class="headerlink" title="配置JWT"></a>配置JWT</h3><p>1、新建<code>JwtTokenTemplate</code>工具模板</p>
<p>封装jwt，方便调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config.jwt;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.User;</span><br><span class="line">import io.jsonwebtoken.Claims;</span><br><span class="line">import io.jsonwebtoken.Jwts;</span><br><span class="line">import io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">//import org.springframework.security.core.userdetails.User;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.time.Instant;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config.jwt</span><br><span class="line"> * @ClassName: JwtTokenTemplate</span><br><span class="line"> * @Description: jwt工具模板</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-10 December</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class JwtTokenTemplate implements Serializable &#123;</span><br><span class="line">    // 密钥</span><br><span class="line">    private static final String SECRET = &quot;secret&quot;;</span><br><span class="line">    private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;</span><br><span class="line">    // 超时时间，单位（毫秒）</span><br><span class="line">    private static final long EXPIRATION_TIME = 60 * 1000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建 token</span><br><span class="line">     * @param userDetails</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(16);</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setClaims(claims)  // 自定义属性</span><br><span class="line">                .setExpiration(new Date(Instant.now().toEpochMilli() + EXPIRATION_TIME))  // 过期时间</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, SECRET)  // 签名算法及密钥</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获得 token 的 body</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Claims getClaimsFromToken(String token) &#123;</span><br><span class="line">        Claims claims = Jwts.parser()</span><br><span class="line">                .setSigningKey(SECRET)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证 token</span><br><span class="line">     * @param token</span><br><span class="line">     * @param userDetails</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean validateToken(String token, UserDetails userDetails) &#123;</span><br><span class="line">        User user = (User) userDetails;</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        return (username.equals(user.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * token 是否过期</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Boolean isTokenExpired(String token) &#123;</span><br><span class="line">        Date expiration = getExpirationDateFromToken(token);</span><br><span class="line">        return expiration.before(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从 token 里获取用户名</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getUsernameFromToken(String token) &#123;</span><br><span class="line">        String username = getClaimsFromToken(token).getSubject();</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从 token 里得到过期时间</span><br><span class="line">     * @param token</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Date getExpirationDateFromToken(String token) &#123;</span><br><span class="line">        Date expiration = getClaimsFromToken(token).getExpiration();</span><br><span class="line">        return expiration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：User是自己定义的model，不是 org.springframework.security.core.userdetails.User</p>
</blockquote>
<p>2、新建<code>JwtTokenFilter</code>过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config.jwt;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line">import org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line">import org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config.jwt</span><br><span class="line"> * @ClassName: JwtTokenFilter</span><br><span class="line"> * @Description: 过滤器</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-11 December</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class JwtTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    public static final String HEADER_STRING = &quot;Authorization&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenTemplate jwtTokenTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        String token = request.getHeader(HEADER_STRING);</span><br><span class="line">        if (null != token) &#123;</span><br><span class="line">            String username = jwtTokenTemplate.getUsernameFromToken(token);</span><br><span class="line">            if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123;</span><br><span class="line">                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);</span><br><span class="line">                if (jwtTokenTemplate.validateToken(token, userDetails)) &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(</span><br><span class="line">                            userDetails, null, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(</span><br><span class="line">                            request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：HEADER_STRING 是后面输 token时需要添加的字段名</p>
</blockquote>
<h3 id="配置Security"><a href="#配置Security" class="headerlink" title="配置Security"></a>配置Security</h3><p>在原有的基础上重载 configure 接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.csrf().disable()</span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()</span><br><span class="line">            .antMatchers(&quot;/auth/login&quot;).permitAll()</span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line">    http.addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    http.headers().cacheControl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public JwtTokenFilter authenticationTokenFilterBean() &#123;</span><br><span class="line">    return new JwtTokenFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@Override</span><br><span class="line">public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">    return super.authenticationManagerBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 jwt 的过滤操作放到 security 配置中。</p>
<h3 id="授权参数"><a href="#授权参数" class="headerlink" title="授权参数"></a>授权参数</h3><p>获取授权时，需要用户名和密码信息，这些信息通过 JwtParam 结构传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: JwtParam</span><br><span class="line"> * @Description: 授权参数</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-11 December</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class JwtParam &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="controller接口"><a href="#controller接口" class="headerlink" title="controller接口"></a>controller接口</h3><p>实现了两个接口：</p>
<ul>
<li>auth/login：获取token</li>
<li>auth/jwt：正常请求接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.config.jwt.JwtTokenTemplate;</span><br><span class="line">import com.example.demo.model.dto.JwtParam;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line">import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line">import org.springframework.security.core.Authentication;</span><br><span class="line">import org.springframework.security.core.AuthenticationException;</span><br><span class="line">import org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: JwtController</span><br><span class="line"> * @Description: 授权接口</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-11 December</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;auth&quot;)</span><br><span class="line">public class JwtController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenTemplate jwtTokenTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(value = &quot;login&quot;)</span><br><span class="line">    public String login(@RequestBody JwtParam body) throws AuthenticationException &#123;</span><br><span class="line">        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(body.getUsername(), body.getPassword());</span><br><span class="line">        Authentication authentication = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(body.getUsername());</span><br><span class="line">        return jwtTokenTemplate.generateToken(userDetails);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;jwt&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello Jwt&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1、校验前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &apos;http://localhost:8080/auth/jwt&apos;</span><br></pre></td></tr></table></figure>
<p>返回403错误，提示未授权</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jwt-test-1.png-xtdf" alt="1"></p>
<p>2、获取授权的token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &apos;http://127.0.0.1:8080/auth/login&apos; --header &apos;Content-Type: application/json&apos; -d &apos;&#123;&quot;username&quot;: &quot;夏天&quot;, &quot;password&quot;: &quot;abc123&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的用户名和密码来自mysql数据库</p>
</blockquote>
<p>返回token信息</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jwt-test-2.png-xtdf" alt="2"></p>
<p>3、使用返回的token访问第一步的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &apos;http://localhost:8080/auth/jwt&apos; --header &apos;Authorization:eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiLlpI_lpKkiLCJleHAiOjE1NzY0ODYwODl9.JKQmDkCmY2_qK249slOqbC1p7WCz0oLKgSf8djN-vYPu1D00Jlrg031vqLZQqACgvCJRRzCcQqTrQEn41mZLkg&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：token前有字段Authorization</p>
</blockquote>
<p><img src="http://oow6unnib.bkt.clouddn.com/jwt-test-3.png-xtdf" alt="3"></p>
<p>4、如果超时了，会报错，需要重新申请token</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jwt-test-4.png-xtdf" alt="4"></p>
<p>我这里设置的超时时间为一分钟，一分钟后再次执行，会报错。</p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践二十一：security]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-21-security/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第二十一篇，security登录认证。<br><a id="more"></a></p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>目前Web开发常用的两个安全框架：Apache Shiro 和 Spring Security。</p>
<p>Spring Security本身是Spring社区的一个子架构，相对而言对Spring有更好的支持。</p>
<p>Spring Security官方文档：<a href="https://docs.spring.io/spring-security/site/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/</a></p>
<p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。Spring Security 功能的实现主要是靠一系列的过滤器链相互配合来完成的。</p>
<p>安全框架基本概念：</p>
<ul>
<li>“认证” （Authentication）：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li>“授权”（Authorization） ：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。</li>
</ul>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h2><p><img src="http://oow6unnib.bkt.clouddn.com/security-1.png-xtdf" alt="1"></p>
<p>访问之前已经实现的接口：<code>http://localhost:8080/user/all</code>，发现需要登录</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/security-2.png-xtdf" alt="2"></p>
<p>输入用户 user，密码为上面控制台输出的密码，登录后才能执行访问的接口。</p>
<p>所以，可以看到，只需要引入了<code>Spring-Security</code>的依赖，它就开始生效，并且保护我们的接口。</p>
<p>问题就是，它的用户名只能是user，并且密码是通过日志打印在控制台。</p>
<p>我们期望能通过数据来访问我们的用户并且判断登录，新增SecurityConfig配置文件以及UserDetailsServiceImpl实现即可。</p>
<p>在实现上面两个接口之前，先了解一下两个Security自带的接口类：UserDetails和UserDetailsService</p>
<h2 id="UserDetails和UserDetailsService"><a href="#UserDetails和UserDetailsService" class="headerlink" title="UserDetails和UserDetailsService"></a>UserDetails和UserDetailsService</h2><p>1、UserDetails</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line">public interface UserDetails extends Serializable &#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String getPassword();</span><br><span class="line"></span><br><span class="line">    String getUsername();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonLocked();</span><br><span class="line"></span><br><span class="line">    boolean isCredentialsNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明了七个接口，功能依次如下：</p>
<ul>
<li>获取用户的权限集合</li>
<li>获取用户密码</li>
<li>获取用户名</li>
<li>判断账号是否过期</li>
<li>判断账号是否锁定</li>
<li>判断用户的认证是否过期</li>
<li>判断当前要不过户是否禁用</li>
</ul>
<p>2、UserDetailsService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package org.springframework.security.core.userdetails;</span><br><span class="line"></span><br><span class="line">public interface UserDetailsService &#123;</span><br><span class="line">    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个方法的声明，就是通过用户名去查找用户信息。SpringSecurity回调<code>UserDetails#loadUserByUsername</code>去获取用户，但是它不知道用户信息存在哪里，所以定义成接口，让使用者去实现。</p>
<p>这里新建一个类<code>UserDetailsServiceImpl</code>来实现该接口。</p>
<h2 id="UserDetailsServiceImpl"><a href="#UserDetailsServiceImpl" class="headerlink" title="UserDetailsServiceImpl"></a>UserDetailsServiceImpl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config;</span><br><span class="line"></span><br><span class="line">import com.example.demo.dao.UserDAO;</span><br><span class="line">import com.example.demo.model.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.service.impl</span><br><span class="line"> * @ClassName: UserDetailsServiceImpl</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-09 December</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UserDetailsServiceImpl implements UserDetailsService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">        User user = userDAO.selectByUsername(username);</span><br><span class="line">        System.out.println(&quot;loadUserByUsername &quot; + username);</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例中，我把用户信息存在了数据库中，所以需要调用UserDAO的方法去访问数据库查询用户信息。</p>
<h2 id="SecurityConfig"><a href="#SecurityConfig" class="headerlink" title="SecurityConfig"></a>SecurityConfig</h2><p>配置<code>UserDetailsService</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line">import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config</span><br><span class="line"> * @ClassName: SecurityConfig</span><br><span class="line"> * @Description: security配置</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-09 December</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置UserDetailsService 和 PasswordEncoder 加密器</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">        auth.eraseCredentials(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，通过方法 configureGlobal 来配置UserDetailsService，以及PasswordEncoder 加密器来对密码进行加密。</p>
<h2 id="改造user实体类"><a href="#改造user实体类" class="headerlink" title="改造user实体类"></a>改造user实体类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.security.core.GrantedAuthority;</span><br><span class="line">import org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line">import org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model</span><br><span class="line"> * @ClassName: User</span><br><span class="line"> * @Description: 用户</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-12 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class User implements UserDetails &#123;</span><br><span class="line">    //private static final long serialVersionUID = 121121L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123; &quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&quot; + username +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, password=&quot; + password + &quot; &#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 暂时没用到权限，返回默认admin的权限</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        return AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 UserDetails 接口即可。</p>
<h2 id="新增用户信息"><a href="#新增用户信息" class="headerlink" title="新增用户信息"></a>新增用户信息</h2><p>新增一个测试用例，通过调用DAO接口，向数据库里插入两条记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import com.example.demo.dao.UserDAO;</span><br><span class="line">import com.example.demo.model.User;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo</span><br><span class="line"> * @ClassName: UserTest</span><br><span class="line"> * @Description: User类的测试</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-08 December</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void insert() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;的风&quot;);</span><br><span class="line">        user.setSex(&quot;男&quot;);</span><br><span class="line">        user.setAge(16);</span><br><span class="line"></span><br><span class="line">        //user.setPassword(bCryptPasswordEncoder.encode(&quot;abc123&quot;));</span><br><span class="line">        user.setPassword(passwordEncoder.encode(&quot;456&quot;));</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        userDAO.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>密码分别用 PasswordEncoder 和 BCryptPasswordEncoder 来进行加密。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/security-3.png-xtdf" alt="3"></p>
<p>插入完如下</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/security-4.png-xtdf" alt="4"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动工程，输入<code>http://localhost:8080/user/all</code> 或者任意其他已实现的接口，都会跳到登录界面，如之前的截图。</p>
<p>然后输入如下两组用户名密码：<code>夏天 abc123</code> 或 <code>的风 456</code>，即可成功登录，并执行接口指令。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践二十：freemarker]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-20-freemarker/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第二十篇，freemarker模板引擎。<br><a id="more"></a></p>
<h2 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h2><p>FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p>
<p>官方中文文档：<a href="http://freemarker.foofun.cn/" target="_blank" rel="noopener">在线手册</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/freemaker.png-xtdf" alt="1"><br>Freemarker主要卓做静态页面或是页面展示，是主流模板引擎之一。</p>
<blockquote>
<p>在所有采用网页静态化手段的网站中，FreeMarker使用的比例大大的超过了其他的一些技术。HTML静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以使用FreeMarker将HTML静态化。比如一些网站的公用设置信息，这些信息基本都是可以通过后台来管理并存储在数据库中，这些信息其实会大量的被前台程序调用，每一次调用都会去查询一次数据库，但是这些信息的更新频率又会很小，因此也可以考虑将这部分内容进行后台更新的时候进行静态化，这样就避免了大量的数据库访问请求，提高了网站的性能。</p>
</blockquote>
<p>特性：</p>
<ul>
<li>FreeMarker被设计用来生成HTML Web页面，特别是基于MVC模式的应用程序</li>
<li>虽然FreeMarker具有一些编程的能力，但通常由Java程序准备要显示的数据，由FreeMarker生成页面，通过模板显示准备的数据（如下图）</li>
<li>FreeMarker不是一个Web应用框架，而适合作为Web应用框架一个组件。</li>
<li>FreeMarker与容器无关，因为它并不知道HTTP或Servlet；FreeMarker同样可以应用于非Web应用程序环境。</li>
</ul>
<p>优点：</p>
<p>1、不能编写java代码，可以实现严格的mvc分离</p>
<p>2、性能非常不错</p>
<p>3、对jsp标签支持良好</p>
<p>4、内置大量常用功能，使用非常方便</p>
<p>5、宏定义（类似jsp标签）非常方便</p>
<p>6、使用表达式语言</p>
<p>缺点：</p>
<p>1、不是官方标准</p>
<p>2、需要学习freemaker模板语言的一些语法</p>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  freemarker:</span><br><span class="line">    request-context-attribute: req</span><br><span class="line">    suffix: .ftl</span><br><span class="line">    content-type: text/html</span><br><span class="line">    enabled: true</span><br><span class="line">    cache: false</span><br><span class="line">    template-loader-path: classpath:/templates/</span><br><span class="line">    charset: UTF-8</span><br><span class="line">    settings:</span><br><span class="line">      number_format: &apos;0.##&apos;</span><br></pre></td></tr></table></figure>
<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>使用之前已经有的User，就不重写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 121121L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123; &quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&quot; + username +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, age=&quot; + age + &quot; &#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>使用thymeleaf同一个controller，在里面新增一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/freemaker&quot;)</span><br><span class="line">public String freemaker(Model model) &#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setAge(18);</span><br><span class="line">    user.setUsername(&quot;夏天的风&quot;);</span><br><span class="line">    user.setSex(&quot;男&quot;);</span><br><span class="line">    user.setId(888l);</span><br><span class="line">    model.addAttribute(&quot;user&quot;, user);</span><br><span class="line">    return &quot;index&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="index-ftl"><a href="#index-ftl" class="headerlink" title="index.ftl"></a>index.ftl</h2><p>在<code>templates</code>文件夹下新建文件<code>index.ftl</code>。freemark文件的后缀名是<code>ftl</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot;</span><br><span class="line">          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Freemarker&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt; 欢迎$&#123;user.username&#125;</span><br><span class="line">    &lt;#if user.sex==&quot;男&quot;&gt;</span><br><span class="line">        先生</span><br><span class="line">     &lt;#else&gt;</span><br><span class="line">        女士</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">    的光临！</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt; TA是一个</span><br><span class="line">    &lt;#if (user.age &lt; 12)&gt;</span><br><span class="line">        儿童</span><br><span class="line">    &lt;#elseif (user.age &gt; 18)&gt;</span><br><span class="line">        成年</span><br><span class="line">    &lt;#else&gt;</span><br><span class="line">        青年</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：比较数据大小时，要加括号</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动项目，访问：<code>http://localhost:8080/freemaker</code></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/freemaker-demo.png-xtdf" alt="2"></p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十九：thymeleaf]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-19-thymeleaf/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十九篇，thymeleaf模板引擎。<br><a id="more"></a></p>
<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf 是Java服务端的模板引擎，与传统的JSP不同，前者可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。</p>
<p>Thymeleaf支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p>
<p>优点：</p>
<ul>
<li>语法简洁，功能强大。</li>
<li>静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调。</li>
<li>springboot官方推荐方案。</li>
</ul>
<p>缺点：</p>
<ul>
<li>模板必须符合xml规范</li>
<li>性能差</li>
</ul>
<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="thymeleaf配置"><a href="#thymeleaf配置" class="headerlink" title="thymeleaf配置"></a>thymeleaf配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  thymeleaf:</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    mode: html</span><br><span class="line">    cache: false</span><br></pre></td></tr></table></figure>
<h2 id="controler"><a href="#controler" class="headerlink" title="controler"></a>controler</h2><p>新建IndexController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: IndexController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-08 December</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @GetMapping(&quot;/thymeleaf&quot;)</span><br><span class="line">    public String hello(@RequestParam(defaultValue = &quot;夏天的风&quot;, required = false) String name, Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;name&quot;, name);</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里使用的是<code>@Controller</code>，不是<code>@RestController</code></p>
</blockquote>
<h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>在<code>resource</code>目录下新建<code>templates</code>文件夹并且在该目录下新建文件<code>index.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Start&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;欢迎进入XqfSpringBoot&lt;/h1&gt;</span><br><span class="line">    &lt;h1 th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>语法：</strong></p>
<ul>
<li>获取变量的值<code>${...}</code></li>
<li>链接<code>@{...}</code></li>
<li>文本替换<code>th:text=${...}</code>（这里可以替换id值，class值以及内容等）</li>
<li>判断语句<code>th:if　　th:unless　　th:switch</code>等</li>
<li>遍历<code>th:each</code></li>
</ul>
<p><img src="http://oow6unnib.bkt.clouddn.com/thymeleaf.png-xtdf" alt="1"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>访问<code>http://localhost:8080/thymeleaf</code></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/thymeleaf-demo.png-xtdf" alt="2"></p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十八：redis topic]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-18-rabbitmq-topic/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十八篇，rabbitmq topic模式</p>
<a id="more"></a>
<h2 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a>topic模式</h2><p>模式简介</p>
<p>TODO</p>
<h2 id="配置topic队列和交换器"><a href="#配置topic队列和交换器" class="headerlink" title="配置topic队列和交换器"></a>配置topic队列和交换器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 定义 topics 队列</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Bean</span><br><span class="line">   public Queue topicA() &#123;</span><br><span class="line">       return new Queue(&quot;topic.a&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Queue topicB() &#123;</span><br><span class="line">       return new Queue(&quot;topic.b&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Queue topicC() &#123;</span><br><span class="line">       return new Queue(&quot;topic.c&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 定义一个名为 topicExchange 的交换机</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Bean</span><br><span class="line">   TopicExchange topicExchange() &#123;</span><br><span class="line">       return new TopicExchange(&quot;topicExchange&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 将定义的 topics 队列与 topicExchange 交换机绑定</span><br><span class="line">    * 注：需要填写 routingKey</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Bean</span><br><span class="line">   public Binding bindingTopicExchangeWithA() &#123;</span><br><span class="line">       return BindingBuilder.bind(topicA()).to(topicExchange()).with(&quot;topic.msg&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Binding bindingTopicExchangeWithB() &#123;</span><br><span class="line">       return BindingBuilder.bind(topicB()).to(topicExchange()).with(&quot;topic.#&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Bean</span><br><span class="line">   public Binding bindingTopicExchangeWithC() &#123;</span><br><span class="line">       return BindingBuilder.bind(topicC()).to(topicExchange()).with(&quot;topic.*.z&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们配置了三个队列名、一个topic交换机，并且将这三个队列绑定到了topic交换器上。</p>
<p>关于队列的 routingKey：</p>
<ul>
<li>topicA的key为<code>topic.msg</code>，该队列只会接收包含<code>topic.msg</code>的消息</li>
<li>topicB的key为<code>topic.#</code>，该队列只会接收<code>topic</code>开头的消息</li>
<li>topicC的key为<code>topic.*.z</code>，该队列只会接收<code>topic.XXX.z</code>这样格式的消息</li>
</ul>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>在<code>RabbitProducer</code>添加topic生产方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * topic生产方法</span><br><span class="line"> */</span><br><span class="line">public void topic1Send() &#123;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    String dateString = new SimpleDateFormat(&quot;YYYY-mm-DD hh:MM:ss&quot;).format(date);</span><br><span class="line">    System.out.println(&quot;[topic.msg] send msg: &quot; + dateString);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数1：交换机名</span><br><span class="line">     * 参数2：routeKey，此处为 topic.msg</span><br><span class="line">     * 参数3：发送的消息</span><br><span class="line">     */</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.msg&quot;, dateString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void topic2Send() &#123;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    String dateString = new SimpleDateFormat(&quot;YYYY-mm-DD hh:MM:ss&quot;).format(date);</span><br><span class="line">    System.out.println(&quot;[topic.good.msg] send msg: &quot; + dateString);</span><br><span class="line"></span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.good.msg&quot;, dateString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void topic3Send() &#123;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    String dateString = new SimpleDateFormat(&quot;YYYY-mm-DD hh:MM:ss&quot;).format(date);</span><br><span class="line">    System.out.println(&quot;[topic.bb.z] send msg: &quot; + dateString);</span><br><span class="line"></span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.bb.z&quot;, dateString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了三个生产方法，三个routingKey分别为：</p>
<ul>
<li><code>topic.msg</code>：会被A和B队列匹配</li>
<li><code>topic.good.msg</code>：会被B队列匹配</li>
<li><code>topic.bb.z</code>：会被C和B队列匹配</li>
</ul>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>创建三个消费者，来消费三个队列</p>
<p>消费者A：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitconsumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: rabbitconsumer</span><br><span class="line"> * @Package: com.example.rabbitconsumer</span><br><span class="line"> * @ClassName: TopicAConsumer</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-01 December</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;topic.a&quot;)</span><br><span class="line">public class TopicAConsumer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接受消息后的处理方法</span><br><span class="line">     * @param msg</span><br><span class="line">     */</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;[Topic -&gt; A] recieved message: &quot; + msg);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者B和C同A。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、在生产者工程中新增测试用例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTopicSend() &#123;</span><br><span class="line">    producer.topic1Send();</span><br><span class="line">    producer.topic2Send();</span><br><span class="line">    producer.topic3Send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产三种不同routingKey的消息</p>
<p>运行：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-topic-1.png-xtdf" alt="1"></p>
<p>三条消息发送成功。</p>
<p>2、查看mq</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-topic-2.png-xtdf" alt="2"></p>
<p>可以看到，队列A和C中，都只有一条消息，队列B中有三条消息，符合预期。</p>
<p>3、运行消费者</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-topic-3.png-xtdf" alt="3"></p>
<p>可以看到，五条消息都已被消费，其中B消费了三条，A和C分别消费了一条。</p>
<p>4、查看mq</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-topic-4.png-xtdf" alt="4"></p>
<p>队列里已没有消息。</p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> mq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十七：redis fanout]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-17-rabbitmq-fanout/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十七篇，rabbitmq fanout模式。</p>
<p>前一篇写的是rabbitmq的简单模式，只有一个生产者和消费者。<br><a id="more"></a></p>
<h2 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h2><p>Publish/Subscribe模式，也叫fanout广播模式，只要跟它绑定的队列都会通知并且接受到消息。</p>
<h2 id="配置队列和交换机"><a href="#配置队列和交换机" class="headerlink" title="配置队列和交换机"></a>配置队列和交换机</h2><p>在<code>RabbitConfig</code>中配置一下fanout模式的队列跟交换机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义 fanout 队列</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public Queue fanoutA() &#123;</span><br><span class="line">    return new Queue(&quot;fanout.a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue fanoutB() &#123;</span><br><span class="line">    return new Queue(&quot;fanout.b&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Queue fanoutC() &#123;</span><br><span class="line">    return new Queue(&quot;fanout.c&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义名为 fanoutExchange 的交换器</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">FanoutExchange fanoutExchange() &#123;</span><br><span class="line">    return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将定义的队列与 fanoutExchange 交换机绑定</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public Binding bindingExchangeWithA() &#123;</span><br><span class="line">    return BindingBuilder.bind(fanoutA()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Binding bindingExchangeWithB() &#123;</span><br><span class="line">    return BindingBuilder.bind(fanoutB()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Binding bindingExchangeWithC() &#123;</span><br><span class="line">    return BindingBuilder.bind(fanoutC()).to(fanoutExchange());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们配置了三个队列名、一个fanout交换机，并且将这三个队列绑定到了fanout交换器上。</p>
<p>只要我们往这个交换机生产新的消息，那么这三个队列都会收到。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>在<code>RabbitProducer</code> 中添加fanout的生产方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * fanout生产方法</span><br><span class="line"> */</span><br><span class="line">public void fanoutSend() &#123;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    String dateString = new SimpleDateFormat(&quot;YYYY-mm-DD hh:MM:ss&quot;).format(date);</span><br><span class="line">    System.out.println(&quot;[Fanout] send msg: &quot; + dateString);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数1：交换机名</span><br><span class="line">     * 参数2：routerKey，暂时为空</span><br><span class="line">     * 参数3：发送的消息</span><br><span class="line">     */</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;, &quot;&quot;, dateString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>在消费者工程中新建三个消费者类</p>
<p>消费者A：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitconsumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: rabbitconsumer</span><br><span class="line"> * @Package: com.example.rabbitconsumer</span><br><span class="line"> * @ClassName: FanoutAConsumer</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-12-01 December</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;fanout.a&quot;)</span><br><span class="line">public class FanoutAConsumer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接受消息后的处理方法</span><br><span class="line">     * @param msg</span><br><span class="line">     */</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;[Fanout -&gt; A] recieved message: &quot; + msg);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者B和C同A。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、在生产者工程中添加添加测试用例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFonoutSend() &#123;</span><br><span class="line">    producer.fanoutSend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-fanout-1.png-xtdf" alt="1"></p>
<p>向交换机发送了一条消息。</p>
<p>2、查看mq</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-fanout-2.png-xtdf" alt="2"></p>
<p>可以看到，在和交换机连接的三个队列里，都已经有一条消息在里面。</p>
<p>3、运行消费者</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-fanout-3.png-xtdf" alt="3"></p>
<p>看到三个消费者分别消费了队列里的数据</p>
<p>4、查看队列</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-fanout-4.png-xtdf" alt="4"></p>
<p>可以看到，队列里原先有的一条数据被消费了。</p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> mq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十六：RabbitMq]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-16-rabbitmq/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十五篇，rabbitmq。<br><a id="more"></a></p>
<h2 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h2><p>MQ作为消息队列中间件，经常会被我们用到各种环境中，例如：异步处理、削峰、解耦等。RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），轻量、高性能、健壮、可伸缩，是经常被使用的MQ之一。</p>
<p>在spring中可以借助Spring AMQP模块直接使用rabbitmq。Spring AMQP包含两部分内容：spring-amqp和spring-rabbit。spring-amqp不依赖任何特定AMQP代理实现，只为提供基于AMQP的通用抽象。目前，spring针对spring-amqp的通用抽象，只基于rabbitmq做了实现，也就是这里的spring-rabbit。</p>
<p>AMQP协议中的核心思想就是生产者和消费者隔离，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由Exchange来接收，然后Exchange按照特定的策略转发到Queue进行存储。同理，消费者也是如此。Exchange 就类似于一个交换机，转发各个消息分发到相应的队列中。s</p>
<p>在spring中使用rabbitmq非常简单，利用提供的AmqpTemplete或者RabbitTemplete就能够很好的完成任务。springboot中类似，配置一下即可使用。</p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="创建生产者工程"><a href="#创建生产者工程" class="headerlink" title="创建生产者工程"></a>创建生产者工程</h3><p>创建springboot工程，选择spring for rabbitmq依赖</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-1.png-xtdf" alt="1"></p>
<p>创建完工程，可以查看pom.xml，发现依赖以及添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在 application.yml 中添加rabbitmq配置（都是默认值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    addresses: 127.0.0.1</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure>
<h3 id="rabbitmq配置类"><a href="#rabbitmq配置类" class="headerlink" title="rabbitmq配置类"></a>rabbitmq配置类</h3><p>创建一个名为string的队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitproducer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: rabbitproducer</span><br><span class="line"> * @Package: com.example.rabbitproducer</span><br><span class="line"> * @ClassName: RabbitConfg</span><br><span class="line"> * @Description: rabbitmq配置类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-26 November</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitConfg &#123;</span><br><span class="line"></span><br><span class="line">    public final static String STRING = &quot;string&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义名为 string 的队列</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue string() &#123;</span><br><span class="line">        return new Queue(STRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h3><p>创建生产者：RabbitProducer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitproducer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: rabbitproducer</span><br><span class="line"> * @Package: com.example.rabbitproducer</span><br><span class="line"> * @ClassName: RabbitProducer</span><br><span class="line"> * @Description: rabbitmq消息的生产者</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-26 November</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RabbitProducer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void stringSend() &#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        String dateString = new SimpleDateFormat(&quot;YYYY-mm-DD hh:MM:ss&quot;).format(date);</span><br><span class="line">        System.out.println(&quot;[Queue -&gt; String] send msg: &quot; + dateString);</span><br><span class="line"></span><br><span class="line">        this.rabbitTemplate.convertAndSend(RabbitConfg.STRING, dateString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AmqpTemplate</code> 或 <code>RabbitTemplate</code>是spring amqp模块提供给我们用于消息的发送与接受的模块，直接使用即可。</p>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>调用生产者，生产消息并发出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitproducer;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitproducerApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitProducer producer;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testStringSend() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            producer.stringSend();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发20条消息，每秒发一条。</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="创建消费者工程"><a href="#创建消费者工程" class="headerlink" title="创建消费者工程"></a>创建消费者工程</h3><p>同上</p>
<h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.example.rabbitconsumer;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: rabbitproducer</span><br><span class="line"> * @Package: com.example.rabbitproducer</span><br><span class="line"> * @ClassName: StringConsumer</span><br><span class="line"> * @Description: string队列的消费者</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-26 November</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;string&quot;)</span><br><span class="line">public class StringConsumer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitmqTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接受消息后的处理方法</span><br><span class="line">     * @param msg</span><br><span class="line">     */</span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void recieved(String msg) &#123;</span><br><span class="line">        System.out.println(&quot;[Queue -&gt; string] recieved message: &quot; + msg);</span><br><span class="line">        try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@RabbitListener用作异步消息监听</li>
<li>@RabbitHandler 代表此方法为接受到消息后的处理方法</li>
</ul>
<p>@RabbitListener支持多个属性，例如：containerFactory设置容器工厂，queues设置监听队列，concurrency设置消费者并发数量等。</p>
<blockquote>
<p>假如我们想让某个监听手动ack，可以配置此参数containerFactory，为该监听配置独立的容器工厂，虽然我们可以通过spring.rabbitmq.listener.simple.acknowledge-mode或者spring.rabbitmq.listener.direct.acknowledge-mode配置手动ack，但它是全局共享的。</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、运行生产者工程的测试类</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-2.png-xtdf" alt="2"></p>
<p>2、查看rabbitmq</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-3.png-xtdf" alt="3"></p>
<p>可以看到，string队列里已经有20条数据ready</p>
<p>3、启动消费者工程</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-4.png-xtdf" alt="4"></p>
<p>启动后就开始消费队列 string 里的消息</p>
<p>4、查看rabbitmq</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/rabbitmq-5.png-xtdf" alt="5"></p>
<p>可以看到，string队列已经为空了，队列里的数据全部消耗完毕。</p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> mq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十五：elasticsearch]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-15-elasticsearch/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十五篇，集成elasticsearch<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为ElasticSearch（以下简称ES）全文搜索引擎在实际大数据项目的应用；ES的底层是开源库 <a href="https://lucene.apache.org/" target="_blank" rel="noopener">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。ES 是 Lucene 的封装，java开发，提供了 REST API 的操作接口，开箱即用，是目前全文搜索的首选；</p>
<p>springboot整合elasticsearch常用的方式有以下三种</p>
<ul>
<li>1，<strong>Java API</strong><br>这种方式基于TCP和ES通信，官方已经明确表示在ES 7.0版本中将弃用TransportClient客户端，且在8.0版本中完全移除它,所以不提倡。</li>
<li>2，<strong>REST Client</strong><br>上面的方式1是基于TCP和ES通信的(而且TransPort将来会被抛弃……)，官方也给出了基于HTTP的客户端REST Client(推荐使用)，官方给出来的REST Client有Java Low Level REST Client和Java Hight Level REST Client两个，前者兼容所有版本的ES，后者是基于前者开发出来的，只暴露了部分API，待完善</li>
<li>3，<strong>spring-data-elasticsearch</strong><br>除了上述方式，Spring也提供了本身基于SpringData实现的一套方案spring-data-elasticsearch</li>
</ul>
<p>这里打算采用方式三来集成ES，因为这种方式spring为我们封装了常见的es操作，和使用jpa操作数据库一样方便。</p>
<p>jpa只需要简单继承JpaRepository就可以实现对数据库表的crud操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;UserBean, Long&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>spring-data-elasticsearch同样，只要继承ElasticsearchRepository就可以实现常见的es操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface UserESRepository extends ElasticsearchRepository&lt;UserBean, Long&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>我想指定我自己本机的版本号时，一直不成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;7.4.2&lt;/version&gt;</span><br></pre></td></tr></table></figure>
<p>目前用的springboot版本为2.2.0，当前能安装的最新版es为6.8.3。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/es-springboot-1.png-xtdf" alt="1"></p>
<p>看了一些文章，都说如果elasticsearch的版本是7.x版本，目前是无法使用spring-boot-starter-data-elasticsearch封装的客户端的。</p>
<table>
<thead>
<tr>
<th>spring data elasticsearch</th>
<th>elasticsearch</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.2.x</td>
<td>6.5.0</td>
</tr>
<tr>
<td>3.1.x</td>
<td>6.2.2</td>
</tr>
<tr>
<td>3.0.x</td>
<td>5.5.0</td>
</tr>
<tr>
<td>2.1.x</td>
<td>2.4.0</td>
</tr>
<tr>
<td>2.0.x</td>
<td>2.2.0</td>
</tr>
<tr>
<td>1.3.x</td>
<td>1.5.2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>意思是新版本的SpringBoot 2的spring-boot-starter-data-elasticsearch中支持的Elasticsearch版本是2.X，<br>但Elasticsearch实际上已经发展到6.X和7.X版本了，为了更好的使用Elasticsearch的新特性，<br>所以弃用了spring-boot-starter-data-elasticsearch依赖，而改为直接使用Spring-data-elasticsearch。</p>
</blockquote>
<p>但是文章：<a href="https://blog.csdn.net/chengyuqiang/article/details/86135795" target="_blank" rel="noopener">https://blog.csdn.net/chengyuqiang/article/details/86135795</a> 里用spring-boot-starter-data-elasticsearch成功实践了 es 6.x版本。于是我启了一个 6.5.1 的es，还是不行。</p>
<p>参考的文章是：</p>
<p><a href="https://www.jianshu.com/p/0481963ce528" target="_blank" rel="noopener">https://www.jianshu.com/p/0481963ce528</a></p>
<p><a href="https://www.jianshu.com/p/8f8f0ee83da0" target="_blank" rel="noopener">https://www.jianshu.com/p/8f8f0ee83da0</a></p>
<p>但是在运行的时候，接口返回的都是空，而且集群里也没有相应数据。</p>
<p>Spring-data-elasticsearch: <a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-elasticsearch</a></p>
<p>后续有空再研究。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><ul>
<li>@Id：表示是主键。</li>
<li>@Accessors(chain = true) ：set方法可以链式调用</li>
<li>@Document：<ul>
<li>indexName –&gt; 索引库的名称，建议以项目的名称命名，就相当于数据库DB</li>
<li>type –&gt; 类型，建议以实体的名称命名Table ，就相当于数据库中的表table</li>
<li>Document –&gt; row 就相当于某一个具体对象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.EqualsAndHashCode;</span><br><span class="line">import lombok.ToString;</span><br><span class="line">import lombok.experimental.Accessors;</span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line">import org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: Good</span><br><span class="line"> * @Description: 商品实体类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-24 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">@Accessors(chain = true)</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">@Document(indexName = &quot;goods&quot;, type = &quot;computer&quot;)</span><br><span class="line">public class Good &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String desc;</span><br><span class="line">    private Integer number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jpa构建文档"><a href="#jpa构建文档" class="headerlink" title="jpa构建文档"></a>jpa构建文档</h3><p>将文档库继承ElasticsearchRepository，操作elasticSearch与操作spring data jpa的方法完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.repository;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.dto.Good;</span><br><span class="line">import org.springframework.data.domain.Page;</span><br><span class="line">import org.springframework.data.domain.Pageable;</span><br><span class="line">import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.repository</span><br><span class="line"> * @ClassName: GoodRepository</span><br><span class="line"> * @Description: 文档库</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-24 November</span><br><span class="line"> */</span><br><span class="line">public interface GoodRepository extends ElasticsearchRepository&lt;Good, String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @description: 根据商品名称查询商品信息</span><br><span class="line">     * @param name</span><br><span class="line">     * @param pageable</span><br><span class="line">     * @return: org.springframework.data.domain.Page&lt;com.example.demo.model.dto.Good&gt;</span><br><span class="line">     * @date: 2019-11-24</span><br><span class="line">     */</span><br><span class="line">    Page&lt;Good&gt; findByName(String name, Pageable pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写测试方法，分别测试添加 删除 修改 查询 方法</p>
<p><code>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</code>这个注解是表示按照方法名的顺序来排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.dto.Good;</span><br><span class="line">import com.example.demo.repository.GoodRepository;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.FixMethodOrder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runners.MethodSorters;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo</span><br><span class="line"> * @ClassName: GoodRepositoryTest</span><br><span class="line"> * @Description: 商品信息测试</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-24 November</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@FixMethodOrder(MethodSorters.NAME_ASCENDING)</span><br><span class="line">public class GoodRepositoryTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private GoodRepository goodRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        Good good = new Good();</span><br><span class="line">        good.setId(&quot;8&quot;)</span><br><span class="line">                .setName(&quot;Mac Pro 18&quot;)</span><br><span class="line">                .setDesc(&quot;苹果笔记本2018款&quot;)</span><br><span class="line">                .setNumber(3);</span><br><span class="line">        Good result = goodRepository.save(good);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">        System.out.println(&quot;Add success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void select() &#123;</span><br><span class="line">        Good result = goodRepository.findById(&quot;8&quot;).get();</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">        System.out.println(&quot;Select success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        Good good = goodRepository.findById(&quot;8&quot;).get();</span><br><span class="line">        good.setNumber(88);</span><br><span class="line"></span><br><span class="line">        Good result =  goodRepository.save(good);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">        System.out.println(&quot;Update success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        goodRepository.deleteById(&quot;8&quot;);</span><br><span class="line">        System.out.println(&quot;Delete success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一运行就出错。后续再研究。</p>
<p>TODO</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十四：redis缓存mysql]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-14-redis-cache/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十四篇，redis缓存mysql数据。<br><a id="more"></a></p>
<h2 id="redis数据缓存管理"><a href="#redis数据缓存管理" class="headerlink" title="redis数据缓存管理"></a>redis数据缓存管理</h2><p>实现数据缓存，如果缓存中没有数据，则从数据库查询，并且写入redis缓存，如果redis缓存中有数据，则直接从redis中读取，同时删除更新等操作也需要维护缓存。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、在 <code>application.yml</code> 中配置包日志级别为debug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">    com.example.demo.dao: debug</span><br></pre></td></tr></table></figure>
<p>将DAO接口所在的包日志级别设置为debug，这样sql语句就会被打印出来。</p>
<blockquote>
<p>root: info 也可以省略，默认整个工程的log级别就是info的</p>
</blockquote>
<p>2、配置缓存管理器</p>
<p>修改之前的redis配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 配置缓存管理器</span><br><span class="line"> * @param redisConnectionFactory</span><br><span class="line"> * @return: org.springframework.cache.CacheManager</span><br><span class="line"> * @date: 2019-11-13</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">    // 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span><br><span class="line">    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line"></span><br><span class="line">    // 设置缓存的默认过期时间，也是使用Duration设置</span><br><span class="line">    config = config.entryTtl(Duration.ofMinutes(1))</span><br><span class="line">            // 设置 key为string序列化</span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))</span><br><span class="line">            // 设置value为json序列化</span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()))</span><br><span class="line">            // 不缓存空值</span><br><span class="line">            .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">    // 设置一个初始化的缓存空间set集合</span><br><span class="line">    Set&lt;String&gt; cacheNames = new HashSet&lt;&gt;();</span><br><span class="line">    cacheNames.add(&quot;timeGroup&quot;);</span><br><span class="line">    cacheNames.add(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">    // 对每个缓存空间应用不同的配置</span><br><span class="line">    Map&lt;String, RedisCacheConfiguration&gt; configMap = new HashMap&lt;&gt;();</span><br><span class="line">    configMap.put(&quot;timeGroup&quot;, config);</span><br><span class="line">    configMap.put(&quot;user&quot;, config.entryTtl(Duration.ofSeconds(120)));</span><br><span class="line"></span><br><span class="line">    // 使用自定义的缓存配置初始化一个cacheManager</span><br><span class="line">    RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">            // 一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span><br><span class="line">            .initialCacheNames(cacheNames)</span><br><span class="line">            .withInitialCacheConfigurations(configMap)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置了一个缓存管理器，在<code>springboot2</code>中配置缓存管理是新的api也就是<code>builder</code>模式构建。</li>
<li>通过<code>@EnableCaching</code> 开启缓存注解。</li>
<li>注：在redistemplate中的配置的key，value序列化方法并不会生效，需要在<code>RedisCacheConfiguration</code> 定义的config中单独配置</li>
</ul>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>为User实例建表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(32) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(255) DEFAULT NULL,</span><br><span class="line">	`sex` VARCHAR(32) DEFAULT NULL,</span><br><span class="line">	`age` int(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT into user VALUES (1, &apos;张三&apos;, &apos;男&apos;, 18);</span><br><span class="line">INSERT into user VALUES (2, &apos;李四&apos;, &apos;女&apos;, 16);</span><br></pre></td></tr></table></figure>
<h3 id="接口代码"><a href="#接口代码" class="headerlink" title="接口代码"></a>接口代码</h3><p>依次创建下面各层</p>
<ul>
<li>controller: UserController.java</li>
<li>service: UserService.java  UserServiceImpl.java</li>
<li>dao: UserDAO.java</li>
<li>mapper: UserMapper.xml</li>
</ul>
<p>具体方法详见第一篇文章：TODO，就不再详述了。</p>
<p>五个Rest接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/add&quot;)</span><br><span class="line">    public User addUser(@RequestBody User user) &#123;</span><br><span class="line">        return userService.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(&quot;/update&quot;)</span><br><span class="line">    public User updateUser(@RequestBody User user) &#123;</span><br><span class="line">        return userService.updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(value = &quot;/id/&#123;id&#125;&quot;)</span><br><span class="line">    public Boolean deleteUser(@PathVariable long id) &#123;</span><br><span class="line">        return userService.removeUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;/id/&#123;id&#125;&quot;)</span><br><span class="line">    public User getUser(@PathVariable long id) &#123;</span><br><span class="line">        return userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @GetMapping(&quot;/all&quot;)</span><br><span class="line">    public List&lt;User&gt; getAll() &#123;</span><br><span class="line">        return userService.getAllUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p>1、获取所有用户</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-1.png-xtdf" alt="1"></p>
<p>2、获取用户1的信息</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-2.png-xtdf" alt="2"></p>
<p>3、新增用户</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-3.png-xtdf" alt="3"></p>
<p>4、更新用户信息</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-4.png-xtdf" alt="4"></p>
<p>5、删除用户</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-5.png-xtdf" alt="5"></p>
<p>所有接口都测试成功。可以接下来的操作了。</p>
<h2 id="使用caching"><a href="#使用caching" class="headerlink" title="使用caching"></a>使用caching</h2><h3 id="设置缓存"><a href="#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h3><p>常用的缓存注解</p>
<ul>
<li><code>@Cacheable</code> – 表明对应方法的返回结果可以被缓存，首次调用后，下次就从缓存中读取结果，方法不会再被执行了。</li>
<li><code>@CachePut</code> – 更新缓存，方法每次都会执行</li>
<li><code>@CacheEvict</code> – 清除缓存，方法每次都会执行</li>
</ul>
<p>因为主要的业务逻辑在服务层实现，一般会把缓存注解加在服务层的方法上。service层使用缓存代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @CacheEvict 在这里调用时会从缓存中删除对应key的数据</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@CacheEvict(value = &quot;user&quot;, key = &quot;#p0&quot;, condition = &quot;#result eq true&quot;)</span><br><span class="line">@Override</span><br><span class="line">public Boolean removeUser(Long id) &#123;</span><br><span class="line">    return userDAO.removeById(id) == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @CachePut 修改数据，会把数据放入缓存中</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;, unless = &quot;#user eq null&quot;)</span><br><span class="line">@Override</span><br><span class="line">public User updateUser(User user) &#123;</span><br><span class="line">    userDAO.update(user);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Cacheable 先从缓存中读，如果没有再从DB中读取，同时将数据缓存在redis中</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Cacheable(value = &quot;user&quot;, key = &quot;#root.args[0]&quot;, unless = &quot;#result eq null&quot;)</span><br><span class="line">@Override</span><br><span class="line">public User getUser(Long id) &#123;</span><br><span class="line">    return userDAO.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对读取、更新和删除加了cache方法，分别对应常用的三个注解。get方法使用的 @Cacheable，首次调用后被加入缓存。更新和清除则每次都被调用。</p>
<blockquote>
<p>当然，更新方法也可以使用 @CacheEvict，原始数据被更新了，废弃缓存数据。</p>
</blockquote>
<p>关键词：</p>
<ul>
<li>key 缓存在redis中的key</li>
<li>value key对应的值</li>
<li>unless 表示条件表达式成立的话不执行缓存操作</li>
<li>condition 与unless相反，只有表达式为真才会执行</li>
</ul>
<h3 id="key的选取"><a href="#key的选取" class="headerlink" title="key的选取"></a>key的选取</h3><p>key属性是用来指定Spring缓存方法的返回结果时对应的key，该属性支持SpringEL表达式。所以可以通过Spring的EL表达式来指定自定义 key。</p>
<p>1、直接使用 “#参数名” 或者 “#p参数index”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)</span><br><span class="line">public User find(Integer id) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</span><br><span class="line">public User find(Integer id) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#user.id&quot;)</span><br><span class="line">public User find(User user) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#p0.id&quot;)</span><br><span class="line">public User find(User user) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>2、通过root对象生成key</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>methodName</td>
<td>root对象</td>
<td>当前被调用的方法名</td>
<td>root.methodName</td>
</tr>
<tr>
<td>method</td>
<td>root对象</td>
<td>当前被调用的方法</td>
<td>root.method.name</td>
</tr>
<tr>
<td>target</td>
<td>root对象</td>
<td>当前被调用的目标对象</td>
<td>root.target</td>
</tr>
<tr>
<td>targetClass</td>
<td>root对象</td>
<td>当前被调用的目标对象类</td>
<td>root.targetClass</td>
</tr>
<tr>
<td>args</td>
<td>root对象</td>
<td>当前被调用的方法的参数列表</td>
<td>root.args[0]</td>
</tr>
<tr>
<td>caches</td>
<td>root对象</td>
<td>当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache</td>
<td>root.caches[0].name</td>
</tr>
<tr>
<td>argument name</td>
<td>执行上下文</td>
<td>当前被调用的方法的参数，如findById(Long id)，我们可以通过#id拿到参数</td>
<td>user.id</td>
</tr>
<tr>
<td>result</td>
<td>执行上下文</td>
<td>方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的beforeInvocation=false）</td>
<td>result</td>
</tr>
</tbody>
</table>
<h3 id="cache测试"><a href="#cache测试" class="headerlink" title="cache测试"></a>cache测试</h3><p>1、get</p>
<p>请求：<code>http://localhost:8080/user/id/1</code></p>
<p>日志：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-6.png-xtdf" alt="6"></p>
<p>看到了 selectById 的 DEBUG 日志。再次执行该请求，没有日志产生，说明直接从redis读取了。</p>
<p>查看redis：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-7.png-xtdf" alt="7"></p>
<p>可以看到，user 1 已被缓存在redis中。</p>
<blockquote>
<p>注：长时间不对缓存数据进行操作，缓存会自动被淘汰</p>
</blockquote>
<p>2、update</p>
<p>执行update操作，发现缓存也更新了</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-8.png-xtdf" alt="8"></p>
<p>3、delete</p>
<p>删除 id=9 的user，数据也随之从redis中删除</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-9.png-xtdf" alt="9"></p>
<p>4、Sql日志如下</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-cache-10.png-xtdf" alt="10"></p>
<p>以上！</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十三：redis]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-13-redis/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十三篇，redis数据缓存。<br><a id="more"></a></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>springboot 2.x版本中默认客户端是用 lettuce实现的。</p>
<p><strong>Lettuce</strong> 是 一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection,它利用Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。</p>
<blockquote>
<p>在 springboot 1.5.x版本的默认的Redis客户端是 Jedis实现的。<strong>Jedis</strong> 在实现上是直连 redis server，多线程环境下非线程安全，除非使用连接池，为每个 redis实例增加物理连接。</p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # REDIS配置</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password:</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8</span><br><span class="line">        max-idle: 8</span><br><span class="line">        min-idle: 0</span><br></pre></td></tr></table></figure>
<p>配置了本地redis，其他参数都是默认值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3><p>配置redis的key跟value的序列化方式。默认使用的<code>JdkSerializationRedisSerializer</code>，且模板只能支持 <code>RedisTemplate&lt;String,String&gt;</code>，只能存入字符串。所以需要自定义 RedisTemplate ，设置序列化器，这样可以很方便的操作实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line">import com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.springframework.boot.autoconfigure.AutoConfigureAfter;</span><br><span class="line">import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config</span><br><span class="line"> * @ClassName: RedisConfig</span><br><span class="line"> * @Description: redis配置</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-12 November</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span><br><span class="line">        Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        //使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Configuration</code> 设置该类为配置类</li>
<li><code>@AutoConfigureAfter(RedisAutoConfiguration.class)</code> 让这个配置类在内置的配置类之后再进行配置，保证自定义配置类生效，且不会被覆盖</li>
</ul>
<blockquote>
<p>注意：方法名一定要叫<code>redisTemplate</code>  因为<code>@Bean</code>注解是根据方法名配置这个bean的name</p>
</blockquote>
<h3 id="定义实体类"><a href="#定义实体类" class="headerlink" title="定义实体类"></a>定义实体类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: User</span><br><span class="line"> * @Description: 用户</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-12 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 121121L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123; &quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&quot; + username +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, age=&quot; + age + &quot; &#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>implements Serializable</code>：该类对象是可序列化的</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写了一段测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.dto.User;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo</span><br><span class="line"> * @ClassName: UserRedisTest</span><br><span class="line"> * @Description: User类的Redis测试</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-12 November</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserRedisTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void redisTest() &#123;</span><br><span class="line">        // 往redis存储普通数据</span><br><span class="line">        String key = &quot;name&quot;;</span><br><span class="line">        redisTemplate.opsForValue().set(key, &quot;summer&quot;);</span><br><span class="line"></span><br><span class="line">        // 从redis中读取数据</span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(key);</span><br><span class="line">        System.out.println(&quot;redis中：key=&quot; + key + &quot;, value=&quot; + value);</span><br><span class="line"></span><br><span class="line">        // 往redis存入实体类数据</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setId(1L);</span><br><span class="line">        user.setUsername(&quot;summer&quot;);</span><br><span class="line">        user.setSex(&quot;male&quot;);</span><br><span class="line">        user.setAge(18);</span><br><span class="line"></span><br><span class="line">        String userKey = &quot;summer&quot;;</span><br><span class="line">        redisTemplate.opsForValue().set(userKey, user);</span><br><span class="line"></span><br><span class="line">        // 从redis读取实体类</span><br><span class="line">        User userValue = (User) redisTemplate.opsForValue().get(userKey);</span><br><span class="line">        System.out.println(&quot;redis中：key=&quot; + userKey + &quot;, value=&quot; + userValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进行了两次读写操作：</p>
<p>1、存入普通的String数据并读取</p>
<p>2、存入User数据并读取</p>
<p>Redis其它类型所对应的操作方式</p>
<ul>
<li>opsForValue： 对应 String（字符串）</li>
<li>opsForZSet： 对应 ZSet（有序集合）</li>
<li>opsForHash： 对应 Hash（哈希）</li>
<li>opsForList： 对应 List（列表）</li>
<li>opsForSet： 对应 Set（集合）</li>
</ul>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="http://oow6unnib.bkt.clouddn.com/redis-lettuce-1.png-xtdf" alt="1"></p>
<p>可以看到，存入的数据都已被正常读取出来。</p>
<h3 id="查看redis"><a href="#查看redis" class="headerlink" title="查看redis"></a>查看redis</h3><p><img src="http://oow6unnib.bkt.clouddn.com/redis-lettuce-2.png-xtdf" alt="2"></p>
<p>可以看到，代码里写的两个key都已存入redis中。并且，对象在redis中的值是以json方式存储的。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装redis]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/redis-install/</url>
      <content type="html"><![CDATA[<p>在mac上安装redis，并进行简单的操作。<br><a id="more"></a></p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><a href="https://redis.io/" target="_blank" rel="noopener">redis</a>是一个开源的内存NOSQL数据库，在web开发中主要被用于数据缓存。一般在高并发的情况下，web服务器接受访问时，直接从数据库加载是慢的，需要把常用数据缓存到redis中，提高加载速度和并发能力。</p>
<h2 id="安装redis服务器"><a href="#安装redis服务器" class="headerlink" title="安装redis服务器"></a>安装redis服务器</h2><p>官网文档：<a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">https://redis.io/topics/quickstart</a></p>
<p>redis 的默认端口是 6379</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">$ tar xzf redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure>
<p>移动到 /usr/local 下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ sudo mv redis-5.0.5 /usr/local</span><br></pre></td></tr></table></figure>
<p>2、修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis-5.0.5</span><br><span class="line">▶ vim redis.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>查找字段 requirepass，把password 替换成电脑的开机密码 (把注释符”#”去掉)</li>
<li>查找字段 bind，把IP改为自己的服务器地址（默认127.0.0.1，如果是本地就不用修改）</li>
</ul>
<p>3、编译测试 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ sudo make test</span><br></pre></td></tr></table></figure>
<p>4、编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">▶ sudo make install</span><br><span class="line">Password:</span><br><span class="line">cd src &amp;&amp; /Applications/Xcode.app/Contents/Developer/usr/bin/make install</span><br><span class="line"></span><br><span class="line">Hint: It&apos;s a good idea to run &apos;make test&apos; ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br></pre></td></tr></table></figure>
<p>5、Q&amp;A</p>
<p>编译测试的时候遇到如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[exception]: Executing test client: couldn&apos;t execute &quot;src/redis-benchmark&quot;: no such file or directory.</span><br></pre></td></tr></table></figure>
<p>按顺序执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▶ sudo make distclean</span><br><span class="line">...</span><br><span class="line">▶ sudo make</span><br><span class="line">...</span><br><span class="line">▶ sudo make test</span><br><span class="line">...</span><br><span class="line">\o/ All tests passed without errors!</span><br><span class="line"></span><br><span class="line">Cleanup: may take some time... OK</span><br></pre></td></tr></table></figure>
<h3 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h3><p>1、启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">▶ redis-server</span><br><span class="line">18662:C 06 Nov 2019 09:03:12.958 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">18662:C 06 Nov 2019 09:03:12.959 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=18662, just started</span><br><span class="line">18662:C 06 Nov 2019 09:03:12.959 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">18662:M 06 Nov 2019 09:03:12.960 * Increased maximum number of open files to 10032 (it was originally set to 4864).</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ &apos;&apos;-._</span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 5.0.5 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._</span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 18662</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;</span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io</span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|</span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |</span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;</span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;</span><br><span class="line">          `-._        _.-&apos;</span><br><span class="line">              `-.__.-&apos;</span><br><span class="line"></span><br><span class="line">18662:M 06 Nov 2019 09:03:12.964 # Server initialized</span><br><span class="line">18662:M 06 Nov 2019 09:03:12.964 * Ready to accept connections</span><br></pre></td></tr></table></figure>
<p>2、进入客户端</p>
<p>客户端常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value</td>
<td>设置 key 的值</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key 的值</td>
</tr>
<tr>
<td>exists key</td>
<td>查看此 key 是否存在</td>
</tr>
<tr>
<td>keys *</td>
<td>查看所有的 key</td>
</tr>
<tr>
<td>flushall</td>
<td>消除所有的 key</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">▶ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; echo &quot;hello&quot;</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; set aa cat</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set bb dog</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;bb&quot;</span><br><span class="line">2) &quot;aa&quot;</span><br><span class="line">127.0.0.1:6379&gt; get aa</span><br><span class="line">&quot;cat&quot;</span><br><span class="line">127.0.0.1:6379&gt; get cc</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; exists cc</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; exists bb</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;bb&quot;</span><br><span class="line">2) &quot;aa&quot;</span><br><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br></pre></td></tr></table></figure>
<p>输入 exit 退出。</p>
<p>3、停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ redis-cli shutdown</span><br></pre></td></tr></table></figure>
<p>停止后，redis-server所在的terminal可以看到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">18662:M 06 Nov 2019 09:10:53.822 * DB saved on disk</span><br><span class="line">18662:M 06 Nov 2019 09:13:52.827 # User requested shutdown...</span><br><span class="line">18662:M 06 Nov 2019 09:13:52.827 * Saving the final RDB snapshot before exiting.</span><br><span class="line">18662:M 06 Nov 2019 09:13:52.827 * DB saved on disk</span><br><span class="line">18662:M 06 Nov 2019 09:13:52.827 # Redis is now ready to exit, bye bye...</span><br></pre></td></tr></table></figure>
<p>4、后台启动</p>
<p>修改配置文件 redis.conf，查找字段 daemonize，设为yes（默认为no）。</p>
<p>设置完后，执行 <code>redis-cli shutdown</code> 命令，redis-server 不会退出，需要手动 ctrl+c 退出。</p>
<h2 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h2><p>mac客户端软件：redis-desktop-manager</p>
<p>官网：<a href="https://redisdesktop.com/" target="_blank" rel="noopener">https://redisdesktop.com/</a></p>
<p>github：<a href="https://github.com/uglide/RedisDesktopManager" target="_blank" rel="noopener">https://github.com/uglide/RedisDesktopManager</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-1.png" alt="1"></p>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis初识]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/redis-intro/</url>
      <content type="html"><![CDATA[<p>redis学习<br><a id="more"></a></p>
<h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>Remote DIctionary Server(Redis)是一个<strong>开源的高性能的key-value存储系统</strong>。使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>1、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>2、Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，sorted set，hash等数据结构的存储。</li>
<li>3、Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h2 id="高并发和速度快"><a href="#高并发和速度快" class="headerlink" title="高并发和速度快"></a>高并发和速度快</h2><p>1.redis是基于内存的，内存的读写速度非常快；</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>
<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>
<h3 id="单线程的优劣势"><a href="#单线程的优劣势" class="headerlink" title="单线程的优劣势"></a>单线程的优劣势</h3><p><strong>单进程单线程优势</strong></p>
<ol>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的切换而消耗CPU</li>
</ol>
<p><strong>单进程单线程弊端</strong></p>
<ol>
<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>
</ol>
<h3 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a><strong>IO多路复用技术</strong></h3><p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p>
<ul>
<li>多路-指的是多个socket连接</li>
<li>复用-指的是复用一个线程</li>
<li>多路复用主要有三种技术：select，poll，epoll。</li>
</ul>
<p>epoll是最新的也是目前最好的多路复用技术。</p>
<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让<strong>单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="VS-mysql"><a href="#VS-mysql" class="headerlink" title="VS mysql"></a>VS mysql</h3><ul>
<li>Redis是远程的，有客户端和服务端，我们一般说的是服务端；</li>
<li>Redis是<strong>基于内存</strong>的，所以比基于硬盘的MySQL要快很多，但非常吃内存</li>
<li>Redis是非关系型数据库。本质上也是数据库，但MySQL关系型数据库存储时必须定义数据词典，而Redis则不需要。</li>
</ul>
<h3 id="VS-memcached"><a href="#VS-memcached" class="headerlink" title="VS memcached"></a>VS memcached</h3><p><img src="http://oow6unnib.bkt.clouddn.com/redis-5.jpg" alt="1"></p>
<ul>
<li><code>Redis</code>数据类型都支持<code>push/pop、add/remove</code>及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li>
<li>与<code>Memcached</code>一样，为了保证效率，数据都是缓存在内存中。区别的是<code>Redis</code>会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了<code>master-slave</code>(主从)同步。</li>
<li>redis单个value的最大限制是1GB，memcached只能保存1MB数据</li>
</ul>
<blockquote>
<p>其他可参考：<a href="https://dbaplus.cn/news-141-1988-1.html" target="_blank" rel="noopener">https://dbaplus.cn/news-141-1988-1.html</a></p>
</blockquote>
<h2 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h2><p>Redis最广泛的应用场景就是Cache，其他用途：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-2.png" alt="2"></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><strong>1、缓存，</strong>毫无疑问这是Redis当今最为人熟知的使用场景，再提升服务器性能方面非常有效。</li>
<li><strong>2、排行榜</strong>，如果使用传统的关系型数据库来做，非常麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；</li>
<li><strong>3、计算器/限速器</strong>，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</li>
<li><strong>4、好友关系</strong>，利用集合的一些命令，比如求交集、并集、差集等，可以方便搞定一些共同好友、共同爱好之类的功能；</li>
<li><strong>5、简单消息队列</strong>，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</li>
<li><strong>6、Session共享</strong>，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</li>
</ul>
<h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><p>数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，浪费内存资源。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><img src="http://oow6unnib.bkt.clouddn.com/redis-3.png" alt="3"></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/redis-4.png" alt="4"></p>
<blockquote>
<p>上图来源一篇转载的文章，原文链接没找到</p>
</blockquote>
<h2 id="缺点和其他"><a href="#缺点和其他" class="headerlink" title="缺点和其他"></a>缺点和其他</h2><p>参考这篇文章：<a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9096228.html</a></p>
<p>包括一致性问题、缓存穿透和缓存雪崩等问题，可以作为深入研究的文章，前期可不用了解这么多。</p>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十二：init binder]]></title>
      <url>http://xiaqunfeng.cc/2020/02/15/java-springboot-12-init-binder/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十二篇，init binder全局数据预处理。<br><a id="more"></a></p>
<h2 id="全局数据预处理"><a href="#全局数据预处理" class="headerlink" title="全局数据预处理"></a>全局数据预处理</h2><p>如果有两个类，都有一个相同的属性，从前端传递时，无法区分。</p>
<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>1、书籍类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: Book</span><br><span class="line"> * @Description: 书籍类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-11 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer price;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book name: &quot; + name + &quot;, price: &quot; + price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、作者类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: Author</span><br><span class="line"> * @Description: 作者类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-11 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class Author &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Author name: &quot; + name + &quot;, age: &quot; + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，都有一个同名的属性  name。</p>
<h2 id="正常调用"><a href="#正常调用" class="headerlink" title="正常调用"></a>正常调用</h2><p>定义controller</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/book&quot;)</span><br><span class="line">public String addBook(Book book, Author author) &#123;</span><br><span class="line">    return book.toString() + &quot;\n&quot; + author.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端测试：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/init-binder-1.png-xtdf" alt="1"></p>
<p>发现，前端只识别第一个 name，Author的name没有被对应上。</p>
<p>通过 @ControllerAdvice 的全局数据预处理可以解决这个问题</p>
<h2 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h2><p>1、给接口中的变量取别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/book1&quot;)</span><br><span class="line">public String addBook1(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) &#123;</span><br><span class="line">    return book.toString() + &quot;\n&quot; + author.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、进行请求数据预处理</p>
<p>在 AppControllerAdvice.java 类中，添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@InitBinder(&quot;b&quot;)</span><br><span class="line">public void b(WebDataBinder binder) &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(&quot;b.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@InitBinder(&quot;a&quot;)</span><br><span class="line">public void a(WebDataBinder binder) &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(&quot;a.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数</li>
<li>在方法中，给参数添加一个<code>b.</code> 前缀，即请求参数要有<code>b.</code>前缀</li>
</ul>
<p>3、测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/init-binder-2.png-xtdf" alt="2"></p>
<p>通过给不同对象添加不同前缀，已可正确识别参数。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十一：model attribute]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-11-model-attribute/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十一篇，ModelAttribute全局数据绑定。</p>
<a id="more"></a>
<h2 id="全局数据绑定"><a href="#全局数据绑定" class="headerlink" title="全局数据绑定"></a>全局数据绑定</h2><p>前面说过利用 @ControllerAdvice 注解实现全局错误处理，该注解还可以用来配合实现全局数据绑定和全局数据预处理。</p>
<p>很多时候前端页面需要数据回显或者查询条件来自同一个类，需要从后台获取数据，@ModelAttribute注解用在类上面时，当加载所在controller时，将数据放入到Model中，视图直接可以访问</p>
<p>@ModelAttribute</p>
<ul>
<li>该Controller类所有方法执行前，先调用此@ModelAttribute方法，可用于注解和方法参数中。</li>
<li>@ModelAttribute注解用于将请求参数绑定到Model对象</li>
</ul>
<h2 id="ModelAttribute-“xxx”-注释返回具体类的方法"><a href="#ModelAttribute-“xxx”-注释返回具体类的方法" class="headerlink" title="@ModelAttribute(“xxx”)注释返回具体类的方法"></a>@ModelAttribute(“xxx”)注释返回具体类的方法</h2><p>1、定义全局数据</p>
<p>在 AppControllerAdvice.java 类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute(&quot;user&quot;)</span><br><span class="line">private UserInfo getUser() &#123;</span><br><span class="line">    UserInfo userInfo = new UserInfo();</span><br><span class="line">    userInfo.setId(&quot;888&quot;);</span><br><span class="line">    userInfo.setUserName(&quot;summer_wind&quot;);</span><br><span class="line">    return userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ModelAttribute 注解标记该方法的返回数据是一个全局数据。</p>
<p>2、controller中获取全局数据</p>
<p>在 UserInfoController.java 中，新增 /user 接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public RetResult&lt;UserInfo&gt; getUser(@ModelAttribute(&quot;user&quot;) UserInfo userInfo) &#123;</span><br><span class="line">    return RetResponse.makeOKRsp(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>@ModelAttribute(&quot;user&quot;)</code> 来获取全局的 UserInfo 数据。</p>
<p>3、测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/model-attribute-1.png-xtdf" alt="1"></p>
<p>可以看到，已获取全局定义的 UserInfo 数据。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="ModelAttribute注释-void-返回值的方法"><a href="#ModelAttribute注释-void-返回值的方法" class="headerlink" title="@ModelAttribute注释 void 返回值的方法"></a>@ModelAttribute注释 void 返回值的方法</h3><p>此方法在<code>@RequestMapping</code>注解的方法之前执行，通过方法 <code>model.addAttribute(key,value)</code>绑定数据。</p>
<p>1、定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">private void getUser(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;pwd&quot;) String pwd, Model model) &#123;</span><br><span class="line">    model.addAttribute(&quot;userName&quot;, userName);</span><br><span class="line">    model.addAttribute(&quot;pwd&quot;, pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、controller</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">public String login(Model model) &#123;</span><br><span class="line">    System.out.println(model.containsAttribute(&quot;userName&quot;));</span><br><span class="line">    System.out.println(model.containsAttribute(&quot;pwd&quot;));</span><br><span class="line"></span><br><span class="line">    return &quot;login success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/model-attribute-2.png-xtdf" alt="2"></p>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>还有 @ModelAttribute注释返回具体类的方法，以及 @ModelAttribute(“xxx”)和@RequestMapping(“/yyy’)同时注释的有返回值的方法，这里暂时不深究，有空再看。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践十：profile]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-10-profile/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第十篇，profile环境配置。</p>
<a id="more"></a>
<h2 id="环境配置切换"><a href="#环境配置切换" class="headerlink" title="环境配置切换"></a>环境配置切换</h2><p>在实际的项目开发中，经常需要不同的环境配置，如开发、测试和线上环境。</p>
<p>spring boot项目中，会引入不同环境的配置文件，如：<code>application-dev.properties</code>，<code>application-prod.properties</code>等，通过在默认配置文件<code>application.properties</code>中指定<code>spring.profiles.active</code>的值切换配置文件，从而实现环境配置的切换。</p>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h3 id="application配置文件"><a href="#application配置文件" class="headerlink" title="application配置文件"></a>application配置文件</h3><p>添加开发、测试和生产的配置文件:</p>
<ul>
<li><code>application-dev.yml</code> – 开发环境配置</li>
<li><code>application-prod.yml</code> – 生产环境配置</li>
<li><code>application-test.yml</code> – 测试环境配置</li>
</ul>
<p>dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profile:</span><br><span class="line">  name: dev</span><br></pre></td></tr></table></figure>
<p>prod</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profile:</span><br><span class="line">  name: prod</span><br></pre></td></tr></table></figure>
<p>test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profile:</span><br><span class="line">  name: test</span><br></pre></td></tr></table></figure>
<p>application.yml 添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: SwitchEnvController</span><br><span class="line"> * @Description: 切换环境</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-10 November</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class SwitchEnvController &#123;</span><br><span class="line">    @Value(&quot;$&#123;profile.name&#125;&quot;)</span><br><span class="line">    private String profileName;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/env&quot;)</span><br><span class="line">    public String getEnv() &#123;</span><br><span class="line">        return &quot;current env: &quot; + profileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@Value</code>注解读取<code>profile.name</code>，赋给<code>profileName</code>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="http://oow6unnib.bkt.clouddn.com/profile-1.png-xtdf" alt="1"></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践九：interceptor]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-9-interceptor/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第九篇，interceptor拦截器。</p>
<a id="more"></a>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在web开发的过程中，为了实现登录权限验证，安全验证等，我们往往需要添加一个拦截器在用户的的请求到达controller层的时候实现一些验证。</p>
<p>Spring MVC 中的拦截器（Interceptor），类似于 Servlet 开发中的过滤器 Filter，它主要用于拦截用户请求并作相应的处理，它也是 AOP 编程思想的体现，底层通过动态代理模式完成。</p>
<h2 id="创建拦截器"><a href="#创建拦截器" class="headerlink" title="创建拦截器"></a>创建拦截器</h2><ul>
<li>preHandle：在请求处理之前调用（Controller方法调用之前）</li>
<li>postHandle：在请求处理之后调用（Controller方法调用之后）</li>
<li>afterCompletion：在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.interceptor;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.interceptor</span><br><span class="line"> * @ClassName: FirstInterceptor</span><br><span class="line"> * @Description: 第一个拦截器</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-10 November</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class FirstInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @description: 在请求处理之前调用</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return: boolean</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt; FirstInterceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;  preHandle&quot;);</span><br><span class="line">        // 只有返回true才会继续向下执行，返回false取消当前请求</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 在请求处理之后调用</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param modelAndView</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">                           ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt; FirstInterceptor &gt;&gt;&gt;&gt;&gt;&gt;&gt;  postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 在整个请求结束之后被调用</span><br><span class="line">     * @param request</span><br><span class="line">     * @param response</span><br><span class="line">     * @param handler</span><br><span class="line">     * @param ex</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt; FirstInterceptor1 &gt;&gt;&gt;&gt;&gt;&gt;&gt;  afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改WebConfigurer配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config;</span><br><span class="line"></span><br><span class="line">import com.example.demo.core.interceptor.FirstInterceptor;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config</span><br><span class="line"> * @ClassName: WebMvcConfig</span><br><span class="line"> * @Description: web拦截器的配置文件</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-10 November</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfig extends WebMvcConfigurationSupport &#123;</span><br><span class="line">//    @Bean</span><br><span class="line">//    public FirstInterceptor firstInterceptor() &#123;</span><br><span class="line">//        return new FirstInterceptor();</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    private FirstInterceptor firstInterceptor;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public WebMvcConfig(FirstInterceptor firstInterceptor) &#123;</span><br><span class="line">        this.firstInterceptor = firstInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 拦截器配置</span><br><span class="line">     * @param registry</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        // 注册自定义拦截器，添加拦截路径的黑白名单</span><br><span class="line">        // 同时可以重写拦截器的方法</span><br><span class="line">        registry.addInterceptor(firstInterceptor)         // 添加拦截器1</span><br><span class="line">                .addPathPatterns(&quot;/test1&quot;);               // 添加拦截路径</span><br><span class="line">               // .excludePathPatterns(&quot;/hello&quot;, &quot;/selectById&quot;)   // 添加排除拦截路径</span><br><span class="line">               // .order(0);  // 执行顺序</span><br><span class="line"></span><br><span class="line">        super.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: InterceptorController</span><br><span class="line"> * @Description: 拦截器测试</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-10 November</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class InterceptorController &#123;</span><br><span class="line">    @RequestMapping(&quot;/test1&quot;)</span><br><span class="line">    public String test1() &#123;</span><br><span class="line">        System.out.println(&quot;test1 controller&quot;);</span><br><span class="line">        return &quot;test1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>一直不起作用，不知道为啥。</p>
<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/zwqh/p/11719254.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwqh/p/11719254.html</a></p>
<p><a href="https://juejin.im/post/5b10cc706fb9a01e2d702c1d" target="_blank" rel="noopener">https://juejin.im/post/5b10cc706fb9a01e2d702c1d</a></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践八：schedule]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-8-schedule/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第八篇，shcedule定时任务。</p>
<a id="more"></a>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>使用SpringBoot创建定时任务目前主要有以下三种创建方式：</p>
<ul>
<li>一、基于注解：@Scheduled</li>
<li>二、基于接口：SchedulingConfigurer</li>
<li>三、基于注解设定多线程定时任务</li>
</ul>
<h2 id="静态定时任务：基于注解"><a href="#静态定时任务：基于注解" class="headerlink" title="静态定时任务：基于注解"></a>静态定时任务：基于注解</h2><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>@EnableScheduling 注解启用定时调动功能</p>
<p>@Scheduled 参数说明：</p>
<ul>
<li>@Scheduled(fixedRate = 5000)：上次开始执行时间点后5秒再次执行</li>
<li>@Scheduled(fixedDelay = 3000)：上次执行完毕时间点后3秒再次执行</li>
<li>@Scheduled(cron = “0/10 <em> </em> <em> </em> ?”)：每隔10秒执行一次（按照 corn 表达式规则执行）</li>
<li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li>
<li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li>
<li>initialDelay 表示首次任务启动的延迟时间。</li>
</ul>
<blockquote>
<p>注：基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。所有时间的单位都是毫秒。</p>
</blockquote>
<h3 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h3><p>1.Cron表达式格式</p>
<blockquote>
<p>{秒} {分} {时} {日} {月} {周} {年(可选)}</p>
</blockquote>
<p>2.Cron 表达式字段取值范围及说明</p>
<p>具体取值如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>说明</th>
<th>是否必填</th>
<th>允许填写的值</th>
<th>允许的通配符</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>秒</td>
<td>是</td>
<td>0-59</td>
<td>- * /</td>
</tr>
<tr>
<td>2</td>
<td>分</td>
<td>是</td>
<td>0-59</td>
<td>- * /</td>
</tr>
<tr>
<td>3</td>
<td>时</td>
<td>是</td>
<td>0-23</td>
<td>- * /</td>
</tr>
<tr>
<td>4</td>
<td>日</td>
<td>是</td>
<td>1-31</td>
<td>- * ? / L W</td>
</tr>
<tr>
<td>5</td>
<td>月</td>
<td>是</td>
<td>1-12 or JAN-DEC</td>
<td>- * /</td>
</tr>
<tr>
<td>6</td>
<td>周</td>
<td>是</td>
<td>1-7 or SUN-SAT</td>
<td>- * ? / L #</td>
</tr>
<tr>
<td>7</td>
<td>年</td>
<td>否</td>
<td>1970-2099</td>
<td>- * /</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ?</p>
</blockquote>
<p>3.Cron 表达式中特殊字符的意义</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>表示可以匹配该域的所有值</td>
</tr>
<tr>
<td>？</td>
<td>主要用于日和星期，可以匹配域的任意值，但实际不会。当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为？</td>
</tr>
<tr>
<td>/</td>
<td>表示为每隔一段时间。如 0 0/10 <em> </em> * ? 其中的 0/10表示从0分钟开始，每隔10分钟执行一次</td>
</tr>
<tr>
<td>-</td>
<td>表示范围。如 0 0-5 14 <em> </em> ? 表示在每天14:00到14:05期间每1分钟执行一次</td>
</tr>
<tr>
<td>,</td>
<td>表示枚举多个值，这些值之间是”或”的关系。如 0 10,30 14 * 3 ? 表示每个星期二14点10分或者14点30分执行一次</td>
</tr>
<tr>
<td>L</td>
<td>表示每月或者每周的最后一天。如 0 0 0 L <em> ? </em> 表示每月的最后一天执行</td>
</tr>
<tr>
<td>W</td>
<td>表示最近工作日。如 0 0 0 15W <em> ？</em> 表示每月15号最近的那个工作日执行</td>
</tr>
<tr>
<td>#</td>
<td>用来指定具体的周数，”#”前面代表星期，”#”后面代表本月的第几周。如”2#1”表示本月第二周的星期日</td>
</tr>
</tbody>
</table>
<p>4.Cron 在线生成工具</p>
<p><a href="http://www.bejson.com/othertools/cron/" target="_blank" rel="noopener">http://www.bejson.com/othertools/cron/</a></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.schedule;</span><br><span class="line"></span><br><span class="line">import org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line">import org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.schedule</span><br><span class="line"> * @ClassName: StaticScheduleTask</span><br><span class="line"> * @Description: 静态定时任务</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-10 November</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class StaticScheduleTask &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 每隔5秒执行一次</span><br><span class="line">     * @param </span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span><br><span class="line">    public void job1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;thread job1 sleep failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行定时任务 job1：&quot; + new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 上次执行完毕5秒后再次执行</span><br><span class="line">     * @param </span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedDelay = 5000)</span><br><span class="line">    public void job2() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;thread job2 sleep failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行定时任务 job2：&quot; + new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @description: 上次开始执行后5秒后再次执行</span><br><span class="line">     * @param </span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019-11-10</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedRate = 5000)</span><br><span class="line">    public void job3() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;thread job3 sleep failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行定时任务 job3：&quot; + new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;).format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态定时任务：基于接口"><a href="#动态定时任务：基于接口" class="headerlink" title="动态定时任务：基于接口"></a>动态定时任务：基于接口</h2><p>通过实现 SchedulingConfigurer 接口来做。</p>
<h2 id="多线程定时任务"><a href="#多线程定时任务" class="headerlink" title="多线程定时任务"></a>多线程定时任务</h2><p>以上两种定时任务都是单线程的，要实现多线程执行任务，可以通过在 SchedulingConfigurer 接口的 configureTasks方法中添加线程池即可。</p>
<blockquote>
<p>动态和多线程定时任务目前用不上，后续再研究。</p>
</blockquote>
<p>后续参考资料：</p>
<p><a href="https://www.cnblogs.com/zwqh/p/11764688.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwqh/p/11764688.html</a></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践七：validation]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-7-validation/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第七篇，validation输入数据校验。</p>
<a id="more"></a>
<h2 id="输入数据校验"><a href="#输入数据校验" class="headerlink" title="输入数据校验"></a>输入数据校验</h2><p>在项目的过程中，对于参数的校验是必须的，输入的数据很有可能是不安全或不正确的，所以在被处理前需要做校验。</p>
<p>数据校验有两种：</p>
<ul>
<li>一种是通过代码逻辑，写一个validation的函数，来对前端传输过来的数据进行判断。</li>
<li>另一种就是通过注解进行校验，这里学习一下这种。</li>
</ul>
<p>如果参数比较少的话我们可以直接通过代码进行校验，但是数据较大时再用这个方法就比较笨重，推荐使用validation进行校验，调用的<code>javax.validation</code>。</p>
<h2 id="JSR-303-注释介绍"><a href="#JSR-303-注释介绍" class="headerlink" title="JSR-303 注释介绍"></a>JSR-303 注释介绍</h2><p><code>javax.validation</code>包下的注解如下：（包含了<code>hibernate-validator</code>验证包中的常用注解）</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Null</code></td>
<td>限制必须为 null</td>
</tr>
<tr>
<td><code>@NotNull</code></td>
<td>限制不能为 null</td>
</tr>
<tr>
<td><code>@NotEmpty</code></td>
<td>限制不能为 null 且不能为空；可以作用于字符串，其长度不能为 0；可作用于 Array、Collection、Map，其大小不能为 0</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>限制不能为null，且去除首位空格后长度不能为0。只应用于字符串</td>
</tr>
<tr>
<td><code>@Pattern(value)</code></td>
<td>限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td><code>@Size(max,min)</code></td>
<td>限制长度必须在 min 到 max 之间（可用于字符串、Array、集合等）</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>限制必须为Email邮箱格式，也可以通过正则表达式和flag指定自定义的email格式</td>
</tr>
<tr>
<td><code>@Max(value)</code></td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td><code>@Min(value)</code></td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td><code>@Positive</code></td>
<td>限制必须为正数</td>
</tr>
<tr>
<td><code>@PositiveOrZero</code></td>
<td>限制必须为正数或0</td>
</tr>
<tr>
<td><code>@Negative</code></td>
<td>限制必须为负数</td>
</tr>
<tr>
<td><code>@NegativeOrZero</code></td>
<td>限制必须为负数或0</td>
</tr>
<tr>
<td><code>@DecimalMax(value)</code></td>
<td>限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td><code>@DecimalMin(value)</code></td>
<td>限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td><code>@AssertFalse</code></td>
<td>限制必须为false （很少用）</td>
</tr>
<tr>
<td><code>@AssertTrue</code></td>
<td>限制必须为true （很少用）</td>
</tr>
<tr>
<td><code>@Past</code></td>
<td>限制必须是一个过去的日期</td>
</tr>
<tr>
<td><code>@Future</code></td>
<td>限制必须是一个将来的日期</td>
</tr>
<tr>
<td><code>@Digits(integer,fraction)</code></td>
<td>限制必须为一个小数，且整数部分的位数不能超过 integer，小数部分的位数不能超过 fraction （很少用）</td>
</tr>
</tbody>
</table>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>创建用户注册类，用户注册时，要求输入手机号、密码、昵称，传给该类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Pattern;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: RegisterRequestDTO</span><br><span class="line"> * @Description: 注册请求的数据类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-08 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class RegisterRequestDTO &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(RegisterRequestDTO.class);</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;手机号，必填&quot;)</span><br><span class="line">    @Pattern(regexp = &quot;^[1]([3][0-9]&#123;1&#125;|59|58|88|89)[0-9]&#123;8&#125;$&quot;, message = &quot;请输入11位手机号&quot;)</span><br><span class="line">    private String mobile;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;昵称，必填&quot;)</span><br><span class="line">    @Size(min = 2, max = 6, message = &quot;昵称2~6个字符&quot;)</span><br><span class="line">    private String nickname;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;密码，必填&quot;)</span><br><span class="line">    @Size(min = 3, max = 10, message = &quot;密码3~10位&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@NotNull 表示必填</li>
<li>@Size 字符串长度必须符合指定范围</li>
<li>@Pattern 输入字符串必须匹配正则表达式</li>
</ul>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.core.ret.RetResponse;</span><br><span class="line">import com.example.demo.core.ret.RetResult;</span><br><span class="line">import com.example.demo.model.dto.RegisterRequestDTO;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.validation.Valid;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: AuthController</span><br><span class="line"> * @Description: 校验</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-08 November</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class AuthController &#123;</span><br><span class="line">    @RequestMapping(&quot;/valid&quot;)</span><br><span class="line">    public RetResult&lt;RegisterRequestDTO&gt; register(@Valid RegisterRequestDTO requestDTO) &#123;</span><br><span class="line">        return RetResponse.makeOKRsp(requestDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在参数前面加上 @Valid 注解即可。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、输入手机号不对</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/validation-1.png-xtdf" alt="1"></p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;timestamp&quot;: 1573284851013,</span><br><span class="line">    &quot;status&quot;: 400,</span><br><span class="line">    &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">    &quot;errors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;codes&quot;: [</span><br><span class="line">                &quot;Pattern.registerRequestDTO.mobile&quot;,</span><br><span class="line">                &quot;Pattern.mobile&quot;,</span><br><span class="line">                &quot;Pattern.java.lang.String&quot;,</span><br><span class="line">                &quot;Pattern&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;arguments&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [</span><br><span class="line">                        &quot;registerRequestDTO.mobile&quot;,</span><br><span class="line">                        &quot;mobile&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;arguments&quot;: null,</span><br><span class="line">                    &quot;defaultMessage&quot;: &quot;mobile&quot;,</span><br><span class="line">                    &quot;code&quot;: &quot;mobile&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                [],</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;defaultMessage&quot;: &quot;^[1]([3][0-9]&#123;1&#125;|59|58|88|89)[0-9]&#123;8&#125;$&quot;,</span><br><span class="line">                    &quot;arguments&quot;: null,</span><br><span class="line">                    &quot;codes&quot;: [</span><br><span class="line">                        &quot;^[1]([3][0-9]&#123;1&#125;|59|58|88|89)[0-9]&#123;8&#125;$&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defaultMessage&quot;: &quot;请输入11位手机号&quot;,</span><br><span class="line">            &quot;objectName&quot;: &quot;registerRequestDTO&quot;,</span><br><span class="line">            &quot;field&quot;: &quot;mobile&quot;,</span><br><span class="line">            &quot;rejectedValue&quot;: &quot;123&quot;,</span><br><span class="line">            &quot;bindingFailure&quot;: false,</span><br><span class="line">            &quot;code&quot;: &quot;Pattern&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;message&quot;: &quot;Validation failed for object=&apos;registerRequestDTO&apos;. Error count: 1&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/valid&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、正确输入</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/validation-2.png-xtdf" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;mobile&quot;: &quot;13500001111&quot;,</span><br><span class="line">        &quot;nickname&quot;: &quot;夏天的风&quot;,</span><br><span class="line">        &quot;password&quot;: &quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、只输入一位密码</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/validation-3.png-xtdf" alt="3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;timestamp&quot;: 1573285145289,</span><br><span class="line">    &quot;status&quot;: 400,</span><br><span class="line">    &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">    &quot;errors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;codes&quot;: [</span><br><span class="line">                &quot;Size.registerRequestDTO.password&quot;,</span><br><span class="line">                &quot;Size.password&quot;,</span><br><span class="line">                &quot;Size.java.lang.String&quot;,</span><br><span class="line">                &quot;Size&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;arguments&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [</span><br><span class="line">                        &quot;registerRequestDTO.password&quot;,</span><br><span class="line">                        &quot;password&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;arguments&quot;: null,</span><br><span class="line">                    &quot;defaultMessage&quot;: &quot;password&quot;,</span><br><span class="line">                    &quot;code&quot;: &quot;password&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                10,</span><br><span class="line">                3</span><br><span class="line">            ],</span><br><span class="line">            &quot;defaultMessage&quot;: &quot;密码3~10位&quot;,</span><br><span class="line">            &quot;objectName&quot;: &quot;registerRequestDTO&quot;,</span><br><span class="line">            &quot;field&quot;: &quot;password&quot;,</span><br><span class="line">            &quot;rejectedValue&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;bindingFailure&quot;: false,</span><br><span class="line">            &quot;code&quot;: &quot;Size&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;message&quot;: &quot;Validation failed for object=&apos;registerRequestDTO&apos;. Error count: 1&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/valid&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Validated和-Valid"><a href="#Validated和-Valid" class="headerlink" title="@Validated和@Valid"></a>@Validated和@Valid</h2><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303 规范，是标准 JSR-303 的一个变种），javax提供了@Valid（标准JSR-303规范），配合 BindingResult 可以直接提供参数验证结果。</p>
<p>在检验 Controller 的入参是否符合规范时，使用 @Validated 或者 @Valid 在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p>
<ol>
<li>分组</li>
</ol>
<ul>
<li>@Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制。</li>
<li>@Valid：作为标准JSR-303规范，还没有吸收分组的功能。</li>
</ul>
<ol>
<li>注解地方</li>
</ol>
<ul>
<li>@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上</li>
<li>@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上</li>
</ul>
<p>两者是否能用于成员属性（字段）上直接影响能否提供嵌套验证的功能。</p>
<p>3、嵌套验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Item &#123;</span><br><span class="line">    @NotNull(message = &quot;id不能为空&quot;)</span><br><span class="line">    @Min(value = 1, message = &quot;id必须为正整数&quot;)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Valid // 嵌套验证必须用@Valid</span><br><span class="line">    @NotNull(message = &quot;props不能为空&quot;)</span><br><span class="line">    @Size(min = 1, message = &quot;props至少要有一个自定义属性&quot;)</span><br><span class="line">    private List&lt;Prop&gt; props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，Item 结构里还嵌套有 props结构，如果不加 @Valid，就不会对props结构的成员进行嵌套验证。嵌套验证区别如下：</p>
<ul>
<li>@Validated： 用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</li>
<li>@Valid： 用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</li>
</ul>
<h2 id="嵌套验证测试"><a href="#嵌套验证测试" class="headerlink" title="嵌套验证测试"></a>嵌套验证测试</h2><h3 id="DTO-1"><a href="#DTO-1" class="headerlink" title="DTO"></a>DTO</h3><p>定义一个嵌套结构：</p>
<p>1、客户资料：CustomerDTO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.validation.Valid;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: CustomerDTO</span><br><span class="line"> * @Description: 客户资料</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-09 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class CustomerDTO &#123;</span><br><span class="line">    @NotNull(message = &quot;客户id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;客户地址&quot;)</span><br><span class="line">    private String location;</span><br><span class="line"></span><br><span class="line">    //@Valid</span><br><span class="line">    @NotNull(message = &quot;客户详细信息&quot;)</span><br><span class="line">    private PeopleDetailDTO detailDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次测试不加 @Valid</li>
<li>第二次测试加 @Valid</li>
</ul>
<p>2、每个人的详细信息：PeopleDetailDTO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model.dto;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.Email;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Positive;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model.dto</span><br><span class="line"> * @ClassName: PeopleDetailDTO</span><br><span class="line"> * @Description: 人的详细信息</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-09 November</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class PeopleDetailDTO &#123;</span><br><span class="line">    @NotNull(message = &quot;姓名&quot;)</span><br><span class="line">    @Size(min = 2, max = 4, message = &quot;请输入2~4位姓名&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;性别&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;年龄&quot;)</span><br><span class="line">    @Positive</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Email(message = &quot;email地址&quot;)</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在之前 AuthController 类里添加如下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/nest&quot;)</span><br><span class="line">public RetResult&lt;CustomerDTO&gt; test(@Validated @RequestBody CustomerDTO requestDTO) &#123;</span><br><span class="line">    return RetResponse.makeOKRsp(requestDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>测试数据</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/validation-4.png-xtdf" alt="4"></p>
<p>这里把 name 设为 null。</p>
<p>1、不加 @Valid 结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 12121,</span><br><span class="line">        &quot;location&quot;: &quot;上海&quot;,</span><br><span class="line">        &quot;detailDTO&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: null,</span><br><span class="line">            &quot;sex&quot;: &quot;男&quot;,</span><br><span class="line">            &quot;age&quot;: 18,</span><br><span class="line">            &quot;email&quot;: &quot;abc123@126.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功，没报错。</p>
<p>2、加 @Valid 结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;timestamp&quot;: 1573292805153,</span><br><span class="line">    &quot;status&quot;: 400,</span><br><span class="line">    &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">    &quot;errors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;codes&quot;: [</span><br><span class="line">                &quot;NotNull.customerDTO.detailDTO.name&quot;,</span><br><span class="line">                &quot;NotNull.detailDTO.name&quot;,</span><br><span class="line">                &quot;NotNull.name&quot;,</span><br><span class="line">                &quot;NotNull.java.lang.String&quot;,</span><br><span class="line">                &quot;NotNull&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;arguments&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [</span><br><span class="line">                        &quot;customerDTO.detailDTO.name&quot;,</span><br><span class="line">                        &quot;detailDTO.name&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;arguments&quot;: null,</span><br><span class="line">                    &quot;defaultMessage&quot;: &quot;detailDTO.name&quot;,</span><br><span class="line">                    &quot;code&quot;: &quot;detailDTO.name&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defaultMessage&quot;: &quot;姓名&quot;,</span><br><span class="line">            &quot;objectName&quot;: &quot;customerDTO&quot;,</span><br><span class="line">            &quot;field&quot;: &quot;detailDTO.name&quot;,</span><br><span class="line">            &quot;rejectedValue&quot;: null,</span><br><span class="line">            &quot;bindingFailure&quot;: false,</span><br><span class="line">            &quot;code&quot;: &quot;NotNull&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;message&quot;: &quot;Validation failed for object=&apos;customerDTO&apos;. Error count: 1&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/nest&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报了 detailDTO.name 为 null 的错。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践六：pagehelper]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-6-pagehelper/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第六篇，通过PageHelper对返回的数据增加分页功能。</p>
<a id="more"></a>
<h2 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h2><p>官网：<a href="https://pagehelper.github.io/docs/howtouse/" target="_blank" rel="noopener">https://pagehelper.github.io/docs/howtouse/</a></p>
<p>对返回的数据增加分页功能。</p>
<h2 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pagehelper:</span><br><span class="line">  helper-dialect: mysql</span><br><span class="line">  reasonable: true</span><br><span class="line">  support-methods-arguments: true</span><br><span class="line">  params: count=countsql</span><br><span class="line">  page-size-zero: true</span><br></pre></td></tr></table></figure>
<h3 id="配置参数说明"><a href="#配置参数说明" class="headerlink" title="配置参数说明"></a>配置参数说明</h3><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>helperDialect</td>
<td>指定数据库</td>
<td>可以不配置，插件会自动检测数据库的类型</td>
</tr>
<tr>
<td>reasonable</td>
<td>分页合理化参数，默认值为false</td>
<td>当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。</td>
</tr>
<tr>
<td>params</td>
<td>用于从对象中根据属性名取值</td>
<td>可以配置pageNum,pageSize,count,pageSizeZero,reasonable。不配置映射的用默认值。</td>
</tr>
<tr>
<td>supportMethodsArguments</td>
<td>默认值false</td>
<td>分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。</td>
</tr>
<tr>
<td>pageSizeZero</td>
<td>默认值为false</td>
<td>设置为 <code>true</code> 时，如果 <code>pageSize=0</code> 或者 <code>RowBounds.limit = 0</code> 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 <code>Page</code> 类型）</td>
</tr>
</tbody>
</table>
<h2 id="添加selectAll接口"><a href="#添加selectAll接口" class="headerlink" title="添加selectAll接口"></a>添加selectAll接口</h2><p>主要是 UserInfoServiceImpl 和 UserInfoController 添加实现，然后再在 service、dao中新增selectAll的接口定义，mapper中写该接口的sql实现即可。</p>
<p>1、服务实现层</p>
<p>将userInfoList封装成PageInfo列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserInfoServiceImpl implements UserInfoService &#123;</span><br><span class="line">	...</span><br><span class="line">    @Override</span><br><span class="line">    public PageInfo&lt;UserInfo&gt; selectAll(Integer page, Integer size) &#123;</span><br><span class="line">        PageHelper.startPage(page, size);</span><br><span class="line">        List&lt;UserInfo&gt; userInfoList = userInfoDAO.selectAll();</span><br><span class="line">        PageInfo&lt;UserInfo&gt; pageInfo = new PageInfo&lt;&gt;(userInfoList);</span><br><span class="line">        return pageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、控制接口层</p>
<p>添加接口，以及新增swagger注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserInfoController &#123;</span><br><span class="line">    ...</span><br><span class="line">    @ApiOperation(value = &quot;查询所有用户&quot;, notes = &quot;分页查询所有用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;page&quot;, value = &quot;当前页码&quot;, dataType = &quot;Integer&quot;, paramType = &quot;query&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;size&quot;, value = &quot;每页显示条数&quot;, dataType = &quot;Integer&quot;, paramType = &quot;query&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @PostMapping(&quot;/selectAll&quot;)</span><br><span class="line">    public RetResult&lt;PageInfo&lt;UserInfo&gt;&gt; selectAll(@RequestParam(defaultValue = &quot;0&quot;) Integer page,</span><br><span class="line">                                                   @RequestParam(defaultValue = &quot;0&quot;) Integer size) &#123;</span><br><span class="line">        PageInfo&lt;UserInfo&gt; pageInfo = userInfoService.selectAll(page, size);</span><br><span class="line">        return RetResponse.makeOKRsp(pageInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他代码就不一一列了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>准备数据：将数据增加到7条，方便测试（原先只存了两条玩儿）</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/pagehelper-2.png-xtdf" alt="2"></p>
<p>1、不传参数，默认查询所有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 7,</span><br><span class="line">        &quot;list&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;张三&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;李四&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;3&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;王五&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;4&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;赵六&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;5&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;小明&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;6&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;小红&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;7&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;小吴&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;pageNum&quot;: 1,</span><br><span class="line">        &quot;pageSize&quot;: 0,</span><br><span class="line">        &quot;size&quot;: 7,</span><br><span class="line">        &quot;startRow&quot;: 1,</span><br><span class="line">        &quot;endRow&quot;: 7,</span><br><span class="line">        &quot;pages&quot;: 0,</span><br><span class="line">        &quot;prePage&quot;: 0,</span><br><span class="line">        &quot;nextPage&quot;: 0,</span><br><span class="line">        &quot;isFirstPage&quot;: true,</span><br><span class="line">        &quot;isLastPage&quot;: true,</span><br><span class="line">        &quot;hasPreviousPage&quot;: false,</span><br><span class="line">        &quot;hasNextPage&quot;: false,</span><br><span class="line">        &quot;navigatePages&quot;: 8,</span><br><span class="line">        &quot;navigatepageNums&quot;: [],</span><br><span class="line">        &quot;navigateFirstPage&quot;: 0,</span><br><span class="line">        &quot;navigateLastPage&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、page=1&amp;size=2：第一页，每页两条数据</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/pagehelper-1.png-xtdf" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 7,</span><br><span class="line">        &quot;list&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;张三&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;userName&quot;: &quot;李四&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;pageNum&quot;: 1,</span><br><span class="line">        &quot;pageSize&quot;: 2,</span><br><span class="line">        &quot;size&quot;: 2,</span><br><span class="line">        &quot;startRow&quot;: 1,</span><br><span class="line">        &quot;endRow&quot;: 2,</span><br><span class="line">        &quot;pages&quot;: 4,</span><br><span class="line">        &quot;prePage&quot;: 0,</span><br><span class="line">        &quot;nextPage&quot;: 2,</span><br><span class="line">        &quot;isFirstPage&quot;: true,</span><br><span class="line">        &quot;isLastPage&quot;: false,</span><br><span class="line">        &quot;hasPreviousPage&quot;: false,</span><br><span class="line">        &quot;hasNextPage&quot;: true,</span><br><span class="line">        &quot;navigatePages&quot;: 8,</span><br><span class="line">        &quot;navigatepageNums&quot;: [</span><br><span class="line">            1,</span><br><span class="line">            2,</span><br><span class="line">            3,</span><br><span class="line">            4</span><br><span class="line">        ],</span><br><span class="line">        &quot;navigateFirstPage&quot;: 1,</span><br><span class="line">        &quot;navigateLastPage&quot;: 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，总共7条数据，每页两条的话，有四页。</p>
<p>上面那些参数意思也很简单，参数名就是参数意思，就不列了。</p>
<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>新增了接口，显示new，挺好</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/pagehelper-3.png-xtdf" alt="3"></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践五：swagger2]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-5-swagger2/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第五篇，通过swagger2生成在线文档。</p>
<a id="more"></a>
<h2 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h2><p>1、简介</p>
<p>Swagger2是一款通过添加注解对方法进行说明，从而自动生成项目的在线api接口文档的web服务。</p>
<ul>
<li>swagger2整合到Spring Boot中，构建强大RESTful API文档。省去接口文档管理工作，修改代码，接口文档自动更新。</li>
<li>Swagger2同时提供了强大的页面测试功能来调试RESTful API进行测试 。</li>
</ul>
<p>2、Swagger2注解</p>
<p>swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等。</p>
<p>常用注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Api：修饰整个类，描述Controller的作用</span><br><span class="line">@ApiOperation：描述一个类的一个方法，或者说一个接口</span><br><span class="line">@ApiParam：单个参数描述</span><br><span class="line">@ApiModel：用对象来接收参数</span><br><span class="line">@ApiProperty：用对象接收参数时，描述对象的一个字段</span><br><span class="line">@ApiResponse：HTTP响应其中1个描述</span><br><span class="line">@ApiResponses：HTTP响应整体描述</span><br><span class="line">@ApiIgnore：使用该注解忽略这个API</span><br><span class="line">@ApiError ：发生错误返回的信息</span><br><span class="line">@ApiImplicitParam：一个请求参数</span><br><span class="line">@ApiImplicitParams：多个请求参数</span><br></pre></td></tr></table></figure>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>Pom.xml文件中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>尽量保持版本一致</li>
<li>application.yml不需要做配置</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>创建swagger2配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line">import springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.service.Contact;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.config</span><br><span class="line"> * @ClassName: Swagger2Config</span><br><span class="line"> * @Description: swagger2配置类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-04</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Swagger2的资源文件都是在jar包里面</span><br><span class="line">     * 如果不在此处配置加载静态资源，会导致请求http://localhost:8081/swagger-ui.html失败</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;swagger-ui.html&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);</span><br><span class="line"></span><br><span class="line">        registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;XqfSpringBoot 使用 Swagger2 构建 RESTful APIs&quot;)</span><br><span class="line">                .description(&quot;测试使用Swagger2&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http://github.com/xiaqunfeng&quot;)</span><br><span class="line">                .contact(new Contact(&quot;夏天的风&quot;, &quot;http://xiaqunfeng.cc&quot;, &quot;xiaqunfeng123@126.com&quot;))</span><br><span class="line">                .version(&quot;v1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加API注解"><a href="#添加API注解" class="headerlink" title="添加API注解"></a>添加API注解</h2><p>修改Controller，添加api注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.core.ret.RetResponse;</span><br><span class="line">import com.example.demo.core.ret.RetResult;</span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line">import com.example.demo.service.UserInfoService;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParam;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParams;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: UserInfoController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags = &#123;&quot;用户操作接口&quot;&#125;, description = &quot;user info controller&quot;)</span><br><span class="line">public class UserInfoController &#123;</span><br><span class="line">    //@Resource</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello XqfSpringBoot&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;查询用户&quot;, notes = &quot;根据用户ID查询用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Intger&quot;, paramType = &quot;query&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(&quot;/selectById&quot;)</span><br><span class="line">    public RetResult&lt;UserInfo&gt; selectById(@RequestParam(value = &quot;id&quot;) Integer id) &#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.selectById(id);</span><br><span class="line">        return RetResponse.makeOKRsp(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、浏览器输入：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-1.png-xtdf" alt="1"></p>
<p>2、查看 selectById GET 方法接口</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-2.png-xtdf" alt="2"></p>
<p>3、输入参数进行RESTful API测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-3.png-xtdf" alt="3"></p>
<h2 id="更美观的UI界面"><a href="#更美观的UI界面" class="headerlink" title="更美观的UI界面"></a>更美观的UI界面</h2><ul>
<li><a href="https://github.com/xiaoymin/Swagger-Bootstrap-UI" target="_blank" rel="noopener">https://github.com/xiaoymin/Swagger-Bootstrap-UI</a></li>
<li><a href="https://github.com/caspar-chen/swagger-ui-layer" target="_blank" rel="noopener">https://github.com/caspar-chen/swagger-ui-layer</a></li>
</ul>
<p>Swagger-ui-layer一年前就没更新了，swagger-bootstrap-UI最近还活跃，所以尝试一下后者。</p>
<h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.9.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方<version>${lastVersion}</version>不识别，选择了最新的1.9.6版本</p>
</blockquote>
<h3 id="swagger配置"><a href="#swagger配置" class="headerlink" title="swagger配置"></a>swagger配置</h3><p>Swagger2Config类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">...</span><br><span class="line">      registry.addResourceHandler(&quot;doc.html&quot;)</span><br><span class="line">              .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>输入链接：<a href="http://localhost:8080/doc.html" target="_blank" rel="noopener">http://localhost:8080/doc.html</a></p>
<p>1、主页</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-4.png-xtdf" alt="4"></p>
<p>2、接口文档</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-6.png-xtdf" alt="6"></p>
<p>3、API测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-5.png-xtdf" alt="5"></p>
<p>界面确实比原生的好看，默默点头，哈哈。</p>
<h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>其实我只写了hello和查询用户两个接口，但是从文档里看到，每个接口名都有七种不同的method。</p>
<p>因为我在controller中，接口上使用的是 @RequestMapping 注解，默认可接收所有的method。</p>
<p>我把 @RequestMapping 都改为 @GetMapping 后：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/swagger-7.png-xtdf" alt="7"></p>
<p>接口就只剩两个了。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践四：druid]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-4-druid/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第四篇，druid连接池。</p>
<a id="more"></a>
<h2 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h2><p>Druid连接池是阿里巴巴开源你的数据库连接池项目。Druid连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防SQL注入，内置Logging能诊断Hack应用行为。</p>
<p>Github：<a href="https://github.com/alibaba/druid/" target="_blank" rel="noopener">https://github.com/alibaba/druid/</a></p>
<p>可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>pom.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    ...</span><br><span class="line">    # druid连接池配置</span><br><span class="line">    # https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</span><br><span class="line">    druid:</span><br><span class="line">      initial-size: 5</span><br><span class="line">      min-idle: 5</span><br><span class="line">      max-active: 20</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: SELECT 1 FROM DUAL</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      filters: stat,wall,slf4j</span><br><span class="line">      connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>1、输入 <a href="http://localhost:8080/druid/" target="_blank" rel="noopener">http://localhost:8080/druid/</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/druid-1.png-xtdf" alt="1"></p>
<p>2、查看数据源</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/druid-2.png-xtdf" alt="2"></p>
<p>3、查看SQL监控</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/druid-3.png-xtdf" alt="3"></p>
<p>点击查看该select接口</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/druid-4.png-xtdf" alt="4"></p>
<p>4、URI监控</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/druid-5.png-xtdf" alt="5"></p>
<p>其他信息就不一一查看了。</p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践三：exception]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-3-exception/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第三篇，全局异常处理。</p>
<a id="more"></a>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>使用@ControllerAdvice + @ExceptionHandler进行全局的Controller层异常处理，减少模板代码，减少编码量。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>代码结构如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/exception-1.png-xtdf" alt="1"></p>
<h3 id="先添加两个异常处理类"><a href="#先添加两个异常处理类" class="headerlink" title="先添加两个异常处理类"></a>先添加两个异常处理类</h3><p>1、常规异常处理类：BadRequestException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.exception;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.exception</span><br><span class="line"> * @ClassName: BadRequestException</span><br><span class="line"> * @Description: 异常处理</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">public class BadRequestException extends RuntimeException &#123;</span><br><span class="line">    public BadRequestException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BadRequestException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、未找到异常处理类：NotFoundException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.exception;</span><br><span class="line"></span><br><span class="line">import org.aspectj.weaver.ast.Not;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.exception</span><br><span class="line"> * @ClassName: NotFoundException</span><br><span class="line"> * @Description: 未找到的异常处理</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">public class NotFoundException extends RuntimeException &#123;</span><br><span class="line">    public NotFoundException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NotFoundException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Advice控制类"><a href="#Advice控制类" class="headerlink" title="Advice控制类"></a>Advice控制类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.advice;</span><br><span class="line"></span><br><span class="line">import com.example.demo.core.exception.BadRequestException;</span><br><span class="line">import com.example.demo.core.exception.NotFoundException;</span><br><span class="line">import com.example.demo.core.ret.RetCode;</span><br><span class="line">import com.example.demo.core.ret.RetResponse;</span><br><span class="line">import com.example.demo.core.ret.RetResult;</span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.advice</span><br><span class="line"> * @ClassName: AppControllerAdvice</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class AppControllerAdvice &#123;</span><br><span class="line">    private static Logger logger = LogManager.getLogger(AppControllerAdvice.class);</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BadRequestException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public RetResult&lt;UserInfo&gt; handleBadRequestException(BadRequestException ex) &#123;</span><br><span class="line">        logger.error(ex.getMessage(), ex);</span><br><span class="line">        return RetResponse.makeErrRsp(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(NotFoundException.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public RetResult&lt;UserInfo&gt; handleNotFoundException(NotFoundException ex) &#123;</span><br><span class="line">        logger.error(ex.getMessage(), ex);</span><br><span class="line">        return RetResponse.makeRsp(RetCode.NOT_FOUND.getCode(), ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@ExceptionHandler 表示异常拦截，修饰的方法用于处理括号后面的异常类</li>
<li>@ControllerAdvice 是controller的一个辅助类，最常用的就是全局处理。不用任何的配置，只要把这个类放在项目中，Spring能扫描到的地方。就可以实现全局异常的回调。</li>
<li>@ResponseBody 和@RequestBody一样，json自动绑定</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、notfound</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/exception-2.png-xtdf" alt="2"></p>
<p>2、其他错误</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/exception-3.png-xtdf" alt="3"></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践二：result package]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-2-result-package/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第二篇，将请求结果封装。</p>
<a id="more"></a>
<h2 id="封装请求结果"><a href="#封装请求结果" class="headerlink" title="封装请求结果"></a>封装请求结果</h2><p>调用服务返回的类型多种多样，可以统一成result对象返回，方便其他成员调用接口。</p>
<h2 id="创建package"><a href="#创建package" class="headerlink" title="创建package"></a>创建package</h2><p>创建名为 ret 的包，并分别创建如下类</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/pkg-1.png-xtdf" alt="1"></p>
<h3 id="1、定义响应码"><a href="#1、定义响应码" class="headerlink" title="1、定义响应码"></a>1、定义响应码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.ret;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.ret</span><br><span class="line"> * @ClassName: RetCode</span><br><span class="line"> * @Description: 响应码枚举，参考HTTP状态码的语义</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">public enum RetCode &#123;</span><br><span class="line">    /** 成功 */</span><br><span class="line">    SUCCESS(200),</span><br><span class="line">    /** 失败 */</span><br><span class="line">    FAIL(400),</span><br><span class="line">    /** 未认证（签名错误） */</span><br><span class="line">    UNAUTHORIZED(401),</span><br><span class="line">    /** 接口不存在 */</span><br><span class="line">    NOT_FOUND(404),</span><br><span class="line">    /** 服务器内部错误 */</span><br><span class="line">    INTERNAL_SERVER_ERROR(500);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line"></span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RetCode(int code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、创建返回对象实体"><a href="#2、创建返回对象实体" class="headerlink" title="2、创建返回对象实体"></a>2、创建返回对象实体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.ret;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.ret</span><br><span class="line"> * @ClassName: RetResult</span><br><span class="line"> * @Description: 返回对象实体</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class RetResult&lt;T&gt; &#123;</span><br><span class="line">    public int code;</span><br><span class="line">    private String msg;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public RetResult&lt;T&gt; setCode(int code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RetResult&lt;T&gt; setCode(RetCode retCode) &#123;</span><br><span class="line">        this.code = retCode.getCode();</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RetResult&lt;T&gt; setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RetResult&lt;T&gt; setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、转换数据格式"><a href="#3、转换数据格式" class="headerlink" title="3、转换数据格式"></a>3、转换数据格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.core.ret;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.core.ret</span><br><span class="line"> * @ClassName: RetResponse</span><br><span class="line"> * @Description: 将结果转换为封装后的对象</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-11-03</span><br><span class="line"> */</span><br><span class="line">public class RetResponse &#123;</span><br><span class="line">    private final static String SUCCESS = &quot;success&quot;;</span><br><span class="line">    private final static String FAIL = &quot;FAILED&quot;;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RetResult&lt;T&gt; makeOKRsp() &#123;</span><br><span class="line">        return new RetResult&lt;T&gt;().setCode(RetCode.SUCCESS).setMsg(SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RetResult&lt;T&gt; makeOKRsp(T data) &#123;</span><br><span class="line">        return new RetResult&lt;T&gt;().setCode(RetCode.SUCCESS).setMsg(SUCCESS).setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RetResult&lt;T&gt; makeErrRsp(String message) &#123;</span><br><span class="line">        return new RetResult&lt;T&gt;().setCode(RetCode.FAIL).setMsg(FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RetResult&lt;T&gt; makeRsp(int code, String msg) &#123;</span><br><span class="line">        return new RetResult&lt;T&gt;().setCode(code).setMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RetResult&lt;T&gt; makeRsp(int code, String msg, T data) &#123;</span><br><span class="line">        return new RetResult&lt;T&gt;().setCode(code).setMsg(msg).setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改  UserInfoController  接口代码，封装返回结果。</p>
<p>封装前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/selectById&quot;)</span><br><span class="line">public String selectById(@RequestParam(value = &quot;id&quot;) Integer id) &#123;</span><br><span class="line">    UserInfo userInfo = userInfoService.selectById(id);</span><br><span class="line">    return userInfo.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果详见：TODO 上一篇文章链接</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-11.png-xtdf" alt="11"></p>
<p>封装后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/selectById&quot;)</span><br><span class="line">public RetResult&lt;UserInfo&gt; selectById(@RequestParam(value = &quot;id&quot;) Integer id) &#123;</span><br><span class="line">    UserInfo userInfo = userInfoService.selectById(id);</span><br><span class="line">    return RetResponse.makeOKRsp(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/pkg-2.png-xtdf" alt="2"></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot实践一：mybatis xml]]></title>
      <url>http://xiaqunfeng.cc/2020/02/05/java-springboot-1-mybatis-xml/</url>
      <content type="html"><![CDATA[<p>SpringBoot实践第一篇，基于xml的mybatis项目。</p>
<a id="more"></a>
<h2 id="新建Mybatis项目"><a href="#新建Mybatis项目" class="headerlink" title="新建Mybatis项目"></a>新建Mybatis项目</h2><p>1、通过Spring initializr新建</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-1.png-xtdf" alt="1"></p>
<p>2、选择maven构建项目</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-2.png-xtdf" alt="2"></p>
<p>3、组件选择</p>
<p>三个组件选择如下图所示</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-3.png-xtdf" alt="3"></p>
<p>4、输入自己项目名 XqfSpringBoot，完成</p>
<p>项目结构如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-4.png-xtdf" alt="4"></p>
<ul>
<li>DemoApplicttion.java为项目的启动类</li>
<li>application.properties为项目配置文件</li>
<li>POM是项目对象模型(Project Object Model)的简称，pom.xml主要描述了项目的maven依赖关系等，是项目级别的配置文件</li>
</ul>
<p>注：这里为了写配置方便，将 application.properties 重命名为 application.yml。</p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>1、创建数据库</p>
<p>新建名为demo的数据库</p>
<p>2、创建user_info表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id` int(32) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<p>3、插入两条数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT into user_info VALUES (1, &apos;张三&apos;);</span><br><span class="line">INSERT into user_info VALUES (2, &apos;李四&apos;);</span><br></pre></td></tr></table></figure>
<p>4、数据库和表信息</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-5.png-xtdf" alt="5"></p>
<p>5、配置</p>
<p>在 application.yml 文件中新增配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    # JDBC配置</span><br><span class="line">    url: jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">    username: root</span><br><span class="line">    password: newpass</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h2 id="注解还是xml"><a href="#注解还是xml" class="headerlink" title="注解还是xml"></a>注解还是xml</h2><p>在mybatis中调用sql有两种方式，一种是注解，一种是写xml文件。</p>
<p>1、注解</p>
<p>指CURD的注解：@Insert @Update @select @Many @One 等</p>
<p>在DAO层的接口上，通过注解语句完成sql相关操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDAO &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询一个用户</span><br><span class="line">     * @param name 用户姓名</span><br><span class="line">     * @return 该用户</span><br><span class="line">     */</span><br><span class="line">    @Select(&quot;SELECT * FROM USER WHERE NAME = #&#123;name&#125;&quot;)</span><br><span class="line">    User getUser(@Param(&quot;name&quot;) String name);</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 插入一个用户</span><br><span class="line">     * @param name 用户姓名</span><br><span class="line">     */</span><br><span class="line">    @Insert(&quot;INSERT INTO USER(NAME) VALUES(#&#123;name&#125;)&quot;)</span><br><span class="line">    int insert(@Param(&quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、xml</p>
<p>也就是有单独的xml文件，来写sql语句，和DAO的接口对应，是当前的主流方式。</p>
<ul>
<li>Mybatis 的 XML 就是为了解耦，把 SQL 从 Java 代码中抽离出来，让开发者专注于 SQL 实现。</li>
<li>官方推荐使用xml</li>
<li>注解方式拼接动态 sql 功能有限</li>
</ul>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>主要有如下层：</p>
<ul>
<li>model：存放业务对应的实体类，即领域模型类。通常也用domain / entity来命令package</li>
<li>controller：控制类</li>
<li>service：服务层</li>
<li>dao：数据库操作层</li>
<li>mapper：xml文件，sql语句，和dao的接口一一对应</li>
</ul>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-6.png-xtdf" alt="6"></p>
<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.model;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.model</span><br><span class="line"> * @ClassName: UserInfo</span><br><span class="line"> * @Description: 用户信息类</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class UserInfo &#123;</span><br><span class="line">    /** 主键 */</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    /** 用户名 */</span><br><span class="line">    @Column(name = &quot;user_name&quot;)</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;UserInfo: id = &quot; + id + &quot;, userName = &quot; + userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、重写toString方法，作为结果输出</p>
<p>2、@Column注解，标识实体类中属性与数据表的字段对应关系，@Id注解，声明此属性为主键</p>
<p>需要添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line">import com.example.demo.service.UserInfoService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.controller</span><br><span class="line"> * @ClassName: UserInfoController</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class UserInfoController &#123;</span><br><span class="line">    //@Resource</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello XqfSpringBoot&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/selectById&quot;)</span><br><span class="line">    public String selectById(@RequestParam(value = &quot;id&quot;) Integer id) &#123;</span><br><span class="line">        UserInfo userInfo = userInfoService.selectById(id);</span><br><span class="line">        return userInfo.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写了两个RESTful API：</p>
<ul>
<li>/hello</li>
<li>/selectById</li>
</ul>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>1、接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.service</span><br><span class="line"> * @ClassName: UserInfoService</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">public interface UserInfoService &#123;</span><br><span class="line">    UserInfo selectById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service.impl;</span><br><span class="line"></span><br><span class="line">import com.example.demo.dao.UserInfoDAO;</span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line">import com.example.demo.service.UserInfoService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.service.impl</span><br><span class="line"> * @ClassName: UserInfoServiceImpl</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UserInfoServiceImpl implements UserInfoService &#123;</span><br><span class="line">    //@Resource</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserInfoDAO userInfoDAO;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserInfo selectById(Integer id) &#123;</span><br><span class="line">        return userInfoDAO.selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用DAO中的方法来实现对mysql的操作。</p>
<h3 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.dao;</span><br><span class="line"></span><br><span class="line">import com.example.demo.model.UserInfo;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ProjectName: XqfSpringBoot</span><br><span class="line"> * @Package: com.example.demo.dao</span><br><span class="line"> * @ClassName: UserInfoDAO</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Author: Qunfeng Xia</span><br><span class="line"> * @CreateTime: 2019-10-31</span><br><span class="line"> */</span><br><span class="line">@Mapper</span><br><span class="line">public interface UserInfoDAO &#123;</span><br><span class="line">    UserInfo selectById(@Param(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- DAO文件路径 --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.example.demo.dao.UserInfoDAO&quot;&gt;</span><br><span class="line">    &lt;!-- 设置domain类和数据库中表的字段一一对应，如果字段本身是一致的，就不需要map了 --&gt;</span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.demo.model.UserInfo&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;user_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;userName&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;Base_Column_List&quot;&gt;</span><br><span class="line">        id, user_name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;selectById&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">        &lt;include refid=&quot;Base_Column_List&quot;&gt;&lt;/include&gt;</span><br><span class="line">        from user_info</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h2 id="mybatis配置"><a href="#mybatis配置" class="headerlink" title="mybatis配置"></a>mybatis配置</h2><p>在application.yml文件中添加mybatis配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:com/example/demo/mapper/*.xml</span><br><span class="line">  typeAliasesPackage: com.example.demo.model</span><br></pre></td></tr></table></figure>
<ul>
<li>mapper-locations：mapper xml文件的存放路径</li>
<li>type-aliases-package：实体类的package名</li>
</ul>
<p>配置完，就发现DAO接口和mapper里的函数可以跳转了：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-7.png-xtdf" alt="7"></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-8.png-xtdf" alt="8"></p>
<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>右上角，直接点击运行即可</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-9.png-xtdf" alt="9"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、测试hello</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-10.png-xtdf" alt="10"></p>
<p>2、测试selectById</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mybatis-11.png-xtdf" alt="11"></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的2019]]></title>
      <url>http://xiaqunfeng.cc/2020/02/03/my-2019/</url>
      <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="请输入密码" />
    <label for="hbePass">请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="41621d7838f754f98be6e75f51b4026ffdcf2b9e17d672d925683727a8bc9393">970663122da0020dc30b5528973ce721df0cd114b17d8fbd0663cbc8c13a8cc6faf7edcd69af5ebf5bd558bf5080501165242c8aaa8c810487df34f52c7dcd692286d616684593b756cbf6e2cad48186b439c09f4d042b4ca49680684e43012d2a9ec751300d8b9c1bf1db116e28be0b26f8ae496bffda4557153303ec8701efba3df055f5a8992de1191640be44138710341f68cbd4e859b5a185d289f98ceeb3277e697e82fe57ccc9635adc41571a5037ae704f479c1dcfdcc08e3375b13977f64a4678c4615e5cced9b3dde56aa800417c3ae7514ab5851a36be526b2c4f0e19e49e3ae6b5819e5c0a57c84a43e52c1c41b4aad2efd56efbfba3afac9b0476a8d8e3d16d467d202c0ae4ed68aa1e0e7144baf518812c0a4b628105b26ea3a3827def5bd96b2a189cf2193a9dc9567a58813e3e4aacfb55ef22b9ff11502e014f5885a96cbca166cdb22393cfce0ae7f4aa3ec9e22c52aeccd893bfc81fe5a36fe6a750a28ddfb7907c2acb9a1db606b0a55f89417a1f757122d731e81b563e778ce3c15e79997ad1c72ae3e7ea5d121e5c784f3f927b2ad1f67d93f8fe505f79ac7cf63ec560743c47737a756d95b96cdc6dc23b7291e9231fe259842514d69fdea60a7ca3b158ec28bb22e7c69f606b0aada4e92cf66779c5cf31ff7063b70e6d85c11d006ac7feba2cfb4ee993d1f06c4c55c1aaa6229792912c1566f941fe7aa8e9ad446545c72cb7328df2beb8e5d27a5e5b28c7f0a1053ab872a262fc39f84a8e809dbd3bb64d7f9a2d78abb4a95050c49e8b7cc6d212f509cf8f8cbd35f650ebfb5b5140320d7bdf8b0b2d7bb1e0770e14c0299aee94dbe234f31650a0b8a1c5228d7e6f277c01faafcd0b12a33f75362647405dd097c05395c6514e9ee3a494ba80b634d03b329062d922e2a3131737c872895f2fded5c094940269dfa868f65ae85751c1b05c5dc37c3f4d1171afe0143dd98480a4f481cacfd020904505f1d03474d12010b8d5a4aee1d94dc0023faa2c4912b0d4e6ef8c2c24d8767f914a695c795241b182aaf176a62d91c0f40d80e80d83b1508caa2db4fcee0108c75d28153dfb2f84d8c8b6d81f8dd34d8fc3f69d0d751211b76ba4eb630237bc7e60f71d114336c5d0b0abfff1ad7db67b529cae074818c72d7268305e8c2a0cae7efefa1fc8d9316b6e0efe0a394311a673d6d49cdff1532e1795bb34a789885973a31591aa9f9a47aaf940cf33050042f98219d4a131301118847c42bb04810f35a44d4150736945f9ed9e8daeb0643af295abdf790b88c64183e89e7d6b418ed6b8ebda4f74b52fc528ca2356889c26c468a5cca04d7fcc37e0755d9f807b393ef41a1e9aedf81a3ffdee280e5a39b12d77eddbd50908f231c94b2cbc7b3d9fd99950b7a9da72a111298714fa0faa49c1f18db450d8d75227432d38d6c2a13561a32485d2a745d5ddf3b78505d9b8dc82ed8b44ead0ddff6bd1321b17236bacf3b3c23b3d0995902e2c388a9bb5c2eb5ca86b1f8ec3d9874cae31d7cbd72d8e9c3d6fb545e68c30173d601ef829fbdc85e42efe34dd7af7f35239e5a880d4e6694ecc56e793e18f4f93742841d462d333e29c1fa56388915d965f729dd95181a954964fa4433428e102fdad4ea9a35ab37616b14c1dd65760ab3183d65b191e276bca3fa254c5e76794abb0a40c5c640a7c1387fe739de38050b13b767fc1f92903d25e882bf22e689f1f1fada133baa77919e5d3876621a410c3ae79a7d4c560075be2da9708dfb12a1f689e949847d17404ca8b060dc8b0b8c1abbfd9979493e0dfe595fc57fdf32bff326dbc3e455e91de7f96a4cb8beafcdeedd9d7a52de2b3a1ef0776a448b387a251eb4cefba6e319d4b8c80e8dd97f082a2c3aebeff4d4959b374ea85b4efbd2c11c507a8e8e578d6787cf9978b8fca0505e769f6d135628a3814b08354ac7bf5c281f0f1445878747811451ffe30155479ef251c62081968840290e5344240ff5f29cee25591bbb30bbfdadd5da4a908ba0e454cd8db291616a2fbd68e2b2e5aa45813c62f36c21f18ba507f9bace77e6738f38a9479d22165018abb9009e04575482d4405722831b4db9363a8a66b0c1a00b73a6708da28636c76dcc5ca6d52252cfcf6d20bebf5b53191899d185a85640a89ac7c5d8065bb785d9de6eca05e19098dfb755d12ad30a6913ee4fb741122512183f53503ccb0525b5ec39e637c895fa58ba2e33ffe54c77059c78d3a0a1f1f20b0e0e32b106fde46f05d310fbf3ee7e8c3754a7600ba22cf2c15aef2a76a4a8ba9e7c4741aae83642afd23edfe15316d24dfd92d3d34cdf14c079f7d9eeb1a48709c89054276227850507f6ec14ec8fb82d9857986c163b2be96fbafead5c4c949ab444e76335f29407ba095ac8b65f6d062ea0360ac92ff9dbe3a5c745e201b1ecca3d7ec98303e6475d7d33c170664dee407ec6325de59fa3943043cf56dfadb3ca7d207ed66b6ad3953cc019d85b9ea411071f99845753fa8a0fc7a532675658bb2b0cdef45104e4bd17b209b3b074136275715ece2931fcfdf71259e3e15490c2ce45679dfd60e7211a1c7acf4b629b06c6a8faddf279c1ae923c7fafb132597a1751cd192b9fa1ac50e7f76a410dbb2235ace444512308eea62898c74b2f6ca6489bac8391ee4df4b0edc48bcda760c415d9266cae45fd1a8cabe8af23f1049057c89cf5d38a149fd79ed546af3acc5e43fdf42bc6ca4ebb3c583e0e7b02bf5823d0579fcb86e7eb1933f2f087811a6d516c4ab67806e2dec9bf4c6c283a06967b9472fec347943caa2c3c4cf1cd71547e8d36709019bdf35ea0213bc8e1fd7ea726326076a988ddbf0adcccd65c1d8fecc297646f03b61c38db32fdfbb8569028abad706b51da547e97013816f7233da21a2bf82c064cf3c13d946e4c59dfd8bab7d65ae9733d46b9c22f85a064d0ace81737bdcf90791e6cd7ec1b62a4d99fc313b34a4aa213d97042f97c8cbaeeb4f0dc216fe4fc0df384194e02483e5e05ea6a4c5df83e143b302646f15767ea8ed4518391386a7f8ed6efafe29c419fd75cf86b6bb06d365d39298dab90b68cc773217849cbe37b511c2beea64e747b404b857bb7d3e0d32d3ef8a9da8fdb69b4c6ed292bedc03ac486dded5a5acbbee472c667a4c3f6a6872fc11fb612eb1a1949f8c14fb2df11d1653ce49cdd6b0fd7024a67ad97fc63d61ef9f0870d8c67c601945f993d633950a29b1185eea95f4bb02de4328d7bbd1aa4ecc55c8b9136c558266a2a5184121bddf5d64470b749f39de35e52c2b1f6a826ab98c5a010fd78b8dd83e1899b05ce5cf76f7ccff0b95e224a0f52b67bdc074d262afa38485c0e9a44f00ed9bb5661bb11d656322e9a3b5e42aaf0e5166a2ef2681d85924c42a6c0918bdf307dac4d4bc311ba052b5c9d47de848aeb10fbe51d51679ce0a0be404f8ae0f8ce7efdacc7da1ef0969c030041b6890febd6b0fd2f3823aaf73cbf023ae7533bb3acf64b2cf1fe0ef534ed38b2bd57f2766c61b4fc811437aeb98bf164a6a48ed7d010fa332138167cefb097322e792f5e985a503a863c55e52acd3bee80cbe9472cb2eb5cf6a0f5377733053bdc351ee8baebc5783baf3c9cf922324c8b74e786ed51176c8e829057b0897e5c260b905a00e44ca3a07b17ab621113d83a8a0e884839861d2876b26f7425241a21e768d4de2c0282c7b24ec6c8ab10f7a5b06d501f0f333522df8584216302c364c13dd399c4dcea43c97d5175ae2e4eead395f6503c19b6b93dcf802ece4bd4670c4998600030a918ca5fbaf77b66c090d6dbb02c70060478de5e4f604a774f8c2a17e55e7cd14ad1f4d0ebab56b70906193768d6620c779a44f95e71b35c5527a228ce28fe2b8ca1a6d55c56189c6b399b2dc67954da63577eb51a848d7a43bb62bdb310cef4c8867dd5343ec1440cbc3d814767d13c661d7d505d34915f2185c75526b6cf2b82dc9c24c258126e696a1c20ff478ab818465586e64de50d4cc5c16426fe720a5d12be48a210fd911f24dd5d552fec9a37b46c24424a1797e6948e94ad6501b53a056c120e82219842f7c4d09ccea5848cf2d986fc5e0ac27a211dd79b959289e378bd6d6427a15b489fc350bd9d3783088a36c300928b8f39923ede1508b40f545bb7115c661e19119b21a0a8920ba0378f01e5bde69fb73a7b2a383c9b8d7a6f613e39d652249a3322701146fe74b189171df9b0ec562c0ac3606635d618edc0bd93afc6e8135f740c9f22740ae9313f9861635cc42324f6cda08dd7411fed62db9ab4d9f3e9ca0787d22b0ce1a79d39d3642b8781a523b50af55898b56b97d77234f0e3fa40aa7b33632ea8c4b4b6aa7fa383fff1c152260e5477e73e2428642863e446927b06a67cfb27eeb166970ff5dc1d90a171481681327f14157d61539f6d30d3fe03617d0f94e569dacb66f32d821a13bfc0823930f2c61dc08dfc7183cbdc454973f4df6fd2fb57cb24f955305cb242dae1131722e5493d64fab8fd7f999d4a924f0fa61d0dbcd5f112f8346296a6515fadddacda9f979b41c0436c78ddbb0caee5313846795f231b944660fa9726f2388e3a7fbab5c423dc260633bf5b6af2540ea75a08e2727bca1f8f74faf182498f993a7f3481e21ea09badcb7c387b16732a821c3431e8ab33c8ef9d5fa411b60abfa8bc2a115c2ed2c1f7cf35c479f484e276f759740c7d30dbc59fe3d325f9a5f538c33a61d1b3e65128b3271a07bb13f1bb2b760de18241313fd288ac885a09300e805e6e608baebdbcaea4ecf74a413d866fa2b04c1ae8bc35e23f97ce7e80ccf25cfbe97b3e6e419f933d77de475a69367eabc7d7409aace671e1d1254961d1312299c7d0c0ea8a2f94368c977ab4c5cad9e565f9c1e0cfb2d01ee3be9fbd47eaf804b572518b678766cfbc214558b7c31dc6ed5ef5fb5ee30b476b2589c1583fe445fe84f78dfa5982e831f8dd8f9bf23ce2ca5bbb4a976a1583ed4c28794a788047649ab41d0ea2b37c5e28b746060c9bedc91a1159211d4d0b11788b297e06608f26694eb3d4f5d12f75149e03b2c992a64a69c203dcc07da8d0b635723f1810ca37505f4517e9a539edf0dd8c34ef1da6f27701fdf287c626dbf9fc482233edbbb04e4aca9bbfcbfb57d1f5841b7e78d33821d611a2747363bd686ac93130cbd7f32386a5b0c9732515e72e49ea4f0ec3937f2739ae421506f876f6dc30ee02fc11c3d1f1afef4d2b183c71534b5ef5ecd67a2a27957637297eb49001f9a981f261871768560cd5597a0994f596b7b5e7f313515cc1e3a9cd73e616b074ca445592237cb997047a60cf7a5383d900a340ca28dd576d730d5bf0af2e592e09053e55c9e756624108fbbc47dd0b12861a6508709bf6341ad7a72304c3cd8399466d4f18c1f0407485e26c3e079172c162b751d32f0e32b70e04a77527df37d472a883335cfd914c67c420a79d60eb756cad51e265515d91c8e05e2a3091309ac50e5b6d68df2e0d6b39e3416ec94fefdd4b6c1589e12d137008e5c99cb9904765b2aa7615cd30b9199311e7cd427dbb872c07d9c545c42d3c9c0e79286d94e94c075e52261594979c2aa81c572aa49d83d7b17a5b0bb0d1fc8900c054f0d88774d2df673e6cf10452ab6d707f445a19ca222cbca764c423cdd14e92c9835c2796ffd9e6426c4fa664393a9089d21754b8aa590312aff70e2187163a2dcf9bef76281ff5282bb97253887b6a6044a913dd5425fcc384c63b133a7de61abfdfe2191c07b3f6a26a8219571c0d377d2eb39b7564ebc36a802dce1816d440c6f6179ef6d91e5c4d17822918de7679cba1586441d5d3088e696c9b0bc2275370d51a865dcfdee269d5f80a198f6ca4c32ba3ca5ec91ac64615e4a840ba673e15f5136c17762dcbc94af964f5289d268d29ef4ce556e576fe5c7559414b41854b3b8990b370884beaf388f0836e3619edaeee4b4507396e8de5416fd0a8473be2d8f465405416c35b76f655095585eff1cd75107e1f007ea9309b6cb1db0030077637ab95221a90b776bf77865b0a8ec834d75144391da6c01d1b5d1576f949ddaec9d032e083e22e2b9e51edb9041166ee81c7ba91aec4a3928ccd572f2d910db9e98c88d25c33467453d853c10cf360be2c3a9a38fedce5f6a583df58d5b9a7e55c4fd972eb74d4689661bec2a4be982ba2e1177c8808e264b72ae5f5f10a63304580b7d7c61fdb7e4c01a66b745d88311dc0e6df2947e2738e090d4d36fabf363c0e5fa5355da9217a923cf3fef5053f010db4e57e2eb5600928a27092beda0e4f9724920ff969de3b52784192f2ca9d8da3da70d174adb659d13ce2eaf7ab0b435c22df296645fa8b4bdaf74d84457d0730a95b6e326b31cccae92076f08f6e56e448c6f9613038dc071ab34558906c309c28f5c802850ec449d5f0ae534e49177b5adcd8fb7582b96c79ef9570785500e35341eeea58a7d974c072642cf55c488681ee24e1e505758f20c9359dafaa2bf039a5bed373c2b6032d29e058d41afa5c6bcdd4ccdaaddf01298f429cc8c6f28ab315780a458d6767b0b6e7a20bcaef8d08227ce070575263401beb6b368d32832f5feee53c029113375cda09ddd15ec00d167b14176903a0dc646a65f28d6c3a6d3dd9667a9dfba132859d561aea43b381970ba4b37600a6a2785e1fc6a07fc8072804e1d68f5b78fe2516d5da36a440a47e574676dc612e6f3f4fe9eeb254719ef6bc12e68a1c71a07e45a55caa7318f4f3de663506bdfffe6c97012dac844b7c960f869fa720b004770cd58d1bdb080e6da04463250716adfdc2f69765b86cd7e465349d1fc8cf66e1f119ef6634038d993c89bed2058cc510e5994d5c0de34a2edcbbb43d1b7903e3c3a99d7de3451a0861f93723c942787ec58de81505fdbe9f1b2999c8cc3c63a130bf8e39fe79af944476536d992aaf514520327be31121bc25bd7dbd2f818d529b71f89fea9c5cce8e1c73d1c0d0fc37fa5ca8e9954936e536e2a2a261118acd3fcb23b101b6810f403fd52c821f8184c4cdd93b35b8c26ccd839114568d08f671f987d1cc365951fb71a9903fa9e8f31270c5cbb44b7e6d6611a62951206e25442148c726c628a55b6fb995be795407da0015e2344ac777058483aa542d38d47ce58dbbe77d5d3642c43676413e9f84ffa1b4f381e994ff761f345e1b8565f939241eff1c1a2e3129bb9cba38a81faabc5557e1ee2ba38de3ababe178182e1f23224313f0de4694fb2370e82f3eb7a7c16ede89e15b2ac40850881423242e52fdf07bf9bc873595ba1135c3f76c39b42be0b16233353a5b89dd101b429c4be64b5ad921c5306534d32bc4565310d7d93a18c2caa5557fb111c264426eed9b6379e76002d70046d7c92317ed1310b76064fb5b8a34e5874148da2615bf7973b47c731487cac6f48ca2e15e750fc467d2a5ce8c242353d67fbd2ad8d63ec56f3aabab22003b5bac487e30b4e1d2a082d32a68ed3b048e94ce8d1967db6d910da3ebbd3b552d8678ae7ab7ffab0566e6c4288e9f9e4dabcf3c6be8229a3faccf1160861fdad0b7224ddb010a372f7d4d54780e49af963fde1d38c90ef2c52eb3947219a7470e9af9451839e697857d63974b0fb1fe803db167413f53339a86d24f17353d87cbcf12034d3b61a35bbc9458f41068e46b6a1113d8671895aa80132467a2310cac190e01bab589df7d77615d66cd720e051ec0ea8a67e1b9f967bcbba202db49fe0b80e0c2cf91e17f89e13b315c6d8f4794ef6b198f511c63e85fbe25bfa04d88fef0c33a52ba2f7a0ab96d3731aea2e7e5eb60c7ee30b6e6fa305515f150b4e51b5ebf4263b6eb651ca44190ecedd0ba81ef196a658f137f553fef2a27224cc64519760921e0c10f278675b98b7ae99a8729195a8606b601ca06b2dbd83123ce3fad5b50ac53e34d15d837e225c5b02b91d901ba813f2acf2c3d78c56748495221be56fdb14f4cd037b70cc16cb5fddf75efb427faaef2880529d7fd1dca88ddde960b3ed0621959149e95f148269d3a0507d915363a419df351f1d0dab2aa566f4c70ed398de16ef69d41dec28680aa06512e5e20dff6865825e835b8a0893ba204b06c55aad73989d57b39202f250b8c1ad0db8a227cb5268cf10987e10ec8099728a364ad2f21c0678e12d66dd768b2a43f1dc7698c1a07a7f11ec268a32645e48bfb5e784c699e41b27096f30e5c97f3f2d803249358d3b024e899986e8945db8bcf4f6eacbab92fa4a9365d15a67d38e5bd559cd6b6cfbb7f4eb9e3ac8d0ac62ac4cab05b7caf2f6261c37ce843505d5fb28c4ccf91fa78a704522e33ec82b751fb4b0f56a4b5aee31d31e8ba482cbed2d8b6717d5936141143021af40c41887dd98e65df80850645847349f7750254ae983c187776bc6b811f45578bed58bfa6ccc8e2b1291e980bb664b3434c6a4384cd05314aeb19b4976f484aba87bacfcbcf24849cdba72e2d4b45aaaad06c677ef00eba6c5bf52a952561356ba14090260f2d08d04be91178491400c545a9944e430bf01fd02f49c09033bb4fb679d557dd2268437d065c75c5dc90729c9221333fd268267b5ddc9224e7948c7503054e26cf0e08866bd507a6ce221440d4e6ed7ee37769807344815714abcbee4346b9a8752d3a9ee24a2b8200cae0e176a584a710e77d28db654544bedc1785a53ff98d716e69fb36fd9077527010231c5d4c432e89271a7d36ecbc5e03864c1607143c7d9012c92e1a2cdf33c3886240be9f2875df052a72b6740d8f2e2606f578421419a063c0b2b66861bb3757b993bc32340dcdc93fe1ed81946b2404dcc033c24e562f2cf14f9901b7f64bbd7ac65c66a79ad82a7e35013ef0ee5edb6f98f5c8d25993984466a6ae90832e5f7a75babe30a0b49900c64fad6448adc93a123d96773db94b8db868c3169b9c8072cf4cf47736857ea58d1277590ef4f4bbfbee73b5d8174b23a66af53da12bfc8f1e294c0453d4cd28b875c0d6a9b99607bb4dfed0a4378ca7a581e978ba5258e73b29d6b452015924c89e0aa891bfdeb5e85e7a47d0d030d03733e047909ba2a92c9d588afe57239649b30ad73cb79732079236696d1613786fe8dcb6e31a7534eb4509834a296416cb829dac824e764e58756e28a421179e8345f2e238183f53ee7c8349f9ac4c3f857944f8f0ea7434de7c64a3c36916c79e66477a45ca1c3b110a130e1178d190b16daccf5d247f3499899b53c536e0333e0505fe7dfd9bb10f8c669e7168257aa4224968ea62c10045b09afeaec2dca7f4aa28a505434e746bab38a7231e94d17e928dced68bec6486fbfce3582e38061af0df9c4c04521278ba04881293d2fe60c203d36cc93869b353f041cba0cd5a568b5c558a73c2f029e2c4459f889650d8fd2500362fb8e0f50b3050f6c57cbb1b3fe5569977356b4650512a8848c2cd25670ec5eb379964bc8b1f0e629ff7aebf04e68a64c6c42c663c3cfc2f31637e76e168a56e51e47a4503102db1b96f14afc568eaaf22b562108eb66aef280ff5f65d80d13a2c0208fc4e58a97faf224dd9f27b30dd38617019b21ffaf65a93aa70ba7a3f1d6924671f27b481c93195567f6f04b16d5509917a7021ff64db0109e2d9e9ff46aef7961819446c1eceedaa7c49b3cdcb4ea5e79f1e69128e08cde6fa5c44fddde89727baed435f9f498b2ecbce6fd6bf1cbb1ae07ead0aa6d1a0599aa940d404c3c4eedaf696dfcb505ac3ca016bc1735ad5e40bd1751e8f9f44ea7369e61c0c993127b2152a96fac274bedd9705834686deb5bc91a6cefcb2e544783c4c00694cf5abb71f272e420cac1b82ea54287cfed67205d16e0c8fceae9ef7351b02057868649bbeb13530e952548d2d225037eac4e83d969b42f4454579a863e5821225f106d0fd29838124bfdcf9b6ffa33c210661efa468946761ca4008742c83c29b398304c36d71c50f7d4fb0250dc3688d9ecfc57a83c2f223ab2ad06d0c640627b2050ab48b8be290d9cd79ca7977afc2335e9e8b671305b5453f2b42ed0a3856c90400f9b14e05a570d38bfd517f087386819b345fbfd4fbbfbe9ca5032768b0f420907a8f73eddb8f7966962dbfdc1d66e57eef0d64c75b87af17685ba23dbf2f103f287f0f7ad4f4d0a28478d1cd9a071b71cc89f09d47ab457003ce6509242199f84cc612c11f40a482bf33ffedf44201fd9df2e59317b6c66df3c0737332c5e54e3ef05fd69ce04b62899e478c5456ecca70dbcc5a599a88ba9685ac93f9e9977955085d286af767043092754b7608007420db00e1505f4a3dc41fc3bd7e6abdc052f97b8b01e2cb082ac20a9595bd76bd15589fba84e009ce95fc1343be71194def29926e1c6b67da6db5924e97f2c894d97099705d6d7edd62df9a85ad9ded4cc4aaab7c5642721449a2d20f96e65af7f01631099db5d5d1a8311355f43e1b286d9875c66b5b302d20cbcfdca629817be2093bed80097f2380c2f280b4b080b166137824c0fbd3c5fd2cac348b0bbb80b72439349712c4e6742ec3ffc805c8e9be3a962071fe541646bdfeeb36330b70cdac9318429a955cf155d6af2785d488b4a461fa0800c6a5acb214ae789ab94586eee5c1a953a4feb487402bb236f41bf4f41a5747abda2ebe841db571c08c0627e44d4722f48be17ffbb6893bf7f8d1c31540a4eae73504c1361860e5e730d2b40c7add6cf7bdab565d4add522dbd63dfcc5d747afd3e7f42c0165a8799dd19c892c5a55eed581aea1b84aaa9416e490b3a55ba1d018ca10212cdc01b12a4f8fac5553b7e4e3899fa2a562aab5e3501ee099cd686b16d26d1b188e31bdcfec0d8db2a7360907d3cf0a3d9d89041172eba98b7c7da2db6c587cf3b386ca5b3c3c886ad5416aacb75866c9952d149e2fabf0e976d9e76a714869c6e0f13eade284bd8fc082fec968875f9f4e0303e599ee3657a9fc6bb491f64e98350f7b2f7c612cbeaa9af787ef915e22427c3b7e6cf6059ef9aeae8fb5c97e3bf23b071cd5608b9f6a8a8b01ccaf5396d8f652537e4aafc79d5478f2d685f0a8e096af72565fde0ed8413f68a46500970e972f72f29a72b6b12b5a98cadd3ea4f1cfb407fb1b33d8f56d5169d049fe85b7cb8fada70789d6dc996ccf986894498825ee7f06ff2ca229ed634cc396cc7b9d1580725d02dabe08a2f3190a17a7b7ca469093150c3d180b1a60671eaaf42e49935d8dfc1bff2b4572cd777a77058b249e2420ed29d91ad520ea8b3a975143c1884430f118316be7602dbccfc0867a5eaaa809e24fee8297a070e6823b9d76271ce82bd931aa0cc694f075ca6e869a88bf0e66b27fbfa9ab2f12fc57d01cd856c8d8d326050605c3f106434748451f2af6c7aac5d932ad5643dee2d6c09de15a579010d67afd7960bf06d74a7923cbf423220cd5d4e6c5e7182c2c7689c229079d4875c4e4f947025f74446d855368b8af1bd6d671271314ccafd4bd741ef1e044daf361952e6a7648c6ed5c888fa66d2ab9a1d0689d277215a999cf679f3ecb83d3087722fb7092333ffc7413bbdfc404e00d4f681c410366ae5003cd56b6fffc04a08f08ab00d715c711676078657ede19c7dd2763c51218b412d7ca9f66c87b2d500fe7045da1c7ba0cb5ba145c59060a611ba7cd3fb70252304e4d79c675bb0e3f2e6b9e5d46e345c6b3eee529523ceaf6252326f0c17515117c7025b29853843b9f1e4dc4ded35b6dc9ae36c660a2f9357b08095a56f2857a095992e91749338603e8e804643939ee36d9234e067021ac70239536e31c39d4a7826662728203a45e8f9879b284f3f2db9ce4b7e99fd36a9cc5a3613e7869e67f13436b53352cd3ac343e180bd2891941212ab83313d96b2f6c26cf09f56c43b7d1f2ed95ff2f8a460b64a01687a1a75920a43d8ed7064d75aef35e526f594b3b0e7bdda8bc12d948178480d9840506b7bda8ba06e0157629434008b7f054825c95107c9219aa9c6ba52813e3da6e92e95605b87a889501a0a451655f9d3b684378649949ee70abc4d528686724c37c206c2128d8a563615e16298b3370a17961d1299be8c54ff1965c3f3911fc5d90a7ff63a2ccb5bb76d999a906fc0fb85805ebf697ed69a1623e875cab987441387392bcf0ab0f7f5c7a9c14874ae337024d258981c2d5609ea0a2d89fd52cf4e0d629aa77be52519c23abe1c116c0739fc9f259e77e86a9dcf9ee15cab2e8445debf111023cb279c3da5f1e3aa71422809585cfa40371252629752b902e475c26b30b6ca853faf7a2508a8ea8cb7c815cfe49823577cf28a70631b9722424e24b72fde207d98962879728ef31fe9dc6229acd3cfcc4fcce0702995cc1b3822912d7e3473fb992524dcd8b5f7eba3e7a080017332ee710b54cda636f72c616aeb66d50ea052532995e6242b79437cf583d2c8b95eb4b75f3ddf72bbc5196daf2fe149cbbe6bf9c68fdd74ae76872d52213a422799654f41f30d217392e3b64f6412752b7e5643b51683e5074219ed84535085d0b687f6b14722a4df1092ea8255be752db8c0765ef34678c720d663206fbf1f6d24e05aca6560684236501165cc522d6c9c49ede464f4abcf7b6b7d9e24a2bcb1c0a8b1a75ad819cc585c44ca670d6ef5a0e3c46cc8aec835514bc32f86c0d745b86f97ea23bc17bb54a8fcb425e3abed0f5</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Nvidia Turing vs Volta v Pascal GPU Architecture Comparison]]></title>
      <url>http://xiaqunfeng.cc/2019/12/06/turing-vs-volta-v-pascal/</url>
      <content type="html"><![CDATA[<p>make a comparison of Nvidia’s three modern GPU architectures, which are Pascal, Volta and Turing based on their specifications, performance, usage &amp; applications in graphics industry.<br><a id="more"></a></p>
<p>GPU is the heart of graphics card and its working and performance is defined by its architecture known as GPU architecture. Each graphics card family has its own GPU architecture and every new family or series of graphics card comes with more advanced and power GPU architecture.</p>
<p>Every GPU manufacturer designs its own GPU architecture and GPU architectures of graphics cards from Nvidia and AMD are totally different in working, operation and naming. Examples of Nvidia GPU architectures are Fermi, Kepler, Pascal, Volta, Turing whereas from AMD we have GCN (1.0, 2.0, 3.0), <a href="https://graphicscardhub.com/nvidia-pascal-vs-amd-polaris-gpu-architecture/" target="_blank" rel="noopener">Polaris</a> (GCN 4.0) and <a href="https://graphicscardhub.com/vega-vs-pascal/" target="_blank" rel="noopener">Vega</a>. Also two GPU architectures from same GPU manufacturer are different in working, efficiency and performance e.g. Fermi is different from Kepler, and Pascal is different from Kelper and so on. But here I am going to make a comparison of Nvidia’s three modern GPU architectures, which are Pascal, Volta and Turing based on their specifications, performance, usage &amp; applications in graphics industry.</p>
<h2 id="Pascal-GPU-Architecture"><a href="#Pascal-GPU-Architecture" class="headerlink" title="Pascal GPU Architecture"></a>Pascal GPU Architecture</h2><p>Pascal is one of the most popular GPU architectures from Nvidia and the successor of Maxwell GPU architecture. The GeForce 10 series and Quadro P series graphics cards are built on the Pascal GPU architecture. Pascal GPUs are built on the 16nm / 14nm fabrication process and uses <a href="https://graphicscardhub.com/cuda-cores-vs-stream-processors/" target="_blank" rel="noopener">CUDA Cores</a> as their main pixel processing units and for Rasterization. <a href="https://graphicscardhub.com/best-gtx-1050/" target="_blank" rel="noopener">GeForce GTX 1050</a>, <a href="https://graphicscardhub.com/best-gtx-1050-ti/" target="_blank" rel="noopener">GTX 1050 Ti</a> and <a href="https://graphicscardhub.com/best-geforce-gt-1030/" target="_blank" rel="noopener">GT 1030</a> are built on 14nm FinFET technology while others are built on the 16nmm technology process. Pascal GPU architecture brings significant improvements over the older architectures in terms of performance, power consumption (TDP) and heat generation.</p>
<p><img src="https://graphicscardhub.com/wp-content/uploads/2018/08/nvidia-pascal.jpg" alt="nvidia-pascal"></p>
<p>Pascal GPU architecture supports GDDR5, GDDR5X and HBM2 memory. Only higher end workstation graphics card, Nvidia Quadro GP100 comes with high bandwidth HBM2 memory. Nvidia Pascal GPU architecture supports DirectX 12, OpenGL 4.6, Vulkan, OpenCL, SLI (for high-end GeForce cards), NVLink (for top workstation GPUs only), NVENC, G-Sync, GPU Boost 3.0, DisplayPort 1.4, HDMI 2.0b, CUDA Compute Capability 6.0 / 6.1 and is VR Ready. Pascal based GPUs can also be found in Notebooks or <a href="https://graphicscardhub.com/laptop-graphics-card/" target="_blank" rel="noopener">Laptops</a>.</p>
<p><strong>Must Read:</strong> <a href="https://graphicscardhub.com/gddr5-vs-gddr5x-vs-hbm-vs-hbm2/" target="_blank" rel="noopener">GDDR5 vs GDDR5X vs HBM2 vs GDDR6 Comparison</a></p>
<h2 id="Volta-GPU-Architecture"><a href="#Volta-GPU-Architecture" class="headerlink" title="Volta GPU Architecture"></a>Volta GPU Architecture</h2><p>Volta is the successor of Pascal GPU architecture and is built on the 12nm fabrication process. It supports high-speed and high-bandwidth HBM2 memory. Volta architecture is only designed to cater workstation and datacenter needs. At present there are no gaming graphics cards that use Volta architecture. This GPU architecture is powered by CUDA Cores and Tensor Cores. The Tensor Cores are used for Artificial Intelligence (AI), Deep learning, Machine learning, Complex arithmetic calculations and provides an over 5X increase in performance compared to the Nvidia Pascal architecture.</p>
<p><img src="https://graphicscardhub.com/wp-content/uploads/2017/12/volta.jpg" alt="volta"></p>
<p>The graphics cards that uses Volta GPU architecture includes Nvidia Titan V, Nvidia Titan V CEO Edition and Nvidia Quadro GV100. Volta architecture supports NVLink 2.0 technology which is much faster than the previous NVLink and allows much higher data transfer rates of 25 Gbit/s per data lane per direction. We may be able to see more graphics cards using Volta architecture but I think it would be only in the <a href="https://graphicscardhub.com/best-workstation-graphics-cards/" target="_blank" rel="noopener">workstation graphics cards</a> category.</p>
<p><strong>Check out:</strong> <a href="https://graphicscardhub.com/volta-vs-vega-vs-pascal/" target="_blank" rel="noopener">Volta vs Pascal GPU Architecture Comparison</a></p>
<h2 id="Turing-GPU-Architecture"><a href="#Turing-GPU-Architecture" class="headerlink" title="Turing GPU Architecture"></a>Turing GPU Architecture</h2><p>Turing is the successor of Volta GPU architecture. It is one of the most advanced GPU architecture ever made. Turing GPUs are built on the 12nm FinFET manufacturing process and support GDDR6 memory which operates at very high speed can achieve much higher bandwidth compared to the previous GDDR5X and GDDR5 memories. This advanced GPU architecture comes with CUDA Cores, Tensor Cores and <strong>RT Cores</strong>. Turing is the first GPU architecture to support <strong>Real Time Ray Tracing</strong> for creating lifelike lighting, shadows, reflections, refractions and other advanced lighting effects. This Real Time Ray Tracing is handled by RT Cores and its performance is evaluated in a new metric called <strong>Giga Rays per second</strong>.</p>
<p><img src="https://graphicscardhub.com/wp-content/uploads/2018/08/turing-gpu-architecture.jpg" alt="turing-gpu-architecture"></p>
<p>Tensor Cores in Turing GPUs are designed especially for Artificial Intelligence (AI) and Deep Learning for performing various types of complex calculations. It is also used for a technique called Deep Learning Super-Sampling (DLSS) or (Deep learning anti-aliasing) for smoothening out edges in games and for denoising, resolution scaling and video re-timing.</p>
<p>CUDA Cores are used for standard Pixel-based processing tasks or Rasterization, but in Turing they feature a new streaming multiprocessor (SM) architecture that supports up to 16 trillion floating point operations in parallel with 16 trillion integer operations per second. This can now allow Developers to create complex simulations, such as particles or fluid dynamic for scientific visualization, virtual environments and special effects. According to Nvidia, Turing GPUs provide up to 6X performance over the Pascal based GPUs</p>
<p>There are both workstation and gaming graphics cards based on the Turing GPU architecture. Turing Workstation Graphics Cards include Quadro RTX 8000, Quadro RTX 6000, Quadro RTX 5000, and Gaming Graphics Cards consist of <a href="https://graphicscardhub.com/geforce-rtx-2080-ti-rtx-2080-rtx-2070/" target="_blank" rel="noopener">GeForce RTX 20 series</a> that include GeForce RTX 2080 Ti, RTX 2080, RTX 2070 and also the mighty <a href="https://graphicscardhub.com/nvidia-titan-rtx/" target="_blank" rel="noopener">Nvidia TITAN RTX</a>. Turing supports multi-GPU setup for both Quadro RTX and GeForce RTX graphics cards using NVLink for doubling or tripling their computational performance. GeForce RTX graphics cards also supports <strong>VirtualLink</strong> via USB Type-C connector for connecting VR Headsets on USB Type-C port for an amazing VR experience. On the other hand, Quadro RTX GPUs are capable of processing 8K video in real time which shows the power of this new architecture.</p>
<p><strong>Update:</strong> GTX 16 series Turing graphics cards do not come with RT Cores and Tensor Cores. They include <a href="https://graphicscardhub.com/best-gtx-1660-ti/" target="_blank" rel="noopener">GTX 1660 Ti</a> , <a href="https://graphicscardhub.com/best-gtx-1660/" target="_blank" rel="noopener">GTX 1660</a>.</p>
<h2 id="Pascal-vs-Volta-vs-Turing-Comparison"><a href="#Pascal-vs-Volta-vs-Turing-Comparison" class="headerlink" title="Pascal vs Volta vs Turing Comparison"></a>Pascal vs Volta vs Turing Comparison</h2><p>A quick and brief comparison of Pascal, Volta and Turing GPU architectures from Nvidia.</p>
<table>
<thead>
<tr>
<th><strong>GPU Architecture -&gt;</strong></th>
<th><strong>Pascal</strong></th>
<th><strong>Volta</strong></th>
<th><strong>Turing</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>GPU Manufacturer</td>
<td>Nvidia</td>
<td>Nvidia</td>
<td>Nvidia</td>
</tr>
<tr>
<td>Fabrication Process</td>
<td>14nm / 16nm</td>
<td>12nm</td>
<td>12nm</td>
</tr>
<tr>
<td>CUDA Cores</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Tensor Cores</td>
<td>NA</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>RT Cores</td>
<td>NA</td>
<td>NA</td>
<td>Yes</td>
</tr>
<tr>
<td>Memory support</td>
<td>DDR4, GDDR5, GDDR5X, HBM2</td>
<td>HBM2</td>
<td>GDDR6</td>
</tr>
<tr>
<td>VR Ready</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>VirtualLink (USB Type-C)</td>
<td>NA</td>
<td>NA</td>
<td>Yes</td>
</tr>
<tr>
<td>Multi-GPU support</td>
<td>Yes (in high end cards), SLI and NVLink</td>
<td>NVLink 2</td>
<td>NVLink 2 / NVLink SLI</td>
</tr>
<tr>
<td>Graphics Cards</td>
<td>GeForce 10 series, Nvidia Titan X, Nvidia Titan Xp, Quadro P series workstation graphics cards, Quadro GP100</td>
<td>Nvidia Titan V, Quadro GV100</td>
<td>Quadro RTX 8000, Quadro RTX 6000, Quadro RTX 5000 / RTX series graphics cards</td>
</tr>
<tr>
<td>Applications</td>
<td>Gaming, Workstation</td>
<td>Artificial Intelligence (AI), Workstation, Datacenter</td>
<td>Artificial Intelligence (AI), Workstation, Gaming</td>
</tr>
</tbody>
</table>
<p><strong>Final Thoughts</strong></p>
<p>Well it is no denying fact that Turing is the most advanced GPU architecture and is lead ahead of Pascal and Volta in terms of technology. Turing is more of a multi-purpose GPU architecture that can perform all three things at the same time i.e. Pixel Processing, Artificial Intelligence (AI) and Real Time Ray Tracing. Pascal is a very long-lived and successful GPU architecture but now it has been showing its age because of lack of AI and Ray Tracing advanced functionalities. Volta is a really a question mark for us because there are only couple of graphics cards from it up till now and according to me it has been completely replaced by the newer and better Turing GPU architecture. The future of graphics is definitely lie with the Turing architecture as the previous generations architectures fades out slowly. If you have anything to say then please leave a comment below.</p>
<blockquote>
<p>此文为转载，原文链接：<a href="https://graphicscardhub.com/turing-vs-volta-v-pascal/" target="_blank" rel="noopener">Nvidia Turing vs Volta v Pascal GPU Architecture Comparison</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot 2 study]]></title>
      <url>http://xiaqunfeng.cc/2019/11/12/SpringBoot-2-study/</url>
      <content type="html"><![CDATA[<p>SpringBoot 2.x系列学习和实践。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习SpringBoot 2中常用的技术，并通过小demo实践出来，加深对该技术点的认识，旨在构建一个完整的 SpringBoot 知识框架。</p>
<p>目前写了22篇，详见：<a href="http://xiaqunfeng.cc/categories/SpringBoot/">http://xiaqunfeng.cc/categories/SpringBoot/</a></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Valine评论系统]]></title>
      <url>http://xiaqunfeng.cc/2019/11/06/hexo-valine/</url>
      <content type="html"><![CDATA[<p>RT，增加对Valine评论系统的支持。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前配置系统一直用的gitment，用github账号登录即可评论。详见之前的文章：<a href="http://xiaqunfeng.cc/2018/03/26/hexo-gitment/">添加gitment评论系统</a></p>
<p>展示效果也很好：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/gitment-show.png-xtdf" alt="show"></p>
<p>但是，现在已经凉凉了，一直登录不上去，其他人也有类似的反馈：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/gitment.png-xtdf" alt="1"></p>
<p>一直转圈圈，几分钟后就失败。</p>
<p>本来不想再折腾评论系统了，初衷就是自己总结写给自己看的。想想万一能帮到他人，就像之前的评论一样，同时能有更多交流，也是一件很开心的事情。</p>
<h2 id="Valine配置"><a href="#Valine配置" class="headerlink" title="Valine配置"></a>Valine配置</h2><p>官方文档：<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">https://valine.js.org/quickstart.html</a></p>
<h3 id="获取APP-ID-和-APP-Key"><a href="#获取APP-ID-和-APP-Key" class="headerlink" title="获取APP ID 和 APP Key"></a>获取APP ID 和 APP Key</h3><p>1、先注册leancloud，然后实名认证</p>
<p><a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">https://leancloud.cn/dashboard/login.html#/signup</a></p>
<p>2、创建应用</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-create.png-xtdf" alt="create"></p>
<p>3、设置应用key</p>
<p>进入应用，设置-&gt; 应用keys</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-app.png-logo" alt="set"></p>
<h3 id="配置安全域名"><a href="#配置安全域名" class="headerlink" title="配置安全域名"></a>配置安全域名</h3><p>设置成博客的域名地址和本地地址即可。不设置也可以 ，主要还是为了安全。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-security.png-xtdf" alt="security"></p>
<h2 id="yilia主题配置"><a href="#yilia主题配置" class="headerlink" title="yilia主题配置"></a>yilia主题配置</h2><p>所有hexo主题配置可在这里找：<a href="https://valine.js.org/hexo.html" target="_blank" rel="noopener">https://valine.js.org/hexo.html</a></p>
<p>1、<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#6、Valine https://valine.js.org</span><br><span class="line">valine: </span><br><span class="line"> appid:  #Leancloud应用的appId</span><br><span class="line"> appkey:  #Leancloud应用的appKey</span><br><span class="line"> verify: false #验证码</span><br><span class="line"> notify: false #评论回复提醒</span><br><span class="line"> avatar: mp #评论列表头像样式：&apos;&apos;/mp/identicon/monsterid/wavatar/retro/hide</span><br><span class="line"> placeholder: Just go go #评论框占位符</span><br></pre></td></tr></table></figure>
<p>2、<code>layout/_partial/article.ejs</code></p>
<p>给文章新增评论style</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">    &lt;section id=&quot;comments&quot; style=&quot;margin:10px;padding:10px;background:#fff;&quot;&gt;</span><br><span class="line">      &lt;%- partial(&apos;post/valine&apos;, &#123;</span><br><span class="line">        key: post.slug,</span><br><span class="line">        title: post.title,</span><br><span class="line">        url: config.url+url_for(post.path)</span><br><span class="line">        &#125;) %&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>3、<code>layout/_partial/post/valine.ejs</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; </span><br><span class="line">&lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   var notify = &apos;&lt;%= theme.valine.notify %&gt;&apos; == true ? true : false;</span><br><span class="line">   var verify = &apos;&lt;%= theme.valine.verify %&gt;&apos; == true ? true : false;</span><br><span class="line">    window.onload = function() &#123;</span><br><span class="line">        new Valine(&#123;</span><br><span class="line">            el: &apos;.comment&apos;,</span><br><span class="line">            notify: notify,</span><br><span class="line">            verify: verify,</span><br><span class="line">            app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;,</span><br><span class="line">            app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;,</span><br><span class="line">            placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;,</span><br><span class="line">            avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、评论测试</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-test.png-logo" alt="test"></p>
<p>2、查看leancloud数据仓库</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-comment-detail.png-xtdf" alt="detail"></p>
<p>可以看到，评论的详细信息都被记录到这里。</p>
<h2 id="gravatar头像"><a href="#gravatar头像" class="headerlink" title="gravatar头像"></a>gravatar头像</h2><p>详见头像配置：<a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">https://valine.js.org/avatar.html</a></p>
<p>之前使用的是默认的 mp 匿名头像。</p>
<p>1、登录 <a href="https://cn.gravatar.com/" target="_blank" rel="noopener">gravatar</a>，注册账号并设置头像，我的头像如下，和博客头像一致。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-gravatar.png-logo" alt="gravatar"></p>
<p>2、主题配置文件增加 avatar_cdn 参数：</p>
<p>在上面<code>_config.yml</code>配置中增加：（和参数avatar同级）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar_cdn: https://www.gravatar.com/avatar/</span><br></pre></td></tr></table></figure>
<p>3、设置gravatar CDN</p>
<p>目前Valine的版本不支持 avatar_cdn 参数，这里手工加一个并设置成Gravatar的CDN。</p>
<p>在上面的配置文件<code>layout/_partial/post/valine.ejs</code>中新增：（和参数avatar同级）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar_cdn:&apos;&#123;&#123; theme.valine.avatar_cdn &#125;&#125;&apos;,</span><br></pre></td></tr></table></figure>
<p>4、评论，输入邮箱，发现头像已可正确显示</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/valine-gravatars-test.png-xtdf" alt="11"></p>
<p>以上！</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客更新]]></title>
      <url>http://xiaqunfeng.cc/2019/10/01/hexo-update/</url>
      <content type="html"><![CDATA[<p>记录我的hexo博客的功能升级和bug修复。 <a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这半年有点忙，好久没维护博客了，后续还是要花点时间过来。</p>
<p>本次做了一些小功能升级，其实之前在yilia主题的基础上做过一些改动，不过没记录下来，后续有变化的话，尽量都总结在这。</p>
<h2 id="功能升级"><a href="#功能升级" class="headerlink" title="功能升级"></a>功能升级</h2><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>1、插件安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm uninstall hexo-generator-index --save</span><br><span class="line">sudo npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>2、添加置顶式样</p>
<p>文件：<code>themes/yilia/layout/post.ejs</code></p>
<p>在前面添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.top) &#123; %&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>3、新增配置</p>
<p>在博客根目录下的配置文件 <code>_config.yml</code> 中新增如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by:</span><br><span class="line">    top: 1</span><br><span class="line">    date: -1</span><br></pre></td></tr></table></figure>
<ul>
<li>date：-1，表示按时间倒序</li>
<li>tpo: 1，表示按top值正序排序，top值越大，置顶越靠前</li>
</ul>
<p>4、文章中置顶的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: python学习</span><br><span class="line">date: 2019-01-15 15:41:04</span><br><span class="line">categories:</span><br><span class="line">tags: python</span><br><span class="line">top: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>top数字越大，置顶优先级越高</p>
<blockquote>
<p>还有一种置顶方法，详见commit：<a href="https://github.com/litten/hexo-theme-yilia/commit/9a5c162d3bab7a9713a424ec46608ce6fdeded05" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia/commit/9a5c162d3bab7a9713a424ec46608ce6fdeded05</a></p>
</blockquote>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p>1、添加版权声明代码</p>
<p>文件：<code>themes/yilia/layout/_partial/article.ejs</code></p>
<p>添加位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">  &lt;%- post.content %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;-- 在此处添加代码--&gt;</span><br><span class="line">&lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index)&#123; %&gt;</span><br></pre></td></tr></table></figure>
<p>添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  var sUrl = url.replace(/index\.html$/, &apos;&apos;);</span><br><span class="line">  sUrl = /^(http:|https:)\/\//.test(sUrl) ? sUrl : &apos;https:&apos; + sUrl;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;% if ((theme.declare_type === 2 || (theme.declare_type === 1 &amp;&amp; post.declare)) &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">  &lt;div class=&quot;declare&quot;&gt;</span><br><span class="line">    &lt;strong&gt;本文作者：&lt;/strong&gt;</span><br><span class="line">    &lt;% if(config.author != undefined)&#123; %&gt;</span><br><span class="line">      &lt;%= config.author%&gt;</span><br><span class="line">    &lt;% &#125;else&#123;%&gt;</span><br><span class="line">      &lt;font color=&quot;red&quot;&gt;请在博客根目录“_config.yml”中填入正确的“author”&lt;/font&gt;</span><br><span class="line">    &lt;%&#125;%&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;strong&gt;本文链接：&lt;/strong&gt;</span><br><span class="line">    &lt;a rel=&quot;license&quot; href=&quot;&lt;%=sUrl%&gt;&quot;&gt;&lt;%=sUrl%&gt;&lt;/a&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;strong&gt;版权声明：&lt;/strong&gt;</span><br><span class="line">    本作品采用</span><br><span class="line">    &lt;a rel=&quot;license&quot; href=&quot;&lt;%= theme.licensee_url%&gt;&quot;&gt;&lt;%= theme.licensee_name%&gt;&lt;/a&gt;</span><br><span class="line">    进行许可。转载请注明出处！</span><br><span class="line">    &lt;% if(theme.licensee_img != undefined)&#123; %&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;a rel=&quot;license&quot; href=&quot;&lt;%= theme.licensee_url%&gt;&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;&lt;%= theme.licensee_img%&gt;&quot;/&gt;&lt;/a&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;% &#125; else &#123;%&gt;</span><br><span class="line">  &lt;div class=&quot;declare&quot; hidden=&quot;hidden&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>注意缩进和前面一行保持一致</p>
<p>2、新增declare文件</p>
<p>新建文件：<code>themes/yilia/source-src/css/declare.scss</code></p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.declare &#123;</span><br><span class="line">    background-color: #eaeaea;</span><br><span class="line">    margin-top: 2em;</span><br><span class="line">    border-left: 3px solid #ff1700;</span><br><span class="line">    padding: .5em 1em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、import declare</p>
<p>在文件：<code>themes/yilia/source-src/css/main.scss</code> 中import declare</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;./declare&quot;;</span><br></pre></td></tr></table></figure>
<p>4、前端显示</p>
<p>文件：<code>themes/yilia/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#版权基础设定：0-关闭声明； 1-文章对应的md文件里有declare: true属性，才有版权声明； 2-所有文章均有版权声明</span><br><span class="line">#当前应用的版权协议地址。</span><br><span class="line">#版权协议的名称</span><br><span class="line">#版权协议的Logo</span><br><span class="line"></span><br><span class="line">declare_type: 1</span><br><span class="line">licensee_url: https://creativecommons.org/licenses/by-nc-sa/4.0/</span><br><span class="line">licensee_name: &apos;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&apos;</span><br><span class="line">licensee_img: https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png</span><br></pre></td></tr></table></figure>
<p>5、文章中版权声明的使用</p>
<p>在md文件的头部属性添加 <code>declare: true</code> 即可。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: python学习</span><br><span class="line">date: 2019-01-15 15:41:04</span><br><span class="line">categories:</span><br><span class="line">tags: python</span><br><span class="line">declare: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="鼠标点击小红心"><a href="#鼠标点击小红心" class="headerlink" title="鼠标点击小红心"></a>鼠标点击小红心</h3><p>1、新建love文件</p>
<p>文件名：<code>themes/yilia/source/love.js</code></p>
<p>内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function r()&#123;for(var e=0;e&lt;s.length;e++)s[e].alpha&lt;=0?(t.body.removeChild(s[e].el),s.splice(e,1)):(s[e].y--,s[e].scale+=.004,s[e].alpha-=.013,s[e].el.style.cssText=&quot;left:&quot;+s[e].x+&quot;px;top:&quot;+s[e].y+&quot;px;opacity:&quot;+s[e].alpha+&quot;;transform:scale(&quot;+s[e].scale+&quot;,&quot;+s[e].scale+&quot;) rotate(45deg);background:&quot;+s[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function n()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),o(e)&#125;&#125;function o(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,s.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:c()&#125;),t.body.appendChild(a)&#125;function i(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function c()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var s=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;,i(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),n(),r()&#125;(window,document);</span><br></pre></td></tr></table></figure>
<p>2、在footer里添加效果</p>
<p>文件：<code>themes/yilia/layout/_partial/footer.ejs</code></p>
<p>添加内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--页面点击小红心--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><p>1、安装包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<p>2、添加配置</p>
<p>文件：<code>_config.yml</code></p>
<p>在结尾处添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">## 文章加密 hexo-blog-encrypt</span><br><span class="line">encrypt:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<p>3、使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: python学习</span><br><span class="line">date: 2019-01-15 15:41:04</span><br><span class="line">categories:</span><br><span class="line">tags: python</span><br><span class="line">password: 123</span><br><span class="line">abstract: 这是一篇加密文章，讲的是python相关</span><br><span class="line">message: 请输入密码</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>字段释义：</p>
<ul>
<li>password: 密码</li>
<li>abstract: 主页上显示的摘要（注意，会覆盖之前 more 的摘要）</li>
<li>message: 点击查看博客时，密码输入框上的提示性文字</li>
</ul>
<h3 id="隐藏more"><a href="#隐藏more" class="headerlink" title="隐藏more"></a>隐藏more</h3><p>在文章中会插入 <code>&lt;!-- more --&gt;</code>  来截断文章，在展开全文前只显示阶段前的部分，但是，总是会显示  <code>more&gt;&gt;</code> 式样，和主题已有的 <code>展开全文&gt;&gt;</code> 重复了，这里需要把这个 more&gt;&gt; 隐藏起来。</p>
<p>文件：<code>themes/yilia/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># excerpt_link: more</span><br></pre></td></tr></table></figure>
<p>如上，将 excerpt_link 注释掉即可。</p>
<h2 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h2><p>1、<code>fs.SyncWriteStream is deprecated</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ hexo s</span><br><span class="line">(node:17098) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>issue：<a href="https://github.com/hexojs/hexo/issues/2598" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/2598</a></p>
<p>将文件：<code>node_modules\hexo-deployer-git\node_modules\hexo-fs\lib\fs.js</code> 中的如下行注释掉即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//exports.SyncWriteStream = fs.SyncWriteStream;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文章导航]]></title>
      <url>http://xiaqunfeng.cc/2019/10/01/navigation/</url>
      <content type="html"><![CDATA[<p>分布式相关：<br>&emsp;&emsp;分布式技术：<a href="http://xiaqunfeng.cc/categories/Distribute/">Distribute</a><br>&emsp;&emsp;存储：<a href="http://xiaqunfeng.cc/categories/Ceph/">Ceph</a><br>编程语言：<br>&emsp;&emsp;C++<br>&emsp;&emsp;Go<br>&emsp;&emsp;SpringBoot2：<a href="http://xiaqunfeng.cc/categories/SpringBoot">SpringBoot2</a><br>人工智能：<br>&emsp;&emsp;机器学习：<a href="http://xiaqunfeng.cc/categories/MachineLearning/">MachineLearning</a><br>&emsp;&emsp;深度学习 ：<a href="http://xiaqunfeng.cc/categories/DeepLearning/">DeepLearning</a><br>工具：<a href="http://xiaqunfeng.cc/categories/Tools/">Tools</a> </p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然点击“所有文章”可以根据tag筛选文章，但文章之前打的tag较多，多有不便。文章分类展示的也不是很明显，所以，这里梳理一下。</p>
<ul>
<li>tag和分类使用详见“导航”。</li>
<li>有一些文章没有分类和tag，可通过翻页查看。</li>
<li>可直接 <strong>所有文章 -&gt; 搜索</strong> 通过关键字搜相关文章。</li>
</ul>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h3 id="TAG"><a href="#TAG" class="headerlink" title="TAG"></a>TAG</h3><p>1、从主页通过tag查看文章</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hexo-tag.png" alt="tag"></p>
<p>2、从文章下面的tag标签点击进入tag</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>大部分文章都打了tag，只有少部分文章加了分类。</p>
<p>分类想按以下几个主题来：（完善中）</p>
<ul>
<li>AI</li>
<li>机器学习</li>
<li>分布式存储</li>
<li>云计算</li>
<li>工具</li>
</ul>
<p>1、可在主页直接点击本置顶文章的类别标签即可跳转。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hexo-cls.png" alt="cls"></p>
<p>如点击 <code>MachineLearning</code> 类别，展示如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hexo-cls-show.png" alt="cls-1"></p>
<p>2、也可在文章下面的分类标签点击进入</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[我的2018]]></title>
      <url>http://xiaqunfeng.cc/2019/04/10/my-2018/</url>
      <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="请输入密码" />
    <label for="hbePass">请输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="27c6057535160264ca7f36de5647f69fcf1c76609a3dcfdfdf82a85b98999ed4">a1927d948b0f1ee85a8420886ae83f711d1ef18c72fc87cd7b2285b25d6bc40ce17dd10adf2b48d4367e07bc4011dff1932d2be448fec8590ba97f9d5771eb2a8103c1aec1456361061a25777faab70cd22ffd4ec75a388efb56b8f67d3061d848f8ce113181575ff704e24782f0ca7665a2617ea801e96930ec0e9d811d3d182e1a112d79bfa79cdd0029381ebdb22303123e3e3ec1e704ee3be1a896a2fac53a417dc7f64cbe9b933bec27e4ebb2e8b4da756d0697f0cabed5c0c6ac2b91b39b8a734b75da3b17bbf3000ce73a7b5a1130a1d363d44fe880580165fbebe2ca8fe2fe349667583b83e1ba848fe33cc568d5150b607700e62b7208f46e2dc22bfb5045d1dec9c803a056a4b24de0776c3a748f3f8790849c585174ebcee3d7758b1b8a2d79e350306d53482e34fc2635b5d2689cec42b3a8ffc9087c3080905514126d9140869dc2947279b757ea1a0f0ca64d5020a316537362e61da27fb294cde9bb8139757c6a4dc6664524bff20b39e3ad1c7bee5e3dae43d0dcc6f6ce6892c73057e3889efb1bd148e141c2cdc4b36b427f520e4d6c299748a65653f90fbbf7bce1d17c988bb9c6b2c6a3f6d125c4d6276865dfe67f0d452d6f47372bd6e68f9893c1b7922f7f063c7181ec1917327b3fe18bcf8513d35cba6019711818274229e512fc98aa430dde206e18093d3a631f062b5eef0b8734836b60459b7297c41670111973bd6b4151532da8da91eb923f0913cafced57b3de8cf380da9f94028d0fd7ba5f01432b64c48161309a640d8d1fd9bf96ad2e70b74374e25f5657211cdc94382d02da298504e1a08687a04b0fea5768be2fcc726356ef95a4cec6acc9c1ca214e40f2fad707052a72131b7d1905fe3a37def797e87f86a3ac9f4125795d12ab1c972fdbc39f362fc01543c433d7eecacbc8a04b6e86972b032090a64123c8f5548fe562e18fbf59ed1d99deabf9def2056ab38d4f3f5e493906dc9caa1d3dee91fde4766ce84fb51718e64e950b8056c1606a66642bcf0c0dad9ce55afd6fb3048d7e27977b874e427773e248cc06c15302c8abb7f131670cba7c7c7b91088a653f8ef15d0d1ea85ce42950a12171e19af01dc9fe99ee95feefd77fe7a87e033a68fbe1ac3921a1b8836eed0a519b805046a5caa98d931bc12b30b5ee5f8a9dd0579d291b30ad1accd4e0bd740f3472736ac7131d1f82c3b3e2f7ccc5df13d9355148637f82a729e179a0e19b7807b0902fbd849f0d0f192df1dd556cd5477cdf40e2c9b32c839525e9d70850c311ec35317026616a8d63c00ad8eb5b05b39382219ba925b45c6448dbedb883ab4fe7d584eafb5407f6f314b8a5e1895719a89ce65cbf4a3debf8a9b7e406b89425963abadeaf7851f3a1bc7ad2cdcb5decdb0bc6d235c7ca755a6fdafc34d8587d5bf6832375c67248437ac04d668409004c1a214df61c37ce8cc7614b3b2258b5978692d11393528a2546301ed9cd065ed26e8ac8ae445464da2c8121e152909172a2dc33c6367a27f943a45c12efcdd95a5f902e77ecb1b6f78b4790251ee1b172f17343f60396802dec80f1cea0240d5ddd98f4441bccd5006c17d5af23c389ad822e8b2813881902f09a56c3ba11e78799d49f0791430f10dfbca192a652123b3af06ab7ebbf2828d2348611db36fc8c5d13b39ba41e4736bd886c880b3b2c29cd14ffd8e0b56ee0224aca47fbf302e52bf10b9d02d68a3ffc49a171bc14734302ae9c55f269fa02ceee4acfeb47d56183aed9d1bfb18b44f25649047f8b02cce96acad8c15a78aaece9d03918ba19365f0072f7f61e4eeaca378152bd0a92136f4a20ae202dd306793beb0a302f417aa4ba1e263b9ef536766fa46976f7e60f3cc9e8205ced38aaa3c0500eff711d89f246c46558617504e41c80f48cf249373e35c5b9ba3a8a4574d305d23f49017e60a90b766adb2ae163f1f1fc5ff525b6c9fcb0b7ccc36857c5e1c6ad9460e94d08293f27da4c9e16ed940817700dc8a0e251557ee0e23c0290ed3ea626cd9148139bf2f568020a802795e1787ac7296fab3015952671f304dcbd7e6f6ae615556b3bb787827d95ae9a7fcfaf53762135deff7ede13d0d98e1aca2ba2b7582bb637a94e1e472fb58a3069119afe3d6dbae7b4c1a7451b87f1e1d4b9bc5aad8764508eedd1ceb910cc4baa9479be0f67818a82b91c8a017a0b44880219075a680997ffc998f8e7c268c6afa4769807d10a9af3075341361e7f47c5fc9314c7bbace42c9b21176f05192c001ad966141f6c7b2bbf501d3ab2720ac9d99aca10e4a2ace4a9da62c6548f6390c4ef6657ee15bfe3ab0fb359b69eed8f24c311d4269c3f94ef7c24736b57b71e9cf556d1ab9ddf9b1c7a4aef0a624f6f9710049534760f1b64b05cb5e09c4735cc13fc00afc21c8c48f86bc23c027c776e3134aa5d8594832d98453c72005ff57370529b0e7a7aeb96a24deddde080de3c0c3aff1833f7b120d4c1473d3edc0ff596d55f90e0dac215b03da569bfd7ca7862c1ce9dd94dcac07d92ea70b71129a0475c20620defa518ef302725773a2ab94808c20cb6e3d3453cfb2e7f9a18b61a9f48b4e47ddd01f9a9bd1cfe2ba7a39293f6bf43215a2702a38f0370cfe7bdee364d67efb9d2ca3ade052f56ebe9155a191ee591f9cd37632a6c338f745df3731039e08a2dfbfbf404f758c77b17f696da392222d5bcb4c585ac6ae86aca5a3547916ccf9bdc6b5a25eb1c6c52a64bd6d7c3e266de137ca45489ed0194e9fb34cbadee600a52b693b8ef8221407f7dd7102ed213ee2b96a90d41caa931ff21e05621c266146cae850f0b962ac29a93983139702a86e50f72edad7d35a85ff08f9dc436367c0b1aa5cf4bade46d7f78613ce3aeab66947e5881499c68c30c6d851ae9fa8d436e0d84d6ae4156a0089d042d1dff759cb47313bd70b84a68d08611f3783e277ba6afeea951ce492e4f63f1e7a13cc70e98417299ac484db78d0c57958f1e4aef0ec4513b89846cce6f24b611feb58832d9e2ac9997af4fe7b24dad760ac998331f385c666b6cdc85d0c56bed2a9f9e1c44364a0bcac82e78c944e3a00397adf755ab79dc604d7766c1359540ba37d6337d9e63c889e8b314829345da47fecf6b907e5e5c1ac8a9b08c484d352f158688375cd9c4c06c7d1ff0732f94b7df808cb2c0b0d279e4c3d1c90ff1590813d7c59d08eb84a025a34b4f820e7907b9da9c141e5621d33b686e273dc304a1fdc31bfe042b8e59bfb63ac965ad55003bad0b55b6a987980b55660667fb14e84f1b85ff5f610c932b749c734a835ab621a9a5cc6f14da3eab777000d732ca1a15814c387d6caa3577f1b511653008b3720d8fd8e81d7afad75250ba153703592ed82a7ca3d6df234abdf2309b0eef7c2c62f769469d9f3ad1b25696fc4714feb1ff9a3212adf71bb5a78202f5beae37863d7320b9501ee66a6e2d44f3a2814054a3e6bf6e7cc1fb4b8679da52e277cbcfbdca896db4d7230d88b34a144c65f0881bbd0c870b724cd0e9e097f99967a5cdd2d3548301a835ca39cf8978b508dc8317b94dcc17ec5c9f1ea32ad9c4615ad321a91ae763d716f7145bbe2d65f12b62c01e47dcfb932c4d906d2af127e465aa67e272ac6752931cc3472b73127833d274b9e7f8bac1c1f6bfdb3c4646311dd32bf6a57de04f4b228c4c02a12f99cc9e10c14dab3444ad817eb35cb7b116d1354d601f8bcc1a53215a43973c5f4254ae11425d2cd9ef7b9b894748d95ad68684b8898b648fb76ee61af7678f7dcf3414dfe88ec76c48d480cff033ce235320a4e32bd1bcb670d0849702c843e039d7f096edb7ea3404aae2aab08e54ac302323f30c83164a80e8de1981f946c193f7bbe9d55e2308736758e2064867d0477fdeb2bee4d4ab1ffa9cf136473b3c2f1671f3d67bd0359a2d4da105ceb87e0db00658f814fdfa8f78b9d627b1010e5d9fd19829f1da8dc15d8393389636168f41dc40dca605d111170018749c3eeb228cdc89c7731adad34a82f09ca1a1a9e9e8e7a6f9c284a773456c9c5d79e65499ba98315318113cedbeb3f9daa69299a8b11b4b88c6fede396daad2e4d99190cadbbf2d737d68a9dd2fc74b8a67feb64825e5c98e798a8dec8200dfd0ddf9bd02112c38d618d9df36ee361d719f71a63138c2e90adfcb6316b2242ae5bf2b5b396811444b535758f7747d844a2abc864a80ad37e1f93f1984b5ddbf0787f60084e0cae629ba645343a91b838b64c5f35aeac9056c75eeafabedb44b2ae72b77a9a1316faf5baa4a14d93adfd26c4af3870765598424ec3824bbe7a2a8e8f7042a69e5011b8018fbe8953dc851f9f948f0394714b72ca110769db10b62f93bd65b79d6b2b556921b933102ac93b4f659026f4db98f375e3f1dc4a36230056008d985b31d764a63034dd92f410a02fa91705911f6011c8cd7f3164c0d652fe5df2bd2d58b5c4b2c884b91e26105b198fa11ad4d38e2f49f1f19a10de66f2f293b798e6e7606c8e825e5249af0fac2e590386ebe0bfe8001677892779f3f9f7d635f94dc6b81a1dd7ae38648077e07cf05ac819a23bd7948435c794cc603369e20eddecf0fed561805537a4769b2cfa396d9c8da29bf87e7fa35db0cd38c1d1efd100fd41f4a1b9cedbba5791e35edc4d9bfc855872aeeca04f6a45f736abfbd2ac81a4c705e8ad995af29404b46000369c9f4cfad6fcbd0ff517eca6a012c6fc26b10ff1e341996de8abfff5a6a7cf56288ee9c98ed684a3fb39c33d75f833d8f3995dd886a1a683125495ce2c29f33ccabdb0f142478ec3e9186f95db0c60af5b176bb907ea118bc2bc4f9403d2b6ad98c19908642a6c0bdb941611a503a1fd211904e6259343b87089e12e746ec44e644f4690777d052166371cae8c3e86cc2aeb3059197b37b0bddc9aa3bee1b01ac35b11b2c5c26801c1915313dada4a95e0d2db6d68adc8e6bf9036b5ebcc3441423bbe8a79127a71f593322721d0eb0cc641981aea054d63e04ca6f5342635314784866e5874b0738d81c3460b49c142c194bc57f7ed5a780290e8d1b3c341e60033961aa0362d95fce276b516fd33f86ba536b0a9433f45ece6dd4f0510b3aee51e4938bc1522d0875d4504dbf2d77e96c2edc544a900d1387edcbb9c171bca1f16dfe13075b4f9fb294a8c8616609f59e94dc539b58cd4d3b1423cea25ffb1b83bb04403fb0cf5a111374edb3a4d15286bd40af0a0c4bf43bf08bfca045f1d179b5b3c58b9ee7ffb74088f36a6d132ea6a6ce458a1948f3a0a2aa2e5dd304</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Python编写条件分支代码的技巧]]></title>
      <url>http://xiaqunfeng.cc/2019/01/15/python-skill-of-if-else/</url>
      <content type="html"><![CDATA[<p>编写条件分支代码是编码过程中不可或缺的一部分。</p>
<p>编写优秀的条件分支代码非常重要，因为糟糕、复杂的分支处理非常容易让人困惑，从而降低代码质量。所以，这篇文章将会种重点谈谈在 Python 中编写分支代码应该注意的地方。</p>
<a id="more"></a>
<h3 id="Python-里的分支代码"><a href="#Python-里的分支代码" class="headerlink" title="Python 里的分支代码"></a>Python 里的分支代码</h3><p>Python 支持最为常见的 <code>if/else</code> 条件分支语句，不过它缺少在其他编程语言中常见的 <code>switch/case</code> 语句。</p>
<p>除此之外，Python 还为 <code>for/while</code> 循环以及 <code>try/except</code> 语句提供了 else 分支，在一些特殊的场景下，它们可以大显身手。</p>
<p>下面我会从 <code>最佳实践</code>、<code>常见技巧</code>、<code>常见陷阱</code> 三个方面讲一下如果编写优秀的条件分支代码。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-避免多层分支嵌套"><a href="#1-避免多层分支嵌套" class="headerlink" title="1. 避免多层分支嵌套"></a>1. 避免多层分支嵌套</h3><p>如果这篇文章只能删减成一句话就结束，那么那句话一定是<strong>“要竭尽所能的避免分支嵌套”</strong>。</p>
<p>过深的分支嵌套是很多编程新手最容易犯的错误之一。假如有一位新手 JavaScript 程序员写了很多层分支嵌套，那么你可能会看到一层又一层的大括号：<code>if { if { if { ... }}}</code>。俗称<em>“嵌套 if 地狱（Nested If Statement Hell）”</em>。</p>
<p>但是因为 Python 使用了缩进来代替 <code>{}</code>，所以过深的嵌套分支会产生比其他语言下更为严重的后果。比如过多的缩进层次很容易就会让代码超过 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a> 中规定的每行字数限制。让我们看看这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="string">"""去水果店买苹果</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    - 先得看看店是不是在营业</span></span><br><span class="line"><span class="string">    - 如果有苹果的话，就买 1 个</span></span><br><span class="line"><span class="string">    - 如果钱不够，就回家取钱再来</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> store.is_open():</span><br><span class="line">        <span class="keyword">if</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">            <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">                nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nerd.go_home_and_get_money()</span><br><span class="line">                <span class="keyword">return</span> buy_fruit(nerd, store)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br></pre></td></tr></table></figure>
<p>上面这段代码最大的问题，就是过于直接翻译了原始的条件分支要求，导致短短十几行代码包含了有三层嵌套分支。</p>
<p>这样的代码可读性和维护性都很差。不过我们可以用一个很简单的技巧：<strong>“提前结束”</strong> 来优化这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_fruit</span><span class="params">(nerd, store)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.is_open():</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"store is closed!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> store.has_stocks(<span class="string">"apple"</span>):</span><br><span class="line">        <span class="keyword">raise</span> MadAtNoFruit(<span class="string">"no apple in store!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nerd.can_afford(store.price(<span class="string">"apple"</span>, amount=<span class="number">1</span>)):</span><br><span class="line">        nerd.buy(store, <span class="string">"apple"</span>, amount=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nerd.go_home_and_get_money()</span><br><span class="line">        <span class="keyword">return</span> buy_fruit(nerd, store)</span><br></pre></td></tr></table></figure>
<p>“提前结束”指：<strong>在函数内使用 <code>return</code> 或 <code>raise</code> 等语句提前在分支内结束函数。</strong>比如，在新的 <code>buy_fruit</code> 函数里，当分支条件不满足时，我们直接抛出异常，结束这段这代码分支。这样的代码没有嵌套分支，更直接也更易读。</p>
<h3 id="2-封装那些过于复杂的逻辑判断"><a href="#2-封装那些过于复杂的逻辑判断" class="headerlink" title="2. 封装那些过于复杂的逻辑判断"></a>2. 封装那些过于复杂的逻辑判断</h3><p>如果条件分支里的表达式过于复杂，出现了太多的 <code>not/and/or</code>，那么这段代码的可读性就会大打折扣，比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果活动还在开放，并且活动剩余名额大于 10，为所有性别为女性，或者级别大于 3</span><br><span class="line"># 的活跃用户发放 10000 个金币</span><br><span class="line">if activity.is_active and activity.remaining &gt; 10 and \</span><br><span class="line">        user.is_active and (user.sex == &apos;female&apos; or user.level &gt; 3):</span><br><span class="line">    user.add_coins(10000)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<p>对于这样的代码，我们可以考虑将具体的分支逻辑封装成函数或者方法，来达到简化代码的目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if activity.allow_new_user() and user.match_activity_condition():</span><br><span class="line">    user.add_coins(10000)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<p>事实上，将代码改写后，之前的注释文字其实也可以去掉了。<strong>因为后面这段代码已经达到了自说明的目的。</strong>至于具体的 <em>什么样的用户满足活动条件？</em> 这种问题，就应由具体的 <code>match_activity_condition()</code> 方法来回答了。</p>
<blockquote>
<p><strong>Hint:</strong> 恰当的封装不光直接改善了代码的可读性，事实上，如果上面的活动判断逻辑在代码中出现了不止一次的话，封装更是必须的。不然重复代码会极大的破坏这段逻辑的可维护性。</p>
</blockquote>
<h3 id="3-留意不同分支下的重复代码"><a href="#3-留意不同分支下的重复代码" class="headerlink" title="3. 留意不同分支下的重复代码"></a>3. 留意不同分支下的重复代码</h3><p>重复代码是代码质量的天敌，而条件分支语句又非常容易成为重复代码的重灾区。所以，当我们编写条件分支语句时，需要特别留意，不要生产不必要的重复代码。</p>
<p>让我们看下这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于新用户，创建新的用户资料，否则更新旧资料</span></span><br><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    create_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        <span class="comment"># 对于新建用户，将用户的积分置为 0</span></span><br><span class="line">        points=<span class="number">0</span>,</span><br><span class="line">        created=now(),</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    update_user_profile(</span><br><span class="line">        username=user.username,</span><br><span class="line">        email=user.email,</span><br><span class="line">        age=user.age,</span><br><span class="line">        address=user.address,</span><br><span class="line">        updated=now(),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以一眼看出，在不同的分支下，程序调用了不同的函数，做了不一样的事情。但是，因为那些重复代码的存在，<strong>我们却很难简单的区分出，二者的不同点到底在哪。</strong></p>
<p>其实，得益于 Python 的动态特性，我们可以简单的改写一下上面的代码，让可读性可以得到显著的提升：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    profile_func = create_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'points'</span>: <span class="number">0</span>, <span class="string">'created'</span>: now()&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    profile_func = update_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'updated'</span>: now()&#125;</span><br><span class="line"></span><br><span class="line">profile_func(</span><br><span class="line">    username=user.username,</span><br><span class="line">    email=user.email,</span><br><span class="line">    age=user.age,</span><br><span class="line">    address=user.address,</span><br><span class="line">    **extra_args</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当你编写分支代码时，请额外关注<strong>由分支产生的重复代码块</strong>，如果可以简单的消灭它们，那就不要迟疑。</p>
<h3 id="4-谨慎使用三元表达式"><a href="#4-谨慎使用三元表达式" class="headerlink" title="4. 谨慎使用三元表达式"></a>4. 谨慎使用三元表达式</h3><p>三元表达式是 Python 2.5 版本后才支持的语法。在那之前，Python 社区一度认为三元表达式没有必要，我们需要使用 <code>x and a or b</code> 的方式来模拟它。<a href="#annot1">[注]</a></p>
<p>事实是，在很多情况下，使用普通的 <code>if/else</code> 语句的代码可读性确实更好。盲目追求三元表达式很容易诱惑你写出复杂、可读性差的代码。</p>
<p>所以，请记得只用三元表达式处理简单的逻辑分支。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language = <span class="string">"python"</span> <span class="keyword">if</span> you.favor(<span class="string">"dynamic"</span>) <span class="keyword">else</span> <span class="string">"golang"</span></span><br></pre></td></tr></table></figure>
<p>对于绝大多数情况，还是使用普通的 <code>if/else</code> 语句吧。</p>
<h2 id="常见技巧"><a href="#常见技巧" class="headerlink" title="常见技巧"></a>常见技巧</h2><h3 id="1-使用“德摩根定律”"><a href="#1-使用“德摩根定律”" class="headerlink" title="1. 使用“德摩根定律”"></a>1. 使用“德摩根定律”</h3><p>在做分支判断时，我们有时候会写成这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用户没有登录或者用户没有使用 chrome，拒绝提供服务</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> user.has_logged_in <span class="keyword">or</span> <span class="keyword">not</span> user.is_from_chrome:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"our service is only available for chrome logged in user"</span></span><br></pre></td></tr></table></figure>
<p>第一眼看到代码时，是不是需要思考一会才能理解它想干嘛？这是因为上面的逻辑表达式里面出现了 2 个 <code>not</code> 和 1 个 <code>or</code>。而我们人类恰好不擅长处理过多的“否定”以及“或”这种逻辑关系。</p>
<p>这个时候，就该 <a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">德摩根定律</a> 出场了。通俗的说，德摩根定律就是 <code>not A or not B</code> 等价于 <code>not (A and B)</code>。通过这样的转换，上面的代码可以改写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (user.has_logged_in <span class="keyword">and</span> user.is_from_chrome):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"our service is only available for chrome logged in user"</span></span><br></pre></td></tr></table></figure>
<p>怎么样，代码是不是易读了很多？记住德摩根定律，很多时候它对于简化条件分支里的代码逻辑非常有用。</p>
<h3 id="2-自定义对象的“布尔真假”"><a href="#2-自定义对象的“布尔真假”" class="headerlink" title="2. 自定义对象的“布尔真假”"></a>2. 自定义对象的“布尔真假”</h3><p>我们常说，在 Python 里，“万物皆对象”。其实，不光“万物皆对象”，我们还可以利用很多魔法方法<em>（文档中称为：<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">user-defined method</a>）</em>，来自定义对象的各种行为。我们可以用很多在别的语言里面无法做到、有些魔法的方式来影响代码的执行。</p>
<p>比如，Python 的所有对象都有自己的“布尔真假”：</p>
<ul>
<li>布尔值为假的对象：<code>None</code>, <code>0</code>, <code>False</code>, <code>[]</code>, <code>()</code>, <code>{}</code>, <code>set()</code>, <code>frozenset()</code>, … …</li>
<li>布尔值为真的对象：非 <code>0</code> 的数值、<code>True</code>，非空的序列、元组，普通的用户类实例，… …</li>
</ul>
<p>通过内建函数 <code>bool()</code>，你可以很方便的查看某个对象的布尔真假。而 Python 进行条件分支判断时用到的也是这个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(object())</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>重点来了，虽然所有用户类实例的布尔值都是真。但是 Python 提供了改变这个行为的办法：<strong>自定义类的 <code>__bool__</code> 魔法方法</strong> <em>（在 Python 2.X 版本中为 <code>__nonzero__</code>）</em>。当类定义了 <code>__bool__</code> 方法后，它的返回值将会被当作类实例的布尔值。</p>
<p>另外，<code>__bool__</code> 不是影响实例布尔真假的唯一方法。如果类没有定义 <code>__bool__</code> 方法，Python 还会尝试调用 <code>__len__</code> 方法<em>（也就是对任何序列对象调用 <code>len</code> 函数）</em>，通过结果是否为 <code>0</code> 判断实例真假。</p>
<p>那么这个特性有什么用呢？看看下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(users._users) &gt; <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码里，判断 <code>UserCollection</code> 是否有内容时用到了 <code>users._users</code> 的长度。其实，通过为 <code>UserCollection</code> 添加 <code>__len__</code> 魔法方法，上面的分支可以变得更简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self._users = users</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._users)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = UserCollection([piglei, raymond])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了</span></span><br><span class="line"><span class="keyword">if</span> users:</span><br><span class="line">    print(<span class="string">"There's some users in collection!"</span>)</span><br></pre></td></tr></table></figure>
<p>通过定义魔法方法 <code>__len__</code> 和 <code>__bool__</code> ，我们可以让类自己控制想要表现出的布尔真假值，让代码变得更 pythonic。</p>
<h3 id="3-在条件判断中使用-all-any"><a href="#3-在条件判断中使用-all-any" class="headerlink" title="3. 在条件判断中使用 all() / any()"></a>3. 在条件判断中使用 all() / any()</h3><p><code>all()</code> 和 <code>any()</code> 两个函数非常适合在条件判断中使用。这两个函数接受一个可迭代对象，返回一个布尔值，其中：</p>
<ul>
<li><code>all(seq)</code>：仅当 <code>seq</code> 中所有对象都为布尔真时返回 <code>True</code>，否则返回 <code>False</code></li>
<li><code>any(seq)</code>：只要 <code>seq</code> 中任何一个对象为布尔真就返回 <code>True</code>，否则返回 <code>False</code></li>
</ul>
<p>假如我们有下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="string">"""仅当序列中所有数字大于 10 时，返回 True</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>如果使用 <code>all()</code> 内建函数，再配合一个简单的生成器表达式，上面的代码可以写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10_2</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(numbers) <span class="keyword">and</span> all(n &gt; <span class="number">10</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure>
<p>简单、高效，同时也没有损失可用性。</p>
<h3 id="4-使用-try-while-for-中-else-分支"><a href="#4-使用-try-while-for-中-else-分支" class="headerlink" title="4. 使用 try/while/for 中 else 分支"></a>4. 使用 try/while/for 中 else 分支</h3><p>让我们看看这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_stuff</span><span class="params">()</span>:</span></span><br><span class="line">    first_thing_successed = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">        first_thing_successed = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error while calling do_some_thing"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅当 first_thing 成功完成时，做第二件事</span></span><br><span class="line">    <span class="keyword">if</span> first_thing_successed:</span><br><span class="line">        <span class="keyword">return</span> do_the_second_thing()</span><br></pre></td></tr></table></figure>
<p>在函数 <code>do_stuff</code> 中，我们希望只有当 <code>do_the_first_thing()</code> 成功调用后<em>（也就是不抛出任何异常）</em>，才继续做第二个函数调用。为了做到这一点，我们需要定义一个额外的变量 <code>first_thing_successed</code> 来作为标记。</p>
<p>其实，我们可以用更简单的方法达到同样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def do_stuff():</span><br><span class="line">    try:</span><br><span class="line">        do_the_first_thing()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;Error while calling do_some_thing&quot;)</span><br><span class="line">        return</span><br><span class="line">    else:</span><br><span class="line">        return do_the_second_thing()</span><br></pre></td></tr></table></figure>
<p>在 <code>try</code> 语句块最后追加上 <code>else</code> 分支后，分支下的<code>do_the_second_thing()</code> 便只会在 <strong>try 下面的所有语句正常执行（也就是没有异常，没有 return、break 等）完成后执行</strong>。</p>
<p>类似的，Python 里的 <code>for/while</code> 循环也支持添加 <code>else</code> 分支，它们表示：当循环使用的迭代对象被正常耗尽、或 while 循环使用的条件变量变为 False 后才执行 else 分支下的代码。</p>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="1-与-None-值的比较"><a href="#1-与-None-值的比较" class="headerlink" title="1. 与 None 值的比较"></a>1. 与 None 值的比较</h3><p>在 Python 中，有两种比较变量的方法：<code>==</code> 和 <code>is</code>，二者在含义上有着根本的区别：</p>
<ul>
<li><code>==</code>：表示二者所指向的的<strong>值</strong>是否一致</li>
<li><code>is</code>：表示二者是否指向内存中的同一份内容，也就是 <code>id(x)</code> 是否等于 <code>id(y)</code></li>
</ul>
<p><code>None</code> 在 Python 语言中是一个单例对象，如果你要判断某个变量是否为 None 时，记得使用 <code>is</code> 而不是 <code>==</code>，因为只有 <code>is</code> 才能在严格意义上表示某个变量是否是 None。</p>
<p>否则，可能出现下面这样的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo == <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中，Foo 这个类通过自定义 <code>__eq__</code> 魔法方法的方式，很容易就满足了 <code>== None</code> 这个条件。</p>
<p><strong>所以，当你要判断某个变量是否为 None 时，请使用 <code>is</code> 而不是 <code>==</code>。</strong></p>
<h3 id="2-留意-and-和-or-的运算优先级"><a href="#2-留意-and-和-or-的运算优先级" class="headerlink" title="2. 留意 and 和 or 的运算优先级"></a>2. 留意 and 和 or 的运算优先级</h3><p>看看下面这两个表达式，猜猜它们的值一样吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span>) <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>答案是：不一样，它们的值分别是 <code>False</code> 和 <code>True</code>，你猜对了吗？</p>
<p>问题的关键在于：<strong><code>and</code> 运算符的优先级大于 <code>or</code></strong>。因此上面的第二个表达式在 Python 看来实际上是 <code>True or (False and False)</code>。所以结果是 <code>True</code> 而不是 <code>False</code>。</p>
<p>在编写包含多个 <code>and</code> 和 <code>or</code> 的表达式时，请额外注意 <code>and</code> 和 <code>or</code> 的运算优先级。即使执行优先级正好是你需要的那样，你也可以加上额外的括号来让代码更清晰。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li><a id="annot1"></a>事实上 <code>x and a or b</code> 不是总能给你正确的结果，只有当 a 与 b 的布尔值为真时，这个表达式才能正常工作，这是由逻辑运算的短路特性决定的。你可以在命令行中运行 <code>True and None or 0</code> 试试看，结果是 0 而非 None。</li>
</ol>
<blockquote>
<p>本文内容为转载，原文链接：<a href="https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/2-if-else-block-secrets.md" target="_blank" rel="noopener">Python 工匠：编写条件分支代码的技巧</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【源码分析】caffe code of layer]]></title>
      <url>http://xiaqunfeng.cc/2018/12/28/caffe-code-of-layer/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 layer，本文分析记录了layer基类的成员变量和成员函数，源码文件注释详见 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/layer-annotation.hpp" target="_blank" rel="noopener">layer-annotation.hpp</a> 和 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/layer-annotation.cpp" target="_blank" rel="noopener">layer-annotation.cpp</a>。<br><a id="more"></a></p>
<h2 id="关于layer"><a href="#关于layer" class="headerlink" title="关于layer"></a>关于layer</h2><p>Layer是Caffe模型的本质内容和执行计算的基本单元。Layer可以进行很多运算，如convolve(卷积)、pool(池化)、inner product(内积)，rectified-linear和sigmoid等非线性运算，元素级的数据变换，normalize(归一化)、load data(数据加载)、softmax和hinge等losses(损失计算)。可在Caffe的<a href="http://caffe.berkeleyvision.org/tutorial/layers.html" target="_blank" rel="noopener">层目录</a>中查看所有操作，其囊括了绝大部分目前最前沿的深度学习任务所需要的层类型。</p>
<p>一个layer通过bottom(底部) 连接层接收blobs数据，通过top(顶部)连接层输出blobs数据。Caffe中每种类型layer的参数说明定义在caffe.proto文件中，具体的layer参数值则定义在具体应用的prototxt网络结构说明文件中。</p>
<p>在Caffe中，一个网络的大部分功能都是以layer的形式去展开的。在创建一个Caffe模型的时候，也是以layer为基础进行的，需按照caffe.proto中定义的网络及参数格式定义网络prototxt文件。在.prototxt文件中会有很多个layer {  } 字段。</p>
<p>每一个layer都定义了3种重要的运算：setup(初始化设置)，forward(前向传播)，backward(反向传播)。</p>
<ul>
<li>(1)、setup：在模型初始化时重置layers及其相互之间的连接；</li>
<li>(2)、forward：从bottom层中接收数据，进行计算后将输出送人到top层中；</li>
<li>(3)、backward：给定相对于top层输出的梯度，计算其相对于输入的梯度，并传递到bottom层。一个有参数的layer需要计算相对于各个参数的梯度值并存储在内部。</li>
</ul>
<p>特别地，forward和backward函数分别有CPU和GPU两张实现方式。如果没有实现GPU版本，那么layer将转向作为备用选项的CPU方式。这样会增加额外的数据传送成本(输入数据由GPU上复制到CPU，之后输出数据从CPU又复制回到GPU)。</p>
<p>总的来说，Layer承担了网络的两个核心操作：</p>
<ul>
<li>forward pass(前向传播)—-接收输入并计算输出；</li>
<li>backward pass(反向传播)—-接收关于输出的梯度，计算相对于参数和输入的梯度并反向传播给在它前面的层。</li>
</ul>
<p>由此组成了每个layer的前向和反向传播。</p>
<p>Layer是网络的基本单元，由此派生出了各种层类。在Layer中input data用bottom表示，output data用top表示。由于Caffe网络的组合性和其代码的模块化，自定义layer是很容易的。只要定义好layer的setup(初始化设置)、forward(前向传播，根据input计算output)和backward(反向传播，根据output计算input的梯度)，就可将layer纳入到网络中。</p>
<blockquote>
<p>以上摘自Caffe官方教程中译本_CaffeCN社区翻译，并加入少量修改。</p>
</blockquote>
<h2 id="message信息"><a href="#message信息" class="headerlink" title="message信息"></a>message信息</h2><p>caffe.proto中，有2个message与blob有关，定义如下：</p>
<p>Phase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Phase &#123;</span><br><span class="line">   TRAIN = 0;</span><br><span class="line">   TEST = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LayerParameter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">message LayerParameter &#123;</span><br><span class="line">  optional string name = 1; // layer名字，可自定义</span><br><span class="line">  optional string type = 2; // layer类型，在具体的layer中写定，可通过type()函数获取之</span><br><span class="line">  repeated string bottom = 3; // 输入bottom blob的名字，可以有多个</span><br><span class="line">  repeated string top = 4; // 输出top blob的名字，可以有多个</span><br><span class="line"></span><br><span class="line">  optional Phase phase = 10; // 计算的阶段，训练还是测试</span><br><span class="line"></span><br><span class="line">  repeated float loss_weight = 5; // 和top blob数量相同，每层分配一个默认值，通常为0或1</span><br><span class="line">  repeated ParamSpec param = 6; // train时用到的参数</span><br><span class="line">  repeated BlobProto blobs = 7; // 含有数字参数层的blob</span><br><span class="line">  repeated bool propagate_down = 11; // 是否BP到每个bottom。数量为0或者等于bottom的个数</span><br><span class="line"></span><br><span class="line">  // 控制是否以及何时在网络中包含一个layer的规则</span><br><span class="line">  repeated NetStateRule include = 8;</span><br><span class="line">  repeated NetStateRule exclude = 9;</span><br><span class="line"></span><br><span class="line">  optional TransformationParameter transform_param = 100; // 数据预处理参数</span><br><span class="line">  optional LossParameter loss_param = 101; // loss层共享的参数</span><br><span class="line"></span><br><span class="line">  // 具体layer的参数</span><br><span class="line">  ...</span><br><span class="line">  optional BatchNormParameter batch_norm_param = 139;</span><br><span class="line">  optional BiasParameter bias_param = 141;</span><br><span class="line">  optional ConvolutionParameter convolution_param = 106;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="layer类成员变量"><a href="#layer类成员变量" class="headerlink" title="layer类成员变量"></a>layer类成员变量</h2><p>类Layer：抽象基类，有纯虚函数，不能实例化，定义了所有layer的基本接口，具体的每个layer完成一类特定的计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected:</span><br><span class="line">  LayerParameter layer_param_;  </span><br><span class="line">  Phase phase_;         </span><br><span class="line">  vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt; blobs_;  </span><br><span class="line">  vector&lt;bool&gt; param_propagate_down_;       </span><br><span class="line">  vector&lt;Dtype&gt; loss_;</span><br></pre></td></tr></table></figure>
<ul>
<li>layer_param_： protobuf文件中存储的layer参数，具体参数详见caffe.proto中的message LayerParameter</li>
<li>phase_ ：layer状态：指定参与网络的是train还是test</li>
<li>blobs_：用于存储layer的学习的参数如权值和偏置，使用向量是因为权值参数和偏置分开保存在两个blob中</li>
<li>param_propagate_down_：标志每个可学习参数blob是否需要计算反向传递的梯度值</li>
<li>loss_：非LossLayer为零，LossLayer中表示每个top blob计算的loss的权重</li>
</ul>
<h2 id="layer类成员函数"><a href="#layer类成员函数" class="headerlink" title="layer类成员函数"></a>layer类成员函数</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// bottom层的输入数据，blob中的存储空间已申请</span><br><span class="line">// top层输出数据，blob对象已构造，但是其存储空间未申请</span><br><span class="line">// 具体空间大小需根据bottom blob大小和layer_param_共同决定，具体在Reshape函数现实</span><br><span class="line">// 函数功能：实现公共layer的setup功能，此方法非虚函数, 所以不需要重写</span><br><span class="line">// 1. 检查blobs输入(bottom)和输出(top)个数是否正确，每层处理的输入输出数据不一样</span><br><span class="line">// 2. 调用LayerSetUp来为各个类型的layer执行特定的setup, 各子类需要重写该函数完成初始化</span><br><span class="line">// 3. Reshape: 设置blobs输出（top）及内部缓存的大小, 即为top blob分配合适大小的存储空间</span><br><span class="line">// 4. 为每个损失权重为非零的top blob设置损失权重乘子</span><br><span class="line">void SetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">  CheckBlobCounts(bottom, top);</span><br><span class="line">  LayerSetUp(bottom, top);</span><br><span class="line">  Reshape(bottom, top);</span><br><span class="line">  SetLossWeights(top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的四个函数，除了SetLossWeights是定义在类内的内联函数外，其他三个均为虚函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 实现指定层的初始化，包括从layer_param_读入并处理相关的层权值和偏置参数</span><br><span class="line">// 调用Reshape函数申请top blob的存储空间</span><br><span class="line">virtual void LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 纯虚函数，每个子类Layer必须重写的Reshape函数，完成top blob形状的设置并为其分配存储空间</span><br><span class="line">virtual void Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) = 0;</span><br></pre></td></tr></table></figure>
<h3 id="前向传播和反向传播"><a href="#前向传播和反向传播" class="headerlink" title="前向传播和反向传播"></a>前向传播和反向传播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// inline函数，调用Forward_cpu和Forward_gpu这两个虚函数来完成数据前向传递</span><br><span class="line">// 根据执行环境的不同每个子类Layer必须重写CPU和GPU版本</span><br><span class="line">inline Dtype Forward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);</span><br><span class="line">    </span><br><span class="line">  // 用法类似Forward</span><br><span class="line">inline void Backward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">    const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);</span><br></pre></td></tr></table></figure>
<p>这两个函数都在类内声明，类外实现。CPU的前向/反向传播为纯虚函数，由子类实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected:</span><br><span class="line">  // CPU实现layer的前向传播</span><br><span class="line"> virtual void Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) = 0;</span><br><span class="line">     </span><br><span class="line"> // GPU实现layer的前向传播</span><br><span class="line"> virtual void Forward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">   // LOG(WARNING) &lt;&lt; &quot;Using CPU code as backup.&quot;;</span><br><span class="line">   return Forward_cpu(bottom, top);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> virtual void Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">     const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) = 0;</span><br><span class="line">     </span><br><span class="line"> virtual void Backward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">     const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">     const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;</span><br><span class="line">   // LOG(WARNING) &lt;&lt; &quot;Using CPU code as backup.&quot;;</span><br><span class="line">   Backward_cpu(top, propagate_down, bottom);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="blob相关"><a href="#blob相关" class="headerlink" title="blob相关"></a>blob相关</h3><p>下面几个函数主要设置bottom或者top blob的数量状态，通常需要layer类的派生类重写，因为不同层指定的输入输出数量不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 获得layer所需的bottom blobs的个数</span><br><span class="line">virtual inline int ExactNumBottomBlobs() const &#123; return -1; &#125;</span><br><span class="line">// 获得layer所需的bottom blobs的最少个数</span><br><span class="line">virtual inline int MinBottomBlobs() const &#123; return -1; &#125;</span><br><span class="line">// 获得layer所需的bottom blobs的最多个数</span><br><span class="line">virtual inline int MaxBottomBlobs() const &#123; return -1; &#125;</span><br><span class="line"></span><br><span class="line">virtual inline int ExactNumTopBlobs() const &#123; return -1; &#125;</span><br><span class="line">virtual inline int MinTopBlobs() const &#123; return -1; &#125;</span><br><span class="line">virtual inline int MaxTopBlobs() const &#123; return -1; &#125;</span><br><span class="line"></span><br><span class="line">// 判断layer所需的bottom blobs和top blobs的个数是否相等</span><br><span class="line">virtual inline bool EqualNumBottomTopBlobs() const &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">// 判断layer所需的的top blobs是否需要由Net::Init来创建</span><br><span class="line">virtual inline bool AutoTopBlobs() const &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">// 判断layer指定的bottom blob是否需要强制梯度返回</span><br><span class="line">// 有些layer不需要梯度信息</span><br><span class="line">virtual inline bool AllowForceBackward(const int bottom_index) const &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他函数详见 hpp文件。</p>
</blockquote>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// Forward and backward wrappers. You should implement the cpu and</span><br><span class="line">// gpu specific implementations instead, and should not change these</span><br><span class="line">// functions.</span><br><span class="line">// 前向传播，通过输入bottom blobs，计算输出top blobs和loss值</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">inline Dtype Layer&lt;Dtype&gt;::Forward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">  Dtype loss = 0;</span><br><span class="line">  Reshape(bottom, top);</span><br><span class="line">  switch (Caffe::mode()) &#123;</span><br><span class="line">  case Caffe::CPU:</span><br><span class="line">    Forward_cpu(bottom, top);</span><br><span class="line">    for (int top_id = 0; top_id &lt; top.size(); ++top_id) &#123;</span><br><span class="line">      if (!this-&gt;loss(top_id)) &#123; continue; &#125;</span><br><span class="line">      const int count = top[top_id]-&gt;count();</span><br><span class="line">      const Dtype* data = top[top_id]-&gt;cpu_data();</span><br><span class="line">      const Dtype* loss_weights = top[top_id]-&gt;cpu_diff();</span><br><span class="line">      loss += caffe_cpu_dot(count, data, loss_weights);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case Caffe::GPU:</span><br><span class="line">    Forward_gpu(bottom, top);</span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">    for (int top_id = 0; top_id &lt; top.size(); ++top_id) &#123;</span><br><span class="line">      if (!this-&gt;loss(top_id)) &#123; continue; &#125;</span><br><span class="line">      const int count = top[top_id]-&gt;count();</span><br><span class="line">      const Dtype* data = top[top_id]-&gt;gpu_data();</span><br><span class="line">      const Dtype* loss_weights = top[top_id]-&gt;gpu_diff();</span><br><span class="line">      Dtype blob_loss = 0;</span><br><span class="line">      caffe_gpu_dot(count, data, loss_weights, &amp;blob_loss);</span><br><span class="line">      loss += blob_loss;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    LOG(FATAL) &lt;&lt; &quot;Unknown caffe mode.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return loss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Backward"><a href="#Backward" class="headerlink" title="Backward"></a>Backward</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 反向传播，通过给定top blob误差梯度，计算bottom blob误差梯度</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">inline void Layer&lt;Dtype&gt;::Backward(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">    const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;</span><br><span class="line">  switch (Caffe::mode()) &#123;</span><br><span class="line">  case Caffe::CPU:</span><br><span class="line">    Backward_cpu(top, propagate_down, bottom);</span><br><span class="line">    break;</span><br><span class="line">  case Caffe::GPU:</span><br><span class="line">    Backward_gpu(top, propagate_down, bottom);</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    LOG(FATAL) &lt;&lt; &quot;Unknown caffe mode.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ToProto"><a href="#ToProto" class="headerlink" title="ToProto"></a>ToProto</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Serialize LayerParameter to protocol buffer</span><br><span class="line">// 序列化函数，将layer参数写入protobuf文件</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void Layer&lt;Dtype&gt;::ToProto(LayerParameter* param, bool write_diff) &#123;</span><br><span class="line">  param-&gt;Clear();</span><br><span class="line">  param-&gt;CopyFrom(layer_param_);</span><br><span class="line">  param-&gt;clear_blobs();</span><br><span class="line">  for (int i = 0; i &lt; blobs_.size(); ++i) &#123;</span><br><span class="line">    blobs_[i]-&gt;ToProto(param-&gt;add_blobs(), write_diff);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Layer-cpp"><a href="#Layer-cpp" class="headerlink" title="Layer.cpp"></a>Layer.cpp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 模板显式实例化</span><br><span class="line">INSTANTIATE_CLASS(Layer);</span><br></pre></td></tr></table></figure>
<p>在common.hpp中定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Instantiate a class with float and double specifications.</span><br><span class="line">#define INSTANTIATE_CLASS(classname) \</span><br><span class="line">  char gInstantiationGuard##classname; \</span><br><span class="line">  template class classname&lt;float&gt;; \</span><br><span class="line">  template class classname&lt;double&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【源码分析】caffe code of blob]]></title>
      <url>http://xiaqunfeng.cc/2018/12/25/caffe-code-of-blob/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 Blob，本文分析记录了 Blob 类的数据成员和成员函数，源码文件注释详见 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/blob-annotation.hpp" target="_blank" rel="noopener">blob-annotation.hpp</a> 和 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/blob-annotation.cpp" target="_blank" rel="noopener">blob-annotation.cpp</a>。<br><a id="more"></a></p>
<h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p>Blob 是 caffe 中处理和传递实际数据的数据封装包，其可根据CPU主机到GPU设备的同步需要，屏蔽CPU/GPU混合运算在计算上的开销，主机和设备上的内存按需分配，以提高内存使用效率（SyncedMemory内存管理类）。</p>
<p>caffe基于blob存储和交换数据，为便于优化，blob提供统一的内存接口来存储某种类型的数据，例如批量图像数据、模型参数以及用来进行优化的导数。</p>
<p>Blob数据可以通过Protobuf来做相应的序列化操作，ToProto和FromProto两个函数完成相应的序列化、反序列化(数据解析)操作。</p>
<h3 id="blob数据存储"><a href="#blob数据存储" class="headerlink" title="blob数据存储"></a>blob数据存储</h3><p>从数学意义上说，blob是按C风格连续存储的N维数组，即在内部所存储的数据是一块连续的内存，实际上是一个一维的指针。</p>
<p>对于批量图像数据来说，blob常规的维数为：图像数量N、通道数K、图像高度H、图像宽度W。blob按行为主(row-major)进行存储，所以一个4维blob中，坐标为<code>(n,k,h,w)</code>的实际物理位置为<code>((n*K+k)*H+h)*W+w</code>，最右边的维度更新最快。</p>
<ul>
<li>Number/N是每个批次处理的数据量。批量处理信息有利于提供设备处理和交换的数据的吞吐率。在ImageNet上每个训练批量为256张图像，则N=256；</li>
<li>Channel/K是特征维度，例如对RGB图像来说，可以理解为通道数量，K=3；如果是网络中间结果，就是feature map的数量；</li>
<li>H、W：如果是图像数据，可以理解为图像的高度和宽度；如果是参数数据，可以理解为滤波核的高度和宽度。</li>
</ul>
<p>虽然Caffe的图像应用例子中很多blobs都是4维坐标，但是对于非图像应用任务，blobs也完全可以照常使用。例如，如果你仅仅需要类似于传统多层感知机那样的全连接层，使用2维的blobs（形式为(N,D)），之后再调用 InnerProductLayer。</p>
<p>参数Blob的维度是根据层的类型和配置而变化的。一个卷积层中若有96个空间维度为 <code>11*11</code>、输入为3通道的滤波器，那么其blob维度是 <code>96*3*11*11</code>。对于一个输入是 1024 维（输入通道数），输出是 1000 维（输出通道数）的内积层/全连接层，参数blob维度是 <code>1000*1024</code>。</p>
<blockquote>
<p>以上摘自Caffe官方教程中译本_CaffeCN社区翻译（详见doc目录），并加入少量修改。</p>
</blockquote>
<h3 id="message信息"><a href="#message信息" class="headerlink" title="message信息"></a>message信息</h3><p>caffe.proto中，有3个message与blob有关，定义如下：</p>
<p>1、BlobShape</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Specifies the shape (dimensions) of a Blob.</span><br><span class="line">// 指定数据块Blob的维度，若为4维，则为num、channel、height、width</span><br><span class="line">message BlobShape &#123;</span><br><span class="line">  repeated int64 dim = 1 [packed = true];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、BlobProto</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message BlobProto &#123;</span><br><span class="line">  optional BlobShape shape = 7;                     // BlobShappe类对象</span><br><span class="line">  repeated float data = 5 [packed = true];          // 前向传播的data，float类型</span><br><span class="line">  repeated float diff = 6 [packed = true];          // 反向传播的diff，float类型</span><br><span class="line">  repeated double double_data = 8 [packed = true];  // 前向传播的data，double类型</span><br><span class="line">  repeated double double_diff = 9 [packed = true];  // 反向传播的diff，double类型</span><br><span class="line"></span><br><span class="line">  // 4D dimensions -- deprecated.  Use &quot;shape&quot; instead.</span><br><span class="line">  // 已废弃，使用BlobShape shape替代</span><br><span class="line">  optional int32 num = 1 [default = 0];</span><br><span class="line">  optional int32 channels = 2 [default = 0];</span><br><span class="line">  optional int32 height = 3 [default = 0];</span><br><span class="line">  optional int32 width = 4 [default = 0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、BlobProtoVector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// The BlobProtoVector is simply a way to pass multiple blobproto instances</span><br><span class="line">// around.</span><br><span class="line">// 存放多个BlobProto实例</span><br><span class="line">message BlobProtoVector &#123;</span><br><span class="line">  repeated BlobProto blobs = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><code>std::shared_ptr</code> 是通过指针保持对象共享所有权的智能指针。多个 <code>shared_ptr</code> 对象可占有同一对象。当最后一个占有对象的<code>shared_ptr</code>被销毁或被赋值为另一指针时，对象会被自动销毁并释放内存（详见<a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">shared_ptr</a>）。</p>
<h3 id="blob类数据成员"><a href="#blob类数据成员" class="headerlink" title="blob类数据成员"></a>blob类数据成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Blob &#123;</span><br><span class="line">...</span><br><span class="line"> protected:</span><br><span class="line">  shared_ptr&lt;SyncedMemory&gt; data_;        // 存储前向传递数据</span><br><span class="line">  shared_ptr&lt;SyncedMemory&gt; diff_;        // 存储反向传递梯度</span><br><span class="line">  shared_ptr&lt;SyncedMemory&gt; shape_data_;  // 参数维度old version</span><br><span class="line">  vector&lt;int&gt; shape_;                    // 参数维度</span><br><span class="line">  int count_;                            // Blob存储的元素个数（shape_所有元素乘积: n*k*h*w）</span><br><span class="line">  int capacity_;                         // 当前Blob的元素个数（控制动态分配）</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际是在<code>SyncedMemory</code>上做了一层封装。</p>
<h3 id="blob类成员函数"><a href="#blob类成员函数" class="headerlink" title="blob类成员函数"></a>blob类成员函数</h3><blockquote>
<p>主要介绍各函数的功能，部分函数的实现未完全展开，详见 blob.cpp</p>
</blockquote>
<p><strong>1、reshape</strong></p>
<p>Reshape函数对Blob的形状进行初始化或改变。</p>
<blockquote>
<p>在网络传播中，因为每层数据的维度长宽等都不一样，layer中也会调用Reshape函数来实现数据维度的对齐。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过vector&lt;int&gt;参数设置shape_、count_和capacity_大小</span><br><span class="line">void Reshape(const vector&lt;int&gt;&amp; shape);</span><br><span class="line">// 通过类BlobShape参数设置shape_、count_和capacity_大小</span><br><span class="line">void Reshape(const BlobShape&amp; shape);</span><br><span class="line">// 通过外部的blob参数来设置shape_、count_和capacity_大小</span><br><span class="line">void ReshapeLike(const Blob&amp; other);</span><br></pre></td></tr></table></figure>
<p><strong>2、shape</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 获得当前Blob的所有维度值shape_</span><br><span class="line">inline const vector&lt;int&gt;&amp; shape() const &#123; return shape_; &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Returns the &apos;canonical&apos; version of a (usually) user-specified axis,</span><br><span class="line"> *        allowing for negative indexing (e.g., -1 for the last axis).</span><br><span class="line"> *</span><br><span class="line"> * @param axis_index the axis index.</span><br><span class="line"> *        If 0 &lt;= index &lt; num_axes(), return index.</span><br><span class="line"> *        If -num_axes &lt;= index &lt;= -1, return (num_axes() - (-index)),</span><br><span class="line"> *        e.g., the last axis index (num_axes() - 1) if index == -1,</span><br><span class="line"> *        the second to last if index == -2, etc.</span><br><span class="line"> *        Dies on out of range index.</span><br><span class="line"> */</span><br><span class="line">// 对输入的Blob维度索引值进行判断，返回有效的索引值，支持负数输入</span><br><span class="line">// *  0 &lt;= index &lt; num_axes(), 直接返回</span><br><span class="line">// * -num_axes &lt;= index &lt;= -1, 返回num_axes() - (-index)</span><br><span class="line">// * 其他情况报错</span><br><span class="line">inline int CanonicalAxisIndex(int axis_index) const &#123;</span><br><span class="line">  CHECK_GE(axis_index, -num_axes())</span><br><span class="line">      &lt;&lt; &quot;axis &quot; &lt;&lt; axis_index &lt;&lt; &quot; out of range for &quot; &lt;&lt; num_axes()</span><br><span class="line">      &lt;&lt; &quot;-D Blob with shape &quot; &lt;&lt; shape_string();</span><br><span class="line">  CHECK_LT(axis_index, num_axes())</span><br><span class="line">      &lt;&lt; &quot;axis &quot; &lt;&lt; axis_index &lt;&lt; &quot; out of range for &quot; &lt;&lt; num_axes()</span><br><span class="line">      &lt;&lt; &quot;-D Blob with shape &quot; &lt;&lt; shape_string();</span><br><span class="line">  if (axis_index &lt; 0) &#123;</span><br><span class="line">    return axis_index + num_axes();</span><br><span class="line">  &#125;</span><br><span class="line">  return axis_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Returns the dimension of the index-th axis (or the negative index-th</span><br><span class="line"> *        axis from the end, if index is negative).</span><br><span class="line"> *</span><br><span class="line"> * @param index the axis index, which may be negative as it will be</span><br><span class="line"> *        &quot;canonicalized&quot; using CanonicalAxisIndex.</span><br><span class="line"> *        Dies on out of range index.</span><br><span class="line"> */</span><br><span class="line">// 获得当前Blob指定索引的维度值</span><br><span class="line">inline int shape(int index) const &#123;</span><br><span class="line">  return shape_[CanonicalAxisIndex(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获得当前Blob指定索引的维度值, 先进行判断，再调用shape()函数来完成</span><br><span class="line">inline int LegacyShape(int index) const &#123;</span><br><span class="line">  CHECK_LE(num_axes(), 4)</span><br><span class="line">      &lt;&lt; &quot;Cannot use legacy accessors on Blobs with &gt; 4 axes.&quot;;</span><br><span class="line">  CHECK_LT(index, 4);</span><br><span class="line">  CHECK_GE(index, -4);</span><br><span class="line">  if (index &gt;= num_axes() || index &lt; -num_axes()) &#123;</span><br><span class="line">    // Axis is out of range, but still in [0, 3] (or [-4, -1] for reverse</span><br><span class="line">    // indexing) -- this special case simulates the one-padding used to fill</span><br><span class="line">    // extraneous axes of legacy blobs.</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return shape(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、count</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 获得当前Blob的元素个数,即shape_结构中各维度值的乘积：N*C*H*W</span><br><span class="line">inline int count() const &#123; return count_; &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Compute the volume of a slice; i.e., the product of dimensions</span><br><span class="line"> *        among a range of axes.</span><br><span class="line"> *</span><br><span class="line"> * @param start_axis The first axis to include in the slice.</span><br><span class="line"> *</span><br><span class="line"> * @param end_axis The first axis to exclude from the slice.</span><br><span class="line"> */</span><br><span class="line">// 根据指定的start_axis和end_axis计算blob元素个数, 即shape_中指定维度值的乘积</span><br><span class="line">inline int count(int start_axis, int end_axis) const &#123;</span><br><span class="line">  CHECK_LE(start_axis, end_axis);</span><br><span class="line">  CHECK_GE(start_axis, 0);</span><br><span class="line">  CHECK_GE(end_axis, 0);</span><br><span class="line">  CHECK_LE(start_axis, num_axes());</span><br><span class="line">  CHECK_LE(end_axis, num_axes());</span><br><span class="line">  int count = 1;</span><br><span class="line">  for (int i = start_axis; i &lt; end_axis; ++i) &#123;</span><br><span class="line">    count *= shape(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief Compute the volume of a slice spanning from a particular first</span><br><span class="line"> *        axis to the final axis.</span><br><span class="line"> *</span><br><span class="line"> * @param start_axis The first axis to include in the slice.</span><br><span class="line"> */</span><br><span class="line">// 根据指定的start_axis计算blob元素个数，即shape_中从指定维度开始到末尾各维度值的乘积</span><br><span class="line">inline int count(int start_axis) const &#123;</span><br><span class="line">  return count(start_axis, num_axes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、offset</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 根据num、channels、height、width计算在数组中的偏移量,计算公式:((n*C+c)*H+h)*W+w</span><br><span class="line">inline int offset(const int n, const int c = 0, const int h = 0,</span><br><span class="line">    const int w = 0) const &#123;</span><br><span class="line">  CHECK_GE(n, 0);</span><br><span class="line">  CHECK_LE(n, num());</span><br><span class="line">  CHECK_GE(channels(), 0);</span><br><span class="line">  CHECK_LE(c, channels());</span><br><span class="line">  CHECK_GE(height(), 0);</span><br><span class="line">  CHECK_LE(h, height());</span><br><span class="line">  CHECK_GE(width(), 0);</span><br><span class="line">  CHECK_LE(w, width());</span><br><span class="line">  return ((n * channels() + c) * height() + h) * width() + w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据vector&lt;int&gt; index计算偏移量：((n*C+c)*H+h)*W+w</span><br><span class="line">inline int offset(const vector&lt;int&gt;&amp; indices) const &#123;</span><br><span class="line">  CHECK_LE(indices.size(), num_axes());</span><br><span class="line">  int offset = 0;</span><br><span class="line">  for (int i = 0; i &lt; num_axes(); ++i) &#123;</span><br><span class="line">    offset *= shape(i);</span><br><span class="line">    if (indices.size() &gt; i) &#123;</span><br><span class="line">      CHECK_GE(indices[i], 0);</span><br><span class="line">      CHECK_LT(indices[i], shape(i));</span><br><span class="line">      offset += indices[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、cpu和gpu内存数据访问</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Copy from a source Blob.</span><br><span class="line"> *</span><br><span class="line"> * @param source the Blob to copy from</span><br><span class="line"> * @param copy_diff if false, copy the data; if true, copy the diff</span><br><span class="line"> * @param reshape if false, require this Blob to be pre-shaped to the shape</span><br><span class="line"> *        of other (and die otherwise); if true, Reshape this Blob to other&apos;s</span><br><span class="line"> *        shape if necessary</span><br><span class="line"> */</span><br><span class="line">// 从source blob中拷贝数据到当前blob</span><br><span class="line">// 如果copy_diff为false，拷贝data_数据，否则，拷贝diff_数据</span><br><span class="line">// 如果reshape为false，要求source blob预先shape成与当前blob一致，否则，根据二者shape是否一致决定是否执行reshape操作</span><br><span class="line">void CopyFrom(const Blob&lt;Dtype&gt;&amp; source, bool copy_diff = false,</span><br><span class="line">    bool reshape = false);</span><br><span class="line">    </span><br><span class="line">// 根据指定的偏移量获得前向传播数据data_的一个元素的值</span><br><span class="line">inline Dtype data_at(const int n, const int c, const int h,</span><br><span class="line">    const int w) const &#123;</span><br><span class="line">  return cpu_data()[offset(n, c, h, w)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据指定的偏移量获得反向传播梯度diff_的一个元素的值</span><br><span class="line">inline Dtype diff_at(const int n, const int c, const int h,</span><br><span class="line">    const int w) const &#123;</span><br><span class="line">  return cpu_diff()[offset(n, c, h, w)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同上面的data_at，只不过输入是vector矢量</span><br><span class="line">inline Dtype data_at(const vector&lt;int&gt;&amp; index) const &#123;</span><br><span class="line">  return cpu_data()[offset(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同上面的diff_at，只不过输入是vector矢量</span><br><span class="line">inline Dtype diff_at(const vector&lt;int&gt;&amp; index) const &#123;</span><br><span class="line">  return cpu_diff()[offset(index)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取前向传播数据 data_ 的指针</span><br><span class="line">inline const shared_ptr&lt;SyncedMemory&gt;&amp; data() const &#123;</span><br><span class="line">  CHECK(data_);</span><br><span class="line">  return data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取反向传播梯度 diff_ 的指针</span><br><span class="line">inline const shared_ptr&lt;SyncedMemory&gt;&amp; diff() const &#123;</span><br><span class="line">  CHECK(diff_);</span><br><span class="line">  return diff_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、SyncedMemory封装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Blob的CPU和GPU数据访问函数，调用SyncedMemory内存管理类中同名函数来实现</span><br><span class="line">// mutable_ 前缀得到Blob数据的可写指针，const函数得到只读指针</span><br><span class="line">const Dtype* cpu_data() const;</span><br><span class="line">void set_cpu_data(Dtype* data);</span><br><span class="line">const int* gpu_shape() const;</span><br><span class="line">const Dtype* gpu_data() const;</span><br><span class="line">void set_gpu_data(Dtype* data);</span><br><span class="line">const Dtype* cpu_diff() const;</span><br><span class="line">const Dtype* gpu_diff() const;</span><br><span class="line">Dtype* mutable_cpu_data();</span><br><span class="line">Dtype* mutable_gpu_data();</span><br><span class="line">Dtype* mutable_cpu_diff();</span><br><span class="line">Dtype* mutable_gpu_diff();</span><br></pre></td></tr></table></figure>
<p><strong>7、update</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 完成梯度下降过程中的参数更新, 被网络中存储参数的Blob调用</span><br><span class="line">// 调用caffe_axpy函数重新计算data_(weight，bias 等减去对应的导数): data_ = -1 * diff_ + data_</span><br><span class="line">// The &quot;update&quot; method is used for parameter blobs in a Net, which are stored</span><br><span class="line">// as Blob&lt;float&gt; or Blob&lt;double&gt; -- hence we do not define it for</span><br><span class="line">// Blob&lt;int&gt; or Blob&lt;unsigned int&gt;.</span><br><span class="line">template &lt;&gt; void Blob&lt;unsigned int&gt;::Update() &#123; NOT_IMPLEMENTED; &#125;</span><br><span class="line">template &lt;&gt; void Blob&lt;int&gt;::Update() &#123; NOT_IMPLEMENTED; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void Blob&lt;Dtype&gt;::Update() &#123;</span><br><span class="line">  // We will perform update based on where the data is located.</span><br><span class="line">  switch (data_-&gt;head()) &#123;</span><br><span class="line">  case SyncedMemory::HEAD_AT_CPU:</span><br><span class="line">    // perform computation on CPU</span><br><span class="line">    caffe_axpy&lt;Dtype&gt;(count_, Dtype(-1),</span><br><span class="line">        static_cast&lt;const Dtype*&gt;(diff_-&gt;cpu_data()),</span><br><span class="line">        static_cast&lt;Dtype*&gt;(data_-&gt;mutable_cpu_data()));</span><br><span class="line">    break;</span><br><span class="line">  case SyncedMemory::HEAD_AT_GPU:</span><br><span class="line">  case SyncedMemory::SYNCED:</span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">    // perform computation on GPU</span><br><span class="line">    caffe_gpu_axpy&lt;Dtype&gt;(count_, Dtype(-1),</span><br><span class="line">        static_cast&lt;const Dtype*&gt;(diff_-&gt;gpu_data()),</span><br><span class="line">        static_cast&lt;Dtype*&gt;(data_-&gt;mutable_gpu_data()));</span><br><span class="line">#else</span><br><span class="line">    NO_GPU;</span><br><span class="line">#endif</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    LOG(FATAL) &lt;&lt; &quot;Syncedmem not initialized.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中caffe_axpy函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">void caffe_axpy&lt;float&gt;(const int N, const float alpha, const float* X,</span><br><span class="line">    float* Y) &#123; cblas_saxpy(N, alpha, X, 1, Y, 1); &#125;</span><br></pre></td></tr></table></figure>
<p>功能： Y=alpha*X+Y<br>N：为X和Y中element的个数</p>
<p><strong>8、数据持久化</strong></p>
<p>Blob的数据持久化函数，通过Protobuf来做相应的序列化/反序列化操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将BlobProto的shape/data/diff分别copy给当前blob的shape_/data_/diff_完成数据解析(反序列化)，若reshape参数为true，则会对当前的blob重新进行reshape</span><br><span class="line"> void FromProto(const BlobProto&amp; proto, bool reshape = true);</span><br><span class="line"> </span><br><span class="line"> // 将Blob的shape_/data_/diff_(如果write_diff为true)分别copy给BlobProto的shape/data/diff完成序列化</span><br><span class="line"> void ToProto(BlobProto* proto, bool write_diff = false) const;</span><br></pre></td></tr></table></figure>
<p><strong>9、工具函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/// @brief Compute the sum of absolute values (L1 norm) of the data.</span><br><span class="line">// 计算data_的L1范式：向量中各个元素绝对值之和</span><br><span class="line">Dtype asum_data() const;</span><br><span class="line">/// @brief Compute the sum of absolute values (L1 norm) of the diff.</span><br><span class="line">// 计算diff_的L1范式：向量中各个元素绝对值之和</span><br><span class="line">Dtype asum_diff() const;</span><br><span class="line">/// @brief Compute the sum of squares (L2 norm squared) of the data.</span><br><span class="line">// 计算data_的L2范式平方：向量中各元素的平方和</span><br><span class="line">Dtype sumsq_data() const;</span><br><span class="line">/// @brief Compute the sum of squares (L2 norm squared) of the diff.</span><br><span class="line">// 计算diff_的L2范式平方：向量中各元素的平方和</span><br><span class="line">Dtype sumsq_diff() const;</span><br><span class="line"></span><br><span class="line">/// @brief Scale the blob data by a constant factor.</span><br><span class="line">// 将data_数据按照常数因子缩放</span><br><span class="line">void scale_data(Dtype scale_factor);</span><br><span class="line">/// @brief Scale the blob diff by a constant factor.</span><br><span class="line">// 将diff_数据按照常数因子缩放</span><br><span class="line">void scale_diff(Dtype scale_factor);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief Set the data_ shared_ptr to point to the SyncedMemory holding the</span><br><span class="line"> *        data_ of Blob other -- useful in Layer%s which simply perform a copy</span><br><span class="line"> *        in their Forward pass.</span><br><span class="line"> *</span><br><span class="line"> * This deallocates the SyncedMemory holding this Blob&apos;s data_, as</span><br><span class="line"> * shared_ptr calls its destructor when reset with the &quot;=&quot; operator.</span><br><span class="line"> */</span><br><span class="line">// 将外部指定的blob的data_指针指向给当前blob的data_,以实现共享data_</span><br><span class="line">void ShareData(const Blob&amp; other);</span><br><span class="line">/**</span><br><span class="line"> * @brief Set the diff_ shared_ptr to point to the SyncedMemory holding the</span><br><span class="line"> *        diff_ of Blob other -- useful in Layer%s which simply perform a copy</span><br><span class="line"> *        in their Forward pass.</span><br><span class="line"> *</span><br><span class="line"> * This deallocates the SyncedMemory holding this Blob&apos;s diff_, as</span><br><span class="line"> * shared_ptr calls its destructor when reset with the &quot;=&quot; operator.</span><br><span class="line"> */</span><br><span class="line">// 将外部指定的blob的diff_指针指向给当前blob的diff_,以实现共享diff_</span><br><span class="line">void ShareDiff(const Blob&amp; other);</span><br><span class="line"></span><br><span class="line">// 比较两个blob的shape是否相同</span><br><span class="line">bool ShapeEquals(const BlobProto&amp; other);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【源码分析】caffe code of SyncedMemory]]></title>
      <url>http://xiaqunfeng.cc/2018/12/22/caffe-code-of-SyncedMemory/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 SyncedMemory，本文分析记录了SyncedMemory内存管理模块的数据成员和成员函数，源码文件注释详见 <a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/syncedmem-annotation.hpp" target="_blank" rel="noopener">syncedmem-annotation.hpp</a>，<a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/syncedmem-annotation.cpp" target="_blank" rel="noopener">syncedmem-annotation.cpp</a>。<br><a id="more"></a></p>
<h2 id="SyncedMemory类"><a href="#SyncedMemory类" class="headerlink" title="SyncedMemory类"></a>SyncedMemory类</h2><p>该类用来管理caffe中Blob的内存，所以在看blob代码之前先看一下该类的实现。内存管理的方法代码都封装在syncedmem.hpp与syncedmem.cpp两个文件中，两个文件代码都比较短，读起来比较方便。</p>
<p><code>SyncedMemory</code>的两个优点：</p>
<ul>
<li>屏蔽了CPU和GPU上的内存管理以及数据同步细节</li>
<li>使用lazy的内存分配方式（通过<code>enum SyncedHead</code>状态控制来实现），在数据访问时才分配，而不是立马分配，提高效率以及节省内存</li>
</ul>
<h3 id="类的数据成员"><a href="#类的数据成员" class="headerlink" title="类的数据成员"></a>类的数据成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SyncedMemory &#123;</span><br><span class="line">...</span><br><span class="line">   private:</span><br><span class="line">        ...</span><br><span class="line">        void* cpu_ptr_;</span><br><span class="line">        void* gpu_ptr_;</span><br><span class="line">        size_t size_;  </span><br><span class="line">        SyncedHead head_;</span><br><span class="line">        bool own_cpu_data_;</span><br><span class="line">        bool cpu_malloc_use_cuda_;</span><br><span class="line">        bool own_gpu_data_;</span><br><span class="line">        int device_;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1、其中 head_ 指向目前最新数据块的位置，即最后更新过数据的位置，用于cpu和gpu数据同步。这是一个枚举类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum SyncedHead &#123; UNINITIALIZED, HEAD_AT_CPU, HEAD_AT_GPU, SYNCED &#125;;</span><br></pre></td></tr></table></figure>
<p>依次表示：数据未初始化、最新数据在cpu上、最新数据在gpu上、最新数据cpu和gpu共享。</p>
<p>2、size_ 表示数据所占内存大小</p>
<p>3、cpu_ptr_ 和 gpu_ptr_ 分别表示指向cpu和gpu侧的指针，通过该指针访问数据</p>
<p>这两个指针指向的数据空间有两种来源，一种是对象自己内部分配的，一种是外部指定的</p>
<p>4、own_cpu_data_ 和 own_gpu_data_ 表示对象是否是自己内部分配的</p>
<ul>
<li>own_cpu_data_ 为true时，表示cpu_ptr_是对象内部调用CaffeMallocHost分配的CPU内存</li>
<li>own_gpu_data_ 为true时，表示gpu_ptr_是对象内部调用cudaMalloc分配的GPU内存</li>
</ul>
<p>这两个标志位在 set_cpu/gpu_data() 及函数析构的时候会用于判断是否需要释放当前的数据，如果是自己内部申请的，就要内部释放。</p>
<p>5、cpu_malloc_use_cuda_ 为true时，使用cudaMallocHost分配页锁定内存，否则使用系统malloc分配可分页内存</p>
<p>6、device_ 表示gpu的设备编号</p>
<h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SyncedMemory &#123;</span><br><span class="line"> public:</span><br><span class="line">  ...</span><br><span class="line">  const void* cpu_data();</span><br><span class="line">  void set_cpu_data(void* data);</span><br><span class="line">  const void* gpu_data();</span><br><span class="line">  void set_gpu_data(void* data);</span><br><span class="line">  void* mutable_cpu_data();</span><br><span class="line">  void* mutable_gpu_data();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">  void async_gpu_push(const cudaStream_t&amp; stream);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  void check_device();</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1、<code>cpu_data()</code> 函数用于获取cpu数据的const指针，只读不写</p>
<p>cpu_data()函数的核心是to_cpu()函数（在syncedmem.cpp中定义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">inline void SyncedMemory::to_cpu() &#123;</span><br><span class="line">  check_device();</span><br><span class="line">  switch (head_) &#123;</span><br><span class="line">  case UNINITIALIZED:</span><br><span class="line">    CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_);</span><br><span class="line">    caffe_memset(size_, 0, cpu_ptr_);</span><br><span class="line">    head_ = HEAD_AT_CPU;</span><br><span class="line">    own_cpu_data_ = true;</span><br><span class="line">    break;</span><br><span class="line">  case HEAD_AT_GPU:</span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">    if (cpu_ptr_ == NULL) &#123;</span><br><span class="line">      CaffeMallocHost(&amp;cpu_ptr_, size_, &amp;cpu_malloc_use_cuda_);</span><br><span class="line">      own_cpu_data_ = true;</span><br><span class="line">    &#125;</span><br><span class="line">    caffe_gpu_memcpy(size_, gpu_ptr_, cpu_ptr_);</span><br><span class="line">    head_ = SYNCED;</span><br><span class="line">#else</span><br><span class="line">    NO_GPU;</span><br><span class="line">#endif</span><br><span class="line">    break;</span><br><span class="line">  case HEAD_AT_CPU:</span><br><span class="line">  case SYNCED:</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是检查最新数据的位置（即查看 head_ 的标志）</p>
<ul>
<li>数据未初始化 —— 初始化，并将最新数据标志置为位于cpu</li>
<li>最新数据在gpu上 —— 如果指定了CPU_ONLY，则输出NO_GPU并什么都不做；否则将数据复制到cpu，并将数据标志置为共享</li>
<li>最新数据在cpu上或者是共享的 —— 什么都不做</li>
</ul>
<p>2、<code>mutable_cpu_data()</code> 返回可写的cpu指针</p>
<p>它与 cpu_data() 的区别是：在执行 to_cpu() 后，不论 head_ 当前状态如何，将最新数据的位置置为位于cpu上，认为cpu侧数据是最新的，所以调用者可以修改cpu侧数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void* SyncedMemory::mutable_cpu_data() &#123;</span><br><span class="line">  check_device();</span><br><span class="line">  to_cpu();</span><br><span class="line">  head_ = HEAD_AT_CPU;</span><br><span class="line">  return cpu_ptr_;</span><br><span class="line">&#125;</span><br><span class="line">const void* SyncedMemory::cpu_data() &#123;</span><br><span class="line">  check_device();</span><br><span class="line">  to_cpu();</span><br><span class="line">  return (const void*)cpu_ptr_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、<code>set_cpu_data(void* data)</code></p>
<p>设置cpu数据，即将cpu_ptr_ 指针指向外部数据。</p>
<p>4、<code>gpu_data(), mutable_gpu_data(), set_gpu_data(void* data)</code> 功能同cpu</p>
<p>5、<code>async_gpu_push(const cudaStream_t&amp; stream)</code></p>
<p>功能就是以流的形式将数据同步到gpu上。具体操作就是在gpu上分配存储空间，将cpu的数据同步至gpu，并将head_ 置为共享。</p>
<p>总结一下CPU/GPU数据同步的功能：</p>
<ul>
<li>第一次访问某一侧数据时分配该侧内存，如果不曾访问过则不分配内存，按需分配来节省内存。</li>
<li>用<code>head_</code>来指示最近一次数据更新发生在哪一侧，仅在调用另一侧数据时才将该侧数据同步过去，如果访问的仍是该侧，则不会发生同步。</li>
<li>当两侧已同步都是最新时，即<code>head_=SYNCED</code>，访问任何一侧都不会发生数据同步。</li>
</ul>
<blockquote>
<p>其他成员函数的实现代码详见syncedmem-annotation.cpp</p>
</blockquote>
<h2 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h2><p>在 syncedmem.hpp 中有两个内联函数，不属于 SyncedMemory 类：CaffeMallocHost，CaffeFreeHost，用于内存的申请和释放。</p>
<p>代码逻辑比较简单，如果是CPU模式，那么调用malloc和free（或者intel的mkl模块）来申请/释放内存，否则调用CUDA的 cudaMallocHost 和 cudaFreeHost 来申请/释放显存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline void CaffeMallocHost(void** ptr, size_t size, bool* use_cuda) &#123;</span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">  if (Caffe::mode() == Caffe::GPU) &#123;</span><br><span class="line">    CUDA_CHECK(cudaMallocHost(ptr, size));</span><br><span class="line">    *use_cuda = true;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">#ifdef USE_MKL</span><br><span class="line">  *ptr = mkl_malloc(size ? size:1, 64);</span><br><span class="line">#else</span><br><span class="line">  *ptr = malloc(size);</span><br><span class="line">#endif</span><br><span class="line">  *use_cuda = false;</span><br><span class="line">  CHECK(*ptr) &lt;&lt; &quot;host allocation of size &quot; &lt;&lt; size &lt;&lt; &quot; failed&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于-Pinned-和-Non-Pinned-Memory"><a href="#关于-Pinned-和-Non-Pinned-Memory" class="headerlink" title="关于 Pinned 和 Non-Pinned Memory"></a>关于 Pinned 和 Non-Pinned Memory</h3><p>当需要分配CPU内存且会传输到GPU时，有两种方式可以选择：<code>pinned</code> 和 <code>non-pinned</code>。</p>
<p>Pinned memory使用<code>cudaMallocHost</code>来分配CPU内存，可以防止内存页被交换出去，因此可以提供更高的传输速度。Non-pinned memory使用<code>malloc</code>函数分配CPU内存。但是Pinned memory 比Non-pinned memory有更昂贵的内存分配和释放，因为<code>cudaMallocHost</code>分配和释放CPU内存相比<code>malloc</code>更加耗时。</p>
<p>结论：</p>
<ul>
<li>使用<code>Pinned Memory</code>方式的CPU和GPU之间传输速度更大，但是分配和释放的耗时更大</li>
<li>使用<code>Non-Pinned Memory</code>的方式CPU和GPU之间传输耗时更大，但是分配和释放更快</li>
<li>当传输的数据比较大，且均需从CPU传至GPU和从GPU传至CPU时，使用<code>Pinned Memory</code>可以获得更好的性能</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【源码分析】caffe code of layer factory]]></title>
      <url>http://xiaqunfeng.cc/2018/12/22/caffe-code-of-layer-factory/</url>
      <content type="html"><![CDATA[<p>caffe 代码阅读之 layer factory，本文分析记录了layer的注册和创建过程，源码文件注释详见<a href="https://github.com/xiaqunfeng/caffe-study/blob/master/code-analyze/layer_factory-annotation.hpp" target="_blank" rel="noopener">layer_factory-annotation.hpp</a>。<br><a id="more"></a></p>
<h2 id="layer-factory"><a href="#layer-factory" class="headerlink" title="layer factory"></a>layer factory</h2><h3 id="LayerRegistry类"><a href="#LayerRegistry类" class="headerlink" title="LayerRegistry类"></a>LayerRegistry类</h3><p>主要的实现是由该类来完成的。内部维护了一个map，key为layer的string（类型名称），value为对应Creator（工厂函数），caffe就是通过该map来管理string和Creator映射关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*Creator)(const LayerParameter&amp;);</span><br><span class="line">typedef std::map&lt;string, Creator&gt; CreatorRegistry;</span><br></pre></td></tr></table></figure>
<p>map类型为<code>CreatorRegistry</code>，实际类型为<code>std::map&lt;string, Creator&gt;</code>。</p>
<h3 id="layer的注册"><a href="#layer的注册" class="headerlink" title="layer的注册"></a>layer的注册</h3><p>caffe通过两组宏来实现layer的注册：</p>
<p>1、先来看宏 <code>REGISTER_LAYER_CLASS</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define REGISTER_LAYER_CLASS(type)                                             \</span><br><span class="line">  template &lt;typename Dtype&gt;                                                    \</span><br><span class="line">  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; Creator_##type##Layer(const LayerParameter&amp; param) \</span><br><span class="line">  &#123;                                                                            \</span><br><span class="line">    return shared_ptr&lt;Layer&lt;Dtype&gt; &gt;(new type##Layer&lt;Dtype&gt;(param));           \</span><br><span class="line">  &#125;                                                                            \</span><br><span class="line">  REGISTER_LAYER_CREATOR(type, Creator_##type##Layer)`</span><br></pre></td></tr></table></figure>
<p>该宏实现为指定type的Layer创建一个Creator工厂函数，然后调用<code>REGISTER_LAYER_CREATOR</code>将工厂函数和Layer的类型名进行注册，支持两种Layer的数据类型，float和double。</p>
<p>在每个XX_layer.cpp文件末尾处调用，进行layer的添加注册，比如在<code>bias_layer.cpp</code>的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_LAYER_CLASS(Bias);</span><br></pre></td></tr></table></figure>
<p>2、再来看宏 <code>REGISTER_LAYER_CREATOR</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define REGISTER_LAYER_CREATOR(type, creator)                                  \</span><br><span class="line">  static LayerRegisterer&lt;float&gt; g_creator_f_##type(#type, creator&lt;float&gt;);     \</span><br><span class="line">  static LayerRegisterer&lt;double&gt; g_creator_d_##type(#type, creator&lt;double&gt;)    \</span><br></pre></td></tr></table></figure>
<p>声明了两个变量，分别对应float和double两种类型，两个变量通过调用LayerRegisterer类的构造函数来完成初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class LayerRegisterer &#123;</span><br><span class="line"> public:</span><br><span class="line">  LayerRegisterer(const string&amp; type,</span><br><span class="line">                  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; (*creator)(const LayerParameter&amp;)) &#123;</span><br><span class="line">    // LOG(INFO) &lt;&lt; &quot;Registering layer type: &quot; &lt;&lt; type;</span><br><span class="line">    LayerRegistry&lt;Dtype&gt;::AddCreator(type, creator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LayerRegisterer类"><a href="#LayerRegisterer类" class="headerlink" title="LayerRegisterer类"></a>LayerRegisterer类</h3><p>代码如上，该类只有一个方法，即构造函数，在LayerRegisterer的构造方法中调用了<code>LayerRegistry</code>类的静态方法<code>AddCreator</code>，将新的layer和creator注册并添加到registry list中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LayerRegistry &#123;</span><br><span class="line">...</span><br><span class="line">  static CreatorRegistry&amp; Registry() &#123;</span><br><span class="line">    static CreatorRegistry* g_registry_ = new CreatorRegistry();</span><br><span class="line">    return *g_registry_;</span><br><span class="line">  &#125;</span><br><span class="line">  // Adds a creator.</span><br><span class="line">  static void AddCreator(const string&amp; type, Creator creator) &#123;</span><br><span class="line">    CreatorRegistry&amp; registry = Registry();</span><br><span class="line">    CHECK_EQ(registry.count(type), 0)</span><br><span class="line">        &lt;&lt; &quot;Layer type &quot; &lt;&lt; type &lt;&lt; &quot; already registered.&quot;;</span><br><span class="line">    registry[type] = creator;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上实现了动态注册</p>
<h3 id="创建layer"><a href="#创建layer" class="headerlink" title="创建layer"></a>创建layer</h3><p>注册完后，在xxnet.prototxt中定义相关的layer参数，比如mnist文件夹下的lenet.prototxt中定义type为Pooling的layer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">layer &#123;</span><br><span class="line">  name: &quot;pool1&quot;</span><br><span class="line">  type: &quot;Pooling&quot;</span><br><span class="line">  bottom: &quot;conv1&quot;</span><br><span class="line">  top: &quot;pool1&quot;</span><br><span class="line">  pooling_param &#123;</span><br><span class="line">    pool: MAX</span><br><span class="line">    kernel_size: 2</span><br><span class="line">    stride: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在net.cpp中创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Net&lt;Dtype&gt;::Init(const NetParameter&amp; in_param) &#123;</span><br><span class="line">...</span><br><span class="line">    // Setup layer.</span><br><span class="line">    const LayerParameter&amp; layer_param = param.layer(layer_id);</span><br><span class="line">    if (layer_param.propagate_down_size() &gt; 0) &#123;</span><br><span class="line">      CHECK_EQ(layer_param.propagate_down_size(),</span><br><span class="line">          layer_param.bottom_size())</span><br><span class="line">          &lt;&lt; &quot;propagate_down param must be specified &quot;</span><br><span class="line">          &lt;&lt; &quot;either 0 or bottom_size times &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    layers_.push_back(LayerRegistry&lt;Dtype&gt;::CreateLayer(layer_param));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>LayerRegistry</code>类的静态方法<code>CreateLayer</code>来实现layer的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LayerRegistry &#123;</span><br><span class="line">  ...</span><br><span class="line">  // Get a layer using a LayerParameter.</span><br><span class="line">  static shared_ptr&lt;Layer&lt;Dtype&gt; &gt; CreateLayer(const LayerParameter&amp; param) &#123;</span><br><span class="line">    if (Caffe::root_solver()) &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; &quot;Creating layer &quot; &lt;&lt; param.name();</span><br><span class="line">    &#125;</span><br><span class="line">    const string&amp; type = param.type();</span><br><span class="line">    CreatorRegistry&amp; registry = Registry();</span><br><span class="line">    CHECK_EQ(registry.count(type), 1) &lt;&lt; &quot;Unknown layer type: &quot; &lt;&lt; type</span><br><span class="line">        &lt;&lt; &quot; (known types: &quot; &lt;&lt; LayerTypeListString() &lt;&lt; &quot;)&quot;;</span><br><span class="line">    return registry[type](param);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>caffe layer的设计用到了设计模式里<a href="https://blog.csdn.net/wuzhekai1985/article/details/6660462" target="_blank" rel="noopener">工厂模式</a>中的工厂方法模式。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用kubeadm在Ubuntu1604上构建k8s集群]]></title>
      <url>http://xiaqunfeng.cc/2018/11/06/kubernetes-deploy/</url>
      <content type="html"><![CDATA[<p>介绍在部署k8s集群的过程，以及遇到的问题及解决方法。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>本次一共安装3台机器，一台master，两台slave。整个安装过程将在Ubuntu1604服务器上进行，安装kubeadm，以及kubernetes的基本集群，包括calico网络。</p>
<p>注：服务器访问不了外网，所以采用国内源的方式。</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>1、更新Package索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>2、添加Https支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common -y</span><br></pre></td></tr></table></figure>
<p>3、添加Docker官方的GPG key:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">## 如果上面的地址不能下载，可以使用国内镜像</span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg  | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>4、添加Docker-CE稳定版仓储地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
<p>注：由于Docker官方仓储<code>download.docker.com</code>的访问较慢，故使用了中科大镜像源替代。</p>
<p>5、安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<p>6、验证：</p>
<p>运行<code>Hello Word</code>来验证一下是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>7、释放sudo</p>
<p>默认情况下，Docker需要使用root身份来访问，每次都使用<code>sudo</code>命令较为麻烦，我们可以将当前用户添加到<code>docker</code>用户组来实现非root用户访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>重新登录一下，便可以不使用<code>sudo</code>命令来操作docker了。</p>
<h3 id="禁用swap文件"><a href="#禁用swap文件" class="headerlink" title="禁用swap文件"></a>禁用swap文件</h3><p>编辑<code>/etc/fstab</code>文件，注释掉引用<code>swap</code>的行，保存并重启后输入<code>sudo swapoff -a</code>即可。</p>
<h2 id="在所有机器上安装kubeadm-kubelet-and-kubectl"><a href="#在所有机器上安装kubeadm-kubelet-and-kubectl" class="headerlink" title="在所有机器上安装kubeadm, kubelet and kubectl"></a>在所有机器上安装kubeadm, kubelet and kubectl</h2><ul>
<li>kubeadm: 引导启动k8s集群的命令工具。</li>
<li>kubelet: 在群集中的所有计算机上运行的组件, 并用来执行如启动pods和containers等操作。</li>
<li>kubectl: 用于操作运行中的集群的命令行工具。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -</span><br><span class="line"># cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line"># apt-get update</span><br><span class="line"># apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<p>Q&amp;A</p>
<p>出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W: GPG error: https://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn&apos;t be verified because the public key is not available: NO_PUBKEY 6A030B21BA07F4FB</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6A030B21BA07F4FB</span><br></pre></td></tr></table></figure>
<p>再次之行 <code>apt-get update</code>，成功。</p>
<h2 id="初始化master节点"><a href="#初始化master节点" class="headerlink" title="初始化master节点"></a>初始化master节点</h2><p>1、拉取镜像</p>
<p>首先查询下当前版本需要哪些docker image。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubeadm config images list --kubernetes-version v1.12.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.12.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.12.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.12.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.12.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.2.24</span><br><span class="line">k8s.gcr.io/coredns:1.2.2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为服务器没有翻墙，所以提前拉取k8s初始化需要用到的Images，并添加对应的<code>k8s.gcr.io</code>标签。推荐使用镜像：<a href="https://github.com/anjia0532/gcr.io_mirror来拉取，机器人自动跟官方同步，非常及时。" target="_blank" rel="noopener">https://github.com/anjia0532/gcr.io_mirror来拉取，机器人自动跟官方同步，非常及时。</a></p>
</blockquote>
<p>写了个脚本<code>pull-tag-rm-image.sh</code>，先pull，再改tag，最后移除pull的image：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># cat pull-tag-rm-image.sh</span><br><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">    kube-apiserver:v1.12.2</span><br><span class="line">    kube-controller-manager:v1.12.2</span><br><span class="line">    kube-scheduler:v1.12.2</span><br><span class="line">    kube-proxy:v1.12.2</span><br><span class="line">    pause:3.1</span><br><span class="line">    etcd:3.2.24</span><br><span class="line">    coredns:1.2.2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for imagename in $&#123;images[@]&#125; ; do</span><br><span class="line">    docker pull anjia0532/google-containers.$imagename</span><br><span class="line">    docker tag anjia0532/google-containers.$imagename k8s.gcr.io/$imagename</span><br><span class="line">    docker rmi anjia0532/google-containers.$imagename</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行脚本：<code>bash pull-tag-rm-image.sh</code></p>
<p>查看image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# docker image ls</span><br><span class="line">REPOSITORY                                                  TAG                 </span><br><span class="line">k8s.gcr.io/kube-proxy                                       v1.12.2            </span><br><span class="line">k8s.gcr.io/kube-apiserver                                   v1.12.2                </span><br><span class="line">k8s.gcr.io/kube-controller-manager                          v1.12.2            </span><br><span class="line">k8s.gcr.io/kube-scheduler                                   v1.12.2            </span><br><span class="line">ubuntu                                                      16.04              </span><br><span class="line">k8s.gcr.io/etcd                                             3.2.24             </span><br><span class="line">hello-world                                                 latest             </span><br><span class="line">k8s.gcr.io/coredns                                          1.2.2              </span><br><span class="line">k8s.gcr.io/pause                                            3.1</span><br></pre></td></tr></table></figure>
<p>2、选择pod network</p>
<p>这里选择网络为calico，具体参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network" target="_blank" rel="noopener">官网 pod-network</a></p>
<p>3、初始化master</p>
<p>Master节点就是运行着控制组件的机器，包括etcd(集群数据库)和API服务(kubectl CLI通讯服务)。<br>初始化master节点, 只需运行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubeadm init --pod-network-cidr=192.168.0.0/16 --kubernetes-version=1.12.2</span><br><span class="line">...</span><br><span class="line">[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 192.168.212.103:6443 --token 4eqoi9.xekqw6hsc7hbqm9l --discovery-token-ca-cert-hash sha256:64a06d1fc3883066fcf94109399cb68eb6626ed2969153dbd08279e0124eb424</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--pod-network-cidr=192.168.0.0/16</code> ：指定pod网络的IP地址范围，它的值取决于下一步选择的网络插件类型。这里选择calico网络。</li>
<li><code>--kubernetes-version=1.12.2</code>：指定Kubenetes版本，如果不指定该参数，会从google网站下载最新的版本信息。这里选择版本v1.12.2。</li>
<li><code>--apiserver-advertise-address</code>: 指定master服务发布的Ip地址，如果不指定，则会自动检测网络接口，通常是内网IP。</li>
<li><code>--feature-gates=CoreDNS</code>: 是否使用CoreDNS，值为true/false，CoreDNS插件在1.10中提升到了Beta阶段，最终会成为Kubernetes的缺省选项。</li>
</ul>
<p>4、设置使用kubectl的权限</p>
<p>如果想在非root用户下使用<code>kubectl</code>，可以执行如下命令(也是<code>kubeadm init</code>输出的一部分)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p>如果已是root用户，只需执行如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<h2 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h2><p>检查节点的状态，发现节点的状态为not ready：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl get nodes</span><br><span class="line">NAME      STATUS     ROLES    AGE   VERSION</span><br><span class="line">jqgpu34   NotReady   master   14m   v1.12.2</span><br></pre></td></tr></table></figure>
<p>原因是还没有配置网络。配置网络，具体参考参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network" target="_blank" rel="noopener">官网 pod-network</a>。</p>
<p>pods之间需要通过网络插件进行彼此通信。网络部署必须是优先于任何应用的部署，如<code>kube-dns</code>(本文中使用的是<code>coredns</code>)在网络部署成功之前是无法使用的。k8s下通信需要CNI（Container Network Interface），（kubeadm不支持kubenet）。比较常见的network addon有：Calico, Canal, Flannel, Kube-router, Romana, Weave Net等。</p>
<p>1、安装网络插件</p>
<p>使用下列命令来安装网络插件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;add-on.yaml&gt;</span><br></pre></td></tr></table></figure>
<p>在本文中，我使用的是Calico网络，安装如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span><br><span class="line"># kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了Calico可以正常运行，必须在执行kubeadm init时使用 <code>--pod-network-cidr=192.168.0.0/16</code>。</p>
</blockquote>
<p>这时候，发现节点的状态变为ready了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE   VERSION</span><br><span class="line">jqgpu34   Ready    master   18m   v1.12.2</span><br></pre></td></tr></table></figure>
<p>网络插件安装完成后，可以通过检查<code>coredns pod</code>的运行状态来判断网络插件是否正常运行，一旦<code>CoreDNS pod</code>起来并运行，就可以继续加入节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE     NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   calico-node-vps6h                 2/2     Running   0          2m8s</span><br><span class="line">kube-system   coredns-576cbf47c7-56kmg          1/1     Running   0          18m</span><br><span class="line">kube-system   coredns-576cbf47c7-wrvzn          1/1     Running   0          18m</span><br><span class="line">kube-system   etcd-jqgpu34                      1/1     Running   0          17m</span><br><span class="line">kube-system   kube-apiserver-jqgpu34            1/1     Running   0          17m</span><br><span class="line">kube-system   kube-controller-manager-jqgpu34   1/1     Running   0          18m</span><br><span class="line">kube-system   kube-proxy-7jdqx                  1/1     Running   0          18m</span><br><span class="line">kube-system   kube-scheduler-jqgpu34            1/1     Running   0          18m</span><br></pre></td></tr></table></figure>
<p>2、隔离主节点</p>
<p>默认情况下，出于安全的考虑，并不会在主节点上运行pod，如果你想在主节点上运行pod，比如：运行一个单机版的kubernetes集群时，可运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line">node/jqgpu34 untainted</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我这里就三台机器，两台计算节点不够用，所以也把master加入计算节点。这时候Scheduler便可以在任何节点上安排运行pod了。</p>
</blockquote>
<h2 id="slave节点加入集群"><a href="#slave节点加入集群" class="headerlink" title="slave节点加入集群"></a>slave节点加入集群</h2><p>节点就是负载（容器和pod等等）运行的地方。ssh到slave机器上执行<code>kubeadm init</code>输出的那句命令，即可将slave节点加入集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.212.103:6443 --token 4eqoi9.xekqw6hsc7hbqm9l --discovery-token-ca-cert-hash sha256:64a06d1fc3883066fcf94109399cb68eb6626ed2969153dbd08279e0124eb424</span><br></pre></td></tr></table></figure>
<p>随后就可以在master节点上通过命令<code>kubectl get nodes</code>看到新加入的机器了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl get nodes</span><br><span class="line">NAME      STATUS     ROLES    AGE   VERSION</span><br><span class="line">jqgpu34   Ready      master   27m   v1.12.2</span><br><span class="line">jqgpu35   NotReady   &lt;none&gt;   27s   v1.12.2</span><br><span class="line">jqgpu36   NotReady   &lt;none&gt;   10s   v1.12.2</span><br></pre></td></tr></table></figure>
<p>其他可选安装步骤参考<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">官网</a>.</p>
<p>其他参考资料：</p>
<ul>
<li><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/install-kubeadm/</a></li>
<li><a href="https://docs.projectcalico.org/v3.3/getting-started/kubernetes/" target="_blank" rel="noopener">https://docs.projectcalico.org/v3.3/getting-started/kubernetes/</a></li>
<li><a href="https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-ubuntu-server-16.04-with-kubeadm.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/practice/install-kubernetes-on-ubuntu-server-16.04-with-kubeadm.html</a></li>
<li><a href="https://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster.html" target="_blank" rel="noopener">https://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster.html</a></li>
</ul>
<h2 id="slave节点一直not-ready"><a href="#slave节点一直not-ready" class="headerlink" title="slave节点一直not ready"></a>slave节点一直not ready</h2><blockquote>
<p>这个问题花了挺多时间，记录一下</p>
</blockquote>
<p>和该问题一模一样：<a href="https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state，但是并没有说解决方法，需要看日志。" target="_blank" rel="noopener">https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state，但是并没有说解决方法，需要看日志。</a></p>
<p>1、master上查看kubelet log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># journalctl -u kubelet</span><br></pre></td></tr></table></figure>
<p>发现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns.go:131] Nameserver limits were exceeded, some nameservers have been omitted,</span><br></pre></td></tr></table></figure>
<p>网上找到遇到类似问题的：</p>
<p><a href="https://www.reddit.com/r/kubernetes/comments/7ruq0f/kubelet_nameserver_limits_were_exceeded/" target="_blank" rel="noopener">https://www.reddit.com/r/kubernetes/comments/7ruq0f/kubelet_nameserver_limits_were_exceeded/</a></p>
<p><a href="https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state" target="_blank" rel="noopener">https://stackoverflow.com/questions/47918549/kubernetes-slave-node-is-in-not-ready-state</a></p>
<p>是dns的问题。查看resol.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/resolv.conf</span><br><span class="line">nameserver 119.28.28.28</span><br><span class="line">nameserver 119.29.29.29</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 114.114.115.115</span><br><span class="line">options timeout:2 attempts:1</span><br></pre></td></tr></table></figure>
<p>也没找到其他解决方法。</p>
<p>2、slave节点上查看日志</p>
<p>除了上述dns的错误外，还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cni.go:188] Unable to update cni config: No networks found in /etc/cni/net.d</span><br><span class="line">kubelet.go:2167] Container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</span><br></pre></td></tr></table></figure>
<p>在master上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /etc/cni/net.d/</span><br><span class="line">10-calico.conflist  calico-kubeconfig</span><br></pre></td></tr></table></figure>
<p>而两个slave节点没有<code>/etc/cni/net.d/</code>这个目录。在slave节点上创建两个目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d</span><br><span class="line">mkdir -p /opt/cni/bin</span><br></pre></td></tr></table></figure>
<p>3、回到master上操作</p>
<p>查看etcd的状态，正常running</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl -n kube-system get pod -o wide | grep etcd</span><br></pre></td></tr></table></figure>
<p>查看calico的状态，只有master和etcd是runing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl -n kube-system get pod -o wide  | grep calico</span><br></pre></td></tr></table></figure>
<p>查看非running pod <code>calico-node-222fg</code>的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl -n kube-system describe pod calico-node-222fg</span><br></pre></td></tr></table></figure>
<p>发现没有这个镜像<code>k8s.gcr.io/pause:3.1</code>，可能之前脚本拉的时候没有成功，在每台机器上再拉一下。</p>
<p>下载应用的calico yaml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/rbac.yaml</span><br><span class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/calico.yaml</span><br></pre></td></tr></table></figure>
<p>Calico.yaml里的IP为: <code>etcd_endpoints: &quot;http://10.96.232.136:6666&quot;</code></p>
<p>修改里面的IP，重新应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f rbac.yaml</span><br><span class="line">kubectl delete -f calico.yaml</span><br><span class="line">kubectl apply -f rbac.yaml</span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>
<p>修改kube-apiserver.yaml文件，修改IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ls /etc/kubernetes/manifests/</span><br><span class="line">etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml</span><br><span class="line"></span><br><span class="line"># docker ps -a |grep kube-api</span><br><span class="line">567dfc84a46c        51a9c329b7c5           &quot;kube-apiserver --au…&quot;   19 hours ago        Up 19 hours                                       k8s_kube-apiserver_kube-apiserver-jqgpu34_kube-system_ce9a856edd3006dfeece62c00bf608a8_0</span><br><span class="line">b0110d62f45f        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 19 hours ago        Up 19 hours                                       k8s_POD_kube-apiserver-jqgpu34_kube-system_ce9a856edd3006dfeece62c00bf608a8_0</span><br></pre></td></tr></table></figure>
<p>看看etcd都监听了哪些端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># netstat -natlp | grep etcd</span><br><span class="line">tcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      1226075/etcd</span><br><span class="line">tcp        0      0 127.0.0.1:2380          0.0.0.0:*               LISTEN      1226075/etcd</span><br><span class="line">...</span><br><span class="line">tcp6       0      0 :::6666                 :::*                    LISTEN      1232066/etcd</span><br><span class="line">tcp6       0      0 :::6667                 :::*                    LISTEN      1232066/etcd</span><br></pre></td></tr></table></figure>
<p>上面整理的有一点乱，究其根源就是etcd占用了<code>127.0.0.1</code>的网段，而calico</p>
<p>解决以后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES    AGE   VERSION</span><br><span class="line">jqgpu34   Ready    master   20h   v1.12.2</span><br><span class="line">jqgpu35   Ready    &lt;none&gt;   19h   v1.12.2</span><br><span class="line">jqgpu36   Ready    &lt;none&gt;   19h   v1.12.2</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装nvidia显卡驱动]]></title>
      <url>http://xiaqunfeng.cc/2018/10/30/nvidia-driver-install/</url>
      <content type="html"><![CDATA[<p>记录在GPU机器上安装显卡驱动的过程。<br><a id="more"></a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1、系统版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 16.04.2 LTS</span><br><span class="line">Release:	16.04</span><br><span class="line">Codename:	xenial</span><br></pre></td></tr></table></figure>
<p>2、内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# uname -r</span><br><span class="line">4.4.0-62-generic</span><br></pre></td></tr></table></figure>
<p>3、显卡</p>
<p>显卡型号：Tesla P4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# lspci | grep -i nvidia</span><br><span class="line">04:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">05:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">08:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">09:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">85:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">86:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">89:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br><span class="line">8a:00.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1)</span><br></pre></td></tr></table></figure>
<p>显示有8张卡。</p>
<h2 id="卸载掉原有驱动"><a href="#卸载掉原有驱动" class="headerlink" title="卸载掉原有驱动"></a>卸载掉原有驱动</h2><p>如果没有安装驱动，忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove –purge nvidia*</span><br></pre></td></tr></table></figure>
<h2 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h2><p>安装NVIDIA需要把系统自带的驱动禁用</p>
<p>禁用前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# lsmod | grep nouveau</span><br><span class="line">nouveau              1495040  0</span><br><span class="line">video                  40960  1 nouveau</span><br><span class="line">ttm                    94208  2 ast,nouveau</span><br><span class="line">drm_kms_helper        155648  2 ast,nouveau</span><br><span class="line">mxm_wmi                16384  1 nouveau</span><br><span class="line">i2c_algo_bit           16384  3 ast,igb,nouveau</span><br><span class="line">drm                   364544  5 ast,ttm,drm_kms_helper,nouveau</span><br><span class="line">wmi                    20480  2 mxm_wmi,nouveau</span><br></pre></td></tr></table></figure>
<p>1、打开文件: <code>/etc/modprobe.d/blacklist.conf</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br></pre></td></tr></table></figure>
<p>2、执行生效命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# update-initramfs -u</span><br><span class="line">update-initramfs: Generating /boot/initrd.img-4.4.0-62-generic</span><br><span class="line">cryptsetup: WARNING: could not determine root device from /etc/fstab</span><br><span class="line">W: Possible missing firmware /lib/firmware/ast_dp501_fw.bin for module ast</span><br><span class="line">W: mdadm: /etc/mdadm/mdadm.conf defines no arrays.</span><br></pre></td></tr></table></figure>
<p>忽略warning。</p>
<p>3、重启并输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# lsmod | grep nouveau</span><br></pre></td></tr></table></figure>
<p>无任何输出，表示禁用成功。</p>
<h2 id="安装nvidia显卡驱动"><a href="#安装nvidia显卡驱动" class="headerlink" title="安装nvidia显卡驱动"></a>安装nvidia显卡驱动</h2><p>1、下载并安装</p>
<p>下载驱动：<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p>
<p>根据系统和显卡情况正确选择并下载驱动</p>
<p>将下载的驱动文件拷贝到GPU机器上</p>
<p>添加可执行权限并运行</p>
<p>注：Tesla P4 + Ubuntu1604 + 64-bit + CUDA Toolkit 10.0 + Chinese <a href="http://p926l57yp.bkt.clouddn.com/NVIDIA-Linux-x86_64-410.72.run" target="_blank" rel="noopener">下载链接</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# chmod a+x NVIDIA-Linux-x86_64-410.72.run</span><br><span class="line">root@jqgpu34:~# ./NVIDIA-Linux-x86_64-410.72.run</span><br><span class="line">Verifying archive integrity... OK</span><br><span class="line">Uncompressing NVIDIA Accelerated Graphics Driver for Linux-x86_64 410.72...................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br></pre></td></tr></table></figure>
<p>中间会出现 <code>WARNING</code>，一路回车忽略。</p>
<p>2、检查是否安装成功</p>
<p>显示如下表示安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@jqgpu34:~# nvidia-smi</span><br><span class="line">Tue Oct 30 16:37:24 2018</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 410.72       Driver Version: 410.72       CUDA Version: 10.0     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  Tesla P4            Off  | 00000000:04:00.0 Off |                  N/A |</span><br><span class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   1  Tesla P4            Off  | 00000000:05:00.0 Off |                  N/A |</span><br><span class="line">| N/A   39C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   2  Tesla P4            Off  | 00000000:08:00.0 Off |                  N/A |</span><br><span class="line">| N/A   39C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   3  Tesla P4            Off  | 00000000:09:00.0 Off |                  N/A |</span><br><span class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   4  Tesla P4            Off  | 00000000:85:00.0 Off |                  N/A |</span><br><span class="line">| N/A   35C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   5  Tesla P4            Off  | 00000000:86:00.0 Off |                  N/A |</span><br><span class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   6  Tesla P4            Off  | 00000000:89:00.0 Off |                  N/A |</span><br><span class="line">| N/A   37C    P0    23W /  75W |      0MiB /  7611MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   7  Tesla P4            Off  | 00000000:8A:00.0 Off |                  N/A |</span><br><span class="line">| N/A   38C    P0    23W /  75W |      0MiB /  7611MiB |      4%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="添加-NVIDIA-官方-PPA"><a href="#添加-NVIDIA-官方-PPA" class="headerlink" title="添加 NVIDIA 官方 PPA"></a>添加 NVIDIA 官方 PPA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure>
<p>果上面命令执行报<code>sudo: add-apt-repository: command not found</code>，试试下面这个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>
<p>如果上面命令运行后报<code>E: dpkg was interrupted, you must manually run &#39;sudo dpkg --configure -a&#39; to correct the problem.</code>，运行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --configure -a</span><br></pre></td></tr></table></figure>
<h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install nvidia-396</span><br></pre></td></tr></table></figure>
<p>安装完<code>nvidia-396</code>再执行<code>nvidia-smi</code>，显示如下表示显卡驱动已经装好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line"></span><br><span class="line">Thu Dec 20 20:23:36 2018</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 390.46                 Driver Version: 390.46                   |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU Name       Persistence-M| Bus-Id       Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan Temp Perf Pwr:Usage/Cap|         Memory-Usage | GPU-Util Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0 Tesla V100-SXM2... Off | 00000000:00:07.0 Off |                    0 |</span><br><span class="line">| N/A   30C   P0   32W / 300W |     0MiB / 16160MiB |      0%     Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">| GPU       PID   Type   Process name                             Usage     |</span><br><span class="line">|=============================================================================|</span><br><span class="line">| No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>如果驱动安装后，运行<code>nvidia-smi</code>遇到<code>Failed to initialize NVML: Driver/library version mismatch</code>，重启即可。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive架构及应用介绍]]></title>
      <url>http://xiaqunfeng.cc/2018/10/18/Hive/</url>
      <content type="html"><![CDATA[<p>介绍Hive的架构及应用，在工作中的一个产品中用到了，所以系统地了解一下。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hive这个框架在Hadoop的生态体系结构中占有及其重要的地位，在实际的业务当中用的也非常多，可以说Hadoop之所以这么流行在很大程度上是因为Hive的存在。那么Hive究竟是什么，为什么在Hadoop家族中占有这么重要的地位，本篇文章将围绕Hive的体系结构(架构)、Hive的操作、Hive与Hbase的区别等对Hive进行全方面的阐述。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在此之前，先给大家介绍一个业务场景，让大家感受一下为什么Hive如此的受欢迎： </p>
<p>业务描述：统计业务表consumer.txt中北京的客户有多少位？下面是相应的业务数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id      city    name    sex           </span><br><span class="line">0001    beijing zhangli man </span><br><span class="line">0002    guizhou lifang  woman </span><br><span class="line">0003    tianjin wangwei man </span><br><span class="line">0004    chengde wanghe  woman </span><br><span class="line">0005    beijing lidong  man </span><br><span class="line">0006    lanzhou wuting  woman </span><br><span class="line">0007    beijing guona   woman </span><br><span class="line">0008    chengde houkuo  man</span><br></pre></td></tr></table></figure>
<p>首先我先用大家所熟悉的MapReduce程序来实现这个业务分析，完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package IT;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URI;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IOUtils;</span><br><span class="line">import org.apache.hadoop.io.LongWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.partition.HashPartitioner;</span><br><span class="line"></span><br><span class="line">public class Consumer</span><br><span class="line">&#123;</span><br><span class="line">    public static String path1 = &quot;hdfs://192.168.80.80:9000/consumer.txt&quot;;</span><br><span class="line">    public static String path2 = &quot;hdfs://192.168.80.80:9000/dir&quot;;</span><br><span class="line">    public static void main(String[] args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">          FileSystem fileSystem = FileSystem.get(new URI(path1) , new Configuration());</span><br><span class="line">          if(fileSystem.exists(new Path(path2)))</span><br><span class="line">          &#123;</span><br><span class="line">              fileSystem.delete(new Path(path2), true);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Job job = new Job(new Configuration(),&quot;Consumer&quot;);</span><br><span class="line">          FileInputFormat.setInputPaths(job, new Path(path1));</span><br><span class="line">          job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">          job.setMapperClass(MyMapper.class);</span><br><span class="line">          job.setMapOutputKeyClass(Text.class);</span><br><span class="line">          job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line"></span><br><span class="line">          job.setNumReduceTasks(1);</span><br><span class="line">          job.setPartitionerClass(HashPartitioner.class);</span><br><span class="line"></span><br><span class="line">          job.setReducerClass(MyReducer.class);</span><br><span class="line">          job.setOutputKeyClass(Text.class);</span><br><span class="line">          job.setOutputValueClass(LongWritable.class);</span><br><span class="line">          job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">          FileOutputFormat.setOutputPath(job, new Path(path2));</span><br><span class="line">          job.waitForCompletion(true);</span><br><span class="line">          //查看执行结果</span><br><span class="line">          FSDataInputStream fr = fileSystem.open(new Path(&quot;hdfs://hadoop80:9000/dir/part-r-00000&quot;));</span><br><span class="line">          IOUtils.copyBytes(fr, System.out, 1024, true);</span><br><span class="line">     &#125;</span><br><span class="line">    public static class MyMapper extends Mapper&lt;LongWritable, Text, Text, LongWritable&gt;</span><br><span class="line">    &#123;      </span><br><span class="line">            public static long sum = 0L;</span><br><span class="line">            protected void map(LongWritable k1, Text v1,Context context) throws IOException, InterruptedException</span><br><span class="line">            &#123;</span><br><span class="line">                  String[] splited = v1.toString().split(&quot;\t&quot;);</span><br><span class="line">                  if(splited[1].equals(&quot;beijing&quot;))</span><br><span class="line">                  &#123;</span><br><span class="line">                      sum++;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            protected void cleanup(Context context)throws IOException, InterruptedException</span><br><span class="line">            &#123;</span><br><span class="line">                  String str = &quot;beijing&quot;;</span><br><span class="line">                  context.write(new Text(str),new LongWritable(sum));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class MyReducer extends Reducer&lt;Text, LongWritable, Text, LongWritable&gt;</span><br><span class="line">    &#123;</span><br><span class="line">            protected void reduce(Text k2, Iterable&lt;LongWritable&gt; v2s,Context context)throws IOException, InterruptedException</span><br><span class="line">            &#123;</span><br><span class="line">                  for (LongWritable v2 : v2s)</span><br><span class="line">                 &#123;</span><br><span class="line">                     context.write(k2, v2);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MapReduce程序代码运行结果如下： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive1.jpg" alt="PIC1"></p>
<p>从运行结果可以看出：在consumer.txt业务表中，北京的客户共有三位。下面我们将用Hive来实现相同的功能，即统计业务表consumer.txt中北京的客户有多少位？<br>Hive操作如下： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive2.jpg" alt="PIC2"></p>
<p>Hive运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK</span><br><span class="line">beijing 3</span><br><span class="line">Time taken: 19.768 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<p>到这里，是不是感觉Hive这个运行框架很神奇—–对于相同的业务逻辑只需要写几行Sql命令就可以获取我们所需要的结果，这也恰恰是Hive为什么这么流行的原因。</p>
<p>Hive的优势主要体现在：<br>①Hive支持标准的SQL语法，免去了用户编写MapReduce程序的过程，大大减少了公司的开发成本<br>②Hive的出现可以让那些精通SQL技能、但是不熟悉MapReduce 、编程能力较弱与不擅长Java语言的用户能够在HDFS大规模数据集上很方便地利用SQL 语言查询、汇总、分析数据，毕竟精通SQL语言的人要比精通Java语言的多得多<br>③Hive是为大数据批量处理而生的，Hive的出现解决了传统的关系型数据库(MySql、Oracle)在大数据处理上的瓶颈<br>好了，上面通过一个简单的小业务场景说明了Hive的巨大优势，接下来将进入本篇文章的正题。 </p>
<h2 id="（一）Hive体系结构-架构-的介绍"><a href="#（一）Hive体系结构-架构-的介绍" class="headerlink" title="（一）Hive体系结构(架构)的介绍"></a>（一）Hive体系结构(架构)的介绍</h2><h3 id="1、Hive的概念："><a href="#1、Hive的概念：" class="headerlink" title="1、Hive的概念："></a>1、Hive的概念：</h3><p>①Hive是为了简化用户编写MapReduce程序而生成的一种框架，使用MapReduce做过数据分析的人都知道，很多分析程序除业务逻辑不同外，程序流程基本一样。在这种情况下，就需要Hive这样的用户编程接口。Hive提供了一套类SQL的查询语言，称为QL，而在创造Hive框架的过程中之所以使用SQL实现Hive是因为大家对SQL语言非常的熟悉，转换成本低，可以大大普及我们Hadoop用户使用的范围，类似作用的Pig就不是通过SQL实现的。<br>Hive是基于Hadoop的一个开源数据仓库系统，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，Hive可以把SQL中的表、字段转换为HDFS中的目录、文件。 </p>
<p>②Hive是建立在Hadoop之上的数据仓库基础构架、是为了减少MapReduce编写工作的批处理系统，Hive本身不存储和计算数据，它完全依赖于HDFS和MapReduce。Hive可以理解为一个客户端工具，将我们的sql操作转换为相应的MapReduce jobs，然后在Hadoop上面运行。 </p>
<p>在开始为大家列举的consumer.txt小业务当中，从编写Sql到最后得出Beijing 3的分析结果实际上中间走的是MapReduce程序， 只不过这个MapReduce程序不用用户自己编写，而是由Hive这个客户端工具将我们的sql操作转化为了相应的MapReduce程序，下面是我们运行sql命令时显示的相关日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select city,count(*)</span><br><span class="line">    &gt; from t4    </span><br><span class="line">    &gt; where city=&apos;beijing&apos;</span><br><span class="line">    &gt; group by city;</span><br><span class="line">Total MapReduce jobs = 1</span><br><span class="line">Launching Job 1 out of 1</span><br><span class="line">Number of reduce tasks not specified. Estimated from input data size: 1</span><br><span class="line">In order to change the average load for a reducer (in bytes):</span><br><span class="line">  set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</span><br><span class="line">In order to limit the maximum number of reducers:</span><br><span class="line">  set hive.exec.reducers.max=&lt;number&gt;</span><br><span class="line">In order to set a constant number of reducers:</span><br><span class="line">  set mapred.reduce.tasks=&lt;number&gt;</span><br><span class="line">Starting Job = job_1478233923484_0902, Tracking URL = http://hadoop22:8088/proxy/application_1478233923484_0902/</span><br><span class="line">Kill Command = /usr/local/hadoop/bin/hadoop job  -kill job_1478233923484_0902</span><br><span class="line">Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1</span><br><span class="line">2016-11-09 11:36:36,688 Stage-1 map = 0%,  reduce = 0%</span><br><span class="line">2016-11-09 11:36:42,018 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:43,062 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:44,105 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:45,149 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:46,193 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:47,237 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:48,283 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.21 sec</span><br><span class="line">2016-11-09 11:36:49,329 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 3.7 sec</span><br><span class="line">2016-11-09 11:36:50,384 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 3.7 sec</span><br><span class="line">MapReduce Total cumulative CPU time: 3 seconds 700 msec</span><br><span class="line">Ended Job = job_1478233923484_0902</span><br><span class="line">MapReduce Jobs Launched: </span><br><span class="line">Job 0: Map: 1  Reduce: 1   Cumulative CPU: 3.7 sec   HDFS Read: 419 HDFS Write: 10 SUCCESS</span><br><span class="line">Total MapReduce CPU Time Spent: 3 seconds 700 msec</span><br><span class="line">OK</span><br><span class="line">beijing 3</span><br><span class="line">Time taken: 19.768 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<p>从日志可以看出，Hive将我们的sql命令解析成了相应的MapReduce任务，最后得到了我们的分析结果。 </p>
<p>③Hive可以认为是MapReduce的一个封装、包装。Hive的意义就是在业务分析中将用户容易编写、会写的Sql语言转换为复杂难写的MapReduce程序，从而大大降低了Hadoop学习的门槛，让更多的用户可以利用Hadoop进行数据挖掘分析。 </p>
<p>为了让大家容易理解Hive的实质——-“Hive就是一个SQL解析引擎，将SQL语句转化为相应的MapReduce程序”这句话，博主用一个图示进行示例：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive3.jpg" alt="PIC3"></p>
<p>从图示可以看出，Hive从某种程度上讲就是很多“SQL—MapReduce”框架的一个封装，可以将用户编写的Sql语言解析成对应的MapReduce程序，最终通过MapReduce运算框架形成运算结果提交给Client。 </p>
<h3 id="2、Hive体系结构的介绍"><a href="#2、Hive体系结构的介绍" class="headerlink" title="2、Hive体系结构的介绍"></a>2、Hive体系结构的介绍</h3><p>下面是Hive的体系结构图： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive4.jpg" alt="PIC4"></p>
<p>Hive的体系结构可以分为以下几个部分： </p>
<p>①用户接口：包括shell命令、Jdbc/Odbc和WebUi，其中最常用的是shell这个客户端方式对Hive进行相应操作 </p>
<p>②Hive解析器(驱动Driver)：Hive解析器的核心功能就是根据用户编写的Sql语法匹配出相应的MapReduce模板，形成对应的MapReduce job进行执行。 </p>
<p>③Hive元数据库(MetaStore)：Hive将表中的元数据信息存储在数据库中，如derby(自带的)、Mysql(实际工作中配置的)，Hive中的元数据信息包括表的名字、表的列和分区、表的属性(是否为外部表等)、表的数据所在的目录等。Hive中的解析器在运行的时候会读取元数据库MetaStore中的相关信息。<br>在这里和大家说一下为什么我们在实际业务当中不用Hive自带的数据库derby，而要重新为其配置一个新的数据库Mysql，是因为derby这个数据库具有很大的局限性：derby这个数据库不允许用户打开多个客户端对其进行共享操作，只能有一个客户端打开对其进行操作，即同一时刻只能有一个用户使用它，自然这在工作当中是很不方便的，所以我们要重新为其配置一个数据库。 </p>
<p>④Hadoop：Hive用HDFS进行存储，用MapReduce进行计算——-Hive这个数据仓库的数据存储在HDFS中，业务实际分析计算是利用MapReduce执行的。 </p>
<p>从上面的体系结构中可以看出，在Hadoop的HDFS与MapReduce以及MySql的辅助下，Hive其实就是利用Hive解析器将用户的SQl语句解析成对应的MapReduce程序而已，即Hive仅仅是一个客户端工具，这也是为什么我们在Hive的搭建过程中没有分布与伪分布搭建的原因。</p>
<h3 id="3、Hive的运行机制"><a href="#3、Hive的运行机制" class="headerlink" title="3、Hive的运行机制"></a>3、Hive的运行机制</h3><p>Hive的运行机制如下图所示： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive5.jpg" alt="PIC5"></p>
<p>Hive的运行机制正如图所示：创建完表之后，用户只需要根据业务需求编写Sql语句，而后将由Hive框架将Sql语句解析成对应的MapReduce程序，通过MapReduce计算框架运行job，便得到了我们最终的分析结果。 </p>
<p>在Hive的运行过程中，用户只需要创建表、导入数据、编写Sql分析语句即可，剩下的过程将由Hive框架自动完成，而创建表、导入数据、编写Sql分析语句其实就是数据库的知识了，Hive的运行过程也说明了为什么Hive的存在大大降低了Hadoop的学习门槛以及为什么Hive在Hadoop家族中占有着那么重要的地位。 </p>
<h2 id="（二）Hive的操作"><a href="#（二）Hive的操作" class="headerlink" title="（二）Hive的操作"></a>（二）Hive的操作</h2><p>Hive的操作对于用户来说实际上就是表的操作、数据库的操作。下面我们将围绕两个方面进行介绍： </p>
<h3 id="1、Hive表——内部表、外部表、分区表的创建"><a href="#1、Hive表——内部表、外部表、分区表的创建" class="headerlink" title="1、Hive表——内部表、外部表、分区表的创建"></a>1、Hive表——内部表、外部表、分区表的创建</h3><p>所谓内部表就是普通表，创建语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive6.jpg" alt="PIC6"></p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive7.jpg" alt="PIC7"></p>
<p>外部表(external table)的创建语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive8.jpg" alt="PIC8"></p>
<p>注意：最后一行写到的是目录dir，文件就不用写了，Hive表会自动到dir目录下读取所有的文件file<br><strong>我在实际的操作过程当中发现，location关联到的目录下面必须都是文件，不能含有其余的文件夹，不然读取数据的时候会报错。</strong> </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive9.jpg" alt="PIC9"></p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive10.jpg" alt="PIC10"></p>
<p><strong>内部表与外部表的区别：</strong> </p>
<ul>
<li>内部表在加载数据的过程中，实际数据会被移动到数据仓库目录中(hive.metastore.warehouse.dir),之后用户对数据的访问将会直接在数据仓库目录中完成；删除内部表时，内部表中的数据和元数据信息会被同时删除。 </li>
<li>外部表在加载数据的过程中，实际数据并不会被移动到数据仓库目录中，只是与外部表建立一个链接(相当于文件的快捷方式一样)；删除外部表时，仅删除该链接。 </li>
<li>补充：在工作中发现，对于外部表，即使hive中的表删除了，但是在HDFS中表的location仍然存在。 </li>
</ul>
<p>分区表的概念：指的是我们的数据可以分区，即按照某个字段将文件划分为不同的标准，分区表的创建是通过在创建表时启用partitioned by来实现的。</p>
<p>分区表的创建语法格式为：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive11.jpg" alt="PIC11"></p>
<p>注意：分区表在加载数据的过程中要指定分区字段，否则会报错，正确的加载方式如下： </p>
<p><code>load data local inpath ‘/usr/local/consumer.txt’ into table t1 partition (day=2) ;</code></p>
<p>其余的操作和内部表、外部表是一样的。 </p>
<p>实际操作: </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive12.jpg" alt="PIC12"></p>
<h3 id="2、将数据文件加载-导入-到Hive表中"><a href="#2、将数据文件加载-导入-到Hive表中" class="headerlink" title="2、将数据文件加载(导入)到Hive表中"></a>2、将数据文件加载(导入)到Hive表中</h3><p>在Hive中创建完表之后，我们随后自然要向表中导入数据，但是在导入数据的时候和我们的传统数据库(MySql、Oracle)是不同的：Hive不支持一条一条的用insert语句进行插入操作，也不支持update的操作。Hive表中的数据是以load的方式，加载到建立好的表中。数据一旦导入，则不可修改。要么drop掉整个表，要么建立新的表，导入新的数据。 </p>
<p>导入数据的语法格式为： </p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hive13.jpg" alt="PIC13"></p>
<p>导入数据时要注意一下几点： </p>
<p>①local inpath表示从本地linux中向Hive表中导入数据，inpath表示从HDFS中向Hive表中导入数据 </p>
<p>②默认是向原Hive表中追加数据，overwrite表示覆盖表中的原数据进行导入 </p>
<p>③partition是分区表特有的，而且在导入数据数据时是必须添加的，否则会报错 </p>
<p>④load 操作只是单纯的复制/移动操作，将数据文件复制/移动到 Hive 表对应的位置,即Hive 在加载数据的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的表中</p>
<h2 id="（三）Hive与Hbase的区别"><a href="#（三）Hive与Hbase的区别" class="headerlink" title="（三）Hive与Hbase的区别"></a>（三）Hive与Hbase的区别</h2><p>其实从严格意义上讲，Hive与Hbase就不应该谈区别，谈区别的原因无非就是Hive与Hbase本身都涉及到了表的创建、向表中插入数据等等。所以我们希望找到Hive与Hbase的区别，但是为什么两者谈不上区别呢，原因如下： </p>
<ul>
<li>1、根据上文分析，Hive从某种程度上讲就是很多“SQL—MapReduce”框架的一个封装，即Hive就是MapReduce的一个封装，Hive的意义就是在业务分析中将用户容易编写、会写的Sql语言转换为复杂难写的MapReduce程序。 </li>
<li>2、Hbase可以认为是hdfs的一个包装。他的本质是数据存储，是个NoSql数据库；hbase部署于hdfs之上，并且克服了hdfs在随机读写方面的缺点。 </li>
</ul>
<p>因此若要问Hive与Hbase之前的区别，就相当于问HDFS与MapReduce之间的区别，而HDFS与MapReduce两者之间谈区别意义并不大。 </p>
<p>但是当我们非要谈Hbase与Hive的区别时，可以从以下几个方面进行讨论： </p>
<ul>
<li>Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。 </li>
<li>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。 </li>
<li>Hbase非常适合用来进行大数据的实时查询。Facebook用Hive进行消息和实时的分析。它也可以用来统计Facebook的连接数。 </li>
</ul>
<p>Hbase与Hive的区别就谈到此，同时Hive入门笔记也写到此处，如有问题欢迎留言。</p>
<blockquote>
<p>本文内容为转载，原文链接：<a href="https://blog.csdn.net/a2011480169/article/details/51482799" target="_blank" rel="noopener">Hive架构以及应用介绍</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> BigData </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Deep Learning Flow for Video Recognition]]></title>
      <url>http://xiaqunfeng.cc/2018/09/17/dff/</url>
      <content type="html"><![CDATA[<p>目前唯一一个End to End的Video Detection方法。<br><a id="more"></a></p>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>深度卷积神经网络在图像识别任务上取得巨大成功。然而在视频任务上对单帧进行检测太慢。</p>
<p>因此，论文中提出深度特征流（Deep Feature Flow）框架用于快速精确的视频识别。该框架仅在稀疏关键帧上运行卷积网络的子网络，并通过流场（flow field）将关键帧的特征传递到其他帧。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-1.jpg" alt="1"></p>
<p>因为流场计算和特征传播比计算卷积特征快很多，所以可以显著提升速度。整个架构采用端到端的训练，识别精度显著提升。</p>
<p>论文声称是第一次在深度学习框架中联合训练流和视频识别任务。与单帧方法比，实现了巨大的提升（10X），精度稍有损失。</p>
<h2 id="二、相关工作"><a href="#二、相关工作" class="headerlink" title="二、相关工作"></a>二、相关工作</h2><p>1、图像识别</p>
<ul>
<li>目标检测：基于区域方法（R-CNN, Fast R-CNN, SPP-Net, Faster R-CNN, R-FCN）</li>
<li><p>语义分割：全卷积神经网络（FCN）</p>
</li>
<li><p>对每一帧都运用这些网络，计算开销太大。</p>
</li>
</ul>
<p>2、网络加速</p>
<ul>
<li>矩阵分解：将大的网络layers分解层多个小layers</li>
<li>量化网络权重</li>
</ul>
<p>3、光流</p>
<ul>
<li>光流主要针对小偏移量，目前一些针对大偏移和组合匹配的方法（DeepFlow和EpicFlow），但是都是手工设计。</li>
<li>FlowNet第一次应用CNN直接估计运动，取得了不错的结果。最近的金字塔网络简化了架构。</li>
<li>论文中开发光流用于加速一般的视频识别任务。</li>
</ul>
<p>4、视频识别中的开发时序信息</p>
<ul>
<li>T-CNN在视频的tubelets中融合时序和上下文信息。</li>
<li>密集3D CRF提出大范围的时空归一化进行语义视频分割。</li>
<li>STFCN考虑用于视频语义分割的空间-时间FCN。</li>
<li>上诉工作能够提升精度但同时极大的增加计算开销。</li>
<li>本论文方法旨在通过利用视频上的时间连贯性来减少计算量。</li>
</ul>
<p>5、缓慢特征分析</p>
<ul>
<li>在视频中，图像的高级语义特征一般比低级语义特征变化更慢，因此在连续视频帧上，深度特征变化的缓慢且连续。</li>
<li>该特点已经被用于视频特征学习的调整中。本文也可因此受益。</li>
</ul>
<p>6、Clockwork卷积网络</p>
<ul>
<li>该工作与本论文最接近，在某些视频帧上禁用网络中的某些层，并重复使用之前的特征。该方法减少了一些帧中一些层的计算（如1/3或2/3）。</li>
<li>本文的工作减少大部分帧的大部分层的计算（如9/10）。</li>
<li>Clockwork并没有考利用帧之间的关系，并简单地复制特征。它只重新编排现成网络中的推理计算，并未执行微调或重新训练。较小的速度提升却带来了较大的精度损失。</li>
<li>本文重新训练了一个两帧网络，其运动被认为是端到端的。在速度提升3倍的情况下仅带来很小的精度下降。</li>
</ul>
<h2 id="三、DFF（Deep-Feature-Flow）"><a href="#三、DFF（Deep-Feature-Flow）" class="headerlink" title="三、DFF（Deep Feature Flow）"></a>三、DFF（Deep Feature Flow）</h2><h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p>对于给定的前馈神经网络N ，I为图像输入，输出结果为y=N(I)</p>
<p>这里将N分解为两个连续的子网络:</p>
<ul>
<li>第一个子网络：$N_{feat}$，被称为特征网络，该网络是全卷积且输出一些中间特征图，$f=N_{feat}(I)$。</li>
<li>第二个子网络：$N_{task}$，被称为任务网络，具有特定的任务结构，并在特征图上执行识别任务，$y=N_{task}(f)$。</li>
</ul>
<p>连续的视频帧具有高度的相似性，且越深的特征层相似性越高，我们通过该相似性减少计算开销。具体的，$N_{feat}$ 仅运行在特定稀疏关键帧上，非关键帧 $I_{i}$ 的特征通过其之前的关键帧 $I_{k}$ 传播得到。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-2.jpg" alt="2"></p>
<p>$M_{i \rightarrow k}$ 是一个二维的流场，其通过一个流估计算法 F 得到。然后通过双线性缩放到与用于传播的特征图相同的大小。当前帧 i 的位置 p 通过流场得到其与关键帧 k 的位置偏差得到，偏差 $\delta p=M_{i \rightarrow k}(p)$。</p>
<p>因此特征扭曲可以通过双线性差值得到：</p>
<p>$f^c_i(p)=∑_qG(q,p+δp)f^c_k(q)$            (1)</p>
<p>c表示特征通道，q是特征图的所有空间位置，G(·,·)为双线性差值核，是二维的，因此将其分解为两个一维核：</p>
<p>$G(q,p+δp)=g(q_x,p_x+δp_x)⋅g(q_y,p_y+δp_y)$        (2)</p>
<p>$g(a,b)=max(0,1−|a−b|)$</p>
<p>空间扭曲可能由于流估计错误导致不准确。为了更好估计特征，其强度通过尺度场（scale field）进行调节。尺度场通过尺度函数 S 得到 $Si→k=S(I_k,I_i)$。最后，特征传播方程定义为：</p>
<p>$f_i=W(f_k,M_{i\rightarrow k},S_{i \rightarrow k})$        (3)</p>
<p>该函数对所有位置、所有通道的特征进行处理，并对特征乘以尺度因子。</p>
<p>该视频识别算法被称为深度特征流。F 流场函数是手工设计的低级别流，如SIFT-Flow，不需要训练，马上可用。尺度函数 S 的每个位置为1。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-3.jpg" alt="3"></p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>流函数最初用于获得低级图像像素的相关性，推理很快，但是对于识别任务不够准确，并且高级特征图的改变通常比像素慢。</p>
<p>为了对这些变量建模，这里提出使用一个CNN来估计流场和尺度场，这样所有的组件都能够端到端训练。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dff-4.jpg" alt="4"></p>
<p>使用SGD训练，在每个mini-batch，随机选择一对邻近帧，${I <em>k,I</em> i}, 0\le i-k \le 9$。</p>
<ul>
<li>前向传播时，特征网络 $N_{feat}$ 对关键帧图像 $I_k$ 计算得到特征图 $f_k$。</li>
<li>然后在帧  $I_k, I_i$ 上运行流网络 F，来计算流场和尺度场。当 i &gt; k时，根据公式（3）特征 $f_k$ 传播至 $f_i$，否则不传播。最后，任务网络，否则不传播。</li>
<li>最后，在特征图 $f_i$ 上应用任务网络 $N_ {task}$ 生成结果，并产生损失值。反向传播损失到所以组件。可以发现，当 $i=k$ 时退化为每帧训练。</li>
</ul>
<p>流网络比特征网络快得多。</p>
<p>公式（3）中特征传播函数是无参且完全可微的，我们计算特征 $f_i$ 中关于特征 $f_k$ 的导数，尺度场 $S_{i\rightarrow j}$，流场 $M_{i\rightarrow j}$。前两个使用链式法则容易计算。对于后一个，导数为：</p>
<p>$\frac{\partial f_i^c(p)}{\partial M_{i\rightarrow j}}=S^c_{i\rightarrow j}(p)\sum_q \frac{\partial G(q,p+\delta p)}{\partial \delta p}f _ k^c(q)$        （4） </p>
<p>Pre-frame训练方法只能使用已标注的帧，而DFF可以使用所有帧，只要帧 $I_i$是已标注的。 </p>
<h3 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h3><p>非关键帧计算开销与每帧计算开销的比例：</p>
<p>$r=\frac{O(F)+O(S)+O(W)+O(N_{task})}{O(N_{feat})+O(N _ {task})}$        （5）</p>
<p>$N_{task}$ 的复杂度通常很小，$N_{feat}$和 F 的复杂度较高：</p>
<p>$O(N_{task})  &lt;&lt; O(N_{teat})$</p>
<p>$O(N_{task})  &lt;&lt; O(F)$</p>
<p>因为W和S非常简单</p>
<p>$O(W) &lt;&lt; O(F)$</p>
<p>$O(S) &lt;&lt; O(F)$</p>
<p>所以公式（5）中的比率：</p>
<p>$r ≈ \frac{O(F)}{O(N_feat)}$         (6)</p>
<p>因此复杂度比例由流网络和特征网络决定。</p>
<p>另外，速度还跟关键帧的稀疏程度相关，如果定义每 $l$ 连续帧选一个关键帧，则加速因子为：</p>
<p>$s = \frac{l}{1+(l−1)∗r}$        （7）</p>
<h3 id="关键帧安排"><a href="#关键帧安排" class="headerlink" title="关键帧安排"></a>关键帧安排</h3><p>在本文中，采用的是简单的固定关键帧的安排，关键帧的应用区间 $l$ 固定，比较容易实施和调整。</p>
<p>然而根据图像内容的变化可能变化的 $l$ 能够实现更好的精度和速度的权衡。理想情况下，关键帧应该是图像内容具有显著变化时。</p>
<p>如何设计高效和调整关键帧的安排是后续需要改进的工作。不同的视频任务可能有不同的行为和需求。从数据中学习自适应关键帧的是一个更有吸引力的选择。</p>
<h2 id="四、网络架构"><a href="#四、网络架构" class="headerlink" title="四、网络架构"></a>四、网络架构</h2><p>1、流网络</p>
<p>我们采用基于CNN的 FlowNet 作为默认方法，并设计了两个低复杂度变体 </p>
<ul>
<li>FlowNet Half，每层减少一半的卷积核，复杂度为1/4</li>
<li>Inception 结构的FlowNet Inception，复杂度减少为1/8</li>
</ul>
<p>三个网络都在相同的数据集上预训练，输出的stride为4。输入图像缩小一半，因此流网络的输出是原图的1/8。</p>
<p>特征图的stride是16，使用双线性差值将流场降采样，双线性差值为网络的中的非参数层，且可微。</p>
<p>2、特征网络</p>
<ul>
<li>使用ResNet作为特征网络，ResNet-50和ResNet-101默认为ImageNet分类预训练模型，丢弃最后一层1000路分类层，特征stride从32减少为16得到分辨率更高的特征图。</li>
<li>后面接DeepLab用于语义分割和R-FCN用于物体检测。</li>
<li>conv5层的第一个block，其stride从2变为1。holing算法应用于 conv5 中所有 3*3 卷积核，以保持视野（dilation=2）。随机初始化的3×3卷积被附加到 conv5 以将特征通道维度减小到1024，holing算法也被应用（dilation=6）。该1024维的特征图作为后续任务的中间特征图。</li>
</ul>
<p>3、语义分割</p>
<ul>
<li>在中间特征图上应用随机初始化的1×1卷积层以产生（C + 1）得分图，其中C是类别的数量，1是用于背景类别。</li>
<li>之后跟一个softmax层输出每个像素的概率。因此任务网络仅有一个可学习的权重层，整体的网络类似于具有大视野的DeepLab。</li>
</ul>
<p>4、物体检测</p>
<p>采用R-FCN。对于中间特征图，两个全卷积网络分别应用于前512维特征和后512维特征，分别用于区域推荐（region proposal）任务和检测任务。</p>
<p>区域推荐分支，使用RPN。使用 n=9 个anchors，两个并排的1x1的卷积层得到2n维的物体得分和4n的回归值。对每个图像应用NMS（0.7）后得到300个ROI。</p>
<p>检测分支，两个并排的1x1卷积层输出位置敏感的得分图和bbox回归图。他们的维度是 $(C+1)k^2$ 和 $4k^2$，k是检测器/回归器数量。最后使用NMS（0.3）得到结果。</p>
<h2 id="五、实验"><a href="#五、实验" class="headerlink" title="五、实验"></a>五、实验</h2><p>在两个数据集上进行评测</p>
<ul>
<li>Cityscapes：用于语义分割</li>
<li>ImageNet VID：用于物体检测</li>
</ul>
<p>方法和结果详见原论文。</p>
<p>效果：<a href="https://www.youtube.com/watch?v=J0rMHE6ehGw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=J0rMHE6ehGw</a></p>
<h2 id="六、未来工作"><a href="#六、未来工作" class="headerlink" title="六、未来工作"></a>六、未来工作</h2><ul>
<li>联合学习对于流场质量的影响，当前由于缺少gt数据无法评估。</li>
<li>目前的光流工作受限于合成数据或小的真实数据，对深度学习来说还不够。</li>
<li>流场估计和关键帧安排的改进可以使本文工作受益。</li>
<li>本文采用FlowNet主要原因是可选择的方法很少。设计更快更精确的流场网络在未来值得研究。</li>
<li>对于关键帧的安排，好的方法能够同时显著提升精度和速度。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chinese Whispers人脸聚类算法]]></title>
      <url>http://xiaqunfeng.cc/2018/08/14/Chinese-Whispers/</url>
      <content type="html"><![CDATA[<p>学习一下适用于大规模人脸的无监督聚类方法。不需要指定聚类个数。<br><a id="more"></a></p>
<h3 id="论文中CW描述"><a href="#论文中CW描述" class="headerlink" title="论文中CW描述"></a>论文中CW描述</h3><p>CW是一种非常基础的，但有效的算法，用来分割加权的无向图节点。它来源于同名的儿童游戏，孩子们在哪里低声互相耳语？游戏的目标是通过几个带干扰的通道传递后，将原来的信息衍生成一些更有趣的信息。CW算法的目标就是查找传播相同信息到相邻节点的节点组。它可以被看做一个基于代理的社交网络的模拟。</p>
<p>该算法的原理如下：</p>
<ul>
<li>首先，所有的节点都分成不同的类。</li>
<li>然后对节点进行少量的迭代处理，并继承它邻近节点中最大的类别，即对当前节点的边权重值最大的节点所在的类。如果有多个最大的类别，则随机选择一个。</li>
<li>同一类的区域在迭代过程中趋于稳定，直到到达另一个类的稳定区域边界为止。</li>
</ul>
<h3 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h3><p>构建无向图：</p>
<ul>
<li>将每个人脸做为无向图中的一个节点，人脸之间的相似度，作为节点之间的边</li>
<li>设定阈值threshold，当相似度超过threshold，将两个节点相连形成关联边，权重为相似度</li>
<li>如果人脸之间的相似度小于设定的阈值，那么这两个人脸对应的节点之间就没有边</li>
</ul>
<p>初始化：</p>
<p>将每个人脸都赋予一个id，该id作为该人脸的类别。初始化时,每个人脸都是一个类别。</p>
<p>迭代：</p>
<ul>
<li><p>随机选取某个节点，对该节点的所有邻居依次进行如下处理:</p>
</li>
<li><p>就将所有邻居中权重最大的节点对应的类做为该节点的类别，完成对该节点的类别更新。</p>
</li>
<li><p>如果有两个邻居属于同一个类，那么就将同一个类下的邻居权重累加。最后，比较该节点下的所有邻居节点所属的类别的累加权重，取权重最大的类别作为当前节点的类别。</p>
</li>
<li><p>当所有的节点都完成后，一次迭代完成。</p>
</li>
<li><p>重复迭代步骤，直到达到迭代次数</p>
</li>
</ul>
<blockquote>
<p>该算法的结果主要依赖于模型的效果和阈值的选择,在迭代时,将相似度作为权重.</p>
</blockquote>
<p>python代码实现参考: <a href="https://blog.csdn.net/shubao0071/article/details/79086096" target="_blank" rel="noopener">Chinese-whisper:一种简洁的分类方法</a></p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git rebase]]></title>
      <url>http://xiaqunfeng.cc/2018/07/11/git-rebase/</url>
      <content type="html"><![CDATA[<p>三种使用场景：一是合并多个commit；二是基于不同branch在执行merge时的rebase；三是拆分commit。</p>
<a id="more"></a>
<h2 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h2><p>使用场景：</p>
<p>在开发一个功能时，由于种种原因提交了多个临时和失误的 commit，而这些 commit 拼接起来才是一个完整的任务。为了避免过多 commit 造成的版本控制混乱，通常需要将这些 commit 合并成一个。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>选择了一个项目，查看log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">▶ git log</span><br><span class="line">commit 532c6e1481e78ba0e27c56f4492a7e8d3cc36597</span><br><span class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line">Date:   Tue Oct 10 13:35:28 2017 -0700</span><br><span class="line"></span><br><span class="line">    hm......</span><br><span class="line"></span><br><span class="line">commit fbd48ab606dd91f076eaa68588f285c1d5f436fb</span><br><span class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line">Date:   Wed Oct 4 16:51:41 2017 -0700</span><br><span class="line"></span><br><span class="line">    grouped convolutions :snake: :snake: :snake:</span><br><span class="line"></span><br><span class="line">commit 62b781af4d01fc5f074407590cf556b36c70e837</span><br><span class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line">Date:   Mon Oct 2 15:17:48 2017 -0700</span><br><span class="line"></span><br><span class="line">    resnet that works</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>需要将 <code>532c6e</code> 和 <code>fbd48a</code> 合并成一个commit，操作如下：</p>
<p>1、执行rebase命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 62b781</span><br></pre></td></tr></table></figure>
<p>其中，-i 的参数是不需要合并的 commit 的 hash 值，也就是它们前一条 commit。接着就进入 vi 编辑模式，信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pick fbd48ab grouped convolutions :snake: :snake: :snake:</span><br><span class="line">pick 532c6e1 hm......</span><br><span class="line"></span><br><span class="line"># Rebase 62b781a..532c6e1 onto 62b781a (2 command(s))</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure>
<p>未注释部分格式：<code>Command commit-hash commit-content</code></p>
<p>注释部分：指令使用说明</p>
<ul>
<li><strong>pick：正常选中</strong></li>
<li>reword：选中，并且修改提交信息</li>
<li>edit：选中，rebase时会暂停，允许你修改这个commit</li>
<li><strong>squash：选中，会将当前commit与上一个commit合并</strong></li>
<li><strong>fixup：与squash相同，但不会保存当前commit的提交信息</strong></li>
<li>exec：执行其他shell命令</li>
<li>drop：移除commit</li>
</ul>
<p>2、将第二个commit前的command修改为 <code>squash</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick fbd48ab grouped convolutions :snake: :snake: :snake:</span><br><span class="line">squash 532c6e1 hm......</span><br></pre></td></tr></table></figure>
<p>保存退出（:x）</p>
<p>3、这时会进入 commit message 的编辑页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 2 commits.</span><br><span class="line"># The first commit&apos;s message is:</span><br><span class="line"></span><br><span class="line">grouped convolutions :snake: :snake: :snake:</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">hm......</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Author:    Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line"># Date:      Wed Oct 4 16:51:41 2017 -0700</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto 62b781a</span><br><span class="line"># Last commands done (2 commands done):</span><br><span class="line">#    pick fbd48ab grouped convolutions :snake: :snake: :snake:</span><br><span class="line">#    squash 532c6e1 hm......</span><br><span class="line"># No commands remaining.</span><br><span class="line"># You are currently editing a commit while rebasing branch &apos;master&apos; on &apos;62b781a&apos;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       modified:   cfg/darknet.cfg</span><br><span class="line">#       modified:   cfg/tiny.cfg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>将两次 commit message 修改成新的commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 2 commits.</span><br><span class="line">This is a combination of 2 commmits by xiaqunfeng.</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4、保存退出</p>
<p>显示信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[detached HEAD 2863a92] This is a combination of 2 commmits by xiaqunfeng.</span><br><span class="line"> Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line"> Date: Wed Oct 4 16:51:41 2017 -0700</span><br><span class="line"> 16 files changed, 251 insertions(+), 175 deletions(-)</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure>
<p>5、再次查看 git log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 2863a92ea8faef9d2172f8cee343e11cc22d5670</span><br><span class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line">Date:   Wed Oct 4 16:51:41 2017 -0700</span><br><span class="line"></span><br><span class="line">    This is a combination of 2 commmits by xiaqunfeng.</span><br><span class="line"></span><br><span class="line">commit 62b781af4d01fc5f074407590cf556b36c70e837</span><br><span class="line">Author: Joseph Redmon &lt;pjreddie@gmail.com&gt;</span><br><span class="line">Date:   Mon Oct 2 15:17:48 2017 -0700</span><br><span class="line"></span><br><span class="line">    resnet that works</span><br></pre></td></tr></table></figure>
<p>发现前两个commit已经被合并了。</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>如果还想将这两个commit合并，这时候前面没有其他commit了</p>
<p>使用命令，提取最近2笔commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 62b781a resnet that works</span><br><span class="line">pick 2863a92 This is a combination of 2 commmits by xiaqunfeng.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其余操作步骤同上。</p>
<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>继续实践，rebase最近3个commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>
<p>进入编辑界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick a4ae313 FIX OPENCV :snake:</span><br><span class="line">pick 1b001a7 :bug: :bug: :bug:</span><br><span class="line">pick ce8cf62 resnet that works</span><br><span class="line"></span><br><span class="line"># Rebase 1e72980..ce8cf62 onto 1e72980 (3 command(s))</span><br></pre></td></tr></table></figure>
<p>修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick a4ae313 FIX OPENCV :snake:</span><br><span class="line">squash 1b001a7 :bug: :bug: :bug:</span><br><span class="line">fixup ce8cf62 resnet that works</span><br></pre></td></tr></table></figure>
<p>继续进入vim编辑界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 3 commits.</span><br><span class="line"># The first commit&apos;s message is:</span><br><span class="line">FIX OPENCV :snake:</span><br><span class="line"></span><br><span class="line"># This is the 2nd commit message:</span><br><span class="line"></span><br><span class="line">:bug: :bug: :bug:</span><br><span class="line"></span><br><span class="line"># The 3rd commit message will be skipped:</span><br><span class="line"></span><br><span class="line">#       resnet that works</span><br></pre></td></tr></table></figure>
<p>修改方法和之前相同。</p>
<p>可以看出，fixup就相当于直接将该commit丢弃掉了。</p>
<blockquote>
<p>如果有两个commit，你想使用第一个作为最终的commit，那么就只需要将第二个commit直接fixup就好了，不需要squash，这样还省了一次编辑合并后的commit的时间。</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、如果你的 vim 配置了<code>YouCompleteMe</code>，会提示你如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YouCompleteMe unavailable: requires Vim 7.4.1578+.</span><br></pre></td></tr></table></figure>
<p>导致你进不去vi编辑界面。</p>
<p>解决方法</p>
<p>将git默认的编辑器从vi改为vim，执行如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor /usr/bin/vim</span><br></pre></td></tr></table></figure>
<p>2、push的时候会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>
<p>解决方法：加 <code>-f</code> 进行push。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1、关于分支的rebase，参考<a href="http://gitbook.liuhui998.com/4_2.html" target="_blank" rel="noopener">rebase</a>。</p>
<p>2、修改最近一次commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -amend</span><br></pre></td></tr></table></figure>
<p>3、当然，还有拆分提交的功能，可以自行搜之。不过强烈不推荐，特别是代码两次提交代码耦合比较紧密的情况，很难拆分。</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorRT]]></title>
      <url>http://xiaqunfeng.cc/2018/05/29/tensorrt/</url>
      <content type="html"><![CDATA[<p>tensorrt简介、安装及python转caffe脚本。<br><a id="more"></a></p>
<h2 id="关于TensorRT"><a href="#关于TensorRT" class="headerlink" title="关于TensorRT"></a>关于TensorRT</h2><p>​        NVIDIA TensorRT™是一款高性能的深度学习推理优化器和运行库，可为深度学习应用提供低延迟，高吞吐量的推理。TensorRT可用于快速优化，验证和部署经过训练的神经网络，以推理超大规模数据中心，嵌入式或汽车产品平台。</p>
<p>​        开发人员可以使用TensorRT以INT8或FP16的优化精度进行快速推理，从而大幅降低延迟，如实时服务（如云上的流式视频分类或嵌入式和汽车平台上的对象检测和分割）所要求的。</p>
<p>​        有了TensorRT，开发人员可以专注于开发新型的AI驱动的应用程序，而不是推理部署的性能调优。 TensorRT运行时确保最佳的推理性能，可以满足最苛刻的延迟和吞吐量要求。</p>
<p>​        TensorRT可以部署到数据中心内的Tesla GPU，Jetson嵌入式平台和NVIDIA DRIVE自主驾驶平台。</p>
<h3 id="TensorRT-3"><a href="#TensorRT-3" class="headerlink" title="TensorRT 3"></a>TensorRT 3</h3><p>TensorRT 3是在Volta GPU上解锁最佳推理性能的关键。与仅使用CPU推理相比，它在低于7ms的实时延迟下提供高达40倍的吞吐量。</p>
<p>版本亮点：</p>
<ul>
<li>在7ms实时延迟下，Tesla V100与Tesla P100的推理速度提高了3.7倍</li>
<li>与Tesla V100上的TensorFlow框架推理相比，优化和部署TensorFlow模型的速度提高了18倍</li>
<li>Python API容易使用，提高了生产力</li>
</ul>
<h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul>
<li>为低延迟推理生成优化的、部署就绪的运行时引擎</li>
<li>优化常用的神经网络层，如卷积、全连接、LRN、池化、激活、softmax、concat和反卷积层</li>
<li>导入使用Caffe和TensorFlow训练的模型或使用Network Definition API指定网络描述</li>
<li>使用Python API优化、验证和部署模型</li>
<li>使用全精度（FP32）或降低精度（INT8, FP16）来部署神经网络</li>
<li>使用用户自定义层API定义和实现独特的功能</li>
</ul>
<h2 id="TensorRT-3的安装"><a href="#TensorRT-3的安装" class="headerlink" title="TensorRT 3的安装"></a>TensorRT 3的安装</h2><p><strong>1、查看系统环境</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 系统版本</span><br><span class="line"># cat /etc/issue</span><br><span class="line">Ubuntu 16.04.3 LTS \n \l</span><br><span class="line"> </span><br><span class="line">//cuda版本</span><br><span class="line"># cat /usr/local/cuda/version.txt</span><br><span class="line">CUDA Version 8.0.61</span><br><span class="line"> </span><br><span class="line">//python版本</span><br><span class="line"># python --version</span><br><span class="line">Python 2.7.12</span><br></pre></td></tr></table></figure>
<p><strong>2、下载对应的安装包</strong></p>
<p><strong>3、安装 TensorRT</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo dpkg -i nv-tensorrt-repo-ubuntu1604-ga-cuda8.0-trt3.0-20171128_1-1_amd64.deb</span><br><span class="line"># sudo apt-get update</span><br><span class="line"># sudo apt-get install tensorrt</span><br></pre></td></tr></table></figure>
<p><strong>4、安装python依赖包</strong></p>
<p>依赖包包括：python-libnvinfer、python-libnvinfer-dev、swig、swig3.0</p>
<p>执行如下命令安装即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install python-libnvinfer-doc</span><br></pre></td></tr></table></figure>
<p><strong>5、验证安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># dpkg -l | grep TensorRT</span><br><span class="line">ii  libnvinfer-dev   4.0.1-1+cuda8 amd64         TensorRT development libraries and he</span><br><span class="line">ii  libnvinfer-sampl 4.0.1-1+cuda8 amd64         TensorRT samples and documentation</span><br><span class="line">ii  libnvinfer4      4.0.1-1+cuda8 amd64         TensorRT runtime libraries</span><br><span class="line">ii  python-libnvinfe 4.0.1-1+cuda8 amd64         Python bindings for TensorRT</span><br><span class="line">ii  tensorrt         3.0.1-1+cuda8 amd64         Meta package of TensorRT</span><br></pre></td></tr></table></figure>
<p>至此，tensorrt安装完成</p>
<p><strong>6、安装Python UFF包</strong></p>
<p>下载tar包</p>
<p>进入解压后文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd TensorRT-3.0.1/uff</span><br><span class="line"># ls</span><br><span class="line">uff-0.2.0-py2.py3-none-any.whl</span><br><span class="line"># sudo pip install uff-0.2.0-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>
<h2 id="NVCaffe-Python"><a href="#NVCaffe-Python" class="headerlink" title="NVCaffe Python"></a>NVCaffe Python</h2><p>TensorRT 3.0添加了对TensorRT python API的支持，以加载和优化NVCaffe模型，然后将其作为便携式PLAN文件执行和存储。</p>
<p><strong>1、package的导入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import tensorrt as trt         </span><br><span class="line">import pycuda.driver as cuda</span><br><span class="line">import pycuda.autoinit</span><br><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">from tensorrt.parsers import caffeparser</span><br></pre></td></tr></table></figure>
<ul>
<li>tensorrt - 导入tensorrt</li>
<li>pycuda - PyCUDA处理在GPU上分配内存所需的CUDA操作，并将数据传输到GPU并返回到CPU</li>
<li>numpy - 存储和移动数据</li>
<li>Image - 图像处理</li>
<li>caffeparser - 转换 NVCaffe 模型</li>
</ul>
<p><strong>2、定义模型的一些常量和路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INPUT_LAYERS = [&apos;data&apos;]</span><br><span class="line">OUTPUT_LAYERS = [&apos;prob&apos;]</span><br><span class="line">INPUT_H = 28</span><br><span class="line">INPUT_W = 28</span><br><span class="line">OUTPUT_SIZE = 10</span><br><span class="line"></span><br><span class="line">MODEL_PROTOTXT = &apos;/data/mnist/mnist.prototxt&apos;</span><br><span class="line">CAFFE_MODEL = &apos;/data/mnist/mnist.caffemodel&apos;</span><br><span class="line">DATA = &apos;/data/mnist/&apos;</span><br><span class="line">IMAGE_MEAN = &apos;/data/mnist/mnist_mean.binaryproto&apos;</span><br></pre></td></tr></table></figure>
<p><strong>3、创建 engine</strong></p>
<p>使用在 tensorrt.utils 中的 NVCaffe 模型转换工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">engine = tensorrt.utils.caffe_to_trt_engine(G_LOGGER,</span><br><span class="line">                                            MODEL_PROTOTXT,</span><br><span class="line">                                            CAFFE_MODEL,</span><br><span class="line">                                            1,</span><br><span class="line">                                            1 &lt;&lt; 20,</span><br><span class="line">                                            OUTPUT_LAYERS,</span><br><span class="line">                                            trt.infer.DataType.FLOAT)</span><br></pre></td></tr></table></figure>
<p><strong>4、对输入的image应用 mean</strong></p>
<p>使用 caffeparper 从 .binaryproto 文件中读取出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parser = caffeparser.create_caffe_parser()</span><br><span class="line">mean_blob = parser.parse_binary_proto(IMAGE_MEAN)</span><br><span class="line">parser.destroy()</span><br><span class="line">mean = mean_blob.get_data(INPUT_W ** 2)</span><br><span class="line">data = np.empty([INPUT_W ** 2])</span><br><span class="line">for i in range(INPUT_W ** 2):</span><br><span class="line">    data[i] = float(img[i]) - mean[i]</span><br><span class="line">mean_blob.destroy()</span><br></pre></td></tr></table></figure>
<p><strong>5、为推理创建一个 runtime，为engine 创建一个 context</strong></p>
<p><strong>6、运行推理</strong></p>
<p>在CPU上创建一个空的数组用于存放推理的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = np.empty(output_size, dtype = np.float32)</span><br></pre></td></tr></table></figure>
<p><strong>7、使用pycuda在GPU上分配内存并将其注册到engine中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d_input = cuda.mem_alloc(1 * img.size * img.dtype.itemsize)</span><br><span class="line">d_output = cuda.mem_alloc(1 * output.size * output.dtype.itemsize)</span><br></pre></td></tr></table></figure>
<p><strong>8、engine需要绑定，作为指向GPU内存的指针，pycuda通过将这些分配转换为 ints 来完成内存分配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindings = [int(d_input), int(d_output)]</span><br></pre></td></tr></table></figure>
<p><strong>9、创建一个CUDA stream 来运行推理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream = cuda.Stream()</span><br></pre></td></tr></table></figure>
<p><strong>10、将数据传输到GPU，运行推理，然后将结果复制回来</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#transfer input data to device</span><br><span class="line">cuda.memcpy_htod_async(d_input, img, stream)</span><br><span class="line">#execute model</span><br><span class="line">context.enqueue(1, bindings, stream.handle, None)</span><br><span class="line">#transfer predictions back</span><br><span class="line">cuda.memcpy_dtoh_async(output, d_output, stream)</span><br></pre></td></tr></table></figure>
<p><strong>11、结果的保存和使用</strong></p>
<p>运行 ArgMax 得到 prediction</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print (&quot;Prediction: &quot; + str(np.argmax(output)))</span><br></pre></td></tr></table></figure>
<p>保存 engine 到文件，以后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trt.utils.write_engine_to_file(&quot;/data/mnist/new_mnist.engine&quot;, engine.serialize())</span><br></pre></td></tr></table></figure>
<p>加载 engine 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_engine = trt.utils.load_engine(G_LOGGER, &quot;/data/mnist/new_mnist.engine&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>12、清理 context、engine 和 runtime</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.destroy()</span><br><span class="line">engine.destroy()</span><br><span class="line">new_engine.destroy()</span><br></pre></td></tr></table></figure>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>问题1</strong>、导入tensorrt的时候出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorrt as trt</span><br><span class="line">RuntimeError: module compiled against API version 0xb but this version of numpy is 0xa</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/usr/lib/python2.7/dist-packages/tensorrt/__init__.py&quot;, line 77, in &lt;module&gt;</span><br><span class="line">    from tensorrt import infer, parsers, utils, lite, plugins</span><br><span class="line">  File &quot;/usr/lib/python2.7/dist-packages/tensorrt/infer/__init__.py&quot;, line 54, in &lt;module&gt;</span><br><span class="line">    from ._infer_enums import *</span><br><span class="line">  File &quot;/usr/lib/python2.7/dist-packages/tensorrt/infer/_infer_enums.py&quot;, line 54, in &lt;module&gt;</span><br><span class="line">    from tensorrt.infer import _nv_infer_bindings as nvinfer</span><br><span class="line">ImportError: numpy.core.multiarray failed to import</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>更新NumPy到 &gt;= 1.13.0 版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pip install -U numpy==1.13.0</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[文本工具]]></title>
      <url>http://xiaqunfeng.cc/2018/05/25/txt-tools/</url>
      <content type="html"><![CDATA[<p>一些处理文本的工具总结，记录之。<br><a id="more"></a></p>
<p>系统环境：Mac</p>
<h2 id="shuf"><a href="#shuf" class="headerlink" title="shuf"></a>shuf</h2><p>功能：将输入行的随机排列写入标准输出</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">▶ brew install coreutils</span><br><span class="line">...</span><br><span class="line">==&gt; make install</span><br><span class="line">==&gt; Caveats</span><br><span class="line">All commands have been installed with the prefix &apos;g&apos;.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意上面这一行说明，命令前加了一个前缀 <code>g</code>，即<code>gshuf</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">▶ gshuf --help</span><br><span class="line">Usage: gshuf [OPTION]... [FILE]</span><br><span class="line">  or:  gshuf -e [OPTION]... [ARG]...</span><br><span class="line">  or:  gshuf -i LO-HI [OPTION]...</span><br><span class="line">Write a random permutation of the input lines to standard output.</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, read standard input.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">  -e, --echo                treat each ARG as an input line</span><br><span class="line">  -i, --input-range=LO-HI   treat each number LO through HI as an input line</span><br><span class="line">  -n, --head-count=COUNT    output at most COUNT lines</span><br><span class="line">  -o, --output=FILE         write result to FILE instead of standard output</span><br><span class="line">      --random-source=FILE  get random bytes from FILE</span><br><span class="line">  -r, --repeat              output lines can be repeated</span><br><span class="line">  -z, --zero-terminated     line delimiter is NUL, not newline</span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ cat test.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line">eeeee</span><br><span class="line">ff</span><br></pre></td></tr></table></figure>
<p>1、文本行乱序</p>
<p>将原文件里的行随机打乱输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ gshuf test.txt</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line">aaa</span><br><span class="line">eeeee</span><br><span class="line">ff</span><br></pre></td></tr></table></figure>
<p>2、随机抽取N行数据</p>
<p>使用参数 <code>-n</code>，指定随机抽取的行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▶ gshuf -n 3 test.txt</span><br><span class="line">eeeee</span><br><span class="line">bbb</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure>
<p>以上两种都可以将输出指定存储到输出文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ gshuf test.txt -o test-random.txt</span><br></pre></td></tr></table></figure>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>功能：分割文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▶ split --help</span><br><span class="line">split: illegal option -- -</span><br><span class="line">usage: split [-a sufflen] [-b byte_count] [-l line_count] [-p pattern]</span><br><span class="line">             [file [prefix]]</span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a, --suffix-length=N   使用长度为 N 的后缀 (默认 2)，是字母后缀</span><br><span class="line">-b, --bytes=SIZE        设置输出文件的大小。支持单位：m,k</span><br><span class="line">-l, --lines=NUMBER      设备输出文件的行数</span><br><span class="line">-d, --numeric-suffixes  使用数字后缀代替字母(mac上不可用)</span><br><span class="line">file, prifix			指定分割后文件的前缀</span><br></pre></td></tr></table></figure>
<p>可以指定行数、文件大小分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ split -a 3 -l 100 test.json split-</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split-aaa split-aab</span><br></pre></td></tr></table></figure>
<h3 id="找出文件的相同与不同"><a href="#找出文件的相同与不同" class="headerlink" title="找出文件的相同与不同"></a>找出文件的相同与不同</h3><p>有时候会遇到这样的需求，就是从一个文件中随机取一部分数据，然后又要取一部分数据，那么怎样保证数据是否有重复，这就需要比较。</p>
<p>有两个文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cat test1.txt</span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br><span class="line">eeeee</span><br><span class="line"># cat test2.txt</span><br><span class="line">111111</span><br><span class="line">33333</span><br><span class="line">8888</span><br><span class="line">ccc</span><br><span class="line">777777777</span><br><span class="line">dkahkah</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>1、列出两个文件中不同的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cat test1.txt test2.txt | sort | uniq -u | sort -n</span><br><span class="line">bb</span><br><span class="line">dddd</span><br><span class="line">dkahkah</span><br><span class="line">eeeee</span><br><span class="line">8888</span><br><span class="line">33333</span><br><span class="line">111111</span><br><span class="line">777777777</span><br></pre></td></tr></table></figure>
<blockquote>
<p>uniq -u：仅显示出一次的行列</p>
</blockquote>
<p>2、列出两个文件中相同的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># grep -f test1.txt test2.txt</span><br><span class="line">ccc</span><br><span class="line">dkahkah</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里发现第二行不对，以为此时是拿‘a’去匹配的，如果每一行都没有这么短的字符，那没什么问题</p>
</blockquote>
<p>查看<a href="http://man.linuxde.net/grep" target="_blank" rel="noopener">grep</a>的用法：</p>
<ul>
<li>-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</li>
<li>-v 反转查找。</li>
</ul>
<p>这里将test1.txt和test2.txt中的‘a’都改为‘aa’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># grep -f test1.txt test2.txt</span><br><span class="line">ccc</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>
<p>3、列出文件 test2.txt 中有，test1.txt中没有的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># grep -vf test1.txt test2.txt</span><br><span class="line">111111</span><br><span class="line">33333</span><br><span class="line">8888</span><br><span class="line">777777777</span><br><span class="line">dkahkah</span><br></pre></td></tr></table></figure>
<p>注：还有一个命令<a href="http://man.linuxde.net/comm" target="_blank" rel="noopener">comm</a>也可以用来比较两个文件的交集、差集、求差。但是要求两个文件都是已排序过的。所以也可以sort后用该命令来实现上面的想法。</p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/oldstring/newstring/g&apos; full-path-file</span><br></pre></td></tr></table></figure>
<ul>
<li>如果字符串中含反斜杠<code>/</code>，则使用冒号<code>:</code>作为分隔符。如果在shell脚本中替换字符串是变量，需要使用双引号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NEW_STRING=&quot;CCC/DDD&quot;</span><br><span class="line">sed -i &quot;s:ccc/ddd:$&#123;NEW_STRING&#125;:&quot; test-sed.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果字符串中同时含有反斜杠<code>/</code>和冒号<code>:</code>，如<code>http://xxx</code>则可使用井号<code>#</code>作为分割符。</p>
</li>
<li><p>如果字符串中含有引号，需要转义，使用反斜杠“\”，比如替换<code>&quot;&#39;&#39;div</code>，如果需要将它替换成<code>‘div</code>，可以使用<code>sed -i s#\&quot;\&#39;\&#39;#\&#39;#g</code>。</p>
</li>
</ul>
<h3 id="批量替换多个文件的字符串"><a href="#批量替换多个文件的字符串" class="headerlink" title="批量替换多个文件的字符串"></a>批量替换多个文件的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ./* 表示当前目录</span><br><span class="line">grep “oldString” -rl ./* | xargs sed -i ‘s/oldString/newString/g’</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /path 表示指定的目录</span><br><span class="line">sed -i &apos;s/oldString/newString/g&apos; `grep “oldString” -rl /path`</span><br></pre></td></tr></table></figure>
<h3 id="删除匹配行"><a href="#删除匹配行" class="headerlink" title="删除匹配行"></a>删除匹配行</h3><ul>
<li>删除开头为a的匹配行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;/^a.*/d&apos; tmp.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>删除开头为非a的匹配行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;/^a.*/!d&apos; tmp.txt</span><br></pre></td></tr></table></figure>
<h3 id="添加字符串"><a href="#添加字符串" class="headerlink" title="添加字符串"></a>添加字符串</h3><ul>
<li>sed在行首添加字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed ‘s/^/string/&apos;  filename &gt; output</span><br></pre></td></tr></table></figure>
<ul>
<li>sed在行尾添加字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed ‘s/$/string/&apos; filename &gt; output</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，写入原文件要加 -i</p>
</blockquote>
<h3 id="替换换行符"><a href="#替换换行符" class="headerlink" title="替换换行符"></a>替换换行符</h3><ul>
<li>linux下将字符串string替换成换行符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/string/\n/g&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>mac下匹配换行符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed －i &apos;&apos; &apos;s/string/&lt;回车&gt;/g&apos; filename</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：mac下和linux不同，不能简单的写<code>\n</code>，&lt;回车&gt; 需要通过 ctrl + v，然后按回车键 按出，按出来长这样 <code>^M</code></p>
</blockquote>
<h3 id="删除行首行尾的空格"><a href="#删除行首行尾的空格" class="headerlink" title="删除行首行尾的空格"></a>删除行首行尾的空格</h3><p>删除行首空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/[ \t]*$//g&apos; file.txt</span><br></pre></td></tr></table></figure>
<p>删除行尾空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s/^[ \t]*//g&apos; file.txt</span><br></pre></td></tr></table></figure>
<p>合并两个命令一次性去除行首、行末的空格和tab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  -e &apos;s/^[ \t]*//g’ -e ‘s/[ \t]*$//g&apos; file.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sed在处理字符串的时候并不对源文件进行直接处理，先创建一个buffer，但是加g表示对原buffer进行替换</p>
<p>-e 用于多个匹配</p>
</blockquote>
<h3 id="打印匹配行"><a href="#打印匹配行" class="headerlink" title="打印匹配行"></a>打印匹配行</h3><p>命令行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed -n -e &apos;/string/p&apos; file.txt</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▶ cat 11.txt</span><br><span class="line">myddddd</span><br><span class="line">dddddddd</span><br><span class="line">ddddmyddddd</span><br><span class="line">dddd</span><br><span class="line">▶ sed -e &apos;/my/p&apos; 11.txt</span><br><span class="line">myddddd</span><br><span class="line">myddddd</span><br><span class="line">dddddddd</span><br><span class="line">ddddmyddddd</span><br><span class="line">ddddmyddddd</span><br><span class="line">dddd</span><br><span class="line">▶ sed -n -e &apos;/my/p&apos; 11.txt</span><br><span class="line">myddddd</span><br><span class="line">ddddmyddddd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-n表示只输出匹配后的行，不加-n默认输出所有的行，如果匹配到，则匹配行再输出一遍</p>
</blockquote>
<h3 id="mac和linux下sed-i的区别"><a href="#mac和linux下sed-i的区别" class="headerlink" title="mac和linux下sed -i的区别"></a>mac和linux下<code>sed -i</code>的区别</h3><p>在mac上执行会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: command c expects \ followed by text</span><br></pre></td></tr></table></figure>
<p>而在centos和ubuntu上却没问题。</p>
<p>分别在mac和ubuntu/centos上使用命令<code>man sed</code>来查看命令参数<code>-i</code>的详细说明：</p>
<p>mac上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i extension</span><br><span class="line">     Edit files in-place, saving backups with the specified extension.  If a zero-length extension is given, no backup will be saved.  It is not recommended to give a zero-length extension when in-place editing files, as you risk corruption or partial content in situations where disk space is exhausted, etc.</span><br></pre></td></tr></table></figure>
<p>替换之前是要求提供后缀进行备份的，当然也可以使用空字符串来取消备份。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接在file文件中替换</span><br><span class="line">sed -i &apos;&apos; &apos;s/oldstring/newstring/g&apos; file</span><br><span class="line"></span><br><span class="line"># 直接在file文件中替换，但同时备份原文件为 file_bak</span><br><span class="line">sed -i _bak &apos;s/oldstring/newstring/g&apos; file</span><br></pre></td></tr></table></figure>
<p>linux上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-i[SUFFIX], --in-place[=SUFFIX]</span><br><span class="line">      edit files in place (makes backup if SUFFIX supplied)</span><br></pre></td></tr></table></figure>
<p>默认不备份，如果提供后缀，则进行备份。</p>
<blockquote>
<p>注：也可在mac上通过安装gnu-sed来替代sed，和linux上sed表现一样</p>
<p>1.brew install gnu-sed –with-default-names</p>
<p>2.vim ~/.zshrc<br>export PATH=”/usr/local/opt/gnu-sed/libexec/gnubin:$PATH”</p>
<p>3.source ~/.zshrc </p>
<p>参考资料：<a href="https://stackoverflow.com/questions/30003570/how-to-use-gnu-sed-on-mac-os-x" target="_blank" rel="noopener">https://stackoverflow.com/questions/30003570/how-to-use-gnu-sed-on-mac-os-x</a></p>
</blockquote>
<h3 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h3><p>有时候需要一次替换多个模式，有两种方式，第一种是采用分号<code>;</code>，第二种是采用参数<code>-e</code>。</p>
<p>示例：第一个模式把第一行到第三行的my替换成your，第二个则把第3行以后的This替换成了That。</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;1,3s/my/your/g; 3,$s/This/That/g&apos; my.txt</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &apos;1,3s/my/your/g&apos; -e &apos;3,$s/This/That/g&apos; my.txt</span><br></pre></td></tr></table></figure>
<h3 id="a命令、i命令、c命令"><a href="#a命令、i命令、c命令" class="headerlink" title="a命令、i命令、c命令"></a>a命令、i命令、c命令</h3><p>a和i用来添加行：a命令就是append， i命令就是insert。c命令用来替换匹配行</p>
<p>1、<code>1i</code>表明，其要在第1行前插入一行（insert）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;1 i hello, world&quot; my.txt</span><br></pre></td></tr></table></figure>
<p>2、<code>$a</code>表明，其要在最后一行后追加一行（append）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;$ a goodbye&quot; my.txt</span><br></pre></td></tr></table></figure>
<p>3、匹配添加：<code>/fish/a</code>表明匹配到fish就在该行后追加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;/fish/a xxxxxxxxxx&quot; my.txt</span><br></pre></td></tr></table></figure>
<p>4、c用法同a和i，只不过不是添加，是替换</p>
<blockquote>
<p>以上这几个在linux上通过，在mac上不同</p>
</blockquote>
<p>5、mac上追加示例</p>
<p>在第二行后追加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">▶ sed &apos;2 a\</span><br><span class="line">◀ xxx</span><br><span class="line">◀ &apos; my.txt</span><br><span class="line">This is my cat, my cat&apos;s name is betty</span><br><span class="line">This is my dog, my dog&apos;s name is frank</span><br><span class="line">xxx</span><br><span class="line">This is my fish, my fish&apos;s name is george</span><br><span class="line">This is my goat, my goat&apos;s name is adam</span><br></pre></td></tr></table></figure>
<p>匹配到my后追加<code>---</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">▶ sed &apos;/my/a\</span><br><span class="line">◀ ---</span><br><span class="line">◀ &apos; my.txt</span><br><span class="line">This is my cat, my cat&apos;s name is betty</span><br><span class="line">---</span><br><span class="line">This is my dog, my dog&apos;s name is frank</span><br><span class="line">---</span><br><span class="line">This is my fish, my fish&apos;s name is george</span><br><span class="line">---</span><br><span class="line">This is my goat, my goat&apos;s name is adam</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="命令行嵌套"><a href="#命令行嵌套" class="headerlink" title="命令行嵌套"></a>命令行嵌套</h3><p>1、对3行到第6行，匹配到<code>This</code>则删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;3,6 &#123;/This/d&#125;&apos; test.txt</span><br></pre></td></tr></table></figure>
<p>2、对3行到第6行，匹配<code>This</code>成功后，再匹配<code>fish</code>，成功后执行d命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;3,6 &#123;/This/&#123;/fish/d&#125;&#125;&apos; test.txt</span><br></pre></td></tr></table></figure>
<p>3、从第一行到最后一行，如果匹配到<code>This</code>，则删除之；如果前面有空格，则去除空格（这里是多个匹配）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;1,$&#123;/This/d;s/^ *//g&#125;&apos; test.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上这几个在mac上还是有点问题，linux通过</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1、文本合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ cat 1.txt 2.txt 3.txt &gt; merge.txt</span><br></pre></td></tr></table></figure>
<p>2、批量文文件添加前后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ for i in split-*; do mv $i “pre-”$i&quot;.json&quot;; done</span><br></pre></td></tr></table></figure>
<p>3、TO BE ADD</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KCF跟踪算法]]></title>
      <url>http://xiaqunfeng.cc/2018/05/09/kcf-tracking/</url>
      <content type="html"><![CDATA[<p>没有看论文原文及复杂的公式推理，查阅了一些KCF的资料，了解KCF算法的原理及优缺点，记录之。<br><a id="more"></a></p>
<p>KCF是João F. Henriques的论文High-Speed Tracking with Kernelized Correlation Filters提出的一种目标跟踪算法。算法主页<a href="http://www.robots.ox.ac.uk/~joao/circulant/index.html" target="_blank" rel="noopener">KCF</a>。</p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>目前跟踪的主流思想还是基于 tracking by detection，而训练样本的选择基本上是以目标中心提取正样本，然后基于周围的图像提取负样本。大部分算法都是采用非正既负的方法来标记训练样本，即正样本标签为1，负样本为0。这种标记方法有一个问题，就是不能很好的反应每个负样本的权重，即对离中心目标远的样本和离中心目标近的样本同样对待。所以有算法提出使用连续的标签进行标记样本，即根据样本中心离目标远近分别赋值 [0,1] 范围的数。离目标越近，值越趋近于1，越远越趋向于0。KCF通过使用 [0,1] 范围的值作为样本的回归值，从而给不同偏移下得到的样本不同的权重。</p>
<p>KCF是一种鉴别式追踪方法，这类方法一般都是在追踪过程中训练一个目标检测器，使用目标检测器去检测下一帧预测位置是否是目标，然后再使用新检测结果去更新训练集进而更新目标检测器。而在训练目标检测器时一般选取目标区域为正样本，目标的周围区域为负样本，当然越靠近目标的区域为正样本的可能性越大。</p>
<p>KCF跟踪算法是目标跟踪阶段中的<strong>目标搜索</strong>部分，因此目标特征表达可以有很多种选择，作者在论文用的是HOG，还有一些学者用了CNN之类的。</p>
<p>算法中使用轮转矩阵对样本进行采集，把图像向上、向下分别移动不同的像素得到新的样本图像，这就是循环之后的样本，直接增加了样本的数量，然后用这些样本去训练一个判别分类器，判断跟踪到的是目标还是周围的背景信息。</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>相关滤波法，就是根据当前帧的信息和之前帧的信息训练出一个相关滤波器，然后与新输入的帧进行相关性计算，得到的置信图就是预测的跟踪结果，得分最高的那个点（或者块）就是最可能的跟踪结果。</p>
<p>KCF，由目标区域形成循环矩阵，再利用循环矩阵在傅立叶空间可对角化等一些性质，通过岭回归得到通用的预测公式。该预测公式没有矩阵求逆的计算，大大减少的计算量。这归功于作者巧妙地将循环矩阵在傅立叶空间的性质与目标跟踪时循环采样相结合。</p>
<p>KCF的论文中分别实验了三种情形的岭回归：普通线性岭回归、多项式岭回归、核空间下的岭回归。前两种不必多说，最后一种核空间，大家可以回忆一下SVM将低维空间映射到高维空间的方法，可以将线性不可分的样本变得线性可分。当然在KCF里由于要利用循环矩阵的性质，所以这里的核矩阵是循环矩阵（必为方阵）。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>使用目标周围区域的循环矩阵采集正负样本，利用脊回归训练目标检测器，并成功的利用循环矩阵在傅里叶空间可对角化的性质将矩阵的运算转化为向量的Hadamad积，即元素的点乘，大大降低了运算量，提高了运算速度，使算法满足实时性要求。</li>
<li>将线性空间的脊回归通过核函数映射到非线性空间，在非线性空间通过求解一个对偶问题和某些常见的约束，同样的可以使用循环矩阵傅里叶空间对角化简化计算。</li>
<li>给出了一种将多通道数据融入该算法的途径。把以前只能用单通道的灰度特征改进为现在可以使用多通道的HOG特征或者其他特征。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>对特征图像进行cosine window加权，这主要是为了减轻由于边界移位导致图像不光滑。</li>
<li>padding的size是目标框的2.5倍，肯定要使用padding窗口，要不然移位一次目标就被分解重组合了。。。效果能好哪去。。</li>
<li>对于标签使用了高斯加权</li>
<li>对<img src="https://images2015.cnblogs.com/blog/1027162/201609/1027162-20160930215553266-1812662820.png" alt="img">前后帧结果进行了线性插值，为了让他长记性，不至于模型剧烈变化。</li>
<li>速度很快</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、依赖循环矩阵，对于多尺度的目标跟踪效果并不理想。当然可以通过设置多个size，在每个size上进行KCF运算，但这样的话很难确定应预先设置多少size，什么样的size，而且对size的遍历必将影响算法的速度。</p>
<p>2、对目标快速变形（假设用的是HOG特征）或颜色快速变化（假设用的是颜色特征）不鲁棒</p>
<p>这个好理解，毕竟HOG描述的就是形状信息，变化得太快必然会导致效果变差</p>
<p>3、对物体快速运动或者低帧率视频不太鲁棒。这两种情况都是意味着在跟踪过程中下一帧图像中目标得位置偏离search window中心太远，要么靠近边缘，要么出去一半，要么全出去，我们是给样本加了余弦窗的，也就是说目标位置靠近边缘会由于余弦窗的存在损失了部分目标信息，更不用说那些目标超出search window一半或者全超出去的情况了，这也就是CF类算法中的边界效应（Boundary Effets）。</p>
<p>4、虽然算法中对模型系数<img src="https://images2015.cnblogs.com/blog/1027162/201609/1027162-20160930215554656-848218783.png" alt="img">进行线性插值，但是对于目标一旦被遮挡若干帧之后，可能模型就再也回不去了。因为模型已经完全被遮挡物污染掉了。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、为什么对目标进行padding？</p>
<p>答：不padding的话怎么学习背景信息呢？你刚循环移位就把目标给打散了。所以padding就是能让样本中含有特别需要学习的背景信息，而且可以尽量保证样本中目标的完整性。</p>
<p>2、文中的给padding后的图像加余弦窗的目的是什么？</p>
<p>答：如果不加余弦窗，我们可以想象，除了那个最原始样本，其他移动样本的边缘都比较突兀，也就说这些样本数据是比较差的，会干扰训练的结果。而如果加了余弦窗，由于图像边缘像素值就都接近0了，循环移位过程中只要目标保持完整那这个样本就是合理的，不过加了余弦窗也会弱化掉目标的背景信息，对训练也有一定的影响，不过总的来看应该是利大于弊。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="余弦窗"><a href="#余弦窗" class="headerlink" title="余弦窗"></a>余弦窗</h3><p>引入余弦窗就是为了解决边界效应，而解决的方法就是在目标原始像素上乘一个余弦窗使接近边缘的像素值接近于零。</p>
<p>参考资料：<a href="https://blog.csdn.net/LRYUS_HJL/article/details/73302521" target="_blank" rel="noopener">相关滤波里余弦窗作用</a></p>
<h3 id="循环矩阵"><a href="#循环矩阵" class="headerlink" title="循环矩阵"></a>循环矩阵</h3><p><strong>循环矩阵</strong>是一种特殊形式的 <a href="https://zh.wikipedia.org/wiki/Toeplitz%E7%9F%A9%E9%99%A3" target="_blank" rel="noopener">Toeplitz矩阵</a>，它的行向量的每个元素都是前一个行向量各元素依次右移一个位置得到的结果。由于可以用<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">离散傅立叶变换</a>快速解循环矩阵，所以在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90" target="_blank" rel="noopener">数值分析</a>中有重要的应用。</p>
<p>特性：</p>
<p>循环矩阵遵循<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">代数</a>运算法则。对于两个循环矩阵 <em>A</em> 与 <em>B</em> 来说，<em>A</em> + <em>B</em> 也是循环矩阵。<em>AB</em> 也是循环矩阵，并且 AB=BA。</p>
<p>循环矩阵的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F" target="_blank" rel="noopener">特征向量</a>矩阵是同样维数的离散<a href="https://zh.wikipedia.org/wiki/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">傅立叶变换</a>矩阵，因此循环矩阵的<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%80%BC" target="_blank" rel="noopener">特征值</a>可以很容易地通过<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">快速傅立叶变换</a>计算出来。 具体对应关系为傅里叶变换矩阵=N*特征矩阵，N为循环矩阵维度</p>
<p>参考资料：<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">循环矩阵</a></p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">傅里叶变换wiki</a></p>
<h3 id="循环矩阵傅里叶对角化"><a href="#循环矩阵傅里叶对角化" class="headerlink" title="循环矩阵傅里叶对角化"></a>循环矩阵傅里叶对角化</h3><p><a href="https://blog.csdn.net/shenxiaolu1984/article/details/50884830" target="_blank" rel="noopener">循环矩阵傅里叶对角化</a></p>
<h3 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h3><p>岭回归，又称脊回归、吉洪诺夫正则化（Tikhonov regularization），是对<a href="https://baike.baidu.com/item/%E4%B8%8D%E9%80%82%E5%AE%9A%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">不适定问题</a>（ill-posed problem)进行回归分析时最经常使用的一种正则化方法。</p>
<p>岭回归(英文名：ridge regression, Tikhonov regularization)是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得<a href="https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0" target="_blank" rel="noopener">回归系数</a>更为符合实际、更可靠的回归方法，对病态数据的拟合要强于<a href="https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" target="_blank" rel="noopener">最小二乘法</a>。</p>
<p>参考资料：<a href="https://baike.baidu.com/item/%E5%B2%AD%E5%9B%9E%E5%BD%92/554917" target="_blank" rel="noopener">岭回归</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.cnblogs.com/YiXiaoZhou/p/5925019.html" target="_blank" rel="noopener">KCF目标跟踪方法分析与总结</a></p>
<p><a href="https://lidongxuan.github.io/blog/kcf" target="_blank" rel="noopener">目标跟踪：KCF</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26685032" target="_blank" rel="noopener">核化相关滤波器高速跟踪：KCF(2015PAMI)</a></p>
<p><a href="https://blog.csdn.net/crazyice521/article/details/53525366" target="_blank" rel="noopener">目标跟踪算法——KCF入门详解</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Markdown上编辑数学公式]]></title>
      <url>http://xiaqunfeng.cc/2018/05/03/MathJax-Markdown/</url>
      <content type="html"><![CDATA[<p>使用 MathJax 在markdown上显示公式<br><a id="more"></a></p>
<p>最简单的用法是使用 MathJax 的<a href="https://docs.mathjax.org/en/latest/start.html#mathjax-cdn" target="_blank" rel="noopener">内容分发（CDN）</a>服务。</p>
<h2 id="本地编辑器"><a href="#本地编辑器" class="headerlink" title="本地编辑器"></a>本地编辑器</h2><p>1、在markdown文件中，添加 MathJax CDN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line">   src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>此时，就可以在 md 文件中插入公式了。</p>
<p>2、显示方式</p>
<p>公式显示居中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ 此处插入公式 $$</span><br></pre></td></tr></table></figure>
<p>公式显示靠左：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\( 此处插入公式 \\)</span><br></pre></td></tr></table></figure>
<p>3、示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$</span><br><span class="line">\\(x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;\\)</span><br></pre></td></tr></table></figure>
<p>显示公式如下：<br>$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$<br>\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)</p>
<blockquote>
<p>注：</p>
<p>1、编辑器 Typora 不能正常显示公式，但是 Macdown、Markdownpad等编辑器都可以正常显示。</p>
<p>2、markdown文件中的<code>_</code>前需要加上<code>\</code> 转义字符</p>
</blockquote>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>如果是 Chrome 浏览器的话，安装一个插件 <a href="https://chrome.google.com/webstore/detail/github-with-mathjax/ioemnmodlmafdkllaclgeombjnmnbima" target="_blank" rel="noopener">Github with MathJax</a> 即可正常显示本地markdown 编辑的 MathJax 公式。</p>
<p>显示方式：（和以上略有不同）</p>
<p>公式显示居中（该行只显示该公式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ 此处插入公式 $$</span><br></pre></td></tr></table></figure>
<p>行内公式（前后可以有文字）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 此处插入公式 $</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：不需要在md文件中添加 mathjax cdn 代码段</p>
</blockquote>
<h2 id="Hexo博客"><a href="#Hexo博客" class="headerlink" title="Hexo博客"></a>Hexo博客</h2><p>1、安装 hexo-math 插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure>
<p>2、在根目录下的 <code>_config.yml</code> 文件中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins: </span><br><span class="line">  hexo-math</span><br></pre></td></tr></table></figure>
<p>3、重新生成并部署网站即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考资料：</p>
<p><a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=8159393" target="_blank" rel="noopener">http://cwiki.apachecn.org/pages/viewpage.action?pageId=8159393</a></p>
<p><a href="https://weilai5432.github.io/2017/01/11/MathJax-%E5%9C%A8MarkDown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" target="_blank" rel="noopener">https://weilai5432.github.io/2017/01/11/MathJax-%E5%9C%A8MarkDown%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git全局忽略.DS_Store等文件]]></title>
      <url>http://xiaqunfeng.cc/2018/04/24/git-ignore-ds-store/</url>
      <content type="html"><![CDATA[<p>git提交代码时，全局忽略指定类型的文件，不需要每次都去 .gitignore 中声明。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mac 中每个目录都会有个文件叫<code>.DS_Store</code>, 用于存储当前文件夹的一些 Meta 信息。</p>
<p>每次提交代码时，都需要在代码仓库的 .gitignore 中声明，忽略这类文件。这里介绍的方法可以不用每次都去修改 .gitignore，一次配置，永久有效。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1、创建 <code>~/.gitignore_global</code> 文件</p>
<p>把需要全局忽略的文件类型添加到该文件里</p>
<p>我的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># .gitignore_global</span><br><span class="line"></span><br><span class="line"># OS generated files</span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># swp and Icon files</span><br><span class="line">*.swp</span><br><span class="line">Icon?</span><br><span class="line"></span><br><span class="line"># Files that might appear on external disks</span><br><span class="line">.Spotlight-V100</span><br><span class="line">.Trashes</span><br><span class="line"></span><br><span class="line"># Thumbnail cache files</span><br><span class="line">._*</span><br><span class="line">ehthumbs.db</span><br><span class="line">Thumbs.db</span><br><span class="line"></span><br><span class="line"># Packages</span><br><span class="line">*.7z</span><br><span class="line">*.dmg</span><br><span class="line">*.gz</span><br><span class="line">*.iso</span><br><span class="line">*.jar</span><br><span class="line">*.rar</span><br><span class="line">*.tar</span><br><span class="line">*.zip</span><br><span class="line"></span><br><span class="line"># Compiled Python files</span><br><span class="line">*.pyc</span><br><span class="line"></span><br><span class="line"># Compiled C++ files</span><br><span class="line">*.out</span><br></pre></td></tr></table></figure>
<p>2、在 ~/.gitconfig 中引入 <code>.gitignore_global</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = xiaqunfeng</span><br><span class="line">    email = XXXX@gmail.com</span><br><span class="line">[core]</span><br><span class="line">    excludefile = /Users/xiaqunfeng/.gitignore_global</span><br></pre></td></tr></table></figure>
<p>以上！</p>
<p>此时，在所有的文件夹下 .DS_Store  等在 <code>~/.gitignore_global</code>  中指定的文件类型会被 Git 自动忽略。</p>
<h2 id="删除github上文件"><a href="#删除github上文件" class="headerlink" title="删除github上文件"></a>删除github上文件</h2><p>将上传到github上指定的文件删除，但如果只是单纯地删除本地文件，再执行提交操作，删除的只是本地文件，远程的文件依然存在。</p>
<p>正确姿势：</p>
<p>1、先将stage中的文件删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure>
<p>2、然后提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;rm filename&quot;</span><br></pre></td></tr></table></figure>
<p>3、再push到远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>这时github上的文件就不存在了。</p>
<blockquote>
<p>如果要将远程已经上传的 .DS_Store 删除，可使用该方法</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Toolss </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在jupyter中添加conda环境]]></title>
      <url>http://xiaqunfeng.cc/2018/04/13/jupyter-conda/</url>
      <content type="html"><![CDATA[<p>解决在mac下启动jupyter后不能应用conda环境的问题<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在本机利用conda启动了一个虚拟环境，通过命令行使用python环境没问题，但是通过 <code>jupyter notebook</code> 启动jupyter notebook之后却找不到虚拟环境。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>在虚拟环境下缺少kernel.json文件</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、首先安装ipykernel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install ipykernel</span><br></pre></td></tr></table></figure>
<p>2、在虚拟环境下创建kernel文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n 环境名称 ipykernel</span><br></pre></td></tr></table></figure>
<p>我这里想要再自己创建的python36环境中创建kernel文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n python36 ipykernel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前两步不需要启动conda环境，当然，已经启动了也没关系</p>
</blockquote>
<p>3、激活conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate 环境名称</span><br></pre></td></tr></table></figure>
<p>我这里启动 python36</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate python36</span><br></pre></td></tr></table></figure>
<p>当然，在启动环境前，还需要执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>这是使conda环境生效的操作</p>
<p>4、将环境写入notebook的kernel中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;</span><br></pre></td></tr></table></figure>
<p>我这里的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ python -m ipykernel install --user --name 3.6env --display-name &quot;Python (3.6env)&quot;</span><br><span class="line">Installed kernelspec 3.6env in /Users/xiaqunfeng/Library/Jupyter/kernels/3.6env</span><br><span class="line">(python36)</span><br></pre></td></tr></table></figure>
<p>5、查看环境信息</p>
<p>查看所有conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">▶ conda info --envs</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">python27                 /Users/xiaqunfeng/anaconda2/envs/python27</span><br><span class="line">python36              *  /Users/xiaqunfeng/anaconda2/envs/python36</span><br><span class="line">root                     /Users/xiaqunfeng/anaconda2</span><br><span class="line"></span><br><span class="line">(python36)</span><br></pre></td></tr></table></figure>
<p>查看已安装的 jupyter kernel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ ls ~/Library/Jupyter/kernels</span><br><span class="line">3.6env</span><br><span class="line">(python36)</span><br></pre></td></tr></table></figure>
<p>当前只安装了一个jupter kernel</p>
<p>6、打开notebook服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>新建时指定python环境</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jupyter-conda-1.jpg" alt="1"></p>
<p>对于已有的 ipynb 文件，可以更换kernel</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/jupyter-conda-2.jpg" alt="2"></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DBSCAN聚类算法]]></title>
      <url>http://xiaqunfeng.cc/2018/04/10/DBSCAN-cluster/</url>
      <content type="html"><![CDATA[<p>一种基于密度的聚类算法，可用于非凸样本集。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）一种很典型的密度聚类算法，和K-Means，BIRCH这些一般只适用于凸样本集的聚类相比，DBSCAN既可以适用于凸样本集，也可以适用于非凸样本集。</p>
<p>它是一种基于高密度连通区域的、基于密度的聚类算法，能够将具有足够高密度的区域划分为簇，并在具有噪声的数据中发现任意形状的簇，即密度相连的点的最大集合。</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>假设样本集是D=(x1,x2,…,xm)</p>
<p>1） ϵ-邻域：对于xj∈D，其ϵ-邻域包含样本集D中与xj的距离不大于ϵ的子样本集</p>
<p>2) 核心对象：对于任一样本xj∈D，如果其ϵ-邻域对应的子样本集个数至少包含MinPts个样本，则xj是核心对象。　</p>
<p>3）密度直达：如果xi位于xj的ϵ-邻域中，且xj是核心对象，则称xi由xj密度直达。</p>
<p>4）密度可达：对于xi和xj,如果存在样本序列p1,p2,…,pT,满足p1=xi,pT=xj, 且pt+1由pt密度直达，则称xj由xi密度可达。也就是说，密度可达满足传递性。此时序列中的传递样本p1,p2,…,pT−1均为核心对象，因为只有核心对象才能使其他样本密度直达。</p>
<p>5）密度相连：对于xi和xj，如果存在核心对象样本xk，使xi和xj均由xk密度可达，则称xi和xj密度相连。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/dbscan.jpg" alt="img"></p>
<blockquote>
<p>参考资料2</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、DBSCAN算法从一个未被访问的任意的数据点开始。这个点的邻域是用距离epsilon来定义（即该点ε距离范围内的所有点都是邻域点）。</p>
<p>2、如果在该邻域内有足够数量的点（根据minPoints的值），则聚类过程开始，并且当前数据点成为新簇中的第一个点。否则，该点将被标记为噪声（稍后，这个噪声点可能成为聚类中的一部分）。在这两种情况下，该点都会被标记为“已访问”。</p>
<p>3、对于新簇中的第一个点，它的ε距离邻域内的点也会成为同簇的一部分。这个过程使ε邻域内的所有点都属于同一个簇，然后对才添加到簇中的所有新点重复上述过程。</p>
<p>4、重复步骤2和3两个过程直到确定了聚类中的所有点才停止，即访问和标记了聚类的ε邻域内的所有点。</p>
<p>5、一旦我们完成了当前的聚类，就检索和处理新的未访问的点，就能进一步发现新的簇或者是噪声。重复上述过程，直到所有点被标记为已访问才停止。由于所有点已经被访问完毕，每个点都被标记为属于一个簇或是噪声。</p>
<blockquote>
<p>参考资料1</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>算法是基于一组邻域来描述样本集的紧密程度的，参数(ϵ, MinPts)用来描述邻域的样本分布紧密程度，即用户的输入。</p>
<ul>
<li>ϵ - 某一样本的邻域距离阈值（即领域半径）</li>
<li>MinPts - 某一样本的距离为 ϵ 的邻域中样本个数的阈值（即最少点个数）</li>
</ul>
<p>一般由经验得来，如果点P以 ϵ 为半径的邻域内至少包含MinPts个点，则称点P为核心点（核心对象）</p>
<blockquote>
<p>该算法需要选择一种距离度量，任意两个点之间的距离，反映了点之间的密度，由于DBSCAN算法对高维数据定义密度很困难，所以对于二维空间中的点，可以用欧氏距离来度量</p>
</blockquote>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p><strong>时间复杂度：</strong></p>
<p>DBSCAN 对数据库里的每一点进行访问，可能多于一次（例如作为不同聚类的候选者），但在现实的考虑中，时间复杂度主要受regionQuery 的调用次数影响，DBSCAN 对每点都进行刚好一次调用，且如果使用了特别的编号结构，则总平均时间复杂度为 O(n log n) ，最差时间复杂度则为 O(n^2) 。</p>
<p><strong>空间复杂度：</strong></p>
<p>可以使用 O(n^2) 空间复杂度的距离矩阵以避免重复计算距离，但若不使用距离矩阵，DBSCAN 的空间复杂度为 O(n)。</p>
<blockquote>
<p>参考资料3</p>
</blockquote>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>不需要确定簇的数量</li>
<li>不同于Mean-shift算法，当数据点非常不同时，会将它们单纯地引入簇中，DBSCAN能将异常值识别为噪声（对噪声不敏感）</li>
<li>与k-means算法相比，DBSCAN可以发现任意形状的簇类</li>
<li>DBSCAN 只需两个参数，且对数据库内的点的次序几乎不敏感</li>
<li>DBSCAN 被设计成能配合可加速范围访问的数据库结构，例如 <a href="https://zh.wikipedia.org/wiki/R*%E6%A0%91" target="_blank" rel="noopener">R*树</a>。</li>
<li>如果对资料有足够的了解，可以选择适当的参数以获得最佳的分类。</li>
<li>DBSCAN只需扫描一遍数据集即可完成聚类，而不用迭代执行</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当数据簇密度不均匀时，它的效果不如其他算法好。这是因为当密度变化时，用于识别邻近点的距离阈值ε和minPoints的设置将随着簇而变化。</li>
<li>DBSCAN 聚类分析的质量受所使用的度量影响，最常用的度量是欧几里得距离，尤其在高维度资料中，由于受所谓“维数灾难”影响，很难找出一个合适的 ε 。</li>
<li>如果没有对资料和比例的足够理解，将很难选择适合的 ε 参数。</li>
</ul>
<p><strong>其他阅读</strong></p>
<p>一种关于人脸聚类方法，里面使用了DBSCAN方法。</p>
<p>算法简要描述:</p>
<ul>
<li>获取第一照片类和第二照片类，所述第一照片类包括聚类得到的至少两张人脸照片；</li>
<li>对所述第一照片类中的所述人脸照片进行聚类，得到至少一个照片子类；</li>
<li>将所述至少一个照片子类中的一个照片子类确定为正确人脸子类； </li>
<li>计算所述正确人脸子类与所述第二照片类之间的距离；</li>
<li>若所述距离大于阈值，则将所述第一照片类和所述第二照片类分别聚类至不同的照片类。</li>
</ul>
<p>算法链接如下：<br><a href="https://patents.google.com/patent/CN105426878A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN105426878A/zh</a></p>
<p><strong>参考资料：</strong><br>1、<a href="http://www.10tiao.com/html/368/201802/2650784228/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/368/201802/2650784228/1.html</a><br>2、<a href="https://www.cnblogs.com/pinard/p/6208966.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6208966.html</a><br>3、<a href="https://zh.wikipedia.org/wiki/DBSCAN" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/DBSCAN</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AP(affinity propagation)聚类算法]]></title>
      <url>http://xiaqunfeng.cc/2018/04/08/affinity-propagation/</url>
      <content type="html"><![CDATA[<p>一种半监督聚类算法，近邻传播聚类算法<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Affinity Propagation聚类算法简称AP， 是基于数据点间的”信息传递”的一种聚类算法。算法的基本思想是将全部样本看作网络的节点，然后通过网络中各条边的消息传递计算出各样本的聚类中心。聚类过程中，共有两种消息在各节点间传递，分别是吸引度( responsibility)和归属度(availability) 。AP算法通过迭代过程不断更新每一个点的吸引度和归属度值，直到产生m个高质量的Exemplar（类似于质心），同时将其余的数据点分配到相应的聚类中。</p>
<p>AP论文：<a href="http://www.psi.toronto.edu/affinitypropagation/FreyDueckScience07.pdf" target="_blank" rel="noopener">Clustering by Passing Messages Between Data Points</a></p>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ul>
<li>Exemplar：指的是聚类中心，K-Means中的质心。</li>
<li>Similarity：数据点i和点j的相似度记为s(i, j)，是指点j作为点i的聚类中心的相似度。一般使用欧氏距离来计算，一般点与点的相似度值全部取为负值；因此，相似度值越大说明点与点的距离越近，便于后面的比较计算。</li>
<li>Preference：数据点i的参考度称为p(i)或s(i,i)，是指点i作为聚类中心的参考度。一般取s相似度值的中值。</li>
<li>Responsibility：r(i,k)用来描述点k适合作为数据点i的聚类中心的程度。</li>
<li>Availability：a(i,k)用来描述点i选择点k作为其聚类中心的适合程度。</li>
<li>Damping factor(阻尼系数)：为了避免振荡，AP算法更新信息时引入了衰减系数 λ。每条信息被设置为它前次迭代更新值的 λ 倍加上本次信息更新值的1-λ倍。其中，衰减系数 λ 是介于0到1之间的实数。</li>
</ul>
<p>在实际计算应用中，最重要的两个参数（也是需要手动指定）：</p>
<ul>
<li>Preference - 指定聚类数量的多少，值越大聚类数量越多</li>
<li>Damping factor - 控制算法收敛效果</li>
</ul>
<p>阻尼系数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r(i,k)new = λ*r(i,k)old + (1-λ)*r(i,k)</span><br><span class="line">a(i,k)new = λ*a(i,k)old + (1-λ)*a(i,k)</span><br></pre></td></tr></table></figure>
<h3 id="聚类过程"><a href="#聚类过程" class="headerlink" title="聚类过程"></a>聚类过程</h3><p>有一些详细的原理上的东西就不说了，直接说计算过程吧。聚类就是个不断迭代的过程，迭代的过程主要更新两个矩阵：</p>
<ul>
<li>代表(Responsibility)矩阵<em>R =</em>[r(i,k)]N×N</li>
<li><p>适选(Availabilities)矩阵A=[a(i,k)]N×N</p>
<p>这两个矩阵才初始化为0，N是所有样本的数目。<em>r(i,k)</em>表示第<em>k</em>个样本适合作为第<em>i</em>个样本的类代表点的代表程度，<em>a(i,k)</em>表示第<em>i</em>个样本选择第<em>k</em>个样本作为类代表样本的适合程度。</p>
</li>
</ul>
<p>迭代更新公式如下：</p>
<p><img src="http://kylen314.com/wp-content/uploads/2013/11/APgengxingongshi.jpg" alt="1"></p>
<p>一个比较通俗的聚类过程解释：</p>
<ul>
<li>所有人都参加选举（大家都是选民也都是参选人），要选出几个作为代表 </li>
<li>s(i,k)就相当于i对选k这个人的一个固有的偏好程度 </li>
<li>r(i,k)表示用s(i,k)减去最强竞争者的评分，可以理解为k在对i这个选民的竞争中的优势程度 </li>
<li>r(i,k)的更新过程对应选民i对各个参选人的挑选（越出众越有吸引力） </li>
<li>a(i,k)：从公式里可以看到，所有r(i’,k)&gt;0的值都对a有正的加成。对应到我们这个比喻中，就相当于选民i通过网上关于k的民意调查看到：有很多人（即i’们）都觉得k不错（r(i’,k)&gt;0），那么选民i也就会相应地觉得k不错，是个可以相信的选择 </li>
<li>a(i,k)的更新过程对应关于参选人k的民意调查对于选民i的影响（已经有了很多跟随者的人更有吸引力） </li>
<li>两者交替的过程也就可以理解为选民在各个参选人之间不断地比较和不断地参考各个参选人给出的民意调查。 </li>
<li>r(i,k)的思想反映的是竞争，a(i,k)则是为了让聚类更成功。 </li>
</ul>
<blockquote>
<p>源于参考资料2</p>
</blockquote>
<h2 id="与k-means的比较"><a href="#与k-means的比较" class="headerlink" title="与k-means的比较"></a>与k-means的比较</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>AP聚类算法与经典的 K-Means 和 k-centers 聚类算法相比，具有很多独特之处：</p>
<ol>
<li>无需指定聚类“数量”参数。AP聚类不需要指定K（经典的K-Means）或者是其他描述聚类个数（SOM中的网络结构和规模）的参数，这使得先验经验成为应用的非必需条件，人群应用范围增加。</li>
<li>明确的质心（聚类中心点）。样本中的所有数据点都可能成为AP算法中的质心，叫做Examplar，而不是由多个数据点求平均而得到的聚类中心（如K-Means）。</li>
<li>对距离矩阵的对称性没要求。AP通过输入相似度矩阵来启动算法，因此允许数据呈非对称，数据适用范围非常大。</li>
<li>初始值不敏感。多次执行AP聚类算法，得到的结果是完全一样的，即不需要进行随机选取初值步骤（还是对比K-Means的随机初始值）。</li>
<li>若以误差平方和来衡量算法间的优劣，AP聚类比其他方法的误差平方和都要低。（无论k-center clustering重复多少次，都达不到AP那么低的误差平方和）</li>
<li>AP算法相对K-Means鲁棒性强且准确度较高</li>
</ol>
<blockquote>
<p>参考资料1</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>AP聚类应用中需要手动指定Preference和Damping factor，这其实是原有的聚类“数量”控制的变体。</p>
</li>
<li><p>算法复杂度较高，为O(N<em>N</em>logN)，而K-Means只是O(N*K)的复杂度。因此运行较慢。当N比较大时(N&gt;3000)，AP聚类算法往往需要算很久。</p>
<p>​</p>
</li>
</ul>
<p>参考资料：</p>
<p>1、<a href="https://www.dataivy.cn/blog/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95affinity-propagation_ap/" target="_blank" rel="noopener">https://www.dataivy.cn/blog/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95affinity-propagation_ap/</a></p>
<p>2、<a href="https://www.zhihu.com/question/25384514" target="_blank" rel="noopener">https://www.zhihu.com/question/25384514</a></p>
<p>3、<a href="http://www.cnblogs.com/huadongw/p/4202492.html（相关公式）" target="_blank" rel="noopener">http://www.cnblogs.com/huadongw/p/4202492.html（相关公式）</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】A Rank-Order Distance based Clustering Algorithm for Face Tagging]]></title>
      <url>http://xiaqunfeng.cc/2018/04/04/rank-order-clustering/</url>
      <content type="html"><![CDATA[<p>一篇关于人脸聚类的文章<br><a id="more"></a></p>
<p>原文链接：<a href="https://pdfs.semanticscholar.org/efd6/4b7641bea8ca536f4e179be6e2dd25d519d6.pdf" target="_blank" rel="noopener">2011_CVPR_A Rank-Order Distance based Clustering Algorithm for Face Tagging</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rank-Order distance, which measures the dissimilarity between two faces using their neighboring information in the dataset. </span><br><span class="line">The Rank-Order distance is motivated by an observation that faces of the same person usually share their top neigh- bors.</span><br></pre></td></tr></table></figure>
<p>由于人脸的复杂场景，比如光照、姿态、表情等因素，绝对距离的度量方式可能会造成相同人的不同照片相似度很低，而不同人的照片反而相似度很高，所以单纯的L1或L2距离已不再适用。</p>
<p>由于大部分家庭照片都拍摄于不同的环境，对于人脸聚类会有一些要求和挑战：</p>
<p>1、相册中的人脸通常会在高维空间形成几个脸部簇，并具有不同的密度，大小和形状。这种非均匀分布使得绝对距离（例如，两个人脸识别特征之间的L1或L2距离）容易失败。如下图所示，男孩的群集比女孩的群集更稀疏。如果我们在这个例子中使用绝对距离，那么这个在中间男孩的脸更接近女孩群。</p>
<p>2、人脸检测通常会返回一些背景中不感兴趣或不喜欢的人脸。通常，我们不想标记这些面孔。聚类算法应该能够处理这些噪声和异常值。</p>
<p>3、算法的运行时间应该满足快速用户交互的要求。</p>
<p>由于复杂的人脸分布，同一人的所有人脸通常由几个子集群组成。由于这些子聚类相对比较紧密，因此可以通过简单的阈值法以Rank-Order距离来强健地识别它们。然而，由于光照，姿态，表达等变化的干扰，子簇之间的连接通常较弱且稀疏。为了解决这个问题，我们提出了一种基于排序距离的聚类算法，以迭代方式合并子簇凝聚的方式。聚类算法结合了聚类级别的秩距离和聚类级别的距离。在每个迭代步骤中，合并任意两个具有较小Rank-Order距离和较小归一化距离的人脸聚类。以这种方式，来自同一个人的不同子集群被有效连接。</p>
<p>Rank-order distance来度量两个人脸的相似度。这个距离是基于一个有趣的观察：同一个人的两张脸有许多共享的top邻居，但是来自不同人的人脸的邻居通常差异很大。</p>
<p>Rank-Order Distance</p>
<p><img src="https://pminmin.github.io/img/rank-order-1.png" alt="1"></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><a href="https://pminmin.github.io/img/rank-order-2.png" target="_blank" rel="noopener"><img src="https://pminmin.github.io/img/rank-order-2.png" alt="img"></a></p>
<p>该算法的时间复杂度是O(N2)O(N2)，其中DRDR和DNDN对应的两个阈值是固定参数，而K近邻是可以选择的参数，该参数大小直接影响最后聚类的簇数目。</p>
<p>参考资料：<a href="https://pminmin.github.io/2016/12/13/rank-order/" target="_blank" rel="noopener">https://pminmin.github.io/2016/12/13/rank-order/</a></p>
]]></content>
      
        <categories>
            
            <category> Deeplearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决Mac不能写入NTFS磁盘的问题(免安装)]]></title>
      <url>http://xiaqunfeng.cc/2018/03/27/mac-NTFS/</url>
      <content type="html"><![CDATA[<p>使用Mac的同学都知道Mac默认不能在NTFS格式的磁盘中写入内容。下面介绍一个简单的方法，简单几行命令解决所有问题。<br><a id="more"></a></p>
<h2 id="新方法（亲测可用）"><a href="#新方法（亲测可用）" class="headerlink" title="新方法（亲测可用）"></a>新方法（亲测可用）</h2><blockquote>
<p>Update 2019.04</p>
</blockquote>
<h3 id="1、查看磁盘的Volume-Name"><a href="#1、查看磁盘的Volume-Name" class="headerlink" title="1、查看磁盘的Volume Name"></a>1、查看磁盘的Volume Name</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">▶ diskutil list</span><br><span class="line">/dev/disk0 (internal):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                         251.0 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     314.6 MB   disk0s1</span><br><span class="line">   2:                 Apple_APFS Container disk1         250.7 GB   disk0s2</span><br><span class="line"></span><br><span class="line">/dev/disk1 (synthesized):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      APFS Container Scheme -                      +250.7 GB   disk1</span><br><span class="line">                                 Physical Store disk0s2</span><br><span class="line">   1:                APFS Volume Macintosh HD            194.8 GB   disk1s1</span><br><span class="line">   2:                APFS Volume Preboot                 43.5 MB    disk1s2</span><br><span class="line">   3:                APFS Volume Recovery                528.8 MB   disk1s3</span><br><span class="line">   4:                APFS Volume VM                      1.1 GB     disk1s4</span><br><span class="line"></span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line">   #:                       TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        *2.0 TB     disk2</span><br><span class="line">   1:                        EFI                         523.2 MB   disk2s1</span><br><span class="line">   2:         Microsoft Reserved                         134.2 MB   disk2s2</span><br><span class="line">   3:                  Apple_HFS MacOS                   1.1 TB     disk2s3</span><br><span class="line">   4:       Microsoft Basic Data exFAT                   322.1 GB   disk2s4</span><br><span class="line">   5:       Microsoft Basic Data NTFS                    569.1 GB   disk2s5</span><br></pre></td></tr></table></figure>
<p>可以看到，硬盘对应的设备路径是 <code>/dev/disk2</code>。磁盘是有名称的，这里有的会显示，有的不会显示，但是本地磁盘默认会放在 <code>/Volumes</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ ls /Volumes</span><br><span class="line"> MacOS  &apos;Macintosh HD&apos;   NTFS   com.apple.TimeMachine.localsnapshots   exFAT</span><br></pre></td></tr></table></figure>
<p>想要操作的盘名称叫 NTFS</p>
<h3 id="2、更新fstab"><a href="#2、更新fstab" class="headerlink" title="2、更新fstab"></a>2、更新fstab</h3><p>更新 <code>/etc/fstab</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure>
<p>写入内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=NTFS none ntfs rw,auto,nobrowse</span><br></pre></td></tr></table></figure>
<ul>
<li>ntfs rw：表示把这个分区挂载为可读写的ntfs格式</li>
<li>nobrowse：这个代表了在finder里不显示这个分区，这个选项非常重要，如果不写入的话挂载是不会成功的（<strong>实际情况是NTFS盘在finder中可以看见</strong>）</li>
</ul>
<p>写完这里以后不是按回车，按 Ctrl + X，会出现要不要保存的字样，请按 Y 然后回车。</p>
<h3 id="3、重启电脑"><a href="#3、重启电脑" class="headerlink" title="3、重启电脑"></a>3、重启电脑</h3><p>这个时候就可以在finder的侧边栏里看到NTFS盘了，但是在桌面上看不到NTFS盘符图标，此时可以对NTFS盘正常写入，而且以后也一直可以写入。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>如果这个分区在finder里不显示了（我暂时还没遇到，侧边栏直接显示了）</p>
<p>解决方法：软链接</p>
<p>因为这个NTFS分区是挂/Volumes下的，我们把这个目录在桌面做一个快捷方式就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Volumes/NTFS/ ~/Desktop/NTFS</span><br></pre></td></tr></table></figure>
<p>这样在桌面上就能看到NTFS磁盘图标了</p>
<blockquote>
<p>用这种方法打开的是系统原生的ntfs功能，稳定实用，比第三方工具要好用的多。</p>
<p>参考链接：<a href="https://laod.cn/free/mac-ntfs.html" target="_blank" rel="noopener">https://laod.cn/free/mac-ntfs.html</a></p>
</blockquote>
<h2 id="老方法（已废弃）"><a href="#老方法（已废弃）" class="headerlink" title="老方法（已废弃）"></a>老方法（已废弃）</h2><h3 id="第一步：查看磁盘设备文件名"><a href="#第一步：查看磁盘设备文件名" class="headerlink" title="第一步：查看磁盘设备文件名"></a>第一步：查看磁盘设备文件名</h3><p>这一步需要看一下，目标磁盘叫什么名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/diskutil.png" alt="diskutil_list"></p>
<p>可以看到我移动硬盘被挂载了disk2的位置上，其中Windows那个磁盘<strong>设备文件名</strong>为<strong>disk2s4</strong></p>
<p>以上信息告诉我们：1. 在<code>/dev</code>目录下； 2. 设备名称为<code>disk2s4</code></p>
<h3 id="第二步：新建挂载点"><a href="#第二步：新建挂载点" class="headerlink" title="第二步：新建挂载点"></a>第二步：新建挂载点</h3><p>其实他的意思也就是要告诉电脑，你这张盘要放在那里，就好像Windows电脑在你点击<strong>我的电脑</strong>之后可以看到所有的盘一样。<br>这里选择放在桌面。<br>其实是在桌面上新建一个叫<code>Windows</code>的文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/Desktop/Windows</span><br></pre></td></tr></table></figure>
<h3 id="第三步：推出磁盘（重新挂载）"><a href="#第三步：推出磁盘（重新挂载）" class="headerlink" title="第三步：推出磁盘（重新挂载）"></a>第三步：推出磁盘（重新挂载）</h3><p>Mac默认挂载的时候不可写磁盘，这里我们需要重新挂载一次，但是在此之前，需要先取消挂载（等同于鼠标右键菜单中的<strong>推出</strong>，但是不要选择推出全部）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /dev/disk2s4</span><br></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/umount.png" alt="umount"></p>
<h3 id="第四部：重新挂载"><a href="#第四部：重新挂载" class="headerlink" title="第四部：重新挂载"></a>第四部：重新挂载</h3><p>手动挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount_ntfs -o rw,nobrowse /dev/disk2s4 ~/Desktop/Windows</span><br></pre></td></tr></table></figure>
<h5 id="成功，磁盘可以正常读写了！！！"><a href="#成功，磁盘可以正常读写了！！！" class="headerlink" title="成功，磁盘可以正常读写了！！！"></a>成功，磁盘可以正常读写了！！！</h5><blockquote>
<p>本文为转载，亲测可用。原文链接：<a href="https://blog.plcent.com/archives/209" target="_blank" rel="noopener">https://blog.plcent.com/archives/209</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[添加gitment评论系统]]></title>
      <url>http://xiaqunfeng.cc/2018/03/26/hexo-gitment/</url>
      <content type="html"><![CDATA[<p>给自己的博客配置了一个评论系统，该系统使用GitHub账号登陆，使用GitHub Issues来写评论，比较方便。<br><a id="more"></a></p>
<h2 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h2><p>链接: <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
<p>因为Gitment使用了GitHub的服务，因此需要注册OAuth application。</p>
<p>注意：<strong>Authorization callback URL</strong>必须填写博客的域名。</p>
<p>注册成功之后将获取<strong>Client ID</strong>与<strong>Client Secret</strong>。</p>
<p>我的填写如下所示：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/OAuth-Application.jpg" alt="OAuth"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="主题带有gitment选项"><a href="#主题带有gitment选项" class="headerlink" title="主题带有gitment选项"></a>主题带有gitment选项</h3><p>那只需要填写以下信息就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Gitment</span><br><span class="line">gitment_owner: &apos;#&apos;         #你的 GitHub ID</span><br><span class="line">gitment_repo: &apos;#&apos;          #存储评论的 repo</span><br><span class="line">gitment_oauth:</span><br><span class="line">  client_id: &apos;#&apos;           #client ID</span><br><span class="line">  client_secret: &apos;#&apos;       #client secret</span><br></pre></td></tr></table></figure>
<h3 id="主题带没有gitment选项"><a href="#主题带没有gitment选项" class="headerlink" title="主题带没有gitment选项"></a>主题带没有gitment选项</h3><p>如果主题没有gitment选项可配置，可手动添加，步骤如下</p>
<p>1、加载Gitment的CSS与JS文件</p>
<p>下载<a href="https://imsun.github.io/gitment/style/default.css" target="_blank" rel="noopener">gitment.css</a>与<a href="https://imsun.github.io/gitment/dist/gitment.browser.js" target="_blank" rel="noopener">gitment.js</a>，分别放入主题目录的<strong>source/css</strong>与<strong>source/js</strong>目录中</p>
<p>在<strong>layout/partial/head.ejs</strong>中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 加载gitment的css和js文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/gitment.css&quot;&gt; </span><br><span class="line">&lt;script src=&quot;/js/gitment.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2、配置Gitment</p>
<p>添加<strong>layout/partial/gitment.ejs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;gitment&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 主页不要加载gitment --&gt;</span><br><span class="line">&lt;% if (!index)&#123; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment = new Gitment(&#123;</span><br><span class="line">  owner: &apos;xiaqunfeng&apos;,</span><br><span class="line">  repo: &apos;xiaqunfeng.github.io&apos;,</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    client_id: &apos;XXX&apos;,</span><br><span class="line">    client_secret: &apos;XXXX&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render(&apos;gitment&apos;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>client_id</strong>与<strong>client_secret</strong>为第1步注册OAuth Application所获取的<strong>Client ID</strong>与<strong>Client Secret</strong></li>
<li><strong>owner</strong>为你的GitHub账户名</li>
<li><strong>repo</strong>为你保存评论的GitHub仓库名称，所有的评论将保存在该仓库的Issues</li>
</ul>
<p>在<strong>layout/partial/article.ejs</strong>中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&apos;gitment&apos;) %&gt;</span><br></pre></td></tr></table></figure>
<p>3、初始化Gitment</p>
<p>以上步骤完成后就可以在博客页面的最下方看到如图所示的评论框。使用GitHub账号登录之后，就可以对评论进行初始化，然后开始写评论了。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/gitment.jpg" alt="gitment"></p>
<blockquote>
<p>每一篇博客的评论，对应于GitHub仓库一个issue。但是这些issue是不存在的，因此对于每一篇博客都需要进行初始化Gitment去创建issue。</p>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1、我遇到的坑</p>
<p>点击 <code>Initialize Comments</code> 的时候，出现 <code>Error: Validation Failed</code> </p>
<p>原因：</p>
<p>gitment有一项id配置是<code>window.location.pathname</code>，id有长度限制，当标题太长时，会导致id不合法</p>
<p>解决方法：</p>
<p>修改id，把id改成时间，或者其他的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: &apos;&lt;%= page.date %&gt;&apos;</span><br></pre></td></tr></table></figure>
<p>我用的是yilia的主题，要修改的文件是 <code>gitment.ejs</code>，路径如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">▶ cat themes/yilia/layout/_partial/post/gitment.ejs</span><br><span class="line">&lt;div id=&quot;gitment-ctn&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;//imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment = new Gitment(&#123;</span><br><span class="line">  id: &quot;&lt;%=url%&gt;&quot;,						// 要改这一行！</span><br><span class="line">  owner: &apos;&lt;%=theme.gitment_owner%&gt;&apos;,</span><br><span class="line">  repo: &apos;&lt;%=theme.gitment_repo%&gt;&apos;,</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    client_id: &apos;&lt;%=theme.gitment_oauth.client_id%&gt;&apos;,</span><br><span class="line">    client_secret: &apos;&lt;%=theme.gitment_oauth.client_secret%&gt;&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render(&apos;gitment-ctn&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2、其他各种坑，详见<a href="http://xichen.pub/2018/01/31/2018-01-31-gitment/" target="_blank" rel="noopener">添加Gitment评论系统踩过的坑</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】mtcnn]]></title>
      <url>http://xiaqunfeng.cc/2018/03/21/mtcnn-note/</url>
      <content type="html"><![CDATA[<p>一篇2016年的论文MTCNN阅读笔记<br><a id="more"></a></p>
<p>MTCNN 全称 Multi-task convolutional neural networks</p>
<p>论文首页：<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/index.html?from=timeline&amp;isappinstalled=1" target="_blank" rel="noopener">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a></p>
<p>Github: <a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">https://github.com/kpzhang93/MTCNN_face_detection_alignment</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>提供了一个新的框架，通过多任务学习统一级联CNN来整合面部检测和对齐这两项任务。提供的CNN由三个阶段组成。</p>
<p>第一阶段，通过一个浅的CNN快速产生候选窗口。</p>
<p>第二阶段，通过一个更复杂的CNN来优化，拒绝大量的非面部窗口。</p>
<p>最后阶段，用一个更加强大的CNN来优化结果并输出面部特征位置。</p>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><h3 id="Overall-Framework"><a href="#Overall-Framework" class="headerlink" title="Overall Framework"></a>Overall Framework</h3><p>给定一个图像，最初将它调整到不同比例以构建图像金字塔，作为接下来三阶段级联框架的输入：</p>
<p>第一阶段：我们实现一个完全卷积网络（fully convolutional network），叫做提案网络Proposal Network（P-Net），用以获取候选面部窗口以及它们的边界框回归向量。然后我们用估计的边界框回归向量来校准候选边框向量。之后，我们采用非极大值抑制（NMS）来合并高度重叠的候选框。</p>
<p>第二阶段：所有候选边框都被送到另一个CNN，叫做提取网络Refine Network（R-Net），进一步拒绝大量假候选框，用边界框回归执行校准，并用NMS合并候选框。</p>
<p>第三阶段：Output Network（O-Net），这个阶段跟第二阶段很相似，但是在这个阶段我们目标是更详细的描述面部。网络将输出五个面部特征位置。</p>
<p>如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160926111307080" alt="JDA Pipeline"></p>
<h3 id="CNN-Architectures"><a href="#CNN-Architectures" class="headerlink" title="CNN Architectures"></a>CNN Architectures</h3><p>当前用于面部识别的CNN受到以下限制：（1）一些过滤器缺少权重的多样性，这或许会他们产生歧义的描述。（2）与其他多分类对象检测和分类任务相比，面部检测是一个有挑战性的二分类任务，所以，它或许每层网络需要更少数量的过滤器。因此，减少过滤器的数量并且将5x5的过滤器改成3x3的过滤器以减少计算量，同时增加深度以获取更好的性能。有了这些改进，与之前的架构相比，在获得更好性能的同时获得更少的运行时间。文章在convolution和fully connection层后使用PReLU作为非线性激活函数。</p>
<p><strong>Stage1: Proposal Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113319264" alt="JDA Network1"></p>
<p>MP = Max Pooling</p>
<p><strong>Stage2: Refine Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113327249" alt="JDA Network2"></p>
<p><strong>Stage3: Output Net</strong></p>
<p><img src="http://img.blog.csdn.net/20160926113334297" alt="JDA Network3"></p>
<p>prototxt参见mtcnn的python&amp;caffe版本：<a href="https://github.com/DuinoDu/mtcnn" target="_blank" rel="noopener">https://github.com/DuinoDu/mtcnn</a></p>
<p><strong>用Netscope画出来的网络结构图如下：</strong></p>
<p>1、P-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-pnet.jpg" alt="p-net"></p>
<p>2、R-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-rnet.jpg" alt="r-net"></p>
<p>3、O-NET</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/mtcnn-onet.jpg" alt="o-net"></p>
<blockquote>
<p>更详细的网络结构图可用caffe工具 draw_net.py 来绘制。</p>
</blockquote>
<h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>利用三个任务来训练我们的CNN检测器：面部/非面部分类器，边界框回归以及面部特征定位。</p>
<p>1、Face classification</p>
<p>学习目标被定义为一个二分类问题。对于每一个样本，使用交叉熵损失函数</p>
<p><img src="http://img.blog.csdn.net/20160927151710209" alt="img"></p>
<p>pi是网络产生的指示一个样本是一个面部的概率。符号yidet∈{0,1}表示 ground-truth 的标签。</p>
<p>2、Bounding box regression</p>
<p>对于每个候选窗口，预测它与最接近真实值（比如，边界框的左上角坐标，高和宽）的偏移。学习目标被定义为一个回归问题，并且对每个样本Xi使用欧几里得损失函数：</p>
<p><img src="http://img.blog.csdn.net/20160927151729296" alt="img"></p>
<p>上式为通过欧氏距离计算的回归损失。其中，带尖的y为通过网络预测得到，不带尖的y为实际的真实的背景坐标。其中，y为一组成的四元组。</p>
<p>带尖的yibox是从网络获得的回归目标，yibox是正确标注的坐标。y是一个四元组，有4个坐标，（左上角x，左上角y，长，宽）。</p>
<p>3、Facial landmark localization</p>
<p>与边界框回归任务类似，面部特征检测被定义为一个回归问题并且最小化欧氏距离损失函数。</p>
<p><img src="http://img.blog.csdn.net/20160927151747812" alt="img"></p>
<p>其中，带尖的y为通过网络预测得到，不带尖的y为实际的真实的坐标。有五个面部特征点，包括左眼，右眼，鼻子，左嘴角，右嘴角，每个点2个坐标，所以，y属于十元组。</p>
<p>4、Multi-source training</p>
<p>由于我们在每个CNN中采用不同的任务，因此在学习过程中有不同类型的训练图像，比如，面部，非面部以及部分对齐的面部。在这种情况下，一些损失函数没有被使用。举个例子，对于样本的背景区域，我们仅计算Li det，并且其它两个损失值被设置为0。这个可以直接用一个样本类型指示器来实现。那么整个学习目标就可以被定义为</p>
<p><img src="http://img.blog.csdn.net/20160927151808203" alt="img"></p>
<p>整个的训练学习过程就是最小化上面的这个函数，其中，N为训练样本数量，aj表示任务的重要性，bj为样本类型。在这种情况下，采用随机梯度下降来训练CNN是自然而然的。</p>
<p>5、Online Hard sample mining</p>
<p>在线难例挖掘：不同于在原始分类器被训练之后进行传统的难例挖掘，文章中在面部分类任务中进行在线难例挖掘，以适应训练过程。</p>
<p>在每个小批量中，对所有样本在正向传播阶段计算损失并进行排序，选择前70%做为难例。然后我们在反向传播阶段仅从计算难例中的梯度。这意味着，我们忽略了训练过程中对检测器强化鲜有帮助的容易样本（easy samples）</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>由于联合执行面部检测和对齐，训练过程中，使用4种不同类型的数据标注：</p>
<p>（i）Negatives：和ground-truth face交并比（Intersection-over-Union，IoU）小于0.3的特征数据；</p>
<p>（ii）Positives：IoU &gt; 0.65</p>
<p>（iii）Part faces：0.4 &lt; IoU &lt; 0.65</p>
<p>（iv）Landmark faces：标有5个landmark位置的人脸</p>
<ul>
<li>负样本和正样本用于面部分类任务</li>
<li>正样本和部分人脸样本用于边界框回归</li>
<li>landmark人脸样本用于面部landmark定位</li>
</ul>
<p>所有训练数据组成：</p>
<p>3:1:1:2（negatives/ positives/ part face/ landmark face)</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>FDDB上准确率</p>
<p><img src="http://img.blog.csdn.net/20160926115216571" alt="JDA Network3"></p>
<p>速度</p>
<p><img src="http://img.blog.csdn.net/20160926114956302" alt="JDA Network3"></p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac-Tensorflow-Keras]]></title>
      <url>http://xiaqunfeng.cc/2018/03/18/Mac-Tensorflow-Keras/</url>
      <content type="html"><![CDATA[<p>在mac上初步搭建keras，用tensorflow作为backend。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h3><p>激活环境conda环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate python27</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow</span><br><span class="line">conda install keras</span><br></pre></td></tr></table></figure>
<h3 id="正常安装"><a href="#正常安装" class="headerlink" title="正常安装"></a>正常安装</h3><p>python3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tensorflow</span><br><span class="line">pip3 install keras</span><br></pre></td></tr></table></figure>
<p>python2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow</span><br><span class="line">pip install keras</span><br></pre></td></tr></table></figure>
<h3 id="版本和配置"><a href="#版本和配置" class="headerlink" title="版本和配置"></a>版本和配置</h3><p><strong>版本信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; tf.__version__</span><br><span class="line">&apos;1.6.0&apos;</span><br><span class="line">&gt;&gt;&gt; import keras</span><br><span class="line">Using TensorFlow backend.</span><br><span class="line">&gt;&gt;&gt; keras.__version__</span><br><span class="line">&apos;2.1.5&apos;</span><br></pre></td></tr></table></figure>
<p>表示安装成功</p>
<p><strong>配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ cat ~/.keras/keras.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;epsilon&quot;: 1e-07,</span><br><span class="line">    &quot;floatx&quot;: &quot;float32&quot;,</span><br><span class="line">    &quot;image_data_format&quot;: &quot;channels_last&quot;,</span><br><span class="line">    &quot;backend&quot;: &quot;tensorflow&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 <code>image_data_format</code> 是 <code>channels_last</code> ，对于Theano来说，这个参数是<code>channels_first</code>。因为在TensorFlow中图像的存储方式是<code>[height, width, channels]</code>，Theano中是 <code>[channels, height, width]</code>。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上Matplotlib中文乱码问题]]></title>
      <url>http://xiaqunfeng.cc/2018/03/13/mac-Matplotlib-chinese/</url>
      <content type="html"><![CDATA[<p>解决自己再mac上用matplotlib绘图时中文显示乱码的问题<br><a id="more"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/font_manager.py:1297: UserWarning: findfont: Font family [u&apos;sans-serif&apos;] not found. Falling back to DejaVu Sans</span><br><span class="line">  (prop.get_family(), self.defaultFamily[fontext]))</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>找不到字体，在绘制的图片中中文显示乱码</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、查看环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ python --version</span><br><span class="line">Python 2.7.14 :: Anaconda, Inc.</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>我这边起了一个名为 python27 的anaconda环境</p>
<p>2、查看配置路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import matplotlib</span><br><span class="line">&gt;&gt;&gt; print matplotlib.matplotlib_fname()</span><br><span class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br></pre></td></tr></table></figure>
<p>3、下载字体 <a href="http://www.font5.com.cn/font_download.php?id=151&amp;part=1237887120" target="_blank" rel="noopener">simhei.ttf</a></p>
<p>4、将字体拷贝到 ttf 目录下</p>
<p>我这边具体目录为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/fonts/ttf/</span><br></pre></td></tr></table></figure>
<p>5、删除字体缓存文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.matplotlib/*.cache</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有删除的话，会出现有字体但还是显示小方块</p>
</blockquote>
<p>6、字体参数设置</p>
<p>方法一：在代码中动态设置参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># 指定默认字体</span><br><span class="line">plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] </span><br><span class="line">plt.rcParams[&apos;font.family&apos;]=&apos;sans-serif&apos; </span><br><span class="line"># 用来正常显示负号</span><br><span class="line">plt.rcParams[&apos;axes.unicode_minus&apos;]=False</span><br></pre></td></tr></table></figure>
<p>方法二：修改配置文件 matplotlibrc（一劳永逸）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat /Users/xiaqunfeng/anaconda2/envs/python27/lib/python2.7/site-packages/matplotlib/mpl-data/matplotlibrc</span><br><span class="line">...</span><br><span class="line">font.family         : sans-serif </span><br><span class="line">...</span><br><span class="line">font.sans-serif     : SimHei</span><br><span class="line">...</span><br><span class="line">axes.unicode_minus  : False # use unicode for the minus symbol</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>意思就是知道字库族为 sans-serif，同时添加“SimHei”即宋体到字库族列表中，同时将找到axes.unicode_minus，将True改为False，作用就是解决负号’-‘显示为方块的问题</p>
</blockquote>
<p>7、字体显示</p>
<p>有中文出现的情况，需要 <code>u&#39;内容&#39;</code>，比如 <code>plt.xlabel(u&#39;横坐标&#39;)</code></p>
<p>同时还需在开头添加代码行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[inkscope安装配置]]></title>
      <url>http://xiaqunfeng.cc/2018/03/11/ceph-inkscope/</url>
      <content type="html"><![CDATA[<p>关于inkscope监控配置实践手册。<br><a id="more"></a></p>
<h2 id="关于inkscope"><a href="#关于inkscope" class="headerlink" title="关于inkscope"></a>关于inkscope</h2><p><strong>Inkscope</strong> 是一个 Ceph 的管理和监控系统，依赖于 Ceph 提供的 API，使用 MongoDB  来存储实时的监控数据和历史信息。</p>
<p>inkscope是一个基于apache2部署的flask应用， flask项目只负责ceph监控页面展示，实际获取ceph集群状态信息，是通过向ceph-rest-api发起请求实现的。</p>
<p>github地址：<a href="https://github.com/inkscope/inkscope" target="_blank" rel="noopener">https://github.com/inkscope/inkscope</a></p>
<p><strong>架构图</strong> <img src="http://oow6unnib.bkt.clouddn.com/inkscope-platform.png" alt="inkscope-platform"></p>
<p><strong>各组件作用</strong></p>
<ul>
<li>ceph-rest-api：Ceph提供的restfulAPI接口，inkscope通过ceph-rest-api接口访问和操作Ceph集群；</li>
<li>cephprobe：用于获取Ceph集群的相关信息；</li>
<li>sysprobe：用于获取Ceph运行的物理节点的相关信息，如：CPU、内存、网络以及磁盘使用量等相关信息；</li>
<li>mongoDB：用于保存又cephprobe和sysprobe获取的实时和历史数据集合，该数据集合由inkscope web界面展示部分读取调用；</li>
<li>inkscope-admviz：inkscope对外提供web服务。用户通过web浏览器向inkscope-admviz发送restfulAPI格式的读写请求，之后inkscope-admviz通过访问mongoDB数据库或访问ceph-rest-api接口来完成用户的读写请求，之后将读写请求的结果返回给客户浏览器。</li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统版本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.3.1611 (Core) </span><br><span class="line"></span><br><span class="line"># getconf LONG_BIT</span><br><span class="line">64</span><br><span class="line"></span><br><span class="line"># cat /proc/version </span><br><span class="line">Linux version 3.10.0-514.16.1.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) #1 SMP Wed Apr 12 15:04:24 UTC 2017</span><br></pre></td></tr></table></figure>
<p>ceph集群信息</p>
<p>三个节点（ceph0，ceph1，ceph2）即使mon节点，也是osd节点。</p>
<p>这里将ceph0作为inkscope管理节点，配置公网IP。</p>
<p>软件包的安装情况一览</p>
<ul>
<li>集群的mon节点：cephprobe，ceph-rest-api</li>
<li>集群的osd节点：sysprobe，inkscope-common</li>
<li>inkscope管理控制台： inkscope-admviz，inkscope-monitor，mongodb</li>
</ul>
<h2 id="管理节点"><a href="#管理节点" class="headerlink" title="管理节点"></a>管理节点</h2><h3 id="1、安装依赖包"><a href="#1、安装依赖包" class="headerlink" title="1、安装依赖包"></a>1、安装依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install httpd python-setuptools lshw mod_wsgi -y</span><br></pre></td></tr></table></figure>
<h3 id="2、安装mongodb"><a href="#2、安装mongodb" class="headerlink" title="2、安装mongodb"></a>2、安装mongodb</h3><p>创建 repo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/mongodb-org-3.4.repo</span><br><span class="line">[mongodb-org-3.4]   </span><br><span class="line">name=MongoDB Repository    </span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/    </span><br><span class="line">gpgcheck=1    </span><br><span class="line">enabled=1    </span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install mongodb-org -y</span><br></pre></td></tr></table></figure>
<p>修改配置文件，让mongdb可以远程访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/mongod.conf</span><br></pre></td></tr></table></figure>
<p>bind_ip = 127.0.0.1修改为 bind_ip = 0.0.0.0</p>
<p>启动mongodb服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start mongod.service</span><br></pre></td></tr></table></figure>
<p>查看服务是否已启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># netstat -tunlp | grep mongod</span><br><span class="line">tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      12115/mongod</span><br></pre></td></tr></table></figure>
<h3 id="3、安装inkscope相关的包"><a href="#3、安装inkscope相关的包" class="headerlink" title="3、安装inkscope相关的包"></a>3、安装inkscope相关的包</h3><h4 id="建立本地仓库"><a href="#建立本地仓库" class="headerlink" title="建立本地仓库"></a>建立本地仓库</h4><p>参考官方的方法：<a href="https://github.com/inkscope/inkscope-packaging" target="_blank" rel="noopener">https://github.com/inkscope/inkscope-packaging</a></p>
<p>1、从git上将源下载到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/inkscope/inkscope-packaging.git</span><br></pre></td></tr></table></figure>
<p>2、创建本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd inkscope-packaging/</span><br><span class="line">mkdir -p /var/www/html/inkscope-repo</span><br><span class="line">cp -r RPMS/* /var/www/html/inkscope-repo</span><br><span class="line">createrepo /var/www/html/inkscope-repo</span><br></pre></td></tr></table></figure>
<p>3、新建仓库配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/inkscope.repo </span><br><span class="line">[inkscope]</span><br><span class="line">name=My inkScope Repo</span><br><span class="line">baseurl=http://172.20.2.117:8080/inkscope-repo</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>
<h4 id="安装inkscope相关软件"><a href="#安装inkscope相关软件" class="headerlink" title="安装inkscope相关软件"></a>安装inkscope相关软件</h4><p>1、安装并启动cephprobe和ceph-rest-api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># yum install inkscope-cephrestapi</span><br><span class="line"># /etc/init.d/ceph-rest-api start</span><br><span class="line">Starting ceph-rest-api python server</span><br><span class="line">* Running on http://0.0.0.0:5000/</span><br><span class="line"></span><br><span class="line"># yum install inkscope-cephprobe</span><br><span class="line"># /etc/init.d/cephprobe start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在安装cephprobe的时候，inkscope-common作为依赖被安装</p>
</blockquote>
<p>2、安装inkscope-sysprobe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install inkscope-sysprobe -y</span><br><span class="line"># /etc/init.d/sysprobe start</span><br></pre></td></tr></table></figure>
<p>3、安装inskscopeviz</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install inkscope-admviz -y</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时会生成/etc/httpd/conf.d/inkScope.conf</p>
</blockquote>
<h3 id="4、配置权限"><a href="#4、配置权限" class="headerlink" title="4、配置权限"></a>4、配置权限</h3><p>需要创建一个client.restapi的用户 拥有权限 [mds] allow, [mon] allow , [osd] allow </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ceph auth get-or-create client.restapi mds &apos;allow&apos; osd &apos;allow *&apos; mon &apos;allow *&apos; &gt; /etc/ceph/ceph.client.restapi.keyring</span><br><span class="line"></span><br><span class="line">chmod 644 /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">chmod 644 /etc/ceph/ceph.client.restapi.keyring</span><br></pre></td></tr></table></figure>
<p>在/etc/ceph/ceph.conf配置文件里面添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[client.restapi]</span><br><span class="line">    log_file = /dev/null</span><br><span class="line">    keyring = /etc/ceph/ceph.client.restapi.keyring</span><br></pre></td></tr></table></figure>
<h3 id="5、配置http"><a href="#5、配置http" class="headerlink" title="5、配置http"></a>5、配置http</h3><p>/etc/httpd/conf/httpd.conf 中间添加一条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Listen 8080</span><br></pre></td></tr></table></figure>
<p>因为inkscope的web 默认采用虚拟主机的方式使用了8080端口。这个地方是写的这台管理节点的地址和端口，因为本机实现了wsgi的方式的rest-api的接口，不是用的集群的5000的端口，而是直接使用web配置的8080的端口</p>
<h3 id="6、给目录访问权限"><a href="#6、给目录访问权限" class="headerlink" title="6、给目录访问权限"></a>6、给目录访问权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chmod 777 -R /var/log/ceph/</span><br></pre></td></tr></table></figure>
<p>修改ceph-rest-api的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/httpd/conf.d/inkScope.conf</span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># For a ceph_rest_api in wsgi mode</span><br><span class="line">ProxyPass /ceph-rest-api/ http://&lt;inkscope_host&gt;:&lt;inkscope_port&gt;/ceph_rest_api/api/v0.1/</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ProxyPass /ceph-rest-api/ http://172.20.2.117:8080/ceph_rest_api/api/v0.1/</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>启动http服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure>
<p>检查ceph-rest-api是否能访问</p>
<p>地址是上面修改的地址：<a href="http://183.136.239.36:8080/ceph_rest_api/api/v0.1/" target="_blank" rel="noopener">http://183.136.239.36:8080/ceph_rest_api/api/v0.1/</a></p>
<p>修改/opt/inkscope/etc/inkscope.conf配置文件，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;ceph_rest_api&quot;: &quot;172.20.2.117:8080&quot;,</span><br><span class="line">&quot;ceph_rest_api_subfolder&quot;: &quot;ceph_rest_api&quot;,</span><br><span class="line">&quot;mongodb_host&quot; : &quot;172.20.2.117&quot;,</span><br></pre></td></tr></table></figure>
<h3 id="7、启动cephprobe-服务"><a href="#7、启动cephprobe-服务" class="headerlink" title="7、启动cephprobe 服务"></a>7、启动cephprobe 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@inkscope ~]# /etc/init.d/cephprobe restart</span><br></pre></td></tr></table></figure>
<p>现在就可以访问<br><a href="http://123.59.204.199:8080/inkscopeViz/index.html" target="_blank" rel="noopener">http://123.59.204.199:8080/inkscopeViz/index.html</a></p>
<p>这个是没有用户名密码的，我们为了安全采用以下用户名密码的方式,需要安装flask-login</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@inkscope ~]# rpm -ivh python-flask-login-0.2.11-1.el7.centos.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="8、重启httpd服务"><a href="#8、重启httpd服务" class="headerlink" title="8、重启httpd服务"></a>8、重启httpd服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@inkscope ~]# systemctl restart httpd</span><br></pre></td></tr></table></figure>
<p>再次访问就需要用户名密码了</p>
<ul>
<li>默认用户名:admin</li>
<li>默认密码:admin</li>
</ul>
<h2 id="OSD节点"><a href="#OSD节点" class="headerlink" title="OSD节点"></a>OSD节点</h2><h3 id="配置sysprobe"><a href="#配置sysprobe" class="headerlink" title="配置sysprobe"></a>配置sysprobe</h3><p>sysprobe是获取集群节点的主机的信息的</p>
<p>管理节点同时也是OSD节点的话也要配置</p>
<p>1、安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rpm -ivh inkscope-common-1.3.1-2.noarch.rpm</span><br><span class="line"># rpm -ivh inkscope-sysprobe-1.3.1-2.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>将主监控节点的inkscope配置文件拷贝到所有OSD节点上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># scp /opt/inkscope/etc/inkscope.conf 192.168.8.106:/opt/inkscope/etc/</span><br></pre></td></tr></table></figure>
<p>2、在osd节点启动sysprobe服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lab8106 ~]# /etc/init.d/sysprobe start</span><br></pre></td></tr></table></figure>
<p>cephprobe是用来或者集群的相关信息和操作的<br>sysprobe是获取节点的磁盘分区等相关信息的</p>
<p>问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/sysprobe start</span><br><span class="line">Starting sysprob daemon</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/opt/inkscope/bin/sysprobe.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    import psutil</span><br><span class="line">ImportError: No module named psutil</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<p>没有按照系统性能信息模块psutil，该模块能够获取系统运行的进程和系统利用率（cpu、内存、磁盘、网络）等信息。</p>
<p>centos7下安装psutil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install python-psutil</span><br></pre></td></tr></table></figure>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p> <img src="http://oow6unnib.bkt.clouddn.com/inkscope-protal.png" alt="inkscope-protal"></p>
<p>更多相关截图可以在这里查阅：<a href="https://github.com/inkscope/inkscope/tree/master/screenshots" target="_blank" rel="noopener">https://github.com/inkscope/inkscope/tree/master/screenshots</a></p>
<p>ubuntu上的部署指南可以参考这里：<a href="http://gtcsq.readthedocs.io/en/latest/others/inkscope_install.html" target="_blank" rel="noopener">http://gtcsq.readthedocs.io/en/latest/others/inkscope_install.html</a></p>
<p>参考资料：<a href="http://www.zphj1987.com/2016/04/19/inkscope%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">http://www.zphj1987.com/2016/04/19/inkscope%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</a> </p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/cephprobe restart</span><br><span class="line">restarting  cephprob daemon</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/opt/inkscope/bin/cephprobe.py&quot;, line 25, in &lt;module&gt;</span><br><span class="line">    from daemon import Daemon</span><br><span class="line">  File &quot;/opt/inkscope/bin/daemon.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    import psutil</span><br><span class="line">ImportError: No module named psutil</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools</span><br></pre></td></tr></table></figure>
<p>安装完以后我们就可以使用命令easy_install安装 系统性能信息模块psutil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install psutil</span><br></pre></td></tr></table></figure>
<p>这时候又出现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psutil/_psutil_linux.c:12:20: 致命错误：Python.h：没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<p>查看本地是否安装python-devel，这是Python的头文件和静态库包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm -qa |grep python-devel</span><br></pre></td></tr></table></figure>
<p>这时候没有输出，说明没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search python |grep python-devel</span><br></pre></td></tr></table></figure>
<p>选一个安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-devel.x86_64 -y</span><br></pre></td></tr></table></figure>
<p>over</p>
<h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2><p>创建.repo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/mongodb-org-3.4.repo</span><br></pre></td></tr></table></figure>
<p>内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-3.4]   </span><br><span class="line">name=MongoDB Repository    </span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/    </span><br><span class="line">gpgcheck=1    </span><br><span class="line">enabled=1    </span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>
<p>验证MongoDB存储库是否存在于yum实用程序中。 repolist命令显示已启用的存储库的列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum repolist</span><br><span class="line">...</span><br><span class="line">mongodb-org-3.4/7                               MongoDB Repository</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>安装mongodb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mongodb-org</span><br></pre></td></tr></table></figure>
<p>mongodb-org将包含mongodb-org-server、mongodb-org-mongos、mongodb-org-shell、mongodb-org-tools</p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig mongod on   </span><br><span class="line">sudo service mongod start    </span><br><span class="line">netstat -tunpl | grep 27017</span><br></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod stop</span><br></pre></td></tr></table></figure>
<p>移除包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum erase $(rpm -qa | grep mongodb-org)</span><br></pre></td></tr></table></figure>
<p>移除数据和日志文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -r /var/log/mongodb   </span><br><span class="line">sudo rm -r /var/lib/mongo</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[客户端rbd环境检查]]></title>
      <url>http://xiaqunfeng.cc/2018/03/08/ceph-rbd-env-check/</url>
      <content type="html"><![CDATA[<p>检查rbd客户端是否可以正常识别文件系统<br><a id="more"></a></p>
<h2 id="应付的场景"><a href="#应付的场景" class="headerlink" title="应付的场景"></a>应付的场景</h2><p>  编译10.2.6和11.2.1版本的rbd，执行发现，在sysfs_write_rbd_add(buf)步中(该块设备已经被文件系统xfs格式化)，创建的/run/udev/data/b251\:0都为异常状态，ID_FS_TYPE字段为空。执行mount都可以正常挂载。<br>  实际上，通过apt-get install ceph-common的rbd存在异常，而apt-get install ceph的rbd表现正常(ceph-deploy部署的rbd是通过apt-get install ceph实现的)。<br>这个异常与rbd源代码没关系，而是与安装的方式有关，这可能是有组件的依赖有关系。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>暂时无法从rbd代码层面定位问题，通过提供工具检测暂时绕过这个问题。<br>ceph-client-rbd-env-check.py可以协助检查rbd客户端是否可以正常识别文件系统。在rbd环境就绪后，可以运行脚本执行检查。</p>
<p>在rbd环境就绪后，可以运行脚本执行检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># python ceph-client-rbd-env-check.py</span><br><span class="line">EXAMPLE:</span><br><span class="line">python ceph-client-rbd-env-check.py $&#123;pool_name&#125;</span><br><span class="line"></span><br><span class="line"># python ceph-client-rbd-env-check.py rbd</span><br><span class="line">[PASS] get device fstype okay.</span><br></pre></td></tr></table></figure>
<p>脚本下载链接：<a href="https://github.com/xiaqunfeng/ceph-ansible/blob/master/tools/ceph-client-rbd-env-check.py" target="_blank" rel="noopener">ceph-client-rbd-env-check.py</a></p>
<h3 id="异常情形"><a href="#异常情形" class="headerlink" title="异常情形"></a>异常情形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># cat /run/udev/data/b251\:0 </span><br><span class="line">S:rbd/rbd/rbd0</span><br><span class="line">I:162920386411</span><br><span class="line">E:ID_FS_TYPE=</span><br><span class="line">G:systemd</span><br><span class="line"></span><br><span class="line"># python ceph-client-env-rbd-test.py rbd</span><br><span class="line">[FAIL] cmd=&apos;lsblk -nd -o FSTYPE /dev/rbd0&apos;, desc=&apos;get device fstype&apos;</span><br></pre></td></tr></table></figure>
<h3 id="正常情形"><a href="#正常情形" class="headerlink" title="正常情形"></a>正常情形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat /run/udev/data/b251\:0 </span><br><span class="line">S:rbd/rbd/rbd0</span><br><span class="line">I:163204714535</span><br><span class="line">E:ID_FS_UUID=d0296c84-56d7-4adb-89b1-9f60c6a54309</span><br><span class="line">E:ID_FS_UUID_ENC=d0296c84-56d7-4adb-89b1-9f60c6a54309</span><br><span class="line">E:ID_FS_TYPE=xfs</span><br><span class="line">E:ID_FS_USAGE=filesystem</span><br><span class="line">G:systemd</span><br><span class="line"></span><br><span class="line"># python ceph-client-env-rbd-test.py rbd</span><br><span class="line">[PASS] get device fstype okay.</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph osd权重调整]]></title>
      <url>http://xiaqunfeng.cc/2018/03/08/ceph-osd-reweight/</url>
      <content type="html"><![CDATA[<p>介绍调整何时该调整权重，以及调整权重的方法。<br><a id="more"></a></p>
<h2 id="为什么要调整权重？"><a href="#为什么要调整权重？" class="headerlink" title="为什么要调整权重？"></a>为什么要调整权重？</h2><p>ceph是一个去中心化的分布式存储系统，其数据的分布是按照<a href="[https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf](https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf">crush算法</a>)计算得到。</p>
<p>然而遗憾的是crush算法并不能将pg均匀的分布于osd之间。以某三副本pool有1024个pg，共1024*3=3072个pg在30个osd中的分布为例：</p>
<table>
<thead>
<tr>
<th>osd编号</th>
<th>28</th>
<th>22</th>
<th>3</th>
<th>12</th>
<th>7</th>
<th>23</th>
<th>20</th>
<th>13</th>
<th>16</th>
<th>4</th>
<th>2</th>
<th>14</th>
<th>9</th>
<th>8</th>
<th>24</th>
<th>18</th>
<th>17</th>
<th>11</th>
<th>6</th>
<th>21</th>
<th>0</th>
<th>27</th>
<th>10</th>
<th>1</th>
<th>25</th>
<th>29</th>
<th>19</th>
<th>26</th>
<th>15</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>pg数目</td>
<td>112</td>
<td>112</td>
<td>110</td>
<td>110</td>
<td>109</td>
<td>109</td>
<td>109</td>
<td>109</td>
<td>107</td>
<td>106</td>
<td>106</td>
<td>106</td>
<td>105</td>
<td>105</td>
<td>105</td>
<td>105</td>
<td>104</td>
<td>104</td>
<td>101</td>
<td>101</td>
<td>99</td>
<td>98</td>
<td>98</td>
<td>97</td>
<td>94</td>
<td>93</td>
<td>92</td>
<td>91</td>
<td>89</td>
<td>86</td>
</tr>
<tr>
<td>剩余比例(%)</td>
<td>5</td>
<td>5</td>
<td>6.7</td>
<td>6.7</td>
<td>7.6</td>
<td>7.6</td>
<td>7.6</td>
<td>7.6</td>
<td>9.4</td>
<td>10.3</td>
<td>10.3</td>
<td>10.3</td>
<td>11.2</td>
<td>11.2</td>
<td>11.2</td>
<td>11.2</td>
<td>12.1</td>
<td>12.1</td>
<td>14.8</td>
<td>14.8</td>
<td>16.6</td>
<td>17.5</td>
<td>17.5</td>
<td>18.3</td>
<td>21.1</td>
<td>22.0</td>
<td>22.9</td>
<td>23.8</td>
<td>25.5</td>
<td>28.2</td>
</tr>
</tbody>
</table>
<p>该pg数目分布的方差达到7，平均值是102.4。</p>
<p>这么分布的缺点有两个：</p>
<ul>
<li>无法充分利用空间。集群会更早的达到full报警，full之后，在full-osd上的pg将停止写入。full的警报在某个osd达到95%时报出，按照上面表格的数据，最早达到的是osd.28，osd.28写到95%时，按照pg分布的比例，各个osd此时的剩余比例如上，整个集群的剩余空间比例在13.3%。而如果pg数目的分布在[101, 105]之间，某osd达到95%时，整个集群的剩余比例在6%，可见，pg均匀分布会更充分利用空间。</li>
<li>pg分布多的osd将成为性能瓶颈。这个结论显而易见，当pg分布多时，iops就高，因此pg分布均匀能消除系统性能瓶颈。</li>
</ul>
<h2 id="什么时候调整权重？"><a href="#什么时候调整权重？" class="headerlink" title="什么时候调整权重？"></a>什么时候调整权重？</h2><p>一些公开的分享常常提及在集群空间报警时调整权重，实际上我更推荐在集群刚刚建立时即可调整权重，均衡pg分布。这样的好处有两个：</p>
<ul>
<li>新建立的集群没有数据，pg迁移时负担小。老集群迁移数据成本高，且会对应用产生性能影响。</li>
<li>更早的消除了性能瓶颈。</li>
</ul>
<h2 id="如何调整权重？"><a href="#如何调整权重？" class="headerlink" title="如何调整权重？"></a>如何调整权重？</h2><p>我们使用 <code>ceph osd crush reweight osd.N float_weight</code> 来调整某个pool的pg分布来实现均衡分布。我们建议ceph集群中一个ruleset只有一个主力pool，我们将调整这个主力pool的分布实现均衡。举个例子：</p>
<ul>
<li>对象存储。其主力使用的pool为data。如果把index pool放置在其他ruleset(该ruleset与data pool的ruleset不共享osd)上，则index pool也可以调整权重实现index pool pg均衡分布;</li>
<li>块存储。其主力使用的pool是rbd。</li>
<li>对象存储和块存储共享集群，此时建议分布于不同的osd集合，使用不同的ruleset。</li>
</ul>
<p>对于一个pool_id=10的pg分布调整，步骤如下：</p>
<ol>
<li>使用 <code>ceph pg dump|grep &#39;^10\.&#39; |awk &#39;{print $15}&#39; |python pg_stat.py|sort -k2 -rn</code> 得到分布统计</li>
<li>通过方差查看均衡效果：<code>ceph pg dump|grep &#39;^10\.&#39; |awk &#39;{print $15}&#39; | python pg_stat.py |sort -k2 -rn|awk &#39;{print $2}&#39;|python dispersion.py</code></li>
<li>通过 <code>python ceph-reweight.py {osd编号} {float权重}</code>来调整某个osd的权重。每次调整权重建议为osd权重的5%粒度。</li>
<li>等待所有pg进入active状态；</li>
<li>回到第2步查看方差，确认效果，效果不好可以撤销上次调整；继续调整则回到1，选择需要调整的节点。</li>
</ol>
<p>结束的时机选择在 <code>方差/avg_pg_num_per_osd &lt; 3</code> 时可以结束。</p>
<h2 id="有没有更好的办法？"><a href="#有没有更好的办法？" class="headerlink" title="有没有更好的办法？"></a>有没有更好的办法？</h2><p>ceph osd reweight-by-pg的方式早期可能有所效果，但是调整到一定程度时不够彻底，不如手动直接。</p>
<p>后续研究下crushtool，通过离线计算的方式直接得出权重，然后直接reweight osd一步到位。先提供手动方式凑合用。</p>
<p>脚本地址：<a href="https://github.com/xiaqunfeng/ceph-ansible/tree/master/tools/ceph-pg-reweight" target="_blank" rel="noopener">https://github.com/xiaqunfeng/ceph-ansible/tree/master/tools/ceph-pg-reweight</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph luminous最佳部署实践]]></title>
      <url>http://xiaqunfeng.cc/2018/03/04/ceph-luminous-best-deploy-practise/</url>
      <content type="html"><![CDATA[<p>luminous版本ceph最佳部署实践，分别指定rocksdb、osd数据及元数据磁盘位置，最大化集群性能。<br><a id="more"></a></p>
<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>每个OSD对应需要4个磁盘分区（简单起见在一块磁盘上分的四个区）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  436K  0 rom</span><br><span class="line">vda    253:0    0   20G  0 disk</span><br><span class="line">├─vda1 253:1    0    2M  0 part</span><br><span class="line">├─vda2 253:2    0  500M  0 part /boot</span><br><span class="line">└─vda3 253:3    0 19.5G  0 part /</span><br><span class="line">vdd    253:48   0   50G  0 disk</span><br><span class="line">├─vdd1 253:49   0 1023M  0 part </span><br><span class="line">├─vdd2 253:50   0   10G  0 part</span><br><span class="line">├─vdd3 253:51   0   10G  0 part</span><br><span class="line">└─vdd4 253:52   0   29G  0 part</span><br></pre></td></tr></table></figure>
<p>四个分区分别用于：</p>
<table>
<thead>
<tr>
<th>分区</th>
<th>功能</th>
<th>磁盘介质</th>
<th>推荐大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>/dev/vdd1</td>
<td>OSD元数据存放</td>
<td>SSD</td>
<td>1G</td>
</tr>
<tr>
<td>/dev/vdd2</td>
<td>rocksdb数据存放</td>
<td>SSD</td>
<td></td>
</tr>
<tr>
<td>/dev/vdd3</td>
<td>rocksdb wal</td>
<td>SSD</td>
<td>5G</td>
</tr>
<tr>
<td>/dev/vdd4</td>
<td>实际数据存放</td>
<td>SATA</td>
<td>单块SATA盘</td>
</tr>
</tbody>
</table>
<h2 id="安装ceph"><a href="#安装ceph" class="headerlink" title="安装ceph"></a>安装ceph</h2><p><strong>注意：先不要安装OSD</strong></p>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum blue0,blue1,blue2</span><br><span class="line">    mgr: blue0(active)</span><br><span class="line">    osd: 0 osds: 0 up, 0 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   0 pools, 0 pgs</span><br><span class="line">    objects: 0 objects, 0 bytes</span><br><span class="line">    usage:   0 kB used, 0 kB / 0 kB avail</span><br><span class="line">    pgs:</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>1、修改配置文件 ceph.conf 中关于 osd 的部分，为每个OSD的不同部分指定磁盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[osd]</span><br><span class="line">osd mkfs type = xfs</span><br><span class="line">osd mkfs options xfs = -f -i size=2048</span><br><span class="line">osd mount options xfs = noatime,largeio,inode64,swalloc</span><br><span class="line">osd journal size = 5120</span><br><span class="line"></span><br><span class="line">osd objectstore = bluestore</span><br><span class="line">bluestore = true</span><br><span class="line">bluestore fsck on mount = true</span><br><span class="line">bluestore block create = true</span><br><span class="line">bluestore block db size = 67108864</span><br><span class="line">bluestore block db create = true</span><br><span class="line">bluestore block wal size = 134217728</span><br><span class="line">bluestore block wal create =true</span><br><span class="line"></span><br><span class="line">[osd.0]</span><br><span class="line">host = luminous0</span><br><span class="line">osd data = /var/lib/ceph/osd/ceph-0</span><br><span class="line">bluestore block db path = /dev/vdd2</span><br><span class="line">bluestore block wal path = /dev/vdd3</span><br><span class="line">bluestore block path = /dev/vdd4</span><br><span class="line"></span><br><span class="line">[osd.1]</span><br><span class="line">host = luminous1</span><br><span class="line">osd data = /var/lib/ceph/osd/ceph-1</span><br><span class="line">bluestore block db path = /dev/vdd2</span><br><span class="line">bluestore block wal path = /dev/vdd3</span><br><span class="line">bluestore block path = /dev/vdd4</span><br><span class="line"></span><br><span class="line">[osd.2]</span><br><span class="line">host = luminous2</span><br><span class="line">osd data = /var/lib/ceph/osd/ceph-2</span><br><span class="line">bluestore block db path = /dev/vdd2</span><br><span class="line">bluestore block wal path = /dev/vdd3</span><br><span class="line">bluestore block path = /dev/vdd4</span><br></pre></td></tr></table></figure>
<ul>
<li>db path为rocksdb 存放数据的位置</li>
<li>wal path 为rocksdb的原子操作位置</li>
<li>block path 为实际数据存放的位置</li>
<li>/dev/vdd1 作为osd的元数据存放位置</li>
</ul>
<p>2、重启 ceph-mon 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ceph-mon.target</span><br></pre></td></tr></table></figure>
<h2 id="手动安装OSD"><a href="#手动安装OSD" class="headerlink" title="手动安装OSD"></a>手动安装OSD</h2><p>例如，手动安装 osd.1 步骤如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lib/ceph/osd/ceph-1</span><br><span class="line">mkfs -t xfs -d name=/dev/vdd1 -f</span><br><span class="line">mount -noatime /dev/vdd1 /var/lib/ceph/osd/ceph-1</span><br><span class="line">chown ceph:ceph /var/lib/ceph/osd/ceph-1</span><br><span class="line"></span><br><span class="line">ceph osd crush add-bucket luminous1 host</span><br><span class="line">ceph osd crush move luminous1 root=default</span><br><span class="line"></span><br><span class="line">ceph osd create</span><br><span class="line">ceph-osd -i 1 --mkfs --mkkey</span><br><span class="line">ceph auth add osd.1 osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-1/keyring</span><br><span class="line">ceph osd crush add osd.1 0.04 host=luminous1</span><br><span class="line">ceph osd in 1</span><br><span class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-1</span><br><span class="line">systemctl start ceph-osd@1</span><br></pre></td></tr></table></figure>
<p>安装完后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-0</span><br><span class="line">总用量 40</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block -&gt; /dev/vdd4</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block.db -&gt; /dev/vdd2</span><br><span class="line">lrwxrwxrwx. 1 ceph ceph  9 7月  24 18:13 block.wal -&gt; /dev/vdd3</span><br><span class="line">-rw-r--r--. 1 ceph ceph  2 7月  24 18:13 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph 37 7月  24 18:13 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph 37 7月  24 18:13 fsid</span><br><span class="line">-rw-------. 1 ceph ceph 56 7月  24 18:13 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph  8 7月  24 18:13 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph 21 7月  24 18:13 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph  4 7月  24 18:13 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph  6 7月  24 18:13 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph 10 7月  24 18:13 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph  2 7月  24 18:13 whoami</span><br></pre></td></tr></table></figure>
<p>如果不更改配置，为OSD分别指定磁盘，安装完后的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-0/</span><br><span class="line">总用量 484</span><br><span class="line">-rw-r--r--. 1 root root         429 7月  25 10:59 activate.monmap</span><br><span class="line">-rw-r--r--. 1 ceph ceph           3 7月  25 10:59 active</span><br><span class="line">-rw-r--r--. 1 ceph ceph 10737418240 7月  25 10:59 block</span><br><span class="line">-rw-r--r--. 1 ceph ceph           2 7月  25 10:59 bluefs</span><br><span class="line">-rw-r--r--. 1 ceph ceph          37 7月  25 10:59 ceph_fsid</span><br><span class="line">-rw-r--r--. 1 ceph ceph          37 7月  25 10:59 fsid</span><br><span class="line">-rw-------. 1 ceph ceph          56 7月  25 10:59 keyring</span><br><span class="line">-rw-r--r--. 1 ceph ceph           8 7月  25 10:59 kv_backend</span><br><span class="line">-rw-r--r--. 1 ceph ceph          21 7月  25 10:59 magic</span><br><span class="line">-rw-r--r--. 1 ceph ceph           4 7月  25 10:59 mkfs_done</span><br><span class="line">-rw-r--r--. 1 ceph ceph           6 7月  25 10:59 ready</span><br><span class="line">-rw-r--r--. 1 ceph ceph           0 7月  25 10:59 systemd</span><br><span class="line">-rw-r--r--. 1 ceph ceph          10 7月  25 10:59 type</span><br><span class="line">-rw-r--r--. 1 ceph ceph           2 7月  25 10:59 whoami</span><br></pre></td></tr></table></figure>
<p>部署完后磁盘情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  436K  0 rom</span><br><span class="line">vda    253:0    0   20G  0 disk</span><br><span class="line">├─vda1 253:1    0    2M  0 part</span><br><span class="line">├─vda2 253:2    0  500M  0 part /boot</span><br><span class="line">└─vda3 253:3    0 19.5G  0 part /</span><br><span class="line">vdd    253:48   0   50G  0 disk</span><br><span class="line">├─vdd1 253:49   0 1023M  0 part /var/lib/ceph/osd/ceph-0</span><br><span class="line">├─vdd2 253:50   0   10G  0 part</span><br><span class="line">├─vdd3 253:51   0   10G  0 part</span><br><span class="line">└─vdd4 253:52   0   29G  0 part</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph iscsi网关]]></title>
      <url>http://xiaqunfeng.cc/2018/02/28/ceph-iscsi/</url>
      <content type="html"><![CDATA[<p>介绍三种iscsi target的选型：TGT、LIO、SCST。</p>
<a id="more"></a>
<p> Ceph iSCSI Gateway基本框架：<img src="http://oow6unnib.bkt.clouddn.com/ceph_iscsi_gateway.png" alt="ceph iscsi gateway"></p>
<h2 id="用户态（TGT）"><a href="#用户态（TGT）" class="headerlink" title="用户态（TGT）"></a>用户态（TGT）</h2><p>tgt是一个用户态的SCSI target框架。由于是基于用户态的框架，因此对集成同在用户态的RBD接口比较简单。</p>
<p>作为用户态框架，tgt在使用本地存储的情况下，性能相比SCST、LIO有一定差距的，如果从性能的角度考虑，tgt应该不推荐使用的，在新特性验证等方面是很合适的。</p>
<p>使用TGT的开源分布式存储项目：sheepdog 与 hlfs。</p>
<h2 id="内核态（LIO、SCST）"><a href="#内核态（LIO、SCST）" class="headerlink" title="内核态（LIO、SCST）"></a>内核态（LIO、SCST）</h2><h3 id="LIO"><a href="#LIO" class="headerlink" title="LIO"></a>LIO</h3><p>1）支持较多传输协议</p>
<p>2）代码并入linux内核，减少了手动编译内核的麻烦。</p>
<p>3）提供了python版本的编程接口rtslib。</p>
<p>4）LIO在不断backport SCST的功能到linux内核，社区的力量是强大的。</p>
<p>5）LIO也支持一些SCST没有的功能。如“会话多连接”（MC/S）。</p>
<blockquote>
<p>MC/S 让 initiator 可以和 target 在一条或多条物理路径上建立多条连接。这样，在一条路径发生错误的时候，已经建立好的会话可以不中断会话，直接使用其他的路径。MC/S 还可以用来进行所有连接之间的负载均衡。这种情况下，会在所有通信路径上保持会话命令的顺序性。</p>
</blockquote>
<p>MCS是一个比较鸡肋的feature，因为现在Linux内核已经有Device Mapper的支持。</p>
<p>6）LIO支持最高级别的ERL。</p>
<blockquote>
<p>iSCSI 连接的错误可能会发生在三个层面上：会话、校验或是连接层。错误恢复工作也可以在这三个层面开始进行，这样就可以在当前的层面开始进行恢复，不会让错误到达下一个层面。错误恢复首先是检查断开的连接。在这种情况下，iSCSI initiator 驱动会主动建立新的到 target 的 TCP 连接它会告诉 target，SCSI 指令路径已经变到新的连接上了。这样 target 就可以在新的连接上处理 SCSI 命令了。这时，上层的 SCSI 驱动对新的连接已经建立、控制信息已经通过新连接传输的事还是毫无知觉的。iSCSI 会话在这期间会保持正常，不会重新变换状态。LIO 支持的最大错误恢复级别（ERL）为2，这就是说，它可以在会话、校验或连接层进行错误恢复。而SCST 支持的 ERL 为 0，也就是说，它智能恢复会话级别的错误，所有连接层面的错误都会转到 SCSI 驱动层面来处理。</p>
</blockquote>
<h3 id="SCST"><a href="#SCST" class="headerlink" title="SCST"></a>SCST</h3><p>1）支持更多传输协议</p>
<p>2）针对性能做了特殊的优化</p>
<p>3）除了基本的SCSI协议支持外，还有一些高级支持：</p>
<p>SCST支持永久性预留（Persistent Reservation, PR）</p>
<blockquote>
<p>这是一个用于高可用集群中的存储设备的 I/O 隔离与存储设备故障切换、接管的特性。通过使用 PR 命令，initiator 可以在一个 target 上建立、抢占、查询、重置预留策略。在故障接管过程中，新的虚拟资源可以重置老的虚拟资源的预留策略，从而让故障切换更快、更容易地进行。</p>
</blockquote>
<p>SCST 可以使用异步事件通知（AEN）来通告会话状态的变更</p>
<blockquote>
<p>AEN 是一个 SCSI target 用来向 initiator 进行 target 端的事件告知的协议特性，即使在没有服务请求的时候也可以进行。于是 initiator 就可以在 target 端发生事件时，如设备插入、移除、调整尺寸或更换介质时，可以得到通知。这让 initiator 可以以即插即用的方式看到 target 的变化。</p>
</blockquote>
<p>4）SCST 的开发者声称，它们的设计在健壮性和安全性方面更加符合 SCSI 标准。</p>
<blockquote>
<p>SCSI 协议要求，如果一个 initiator 要清除另一个 initiator 的预留资源时，预留者必须要得到清除通知，否则，多个 initiator 都可能来改变预留数据，就可能会破坏数据。SCST 可以实现安全的预留、释放操作，避免类似事情发生。</p>
</blockquote>
<p>5）SCST 也支持非对称逻辑卷分配（ALUA）。</p>
<blockquote>
<p>ALUA 允许 target 管理员来管理 target 的访问状态和路径属性。这让多路径路由机制可以选择最好的路径，从而根据 target 的访问状态，优化带宽的使用。换句话说，在多路径环境下，target 管理员可以通过改变访问状态来调整 initiator 的路径。</p>
</blockquote>
<p>6）各大存储服务提供商都是基于SCST。</p>
<p>7）提供更细粒度的访问控制策略以及QoS保证机制（限制initiator连接的个数）。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>SCST和LIO，工作在内核态，缺点如下：</p>
<p>1、一旦出问题，会导致系统挂掉，直接影响跑在系统上的其他线上服务。</p>
<p>2、SCSI与LIO作为通用的SCSI Target实现，在处理完iSCSI协议后，会把SCSI的处理交给内核SCSI Driver去处理，这对支持分布式文件做二次开发来说，相对更加困难。</p>
<p>3、SCST 的kernel部分没有并入linux，需要手工编译。</p>
<p>4、LIO不支持AEN，所以target状态发生变化时，只能通过IO或者用户手动触发以检测处理变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>SCSI框架</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>TGT</td>
<td>用户态接口，可使用Ceph librbd</td>
<td>librbd 性能较差，FC驱动还不支持</td>
</tr>
<tr>
<td>LIO</td>
<td>性能好，支持用户态和内核态接口，加入linux内核</td>
<td>特性支持不如SCST</td>
</tr>
<tr>
<td>SCST</td>
<td>稳定，性能好，支持用户态和内核态接口</td>
<td>没有纳入linux内核，升级比较麻烦</td>
</tr>
</tbody>
</table>
<p>如果需求只是构建一个iSCSI target，并且规模不是很大，tgt是一个不错的选择。<br>如果要构建一个企业级的存储方案，即高性能、高稳定性的，并且围绕这个有长远计划的，SCST是正确的选择。<br>如果对性能、稳定性要求不是那么高，但又想支持FC、SRP等协议，可以选择LIO。</p>
<p><strong>参考资料</strong></p>
<p><a href="http://infinicloud.cn/blog/1/" target="_blank" rel="noopener">基于ceph RBD的iscsi target实现分析</a></p>
<p><a href="http://www.cnblogs.com/bodhitree/p/6016331.html" target="_blank" rel="noopener">iscsi与ceph</a></p>
<p><a href="http://chuansong.me/n/2297546" target="_blank" rel="noopener">ceph iscsi gateway demo 安装配置</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph ansible使用手册]]></title>
      <url>http://xiaqunfeng.cc/2018/02/28/ceph-ansible-manual/</url>
      <content type="html"><![CDATA[<p>该文档介绍利用ansible来部署ceph集群<br>github：<a href="https://github.com/xiaqunfeng/ceph-ansible" target="_blank" rel="noopener">https://github.com/xiaqunfeng/ceph-ansible</a></p>
<a id="more"></a>
<p>新增role的使用方法详见github里的README.md</p>
<h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install-ansible.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，默认安装的是ansible的最新版，最好安装ansible版本为2.3.X.X。因为该改进的ceph-ansible是基于ansible 2.3版本的，为了避免版本不匹配带来的问题。</p>
</blockquote>
<h2 id="设置机器组"><a href="#设置机器组" class="headerlink" title="设置机器组"></a>设置机器组</h2><p>在文件 <code>/etc/ansible/hosts</code> 中添加如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/ansible/hosts</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[mons]</span><br><span class="line">ceph-0</span><br><span class="line">ceph-1</span><br><span class="line">ceph-2</span><br><span class="line"></span><br><span class="line">[osds]</span><br><span class="line">ceph-0</span><br><span class="line">ceph-1</span><br><span class="line">ceph-2</span><br><span class="line"></span><br><span class="line">[rgws]</span><br><span class="line">ceph-0</span><br></pre></td></tr></table></figure>
<p>mons表示将要安装mon的机器组，osds表示osd机器组，rgws表示要安装rgw网关的机器组。关于其他的机器组，可以在 <code>site.yml</code> 文件中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># cat site.yml</span><br><span class="line">...</span><br><span class="line">- hosts:</span><br><span class="line">  - mons</span><br><span class="line">  - agents</span><br><span class="line">  - osds</span><br><span class="line">  - mdss</span><br><span class="line">  - rgws</span><br><span class="line">  - nfss</span><br><span class="line">  - restapis</span><br><span class="line">  - rbdmirrors</span><br><span class="line">  - clients</span><br><span class="line">  - iscsigws</span><br><span class="line">  - mgrs</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看所有机器是否都能无密登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ansible -m ping all</span><br><span class="line">ceph-1 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">ceph-0 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">ceph-2 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>编辑配置文件：<code>group_vars/all.yml</code></p>
<p>主要修改一下几个配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># or &apos;distro&apos; or &apos;local&apos;</span><br><span class="line">ceph_origin: &apos;upstream&apos;</span><br><span class="line">...</span><br><span class="line">ceph_stable: true</span><br><span class="line">ceph_mirror: http://mirrors.163.com/ceph</span><br><span class="line">ceph_stable_key: http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line">ceph_stable_release: kraken</span><br><span class="line">ceph_stable_repo: &quot;&#123;&#123; ceph_mirror &#125;&#125;/rpm-&#123;&#123; ceph_stable_release &#125;&#125;&quot;	# ubuntu系统的话记得把rpm改成debian</span><br><span class="line">...</span><br><span class="line">ceph_stable_redhat_distro: el7	# ubuntu系统不需要该选项</span><br><span class="line">...</span><br><span class="line">monitor_interface: eth0</span><br><span class="line">...</span><br><span class="line">public_network: 172.20.2.0/24</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="osd"><a href="#osd" class="headerlink" title="osd"></a>osd</h3><p>编辑配置文件：<code>group_vars/osds.yml</code></p>
<p>选择一种部署场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">journal_collocation</span><br><span class="line">raw_multi_journal</span><br><span class="line">dmcrypt_journal_collocation</span><br><span class="line">dmcrypt_dedicated_journal</span><br><span class="line">bluestore</span><br><span class="line">osd_directory</span><br></pre></td></tr></table></figure>
<p>根据不同的场景来编辑如下两个选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">devices:</span><br><span class="line">...</span><br><span class="line">raw_journal_devices:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最常用的场景解释：</p>
<p>journal_collocation：日志盘和数据盘共用一块磁盘，部署的时候不需要分区，只需要指定 devices磁盘就好。</p>
<p>raw_multi_journal：日志盘和数据盘分开指定，devices指定数据盘，raw_journal_devices指定日志盘，都是磁盘主分区。</p>
<p>bluestore：部署bluestore，只需要指定devices盘。当然最佳实践的话需要手动分4个区来部署。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>修改部署yml文件，注释掉不需要安装的选项，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># cat site.yml</span><br><span class="line">...</span><br><span class="line">- hosts: mons</span><br><span class="line">  gather_facts: false</span><br><span class="line">  become: True</span><br><span class="line">  roles:</span><br><span class="line">  - ceph-mon</span><br><span class="line"></span><br><span class="line">#- hosts: agents</span><br><span class="line">#  gather_facts: false</span><br><span class="line">#  become: True</span><br><span class="line">#  roles:</span><br><span class="line">#  - ceph-agent</span><br><span class="line"></span><br><span class="line">- hosts: osds</span><br><span class="line">  gather_facts: false</span><br><span class="line">  become: True</span><br><span class="line">  roles:</span><br><span class="line">  - ceph-osd</span><br><span class="line"></span><br><span class="line">- hosts: rgws</span><br><span class="line">  gather_facts: false</span><br><span class="line">  become: True</span><br><span class="line">  roles:</span><br><span class="line">  - ceph-rgw</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过ansible-playbook来运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ansible-playbook site.yml</span><br></pre></td></tr></table></figure>
<p>更多关于ansible的部署情况可以参见官方文档：<a href="https://github.com/ceph/ceph-ansible/wiki" target="_blank" rel="noopener">https://github.com/ceph/ceph-ansible/wiki</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Faster-R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/12/14/Faster-R-CNN/</url>
      <content type="html"><![CDATA[<p>Faster R-CNN论文阅读小笔记<br><a id="more"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>faster RCNN ~= RPN + fast RCNN</p>
<p>用RPN代替fast RCNN中的Selective Search方法</p>
<p><strong>架构图</strong></p>
<p><img src="http://img.blog.csdn.net/20170314163622365" alt="img"></p>
<p>从 Fast R-CNN 中可以发现，目标检测的时间减少了，这时候，发现生成候选框成了性能瓶颈，所以，下一个改进的两个要点就是：</p>
<ul>
<li>1、将候选框的选取也放到GPU中去实现</li>
<li>2、共享计算，共享已计算出的特征图</li>
</ul>
<p><strong>R-CNN系列的架构演变</strong></p>
<p><img src="http://img.blog.csdn.net/20160414164536029" alt="r-cnn架构对比"></p>
<p>目标检测的四个基本步骤被统一到一个大框架中，计算都在GPU中完成计算，提高了速度，同时消除了重复计算。</p>
<h2 id="RPN"><a href="#RPN" class="headerlink" title="RPN"></a>RPN</h2><p><strong>网络结构</strong></p>
<p><img src="http://img.blog.csdn.net/20160415133947737" alt="arc"></p>
<p>用的是5层的ZF模型。</p>
<h3 id="anchor的生成"><a href="#anchor的生成" class="headerlink" title="anchor的生成"></a>anchor的生成</h3><p>遍历Conv layers计算获得的feature maps</p>
<p><img src="http://img.blog.csdn.net/20170322103903632" alt="img"></p>
<p>对于特征图中的每一个点，以该点为中心，考虑3种长宽比（1:1, 1:2, 2:1）和三种面积大小（128，256，512）共9种窗口，这些候选框即为anchors。示意图如下：</p>
<p><img src="http://img.blog.csdn.net/20170322103823615" alt="img"></p>
<p>关于anchors的生成代码如下：</p>
<p><strong><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="noopener">generate_anchors.py</a></strong></p>
<h3 id="Bounding-box-regression"><a href="#Bounding-box-regression" class="headerlink" title="Bounding-box regression"></a>Bounding-box regression</h3><p>如图，绿色框为飞机的Ground Truth(GT)，红色为提取的foreground anchors。这里得对红色的框进行微调，使得foreground anchors和GT更加接近。</p>
<p><img src="http://img.blog.csdn.net/20170321000420426" alt="img"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于窗口一般使用四维向量(x, y, w, h)表示，分别表示窗口的中心点坐标和宽高。</p>
<p>如下图所示，红色的框A代表原始的Foreground Anchors，绿色的框G代表目标的GT。这里要使得输入A经过映射得到一个跟真实窗口G更接近的回归窗口G’。</p>
<p><img src="http://img.blog.csdn.net/20170321221228658" alt="img"></p>
<p>给定：anchor A=(Ax, Ay, Aw, Ah)，GT=[Gx, Gy, Gw, Gh]</p>
<p>寻找变换<strong>F</strong>：<strong>F</strong>(Ax, Ay, Aw, Ah)=(G’x, G’y, G’w, G’h)</p>
<p>其中：(G’x, G’y, G’w, G’h)≈(Gx, Gy, Gw, Gh)</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、平移</p>
<p><img src="http://img.blog.csdn.net/20170322104630982" alt="img"></p>
<p>2、缩放</p>
<p><img src="http://img.blog.csdn.net/20170322104634390" alt="img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/fast_rcnn/bbox_transform.py" target="_blank" rel="noopener">bbox_transform.py</a></p>
<p>函数：bbox_transform_inv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def bbox_transform_inv(boxes, deltas):</span><br><span class="line">    if boxes.shape[0] == 0:</span><br><span class="line">        return np.zeros((0, deltas.shape[1]), dtype=deltas.dtype)</span><br><span class="line"></span><br><span class="line">    boxes = boxes.astype(deltas.dtype, copy=False)</span><br><span class="line"></span><br><span class="line">    widths = boxes[:, 2] - boxes[:, 0] + 1.0</span><br><span class="line">    heights = boxes[:, 3] - boxes[:, 1] + 1.0</span><br><span class="line">    ctr_x = boxes[:, 0] + 0.5 * widths</span><br><span class="line">    ctr_y = boxes[:, 1] + 0.5 * heights</span><br><span class="line"></span><br><span class="line">    dx = deltas[:, 0::4]</span><br><span class="line">    dy = deltas[:, 1::4]</span><br><span class="line">    dw = deltas[:, 2::4]</span><br><span class="line">    dh = deltas[:, 3::4]</span><br><span class="line"></span><br><span class="line">    pred_ctr_x = dx * widths[:, np.newaxis] + ctr_x[:, np.newaxis]</span><br><span class="line">    pred_ctr_y = dy * heights[:, np.newaxis] + ctr_y[:, np.newaxis]</span><br><span class="line">    pred_w = np.exp(dw) * widths[:, np.newaxis]</span><br><span class="line">    pred_h = np.exp(dh) * heights[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">    pred_boxes = np.zeros(deltas.shape, dtype=deltas.dtype)</span><br><span class="line">    # x1</span><br><span class="line">    pred_boxes[:, 0::4] = pred_ctr_x - 0.5 * pred_w</span><br><span class="line">    # y1</span><br><span class="line">    pred_boxes[:, 1::4] = pred_ctr_y - 0.5 * pred_h</span><br><span class="line">    # x2</span><br><span class="line">    pred_boxes[:, 2::4] = pred_ctr_x + 0.5 * pred_w</span><br><span class="line">    # y2</span><br><span class="line">    pred_boxes[:, 3::4] = pred_ctr_y + 0.5 * pred_h</span><br><span class="line"></span><br><span class="line">    return pred_boxes</span><br></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>RPN和Fast R-CNN都是独立训练的，要用不同方式修改它们的卷积层。因此需要开发一种允许两个网络间共享卷积层的技术，而不是分别学习两个网络。</p>
<p>论文中给出了三种训练具有共享特征的网络的解决方案：</p>
<p>1、交替训练</p>
<p>先训练RPN，并使用提案训练Fast R-CNN。然后，使用Fast R-CNN微调过后的网络初始化RPN，并重复此过程。这是论文中所有实验所使用的解决方案。</p>
<p>2、近似联合训练</p>
<p>RPN和Fast R-CNN网络在训练期间被合并到一个网络中。forward过程中，region proposal固定，训练Fast R-CNN。backward过程中，共享层包含RPN和Fast R-CNN两部分的损失。</p>
<p>忽略了衍生的w.r.t.提案框的坐标也是网络响应，所以产生的结果是近似。但与交替训练相比，训练时间减少了约25-50％。</p>
<p>3、非近似联合训练</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>源码地址：</p>
<p><a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/tools/train_faster_rcnn_alt_opt.py" target="_blank" rel="noopener">train_faster_rcnn_alt_opt.py</a></p>
<p>根据代码，提取并总结的步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Stage 1 RPN, init from ImageNet model (M0 -&gt; M1)</span><br><span class="line">2. Stage1 RPN, generate proposals (M1 -&gt; P1)</span><br><span class="line">3. Stage1 Fast R-CNN using RPN  proposals, init from ImageNet model (M0, P1 -&gt; M2)</span><br><span class="line">4. Stage2 RPN, init from stage 1 Fast R-CNN model (M2 -&gt; M3)</span><br><span class="line">5. Stage2 RPN, generate proposals (M3 -&gt; P2)</span><br><span class="line">6. Stage2 Fast R-CNN, init from stage 2 RPN R-CNN model (M3,P2 -&gt; M4)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【代码阅读】generate_anchors.py]]></title>
      <url>http://xiaqunfeng.cc/2017/12/05/faster-r-cnn-generate-anchors/</url>
      <content type="html"><![CDATA[<p>阅读Faster R-CNN里产生anchors的代码。<br><a id="more"></a></p>
<p>原代码地址：<a href="https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="noopener">https://github.com/rbgirshick/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py</a></p>
<p>注释代码地址：<a href="https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py" target="_blank" rel="noopener">https://github.com/xiaqunfeng/py-faster-rcnn/blob/master/lib/rpn/generate_anchors.py</a></p>
<h2 id="generate-anchors-py"><a href="#generate-anchors-py" class="headerlink" title="generate_anchors.py"></a>generate_anchors.py</h2><p>功能：生成多尺度多宽高比的anchors</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"># --------------------------------------------------------</span><br><span class="line"># Faster R-CNN</span><br><span class="line"># Copyright (c) 2015 Microsoft</span><br><span class="line"># Licensed under The MIT License [see LICENSE for details]</span><br><span class="line"># Written by Ross Girshick and Sean Bell</span><br><span class="line"># --------------------------------------------------------</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Verify that we compute the same anchors as Shaoqing&apos;s matlab implementation:</span><br><span class="line">#</span><br><span class="line">#    &gt;&gt; load output/rpn_cachedir/faster_rcnn_VOC2007_ZF_stage1_rpn/anchors.mat</span><br><span class="line">#    &gt;&gt; anchors</span><br><span class="line">#</span><br><span class="line">#    anchors =</span><br><span class="line">#</span><br><span class="line">#       -83   -39   100    56</span><br><span class="line">#      -175   -87   192   104</span><br><span class="line">#      -359  -183   376   200</span><br><span class="line">#       -55   -55    72    72</span><br><span class="line">#      -119  -119   136   136</span><br><span class="line">#      -247  -247   264   264</span><br><span class="line">#       -35   -79    52    96</span><br><span class="line">#       -79  -167    96   184</span><br><span class="line">#      -167  -343   184   360</span><br><span class="line"></span><br><span class="line">#array([[ -83.,  -39.,  100.,   56.],</span><br><span class="line">#       [-175.,  -87.,  192.,  104.],</span><br><span class="line">#       [-359., -183.,  376.,  200.],</span><br><span class="line">#       [ -55.,  -55.,   72.,   72.],</span><br><span class="line">#       [-119., -119.,  136.,  136.],</span><br><span class="line">#       [-247., -247.,  264.,  264.],</span><br><span class="line">#       [ -35.,  -79.,   52.,   96.],</span><br><span class="line">#       [ -79., -167.,   96.,  184.],</span><br><span class="line">#       [-167., -343.,  184.,  360.]])</span><br><span class="line"></span><br><span class="line"># base_size =16 是因为从conv4层出来的最小的检测大小是16个像素</span><br><span class="line"># 在 fast_rcnn/config.py中有定义：__C.TRAIN.RPN_MIN_SIZE = 16</span><br><span class="line"># ratios 是宽高比，即 w:h = 1:2, 1:1, 2:1</span><br><span class="line"># scales = 8, 16, 32</span><br><span class="line"># [0，0，15，15]这四个数分别表示[x_l,y_l,x_r,y_r]，表示左上角和右下角的坐标</span><br><span class="line">def generate_anchors(base_size=16, ratios=[0.5, 1, 2],</span><br><span class="line">                     scales=2**np.arange(3, 6)):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Generate anchor (reference) windows by enumerating aspect ratios X</span><br><span class="line">    scales wrt a reference (0, 0, 15, 15) window.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    base_anchor = np.array([1, 1, base_size, base_size]) - 1  #初始基准anchor[0，0，15，15]</span><br><span class="line">    ratio_anchors = _ratio_enum(base_anchor, ratios)  #枚举三种宽高比，得到3*4维anchor矩阵</span><br><span class="line">    #垂直方向上堆叠数组</span><br><span class="line">    anchors = np.vstack([_scale_enum(ratio_anchors[i, :], scales)</span><br><span class="line">                         for i in xrange(ratio_anchors.shape[0])]) #读取矩阵第一维大小，为3</span><br><span class="line">    return anchors</span><br><span class="line"></span><br><span class="line"># 根据输入的anchor[x,y,w,h]，返回宽、高、中心坐标：w,h,(x_ctr, y_ctr)</span><br><span class="line">def _whctrs(anchor):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Return width, height, x center, and y center for an anchor (window).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    w = anchor[2] - anchor[0] + 1  #anchor里第三个值减去第一个值得到w</span><br><span class="line">    h = anchor[3] - anchor[1] + 1  #anchor里第四个值减去第二个值得到h</span><br><span class="line">    x_ctr = anchor[0] + 0.5 * (w - 1)  #通过左下角的点和w、h得到中心点</span><br><span class="line">    y_ctr = anchor[1] + 0.5 * (h - 1)</span><br><span class="line">    return w, h, x_ctr, y_ctr</span><br><span class="line"></span><br><span class="line"># 给定一组宽高向量，输出向量维度个数个anchor</span><br><span class="line">def _mkanchors(ws, hs, x_ctr, y_ctr):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Given a vector of widths (ws) and heights (hs) around a center</span><br><span class="line">    (x_ctr, y_ctr), output a set of anchors (windows).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    ws = ws[:, np.newaxis]  #将数组转置成 X*1 维的矩阵，X为ws数组中元素的个数</span><br><span class="line">    hs = hs[:, np.newaxis]</span><br><span class="line">    anchors = np.hstack((x_ctr - 0.5 * (ws - 1),  #水平方向上将数组堆叠起来，得到一个X*4维的矩阵</span><br><span class="line">                         y_ctr - 0.5 * (hs - 1),  #[[-3.5,  2, 18.5, 13]</span><br><span class="line">                         x_ctr + 0.5 * (ws - 1),  # [   0,  0,   15, 15]</span><br><span class="line">                         y_ctr + 0.5 * (hs - 1))) # [ 2.5, -3, 12.5, 18]]</span><br><span class="line">    return anchors</span><br><span class="line"></span><br><span class="line"># 枚举一个anchor的三种宽高比，ratios[0.5，1，2]</span><br><span class="line">def _ratio_enum(anchor, ratios):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Enumerate a set of anchors for each aspect ratio wrt an anchor.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor) #得到框、高、中心点</span><br><span class="line">    size = w * h  </span><br><span class="line">    size_ratios = size / ratios          #[512，256，128]</span><br><span class="line">    ws = np.round(np.sqrt(size_ratios))  #[23，16，11]</span><br><span class="line">    hs = np.round(ws * ratios)           #[12，16，22]</span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr) #输出三个预测窗口</span><br><span class="line">    return anchors</span><br><span class="line"></span><br><span class="line"># 枚举输入anchor的三种尺度，scales[8，16，32]</span><br><span class="line">def _scale_enum(anchor, scales):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Enumerate a set of anchors for each scale wrt an anchor.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    w, h, x_ctr, y_ctr = _whctrs(anchor)</span><br><span class="line">    ws = w * scales  #同比例扩大宽高</span><br><span class="line">    hs = h * scales</span><br><span class="line">    anchors = _mkanchors(ws, hs, x_ctr, y_ctr)</span><br><span class="line">    return anchors</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    import time</span><br><span class="line">    t = time.time()</span><br><span class="line">    a = generate_anchors()  #入口函数</span><br><span class="line">    print time.time() - t</span><br><span class="line">    print a</span><br><span class="line">    from IPython import embed; embed()</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】Fast R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/11/25/Fast-R-CNN/</url>
      <content type="html"><![CDATA[<p>Fast R-CNN 是 RBG大神基于R-CNN的优化，论文阅读记录如下。<br><a id="more"></a></p>
<p>源码：<a href="https://github.com/rbgirshick/fast-rcnn" target="_blank" rel="noopener">https://github.com/rbgirshick/fast-rcnn</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>简化了最先进的基于卷积网络的目标检测器的训练过程（R-CNN）。提出一个单阶段训练算法，联合学习候选框分类和修正他们的空间位置。</p>
<p>所得到的方法用来训练非常深的检测网络（例如VGG16） 比R-CNN快9倍，比SPPnet快3倍。在运行时，检测网络在PASCAL VOC 2012数据集上实现最高准确度，其中mAP为66％（R-CNN为62％），每张图像处理时间为0.3秒，不包括候选框的生成。测试时间比R-CNN快213倍。</p>
<h3 id="R-CNN缺点："><a href="#R-CNN缺点：" class="headerlink" title="R-CNN缺点："></a>R-CNN缺点：</h3><p>1、训练过程是多级流水线（multi-stage pipeline）</p>
<ul>
<li>R-CNN首先使用目标候选框对卷积神经网络使用log损失进行微调。</li>
<li>然后，它将卷积神经网络得到的特征送入SVM。 这些SVM作为目标检测器，替代通过微调学习的softmax分类器。 </li>
<li>在第三个训练阶段，学习检测框回归。</li>
</ul>
<p>2、训练时时间和空间开销大</p>
<p>对于SVM和检测框回归训练，从每个图像中的每个目标候选框提取特征，并写入磁盘。对于非常深的网络，如VGG16，这个过程在单个GPU上需要2.5天（VOC07 trainval上的5k个图像）。这些特征需要数百GB的存储空间。</p>
<p>3、目标检测速度慢</p>
<p>在测试时，从每个测试图像中的每个目标候选框提取特征。用VGG16网络检测目标每个图像需要47秒（在GPU上）。</p>
<p>R-CNN很慢是因为它为每个目标候选框进行卷积神经网络正向传递，而不共享计算。</p>
<p><strong>因为是分阶段训练，训练SVM和bbox回归时无法更新前面CNN的参数，模型精度上不去。</strong></p>
<h3 id="SPPnet"><a href="#SPPnet" class="headerlink" title="SPPnet"></a>SPPnet</h3><p>SPPnet通过共享计算加速R-CNN。SPPnet计算整个输入图像的卷积特征图，然后使用从共享特征图提取的特征向量来对每个候选框进行分类。通过最大池化将候选框内的特征图转化为固定大小的输出（例如，6X6）来提取针对候选框的特征。多个输出被池化，然后连接成空间金字塔池。SPPnet在测试时将R-CNN加速10到100倍。由于更快的候选框特征提取训练时间也减少3倍。</p>
<p>缺点：</p>
<ul>
<li>分阶段训练网络：选取候选区域、训练CNN、训练SVM、训练bbox回归器.</li>
<li>特征需要写入磁盘</li>
<li>训练SVM，bbox回归时算法不能更新卷积层的参数，这会影响网络的精度</li>
</ul>
<h3 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h3><p>针对上述问题，Fast R-CNN的想法是将整个模型分成两步：</p>
<ul>
<li>第一步是选取候选区域;</li>
<li>第二步就是提出一个RoI层，整合了整个模型，把CNN、变换层、SVM分类器、bbox回归这几个模块整一起，大家一起训练</li>
</ul>
<p>新的模型将多个训练阶段合并，训练后面阶段的同时可以更新前面阶段的参数，模型收敛的更好了。同时因为多个阶段合并，候选区域的特征不需要再写入磁盘，一直在显存中，训练的速度大大的提升。</p>
<h2 id="architecture-and-training"><a href="#architecture-and-training" class="headerlink" title="architecture and training"></a>architecture and training</h2><p>架构图：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/fastrcnn.jpg" alt="fastrcnn"></p>
<p>Fast R-CNN网络将整个图像和一组候选框作为输入。</p>
<p>1、网络首先使用几个卷积层（conv）和最大池化层来处理整个图像，以产生卷积特征图。</p>
<p>2、然后，对于每个候选框，RoI池化层从特征图中提取固定长度的特征向量。</p>
<p>把图片的候选区域映射到feature map得到对应的patch(这和SPPNet的处理类似)。然后把这个patch塞给ROI层(Region of interest)得到固定大小的的特征向量(feature vector).</p>
<p>3、每个特征向量被送入一系列全连接（fc）层中，其最终分支成两个同级输出层 ：</p>
<ul>
<li>一个输出K个类别加上1个背景类别的Softmax概率估计</li>
<li>另一个作为bbox回归，输出回归的选框数据。即为K个类别的每一个类别输出四个实数值。每组4个值表示K个类别的一个类别的检测框位置的修正。</li>
</ul>
<h3 id="ROI-pooling-layer"><a href="#ROI-pooling-layer" class="headerlink" title="ROI pooling layer"></a>ROI pooling layer</h3><p>作用：把不同尺寸的侯选区域提取特征变换成为固定大小的特征向量</p>
<p>每个RoI由指定其左上角(r,c)及其高度和宽度(h,w)的四元组(r,c,h,w)定义。</p>
<p>RoI最大池化通过将大小为 h×w 的RoI窗口分割成 H×W 个网格，子窗口大小约 h/H×w/W，然后对每个子窗口执行最大池化，并将输出合并到相应的输出网格单元中。其中 H 和 W 是层的超参数，独立于任何特定的RoI。</p>
<p>通过该层，可以将特征图上大小不一的候选区域转变为大小统一的数据，送入下一层。 </p>
<h3 id="fine-tuning-for-detection-检测微调"><a href="#fine-tuning-for-detection-检测微调" class="headerlink" title="fine-tuning for detection(检测微调)"></a>fine-tuning for detection(检测微调)</h3><p>用反向传播训练所有网络权重是Fast R-CNN的重要能力。</p>
<p>1、为什么SPPnet无法更新低于空间金字塔池化层的权重？</p>
<p>根本原因是当每个训练样本（即RoI）来自不同的图像时，通过SPP层的反向传播是非常低效的，这正是训练R-CNN和SPPnet网络的方法。低效的部分是因为每个RoI可能具有非常大的感受野，通常跨越整个输入图像。由于正向传播必须处理整个感受野，训练输入很大（通常是整个图像）。</p>
<p>2、提出了一种更有效的训练方法：利用训练期间的特征共享</p>
<p><strong>分层采样</strong></p>
<p>在Fast RCNN网络训练中，随机梯度下降（SGD）的小批量是被分层采样的，首先采样N个图像，然后从每个图像采样R/N个 RoI。</p>
<blockquote>
<p>关键的是，来自同一图像的RoI在向前和向后传播中共享计算和内存。减N，就减少了小批量的计算。例如，当N=2和R=128时，得到的训练方案比从128幅不同的图采样一个RoI（即R-CNN和SPPnet的策略）快64倍。</p>
</blockquote>
<p>这个策略的一个令人担心的问题是它可能导致训练收敛变慢，因为来自相同图像的RoI是相关的。然而在实际情况中该问题并不存在，当N=2和R=128时，我们使用比R-CNN更少的SGD迭代就获得了良好的结果。</p>
<p><strong>更加精细的训练过程</strong></p>
<p>在微调阶段联合优化Softmax分类器和检测框回归，而不是分别在三个独立的阶段训练softmax分类器，SVM和回归器。</p>
<h4 id="多任务损失（multi-task-loss）"><a href="#多任务损失（multi-task-loss）" class="headerlink" title="多任务损失（multi-task loss）"></a>多任务损失（multi-task loss）</h4><p>Fast R-CNN在FC层后有两个分支,一个是SVM分类器，一个是bbox回归。</p>
<p>结论就是：把两个分支的损失弄到一起</p>
<blockquote>
<p>具体没太看懂，后续再补</p>
</blockquote>
<h2 id="Fast-R-CNN检测"><a href="#Fast-R-CNN检测" class="headerlink" title="Fast R-CNN检测"></a>Fast R-CNN检测</h2><p>一旦Fast R-CNN网络被微调完毕，检测相当于运行前向传播（假设候选框是预先计算的）。网络将图像（或图像金字塔，编码为图像列表）和待计算概率的R个候选框的列表作为输入。在测试的时候，R通常在2000左右，虽然我们将考虑将它变大（约45k）的情况。当使用图像金字塔时，每个RoI被缩放，使其最接近 R-CNN 中的224个像素。</p>
<p>对于每个测试的RoI r，正向传播输出类别后验概率分布p和相对于r的预测的检测框框偏移集合（K个类别中的每一个获得其自己的精细检测框预测）。使用估计的概率Pr(class=k|r)≜pk为每个对象类别kk分配rr的检测置信度。然后，使用R-CNN算法的设置和对每个类别独立执行非最大抑制。</p>
<h3 id="使用截断的SVD来进行更快的检测"><a href="#使用截断的SVD来进行更快的检测" class="headerlink" title="使用截断的SVD来进行更快的检测"></a>使用截断的SVD来进行更快的检测</h3><p>对于整体图像分类，与卷积层相比，计算全连接层花费的时间较小。相反，为了检测，要处理的RoI的数量很大，并且接近一半的正向传递时间用于计算全连接层。大的全连接层容易通过用截短的SVD压缩来加速。</p>
<p>为了压缩网络，对应于W的单个全连接层由两个全连接层替代，中间以一个低纬数据相连。在它们之间没有非线性。当RoI的数量大时，这种简单的压缩方法给出良好的加速。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Fast RCNN方法修正了R-CNN和SPPnet的缺点，同时提高其速度和准确性，有以下几个优点：</p>
<ul>
<li>比R-CNN和SPPnet具有更高的目标检测精度（mAP）。</li>
<li>训练是使用多任务损失的单阶段训练。</li>
<li>训练可以更新所有网络层参数。</li>
<li>不需要磁盘空间缓存特征。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【论文阅读】R-CNN]]></title>
      <url>http://xiaqunfeng.cc/2017/11/24/R-CNN/</url>
      <content type="html"><![CDATA[<p>该论文是利用深度学习进行目标检测的开山之作<br><a id="more"></a></p>
<p>原文：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Girshick_Rich_Feature_Hierarchies_2014_CVPR_paper.pdf" target="_blank" rel="noopener">R-CNN</a>，</p>
<p>teach report v5：<a href="https://arxiv.org/pdf/1311.2524v5.pdf" target="_blank" rel="noopener">teach report v5</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要解决了两个问题：</p>
<p>1、如何确定物体位置，即建模</p>
<p>这个模型是Region proposal + CNN，所以叫R-CNN</p>
<p>本文通过传统的无监督的与类别无关的方法提取proposal，然后利用CNN对于这些矩形框进行特征提取；对于提取到的特征进行分类。</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/1-1.jpg" alt="1-1"></p>
<ul>
<li>输入图片</li>
<li>提取约2000个 region proposals</li>
<li>使用一个大的CNN 为每个 proposal 计算出特征</li>
<li>使用类别特定的线性 SVM 对每个 region 进行分类</li>
</ul>
<p>2、如何训练一个复杂模型</p>
<p>传统的预训练方法是无监督的，每层自己训练训练一个权重出来（例如通过AutoEncoder）之后，再加上label信息进行整体微调。这个方法没有任何先验，需要大量数据进行训练。而R-CNN则采用了CNN在分类问题上已经训好的权重作为初始权重，再针对detection问题进行微调。这就使得小数据集可以使用大数据集上的先验知识，在分类问题上的研究成果可以轻松迁移到detection问题上了。</p>
<p>论文中使用大型辅助数据集(ILSVRC)上进行监督预训练，然后对小数据集(PASCAL)进行域特定的微调，这是在数据稀缺时训练高容量CNN模型的有效范例。最后在检测库上评测。</p>
<p>一个较大的<strong>识别库</strong>（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。<br>一个较小的<strong>检测库</strong>（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置。一万图像，20类。 </p>
<p>CNN的输入必须是固定大小的。论文中采用了最简单的warp图像变形方法。但是对变形的区域进行了限制，即不单单对proposal选中的矩形框进行变形，还将其扩大（引入背景息），使得变形后原proposal矩形框外围还有p个像素点(p=16)。原话是这样的</p>
<blockquote>
<p>对于这些转换中的每一个，我们还考虑在原始目标提案四周包括附加图像内容。内容填充的量(pp)被定义为在缩放后图像中，原始目标提案周围的边界大小。图7显示了每个示例的顶行中p=0p=0像素，底行中p=16p=16像素。在所有方法中，如果矩形框超出图像边缘，超出的部分将被填充为图像均值（然后在将图像输入到CNN之前减去）。一组实验表明，采用上下文填充（p=16p=16像素）的缩放可以明显提高mAP（提高3-5个点）。显然还有更多其它可行的方案，包括使用复制而不是平均填充。对这些方案的详尽评估将作为未来的工作。</p>
</blockquote>
<h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><p>目标检测系统分为三个部分：1、生成类别无关的 region proposals（构成候选检测集）；2、从每个 region 提取固定长度特征向量的大型CNN；3、一组特定类别的线性 SVM。</p>
<p><strong>region proposals</strong></p>
<p>经典的目标检测算法使用滑动窗法依次判断所有可能的区域。</p>
<p>本文采用了 selective search （选择性搜索），论文中说便于与之前的一些工作进行比较。</p>
<p>从高层理解，Selective Search通过不同尺寸的窗口在图像中进行滑动，对于每个尺寸方法采用纹理、颜色或亮度对邻近的像素进行聚合，从而识别物体。</p>
<blockquote>
<p>关于 selective search，论文如下，后续有空深究：</p>
<p>J. Uijlings, K. van de Sande, T. Gevers, and A. Smeulders. Selective search for object recognition. IJCV, 2013.</p>
</blockquote>
<p><strong>feature extraction</strong></p>
<p>经典的目标检测算法在区域中提取人工设定的特征（Haar，HOG）。</p>
<p>从每个 region proposal 中提取4096维特征向量，将减去像素平均值的227×227227×227分辨率的RGB图像通过五个卷积层和两个全连接层向前传播来计算特征。</p>
<p>不管候选区域的大小或横纵比如何，我们将整个区域不保持横纵比缩放到所需的大小。</p>
<p>在测试时，先对测试图像进行选择性搜索，以提取大约2000个区域提案（我们在所有实验中使用选择性搜索的“快速模式”）。然后缩放每个区域，并通过CNN向前传播，以计算特征。最后，对于每个类，使用针对该类训练的SVM来对每个提取的特征向量进行评分。给定图像中的所有区域的得分，我们应用贪婪非极大值抑制（每个类别独立进行），在训练时学习一个阈值，如果其与得分较高的区域的重叠部分(IoU)高于这个阈值，则丢弃这个区域。</p>
<p><strong>两种性质使检测效率高</strong></p>
<p>首先，所有CNN参数都在<strong>所有类别</strong>中共享。</p>
<p>这种共享的结果是计算 region proposals 和 features（GPU上的13s/image 或 CPU上的53s/image）的时间在所有类别上进行摊销。唯一的类特定计算是特征、SVM权重和非极大值抑制之间的点积。</p>
<p>其次，与其他常见方法比较，由CNN计算出的特征向量是低维度的，例如具有空间金字塔（spatial pyramids）和视像单词（bag-of-visual-word）</p>
<h2 id="training"><a href="#training" class="headerlink" title="training"></a>training</h2><p><strong>supervised pre-training（监督预训练）</strong></p>
<p>通过使用图像级标记来区分性地对大型辅助数据集（ILSVRC2012分类）进行CNN预训练（此数据没有检测框标记）。使用开源的Caffe CNN库进行预训练。</p>
<p><strong>Domain-specific fine-tuning（特定域的微调）</strong></p>
<p>使用缩放后的 region proposals 继续进行CNN参数的随机梯度下降(SGD)训练。</p>
<p>所有 region proposals 与检测框真值（ground-truth）IoU ≥0.5的区域作为正样本，其余的作为负样本。</p>
<p>优化算法采用learning rate=0.001的SGD（这个小学习率可以使得模型既可以有明显的学习，又不至于过分的更改前几层连接的权重）；每个mini-batch由32个正样本（可以是任意类别的）和96个负样本（背景）组成（这样强制要求，对比于随机抽样，的原因是proposal中属于背景的占大多数）</p>
<p><strong>object category classifiers（目标类别分类器）</strong></p>
<p>一旦提取了特征并应用了训练标签，我们就可以优化每类线性SVM。由于训练数据太大内存不够，我们采用 standard hard negative mining method （标准的难分样本挖掘方法）。难分样本挖掘可以快速收敛，实际上所有图像遍历一边，mAP就停止增长了。</p>
<p>对每一类目标，使用一个线性SVM二类分类器进行判别。输入为CNN输出的4096维特征，输出是否属于此类。 </p>
<p>SVM的策略是对于所有IoU &lt; 0.3的proposal视为负样本，而只对ground truth视为正样本。</p>
<blockquote>
<p>IoU的threshold，对于最终结果影响很大。其交叉验证试验了{0,0.1,…,0.5}，发现差值可以达到5个mAP points。特别的，设其为0.5将会使得mAP掉5个点，而设为0则会掉4个点。</p>
</blockquote>
<p><strong>Bounding-box regression（检测框回归）</strong></p>
<blockquote>
<p>目标检测问题的衡量标准是重叠面积：许多看似准确的检测结果，往往因为候选框不够准确，重叠面积很小。故需要一个位置精修步骤。 </p>
</blockquote>
<p>受DPM中使用的检测框回归的启发，训练一个线性回归模型使用在 region proposals 上提取的 pool5 特征来预测一个新的检测框。</p>
<p>使用一个简单的检测框回归来提高定位性能。在使用类特定检测SVM对每个选择性搜索提案进行评分之后，使用类别特定的边界回归器预测新的检测框。</p>
<p><strong>回归器</strong><br>对每一类目标，使用一个线性回归器进行精修。这里转化为标准正则化最小二乘问题，基于验证集，设置正则项 λ=1000。<br>输入为CNN pool5层的4096维特征，输出为xy方向的缩放和平移。<br><strong>训练样本</strong><br>只有当提案P至少在一个检测框真值附近时，我们才执行学习任务。“附近”即，将P分配给具有最大IoU的检测框真值G（在重叠多于一个的情况下），并且仅当重叠大于阈值（基于验证集，我们使用的阈值为0.6）。所有未分配的提案都被丢弃。</p>
<p>为每个目标类别执行一次，以便学习一组特定于类别的检测框回归器。</p>
<p>在测试时，对每个提案进行评分，并预测其新的检测框一次。原则上，可以迭代这个过程（即重新评估新预测的检测框，然后从它预测一个新的检测框，等等）。但是，发现迭代不会改进结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>R-CNN的步骤如下：</p>
<ol>
<li>生成regions proposals集合作为Bounding Box；</li>
<li>采用预训练的AlexNet+SVM判断Bouding Box对应图像的物体类型；</li>
<li>对已分类物体的Bounding Box进行线性回归，输出Box对应的tighter bounding boxes。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>检测目标速度慢</li>
</ul>
<p>在测试阶段，特征来自于每张测试图片的每个候选区域。每个候选区域都需要经过CNN的前向传播计算出特征向量。因此速度很慢。</p>
<ul>
<li>多阶段训练（multi-stage pipeline）</li>
</ul>
<p>阶段一：从原始图片中使用selective search获取约2000个候选区域</p>
<p>阶段二：训练CNN,获取候选区域的特征向量</p>
<p>阶段三：训练SVM和bbox回归</p>
<blockquote>
<p>因为是分阶段训练，训练SVM和bbox回归时无法更新前面CNN的参数，模型精度上不去。</p>
</blockquote>
<ul>
<li>空间时间浪费（in space and time）</li>
</ul>
<p>候选区域经过CNN得到的特征向量要存在到disk内，然后在训练SVM和bbox回归再取出来，这需要大量的磁盘空间，并且很耗费时间。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph写流程分析]]></title>
      <url>http://xiaqunfeng.cc/2017/11/18/ceph-write-flow/</url>
      <content type="html"><![CDATA[<p>之前总结的ceph写流程分析笔记，代码是基于jewel版本10.2.0，现分享出来，欢迎指点。<br><a id="more"></a></p>
<h2 id="一、rbd到OSD映射关系"><a href="#一、rbd到OSD映射关系" class="headerlink" title="一、rbd到OSD映射关系"></a>一、rbd到OSD映射关系</h2><p>​    客户端使用RBD设备，使用librbd、librados库进行访问管理块设备。</p>
<p>​    1、创建 一个pool，为这个pool指定pg的数量，同时在这个pool中指明保存数据的副本数（通常为3个副本）。</p>
<p>​    2、在这个pool中创建一个rbd设备rbd0，那么这个rbd0都会保存三份，在创建rbd0时必须指定rbd的size，对于这个rbd0的任何操作不能超过这个size。</p>
<p>​    3、将这个块设备进行切块，每个块的大小默认为4M，并且每个块都有一个名字，名字就是object+序号。</p>
<p>​    4、将每个object通过pg进行副本位置的分配，pg会寻找3个osd，把这个object分别保存在这三个osd上。最后对于object的存储就变成了存储一个文件 <code>rbd0.object1.file</code>。数据层次映射图如下： <img src="http://oow6unnib.bkt.clouddn.com/ceph_data_map.jpg" alt="ceph数据的映射层次">​</p>
<p>​    经过pool，rbd，object、pg的层层映射关系，在PG这一层中，已经知道存储数据的3个OSD所在位置及主从关系。</p>
<p>​    客户端与primay OSD建立SOCKET 通信，将要写入的数据传给primary OSD，由primary OSD再将数据发送给其他replica OSD数据节点。</p>
<p>​    读写框架图： <img src="http://oow6unnib.bkt.clouddn.com/ceph_rw_arc.jpg" alt="ceph读写框架"></p>
<h2 id="二、写请求流程"><a href="#二、写请求流程" class="headerlink" title="二、写请求流程"></a>二、写请求流程</h2><h3 id="1、rbd上的处理"><a href="#1、rbd上的处理" class="headerlink" title="1、rbd上的处理"></a>1、rbd上的处理</h3><p>​    在rbd中一个操作对象为一个image，这个请求经过处理拆分成object对象的请求，拆分后交给Objector进行处理，找到目标osd的集合及主osd。</p>
<p>​    将请求封装成MOSDOp消息，交由SimpleMessenger处理，SimpleMessager会尝试查找 / 创建一个OSDSession，并且为这个OSDSession创建一个数据通道pipe。消息从SimpleMessager收到后会保存到pipe的outq队列中。</p>
<p>​    pipe 与目标osd建立Socket通信通道，并有专门的写线程writer来负责socket通信。writer线程同时监视这个outq队列，当队列中存在消息等待发送时，会就将消息写入socket，发送给目标OSD。</p>
<p>​    OSD将数据消息处理完成之后，进行回调，反馈执行结果。</p>
<p>​    关键代码序列图如下： <img src="http://oow6unnib.bkt.clouddn.com/libRBD_write_Fotor.jpg" alt="libRBD write"></p>
<h3 id="2、osd上的处理"><a href="#2、osd上的处理" class="headerlink" title="2、osd上的处理"></a>2、osd上的处理</h3><p>​    OSD接收到message信息以后，解析并将消息转换成OpRequest，加入dispatch队列。同时从message中得到pool及PG的信息，将message交由PG进行相关处理。此时从OSD处理的message转化为了PG处理的op，添加到osd-&gt;op_wq队列中。PG中创建一个OpContext结构，接管message中的所有ops的操作。</p>
<p>​    解析出OpRequest中的所有op与data，用Transaction结构进行管理，即将ops与Transaction绑定，将操作和数据打包成事务，并发送给其他副本，同时管理自己和其他副本的数据处理统计，创建repop 所有的applied与commit的管理。</p>
<p>​    提交事务后，交由filestore进行处理。</p>
<p>​    如果数据处理完成了，使用eval_repop()进行收尾的工作，将结果回调给客户端。</p>
<p>​    关键代码序列图如下：  <img src="http://oow6unnib.bkt.clouddn.com/osd_write_Fotor.jpg" alt="osd write"></p>
<h3 id="3、filestore上的处理"><a href="#3、filestore上的处理" class="headerlink" title="3、filestore上的处理"></a>3、filestore上的处理</h3><p>​    当数据进行写入的时候需要写到journal中一份，当data数据失败的时候可以从journal中进行恢复。从_op_journal_transactions()开始激发写入日志的操作，回调函数C_JournaledAhead的会在日志完成之后进行回调处理，将data写入磁盘。</p>
<p>​    将日志保存完成的回调ondisk交给ondisk_finisher，ondisk注册回调为C_OSD_OnOpApplied，在后续finisher线程中处理。在该函数中，循环处理需要回调的请求，回复刚开始接收到请求的MOSDOp的操作，将请求发还给客户端。</p>
<p>​    写完data的回调函数注册的为C_OSD_OnOpCommit，该函数处理并回复OSD一些状态的逻辑。</p>
<p>​    关键代码序列图如下：<img src="http://oow6unnib.bkt.clouddn.com/file_write_Fotor.jpg" alt="file_write"></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上安装caffe并训练mnist]]></title>
      <url>http://xiaqunfeng.cc/2017/11/05/mac-install-caffe-mnist/</url>
      <content type="html"><![CDATA[<p>在mac上安装caffe，然后训练一个mnist项目，熟悉流程。新增anaconda的使用介绍。<br><a id="more"></a></p>
<h2 id="安装caffe"><a href="#安装caffe" class="headerlink" title="安装caffe"></a>安装caffe</h2><p>官方的资料：<a href="http://caffe.berkeleyvision.org/install_osx.html" target="_blank" rel="noopener">http://caffe.berkeleyvision.org/install_osx.html</a></p>
<p>我这里并没有用 Anaconda Python，如果想要安装它的话，去<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">官网下载</a>并安装。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>1、安装必要的库和依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install -vd snappy leveldb gflags glog szip lmdb</span><br><span class="line"># need the homebrew science source for OpenCV and hdf5</span><br><span class="line">brew tap homebrew/science</span><br><span class="line">brew install hdf5 opencv</span><br></pre></td></tr></table></figure>
<p>2、安装boost和protobuf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf boost</span><br></pre></td></tr></table></figure>
<p>3、安装BLAS</p>
<p>BLAS是Mac中自带的库，所以不需要安装。如果没有安装，推荐使用OpenBLAS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openblas</span><br></pre></td></tr></table></figure>
<p>4、安装CUDA</p>
<p>要确定mac的显卡是否支持CUDA。我这里没有安装，为啥，因为不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel Iris Graphics 6100 1536 MB</span><br></pre></td></tr></table></figure>
<h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p>1、克隆代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/BVLC/caffe</span><br><span class="line">cd caffe</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以下所有操作都在 caffe 目录下进行</p>
</blockquote>
<p>查看文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/AI/caffe  master ✔                                                                                                                                                           21d</span><br><span class="line">▶ ls</span><br><span class="line">CMakeLists.txt          LICENSE                 README.md               data                    examples                python</span><br><span class="line">CONTRIBUTING.md         Makefile                build                   distribute              include                 scripts</span><br><span class="line">CONTRIBUTORS.md         Makefile.config         caffe.cloc              docker                  matlab                  src</span><br><span class="line">INSTALL.md              Makefile.config.example cmake                   docs                    models                  tools</span><br></pre></td></tr></table></figure>
<p>2、修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp Makefile.config.example Makefile.config</span><br></pre></td></tr></table></figure>
<p>修改 Makefile.config 文件：</p>
<ul>
<li>去掉CPU_ONLY := 1的注释，使Caffe只运行在CPU上。</li>
<li>去掉OPENCV_VERSION := 3的注释，因为当前的OpenCV版本是3.1.0，如果版本是2.*就不需要。</li>
</ul>
<p>查看当前的opencv版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ pkg-config --modversion opencv</span><br><span class="line">3.3.1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>pkg-config</code> 没安装：<code>brew install pkg-config</code></p>
</blockquote>
<p>修改anaconda的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Anaconda Python distribution is quite popular. Include path:</span><br><span class="line"># Verify anaconda location, sometimes it&apos;s in root.</span><br><span class="line"># ANACONDA_HOME := $(HOME)/anaconda</span><br><span class="line">ANACONDA_HOME := $/Users/xiaqunfeng/anaconda2</span><br><span class="line">PYTHON_INCLUDE := $(ANACONDA_HOME)/include \</span><br><span class="line">         $(ANACONDA_HOME)/include/python2.7 \</span><br><span class="line">         $(ANACONDA_HOME)/lib/python2.7/site-packages/numpy/core/include</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>1、编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCPU_ONLY=ON ..</span><br><span class="line">make all -j8</span><br></pre></td></tr></table></figure>
<p>忽略 warning，有error解决error的错误（正常没有error，有的话一般是依赖包没装成功）。</p>
<p>2、运行test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make runtest</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[----------] 3 tests from MSRAFillerTest/0, where TypeParam = f</span><br><span class="line">[ RUN      ] MSRAFillerTest/0.TestFillAverage</span><br><span class="line">[       OK ] MSRAFillerTest/0.TestFillAverage (0 ms)</span><br><span class="line">[ RUN      ] MSRAFillerTest/0.TestFillFanIn</span><br><span class="line">[       OK ] MSRAFillerTest/0.TestFillFanIn (1 ms)</span><br><span class="line">[ RUN      ] MSRAFillerTest/0.TestFillFanOut</span><br><span class="line">[       OK ] MSRAFillerTest/0.TestFillFanOut (1 ms)</span><br><span class="line">[----------] 3 tests from MSRAFillerTest/0 (2 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 1110 tests from 152 test cases ran. (54652 ms total)</span><br><span class="line">[  PASSED  ] 1110 tests.</span><br></pre></td></tr></table></figure>
<p>此时，caffe安装成功，并通过了测试。</p>
<h2 id="pycaffe安装"><a href="#pycaffe安装" class="headerlink" title="pycaffe安装"></a>pycaffe安装</h2><p>1、在build目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make pycaffe</span><br><span class="line">make pytest</span><br></pre></td></tr></table></figure>
<p>2、设置pycaffe环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">▶ cat ~/.bash_profile</span><br><span class="line">...</span><br><span class="line"># caffe python</span><br><span class="line">export PYTHONPATH=&quot;/Users/xiaqunfeng/AI/caffe/python:$PYTHONPATH&quot;</span><br><span class="line">...</span><br><span class="line">▶ source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>3、在python中测试caffe接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">▶ python</span><br><span class="line">Python 2.7.14 |Anaconda, Inc.| (default, Dec  7 2017, 11:07:58)</span><br><span class="line">[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import caffe</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：python3和caffe不能很好的兼容，官方也说了不推荐，我试了一直会出错：“ImportError: dynamic module does not define module export function (PyInit__caffe)”</p>
</blockquote>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>Q1：<code>ImportError: No module named numpy</code></p>
<p>A1：<code>conda install numpy</code></p>
<p>Q2：<code>ImportError: No module named skimage.io</code></p>
<p>A2：<code>conda install scikit-image</code></p>
<p>Q3：<code>ImportError: No module named google.protobuf.internal</code></p>
<p>A3：<code>conda install protobuf</code></p>
<h2 id="训练mnist数据集"><a href="#训练mnist数据集" class="headerlink" title="训练mnist数据集"></a>训练mnist数据集</h2><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>1、下载mnist数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./data/mnist/get_mnist.sh</span><br></pre></td></tr></table></figure>
<p>下载的数据保存在 <code>./data/mnist/</code> 目录下。</p>
<p>2、建立训练数据和测试数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./examples/mnist/create_mnist.sh</span><br></pre></td></tr></table></figure>
<p>此时 <code>./examples/mnist/</code> 路径下出现 <code>mnist_test_lmdb</code> 和 <code>mnist_train_lmdb</code> 两个文件夹，分别是测试和训练数据。</p>
<p>3、训练</p>
<p>修改 <code>./examples/mnist/lenet_solver.prototxt</code> ，保证整个训练过程在CPU上进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># solver mode: CPU or GPU</span><br><span class="line">solver_mode: CPU</span><br></pre></td></tr></table></figure>
<p>4、执行训练命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./examples/mnist/train_lenet.sh</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">I1102 17:31:49.379988 3124548544 solver.cpp:218] Iteration 9900 (25.582 iter/s, 3.909s/100 iters), loss = 0.00534126</span><br><span class="line">I1102 17:31:49.381337 3124548544 solver.cpp:237]     Train net output #0: loss = 0.00534115 (* 1 = 0.00534115 loss)</span><br><span class="line">I1102 17:31:49.381361 3124548544 sgd_solver.cpp:105] Iteration 9900, lr = 0.00596843</span><br><span class="line">I1102 17:31:54.009297 3124548544 solver.cpp:447] Snapshotting to binary proto file examples/mnist/lenet_iter_10000.caffemodel</span><br><span class="line">I1102 17:31:54.026062 3124548544 sgd_solver.cpp:273] Snapshotting solver state to binary proto file examples/mnist/lenet_iter_10000.solverstate</span><br><span class="line">I1102 17:31:54.059612 3124548544 solver.cpp:310] Iteration 10000, loss = 0.00328907</span><br><span class="line">I1102 17:31:54.059659 3124548544 solver.cpp:330] Iteration 10000, Testing net (#0)</span><br><span class="line">I1102 17:31:56.881471 148017152 data_layer.cpp:73] Restarting data prefetching from start.</span><br><span class="line">I1102 17:31:57.004863 3124548544 solver.cpp:397]     Test net output #0: accuracy = 0.9906</span><br><span class="line">I1102 17:31:57.004914 3124548544 solver.cpp:397]     Test net output #1: loss = 0.0292456 (* 1 = 0.0292456 loss)</span><br><span class="line">I1102 17:31:57.004932 3124548544 solver.cpp:315] Optimization Done.</span><br><span class="line">I1102 17:31:57.004940 3124548544 caffe.cpp:259] Optimization Done.</span><br></pre></td></tr></table></figure>
<p>可以看到，一共迭代10000次，准确率为 0.9906。训练出的模型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▶ ll examples/mnist</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 xiaqunfeng  staff   1.6M 11  2 17:31 lenet_iter_10000.caffemodel</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>5、绘制网络图</p>
<p>用官方自带的python工具绘制网络图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ ./python/draw_net.py examples/mnist/lenet_train_test.prototxt examples/mnist/lenet_train_test.jpg</span><br><span class="line">Drawing net to examples/mnist/lenet_train_test.jpg</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>图如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/lenet_train_test.jpg" alt="lenet_train_test.jpg"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1、对训练的网络模型进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">caffe 网络结构模型文件(.prototxt) 训练好的模型参数（.caffemodel） 迭代测试次数</span><br><span class="line"></span><br><span class="line">▶ ./build/tools/caffe test -model examples/mnist/lenet_train_test.prototxt -weights examples/mnist/lenet_iter_10000.caffemodel -iterations 100</span><br><span class="line">...</span><br><span class="line">I0108 11:41:02.459322 3449701312 caffe.cpp:330] accuracy = 0.9905</span><br><span class="line">I0108 11:41:02.459398 3449701312 caffe.cpp:330] loss = 0.0287398 (* 1 = 0.0287398 loss)</span><br></pre></td></tr></table></figure>
<p>2、用python接口调用训练好的模型识别数字</p>
<p>网络结构图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ ./python/draw_net.py examples/mnist/lenet.prototxt examples/mnist/lenet.jpg</span><br><span class="line">Drawing net to examples/mnist/lenet.jpg</span><br></pre></td></tr></table></figure>
<p><img src="http://oow6unnib.bkt.clouddn.com/lenet.jpg" alt="lenet.jpg"></p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import caffe</span><br><span class="line"></span><br><span class="line">caffe_root = &apos;/Users/xiaqunfeng/AI/caffe/&apos;</span><br><span class="line"></span><br><span class="line">#指定网络结构 与 lenet_train_test.prototxt不同 </span><br><span class="line">MODEL_FILE = caffe_root + &apos;examples/mnist/lenet.prototxt&apos;</span><br><span class="line">PRETRAINED = caffe_root + &apos;examples/mnist/lenet_iter_10000.caffemodel&apos;</span><br><span class="line"></span><br><span class="line">#图片已经处理成 lenet.prototxt的输入要求（尺寸28x28）且已经二值化为黑白色</span><br><span class="line">IMAGE_FILE = caffe_root + &apos;xqf/Learning-caffe/Lenet-mnist/test4.bmp&apos;</span><br><span class="line"></span><br><span class="line">input_image = caffe.io.load_image(IMAGE_FILE, color=False)</span><br><span class="line">net = caffe.Classifier(MODEL_FILE, PRETRAINED)</span><br><span class="line">prediction = net.predict([input_image], oversample=False)</span><br><span class="line">caffe.set_mode_cpu()</span><br><span class="line">print &apos;predicted class:&apos;, prediction[0].argmax()</span><br><span class="line"></span><br><span class="line">这个例子参考这里：https://zhuanlan.zhihu.com/p/24110318</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicted class: 4</span><br></pre></td></tr></table></figure>
<h3 id="关于mnist"><a href="#关于mnist" class="headerlink" title="关于mnist"></a>关于mnist</h3><p>MNIST 数据集来自美国国家标准与技术研究所, <strong>National Institute of Standards and Technology (NIST)</strong>。训练集 (training set) 由来自 250 个不同人手写的数字构成，其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员。测试集(test set) 也是同样比例的手写数字数据。mnist最初备在美国被用与支票上手写数字识别，现在成了DeepLearning的入门练习示例，针对mnist识别的神经网络的专门模型是Lenet，算是最早的CNN模型了。</p>
<ul>
<li>mnist数据的—训练样本为60000张</li>
<li>测试样本为10000张</li>
<li>每个样本为28*28大小的黑白图片</li>
<li>手写数字为0-9,因此分为10类</li>
</ul>
<p>同时，Mnist数据库中的每张图片都进行了:</p>
<ul>
<li>尺寸的归一化处理(所有的图片均为28*28像素大小的图片)</li>
<li>数字进行了居中处理</li>
<li>通过脚本 <code>get_mnist.sh</code> 下载下来的数据不是图片数据，图片是以字节的形式进行存储</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ ll data/mnist</span><br><span class="line">total 107352</span><br><span class="line">-rwxr-xr-x  1 xiaqunfeng  staff   408B 10 18 09:58 get_mnist.sh</span><br><span class="line">-rw-r--r--  1 xiaqunfeng  staff   7.5M  7 22  2000 t10k-images-idx3-ubyte</span><br><span class="line">-rw-r--r--  1 xiaqunfeng  staff   9.8K  7 22  2000 t10k-labels-idx1-ubyte</span><br><span class="line">-rw-r--r--  1 xiaqunfeng  staff    45M  7 22  2000 train-images-idx3-ubyte</span><br><span class="line">-rw-r--r--  1 xiaqunfeng  staff    59K  7 22  2000 train-labels-idx1-ubyte</span><br></pre></td></tr></table></figure>
<p>详解：</p>
<ul>
<li><strong>Training set images</strong>: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本)</li>
<li><strong>Training set labels</strong>: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签)</li>
<li><strong>Test set images</strong>: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本)</li>
<li><strong>Test set labels</strong>: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签)</li>
</ul>
<h2 id="使用模型进行分类"><a href="#使用模型进行分类" class="headerlink" title="使用模型进行分类"></a>使用模型进行分类</h2><p>用Caffe中已经训练好的模型（基于Alexnet的结构）对图像进行分类，并且可以显示不同层中训练得到的特征：</p>
<p><a href="http://nbviewer.jupyter.org/github/BVLC/caffe/blob/master/examples/00-classification.ipynb" target="_blank" rel="noopener">http://nbviewer.jupyter.org/github/BVLC/caffe/blob/master/examples/00-classification.ipynb</a></p>
<h2 id="ubuntu-16-04上安装遇到的问题"><a href="#ubuntu-16-04上安装遇到的问题" class="headerlink" title="ubuntu 16.04上安装遇到的问题"></a>ubuntu 16.04上安装遇到的问题</h2><h3 id="编译依赖问题"><a href="#编译依赖问题" class="headerlink" title="编译依赖问题"></a>编译依赖问题</h3><p><strong>问题1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./include/caffe/common.hpp:5:27: fatal error: gflags/gflags.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgflags-dev</span><br></pre></td></tr></table></figure>
<p><strong>问题2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./include/caffe/util/mkl_alternate.hpp:14:19: fatal error: cblas.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libblas-dev</span><br></pre></td></tr></table></figure>
<p><strong>问题3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./include/caffe/util/hdf5.hpp:6:18: fatal error: hdf5.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法：在 <code>Makefile.config</code> 找到以下亮行并添加最后一部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial </span><br><span class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial</span><br></pre></td></tr></table></figure>
<p><strong>问题4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./include/caffe/util/db_lmdb.hpp:8:18: fatal error: lmdb.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install liblmdb-dev</span><br></pre></td></tr></table></figure>
<p><strong>问题5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lcblas</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libatlas-base-dev</span><br></pre></td></tr></table></figure>
<h3 id="python导入caffe"><a href="#python导入caffe" class="headerlink" title="python导入caffe"></a>python导入caffe</h3><p>编译安装完后，在python脚本中导入 caffe 时出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    import caffe</span><br><span class="line">ImportError: No module named caffe</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>1、先安装 pycaffe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make pycaffe</span><br></pre></td></tr></table></figure>
<p>会遇到如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python/caffe/_caffe.cpp:10:31: fatal error: numpy/arrayobject.h: No such file or directory</span><br></pre></td></tr></table></figure>
<p>原因是python-numpy没有安装到位，安装即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-numpy</span><br></pre></td></tr></table></figure>
<p>2、添加caffe路径</p>
<p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=/workspace/caffe/python:$PYTHONPATH</span><br></pre></td></tr></table></figure>
<p>其中 <code>/workspace</code> 是clone caffe master代码的目录</p>
<p>然后执行 <code>source ~/.bashrc</code> 即可</p>
<p><strong>方法二：</strong></p>
<p>或者，在导入 caffe的时候在python 文件里手动添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">PYCAFFE_ROOT = &apos;/workspace/caffe/python/&apos;</span><br><span class="line">sys.path.append(PYCAFFE_ROOT)</span><br><span class="line">import caffe</span><br></pre></td></tr></table></figure>
<h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><blockquote>
<p>caffe不能和python3很好的支持，所以主要用Python2.7。因为我在mac上的使用习惯都是python3，各种安装包也都是通过 pip3 命令装的python3版本的，所以需要一个anaconda来创建一个python2.7的环境。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、官网<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">下载</a></p>
<p>推荐下载 .pkg 文件进行图形化安装，下载python2和python3版本的均可，只是默认环境不一样，不影响，我这里下载的 Anaconda2。</p>
<p>安装完后会在 <code>~/.bash_profile</code> 中自动添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># added by Anaconda2 5.0.1 installer</span><br><span class="line">export PATH=&quot;/Users/xiaqunfeng/anaconda2/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>
<p>如果没有添加，手动添加之</p>
<p>运行 <code>source ~/.bash_profile</code></p>
<p>2、确认安装</p>
<p>进入选择的安装目录 <code>/Users/xiaqunfeng/anaconda2</code></p>
<p>查看conda命令是否可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># conda list</span><br></pre></td></tr></table></figure>
<p>可用，表示安装成功</p>
<h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>1、创建</p>
<p>创建名为python27的环境，指定python版本2.7（不用指定小版本 2.7.x，conda会自动寻找2.7.x中最新版）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ conda create --name python27 python=2.7</span><br></pre></td></tr></table></figure>
<p>2、激活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ source activate python27</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>这一步系统做的事情就是把默认2.7环境从PATH中去除，再把新的2.7对应的命令加入PATH</p>
<p>查看系统版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ python --version</span><br><span class="line">Python 2.7.14 :: Anaconda, Inc.</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>3、查看</p>
<p>用户安装的不同python环境都会被放在目录<code>~/anaconda/envs</code>下。运行<code>conda info -e</code>查看已安装的环境，当前被激活的环境会显示有一个星号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▶ conda info -e</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">python27              *  /Users/xiaqunfeng/anaconda2/envs/python27</span><br><span class="line">root                     /Users/xiaqunfeng/anaconda2</span><br></pre></td></tr></table></figure>
<p>4、离开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ source deactivate python27</span><br></pre></td></tr></table></figure>
<p>此时系统环境回到了默认的 root 上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">▶ conda info -e</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">python27                 /Users/xiaqunfeng/anaconda2/envs/python27</span><br><span class="line">root                  *  /Users/xiaqunfeng/anaconda2</span><br></pre></td></tr></table></figure>
<p>5、删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ conda remove --name python27 --all</span><br></pre></td></tr></table></figure>
<p>6、共享</p>
<ul>
<li><strong>导出</strong></li>
</ul>
<p>将当前的环境保存到文件中包保存为YAML文件（包括Pyhton版本和所有包的名称）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ conda env export &gt; py27-env.yaml</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。</p>
</blockquote>
<ul>
<li><strong>使用</strong></li>
</ul>
<p>在conda中进入自己的环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ conda activate XXX</span><br></pre></td></tr></table></figure>
<p>然后更新环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ conda env update -f=/yourpath/py27-env.yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不使用 conda ，还可以使用 pip freeze，具体没实践过，可以查阅相关资料</p>
</blockquote>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>conda 的包管理功能可 pip 是一样的，当然你选择 pip 来安装包也是没问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line">conda install package-name</span><br><span class="line"></span><br><span class="line"># 指定环境安装package</span><br><span class="line">conda install -n python34 package-name</span><br><span class="line"></span><br><span class="line"># 查看当前环境已经安装的packages</span><br><span class="line">conda list</span><br><span class="line"></span><br><span class="line"># 查看某个指定环境的已安装包</span><br><span class="line">conda list -n python34</span><br><span class="line"></span><br><span class="line"># 查找package信息</span><br><span class="line">conda search numpy</span><br><span class="line"></span><br><span class="line"># 更新package</span><br><span class="line">conda update -n python34 numpy</span><br><span class="line"></span><br><span class="line"># 删除package</span><br><span class="line">conda remove -n python34 numpy</span><br></pre></td></tr></table></figure>
<p>conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 更新conda，保持conda最新</span><br><span class="line">conda update conda</span><br><span class="line"># 更新anaconda</span><br><span class="line">conda update anaconda</span><br><span class="line"># 更新python</span><br><span class="line">conda update python</span><br></pre></td></tr></table></figure>
<h3 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><p>Anaconda.org的服务器在国外，下载速度有时会比较慢，设置国内清华TUNA镜像源，加入conda的配置。</p>
<p>1、原配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▶ cat ~/.condarc</span><br><span class="line">channels:</span><br><span class="line">  - defaults</span><br><span class="line">ssl_verify: true</span><br></pre></td></tr></table></figure>
<p>2、添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">▶ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">▶ conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>修改后配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">▶ cat ~/.condarc</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br><span class="line">ssl_verify: true</span><br><span class="line">show_channel_urls: true</span><br></pre></td></tr></table></figure>
<p>3、查看配置是否生效，查看当前信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▶ conda info</span><br><span class="line">Current conda install:</span><br><span class="line">...</span><br><span class="line">           channel URLs : https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/osx-64</span><br><span class="line">                          https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/noarch</span><br><span class="line">                          https://repo.continuum.io/pkgs/main/osx-64</span><br><span class="line">                          https://repo.continuum.io/pkgs/main/noarch</span><br><span class="line">                          https://repo.continuum.io/pkgs/free/osx-64</span><br><span class="line">                          https://repo.continuum.io/pkgs/free/noarch</span><br><span class="line">                          https://repo.continuum.io/pkgs/r/osx-64</span><br><span class="line">                          https://repo.continuum.io/pkgs/r/noarch</span><br><span class="line">                          https://repo.continuum.io/pkgs/pro/osx-64</span><br><span class="line">                          https://repo.continuum.io/pkgs/pro/noarch</span><br><span class="line">...</span><br><span class="line">(python27)</span><br></pre></td></tr></table></figure>
<p>在 channel URLs 中有新添加的镜像地址，表示已生效。</p>
]]></content>
      
        <categories>
            
            <category> DeepLearning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> caffe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dd磁盘命令小记]]></title>
      <url>http://xiaqunfeng.cc/2017/10/06/dd-cmd/</url>
      <content type="html"><![CDATA[<p>dd是经常使用的命令了，方便快捷，这里闲来小总结一下，以及怎样测出最真实的写入速度。<br><a id="more"></a></p>
<h2 id="命令的使用"><a href="#命令的使用" class="headerlink" title="命令的使用"></a>命令的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># dd --help</span><br><span class="line">Usage: dd [OPERAND]...</span><br><span class="line">  or:  dd OPTION</span><br><span class="line">Copy a file, converting and formatting according to the operands.</span><br><span class="line"></span><br><span class="line">  bs=BYTES        read and write up to BYTES bytes at a time</span><br><span class="line">  cbs=BYTES       convert BYTES bytes at a time</span><br><span class="line">  conv=CONVS      convert the file as per the comma separated symbol list</span><br><span class="line">  count=N         copy only N input blocks</span><br><span class="line">  ibs=BYTES       read up to BYTES bytes at a time (default: 512)</span><br><span class="line">  if=FILE         read from FILE instead of stdin</span><br><span class="line">  iflag=FLAGS     read as per the comma separated symbol list</span><br><span class="line">  obs=BYTES       write BYTES bytes at a time (default: 512)</span><br><span class="line">  of=FILE         write to FILE instead of stdout</span><br><span class="line">  oflag=FLAGS     write as per the comma separated symbol list</span><br><span class="line">  seek=N          skip N obs-sized blocks at start of output</span><br><span class="line">  skip=N          skip N ibs-sized blocks at start of input</span><br><span class="line">  status=WHICH    WHICH info to suppress outputting to stderr;</span><br><span class="line">                  &apos;noxfer&apos; suppresses transfer stats, &apos;none&apos; suppresses all</span><br></pre></td></tr></table></figure>
<p><strong>翻译</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bs</td>
<td>同时设置读写块的大小为 bytes ，可代替 ibs 和 obs</td>
</tr>
<tr>
<td>cbs</td>
<td>一次转换 bytes 个字节，即转换缓冲区大小</td>
</tr>
<tr>
<td>conv</td>
<td>转换参数</td>
</tr>
<tr>
<td>count</td>
<td>复制的块数</td>
</tr>
<tr>
<td>ibs</td>
<td>一次读入 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>if</td>
<td>输入文件 或 设备名称</td>
</tr>
<tr>
<td>iflag</td>
<td>按照逗号来分隔读参数</td>
</tr>
<tr>
<td>obs</td>
<td>一次写 bytes 个字节(即一个块大小为 bytes 个字节)</td>
</tr>
<tr>
<td>of</td>
<td>输出文件 或 设备名称</td>
</tr>
<tr>
<td>oflag</td>
<td>按照逗号来分隔写参数</td>
</tr>
<tr>
<td>seek</td>
<td>从输出文件开头跳过 blocks 个块后再开始复制</td>
</tr>
<tr>
<td>skip</td>
<td>从输入文件开头跳过 blocks 个块后再开始复制</td>
</tr>
</tbody>
</table>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd --version</span><br></pre></td></tr></table></figure>
<h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><p><strong>两个特殊的设备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/null：伪设备，相当于黑洞，of到该设备不会产生IO</span><br><span class="line">/dev/zero：伪设备，它只产生空字符流，对它不会产生IO</span><br></pre></td></tr></table></figure>
<p><strong>1、测试磁盘写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/test.a bs=8k count=10000</span><br></pre></td></tr></table></figure>
<p>IO都集中在of文件中，of文件只用于写，相当于测试磁盘的写能力。</p>
<p><strong>2、测试磁盘读能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sdb1 of=/dev/null bs=8k count=10000</span><br></pre></td></tr></table></figure>
<p>IO只发生在/dev/sdb1上，相当于测试磁盘的读能力。</p>
<p><strong>3、测试同时读写能力</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sdb1 of=/test.a bs=8k count=10000</span><br></pre></td></tr></table></figure>
<p>一个是物理分区，一个是实际的文件，对它们的读写都会产生IO，如果它们都在一个磁盘中，该命令就相当于测试磁盘的同时读写能力。</p>
<h2 id="几种测试写磁盘的区别"><a href="#几种测试写磁盘的区别" class="headerlink" title="几种测试写磁盘的区别"></a>几种测试写磁盘的区别</h2><p>先给出四种测试方式的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># dd if=/dev/zero of=test bs=1M count=128</span><br><span class="line">128+0 records in</span><br><span class="line">128+0 records out</span><br><span class="line">134217728 bytes (134 MB) copied, 0.116559 s, 1.2 GB/s</span><br><span class="line"></span><br><span class="line"># dd if=/dev/zero of=test bs=1M count=128 ; sync</span><br><span class="line">128+0 records in</span><br><span class="line">128+0 records out</span><br><span class="line">134217728 bytes (134 MB) copied, 0.125106 s, 1.1 GB/s</span><br><span class="line"></span><br><span class="line"># dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</span><br><span class="line">128+0 records in</span><br><span class="line">128+0 records out</span><br><span class="line">134217728 bytes (134 MB) copied, 1.76802 s, 75.9 MB/s</span><br><span class="line"></span><br><span class="line"># dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</span><br><span class="line">128+0 records in</span><br><span class="line">128+0 records out</span><br><span class="line">134217728 bytes (134 MB) copied, 4.91353 s, 27.3 MB/s</span><br></pre></td></tr></table></figure>
<p>1、<code>dd if=/dev/zero of=test bs=1M count=128</code></p>
<p>没有加任何参数，命令只是单纯地把这128MB的数据读到内存缓冲当中，dd命令完成前并没有让系统真正把文件写到磁盘上。所以得到的是一个超级快的速度。直到dd完成后系统才开始真正往磁盘上写数据,但这个速度你是看不到了。</p>
<p>2、<code>dd if=/dev/zero of=test bs=1M count=128 ; sync</code></p>
<p>这事先后两个独立的命令。当sync命令准备开始往磁盘上真正写入数据的时候，前面dd命令已经把错误的“写入速度”值显示在屏幕上了。所以得到的不是真正的写入速度。</p>
<p><strong>3、<code>dd if=/dev/zero of=test bs=1M count=128 conv=fdatasync</code></strong></p>
<p>加入参数 <code>conv=fdatasync</code> 后，dd命令执行到最后会真正执行一次“同步(sync)”操作，所以这时候得到的是读取这128M数据到内存并写入到磁盘上所需的时间，这样算出来的时间才是<strong>比较符合实际</strong>的。这种方式最接近计算机实际操作，所以测出来的数据最有参考价值。</p>
<p>4、<code>dd if=/dev/zero of=test bs=1M count=128 oflag=dsync</code></p>
<p>加入参数 <code>oflag=dsync</code> 后，dd在执行时每次都会进行同步写入操作。这条命令每次读取1M后就要先把这1M写入磁盘，然后再读取下面这1M，一共重复128次。这是最慢的一种方式，因为基本上没有用到写缓存(write cache)。</p>
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph指定版本安装]]></title>
      <url>http://xiaqunfeng.cc/2017/09/27/ceph-assign-version-deploy/</url>
      <content type="html"><![CDATA[<p>通过yum安装指定版本的ceph，避免因小版本不一致导致的一些问题。<br><a id="more"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>ceph集群现有的版本是 11.2.0，需要扩容一台机器，新机器上ceph版本保持一致。</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>添加ceph安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/ceph.repo</span><br><span class="line">[ceph]</span><br><span class="line">name=Ceph packages for x86_64</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-noarch]</span><br><span class="line">name=Ceph noarch packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/noarch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">priority=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line"></span><br><span class="line">[ceph-source]</span><br><span class="line">name=Ceph source packages</span><br><span class="line">baseurl=http://mirrors.163.com/ceph/rpm-kraken/el7/SRPMS</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">type=rpm-md</span><br><span class="line">gpgkey=http://mirrors.163.com/ceph/keys/release.asc</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>
<p>然后执行yum安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install ceph</span><br></pre></td></tr></table></figure>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>通过 <code>yum install ceph --release kraken -y</code> 来安装，出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">错误：软件包：1:ceph-base-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：librados2 = 1:11.2.0-0.el7</span><br><span class="line">          可用: 1:librados2-0.94.5-2.el7.i686 (base)</span><br><span class="line">              librados2 = 1:0.94.5-2.el7</span><br><span class="line">          可用: 1:librados2-11.0.1-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.0.1-0.el7</span><br><span class="line">          可用: 1:librados2-11.0.2-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.0.2-0.el7</span><br><span class="line">          可用: 1:librados2-11.1.0-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.1.0-0.el7</span><br><span class="line">          可用: 1:librados2-11.1.1-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.1.1-0.el7</span><br><span class="line">          可用: 1:librados2-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.2.0-0.el7</span><br><span class="line">          正在安装: 1:librados2-11.2.1-0.el7.x86_64 (ceph)</span><br><span class="line">              librados2 = 1:11.2.1-0.el7</span><br><span class="line"> 您可以尝试添加 --skip-broken 选项来解决该问题</span><br><span class="line"> 您可以尝试执行：rpm -Va --nofiles --nodigest</span><br></pre></td></tr></table></figure>
<h3 id="方法一：指定版本"><a href="#方法一：指定版本" class="headerlink" title="方法一：指定版本"></a>方法一：指定版本</h3><p>因为kraken版本的ceph最新的release版本是 11.2.1，通过yum源来安装的话，会默认安装最新的release版本。</p>
<p>查看源里有哪些可安装的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># yum --showduplicates list ceph | expand</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.btte.net</span><br><span class="line"> * epel: mirrors.ustc.edu.cn</span><br><span class="line"> * extras: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.btte.net</span><br><span class="line">可安装的软件包</span><br><span class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</span><br><span class="line">ceph.x86_64                       1:11.0.1-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.0.2-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.1.0-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.1.1-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.2.1-0.el7                           ceph</span><br></pre></td></tr></table></figure>
<p>可以看到，最新的版本是 <code>11.2.1-0.el7</code>。可以通过指定安装包的形式来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ceph-11.2.0-0.el7</span><br></pre></td></tr></table></figure>
<h3 id="方法二：限制版本"><a href="#方法二：限制版本" class="headerlink" title="方法二：限制版本"></a>方法二：限制版本</h3><p>通过在 <code>/etc/yum.conf</code> 文件中添加配置来限制版本，这里只需要限制住比 11.2.0 高的版本就好了。</p>
<p>1、新增 <code>exclude</code> 配置行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.con</span><br><span class="line">[main]</span><br><span class="line">...</span><br><span class="line">exclude=*11.2.1*</span><br></pre></td></tr></table></figure>
<p>2、再次查看可安装的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># yum --showduplicates list ceph | expand</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.btte.net</span><br><span class="line"> * epel: mirrors.ustc.edu.cn</span><br><span class="line"> * extras: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.btte.net</span><br><span class="line">可安装的软件包</span><br><span class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</span><br><span class="line">ceph.x86_64                       1:11.0.1-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.0.2-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.1.0-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.1.1-0.el7                           ceph</span><br><span class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</span><br></pre></td></tr></table></figure>
<p>发现版本 11.2.1 不见了，当前最高可安装的版本是 11.2.0。</p>
<p>3、然后就可以直接安装了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ceph</span><br></pre></td></tr></table></figure>
<p><strong>如果要一次限制住多个版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exclude=*11.2.1* *11.1.0* *11.1.1* *11.0.1* *11.0.2*</span><br></pre></td></tr></table></figure>
<p>查看可安装版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># yum --showduplicates list ceph | expand</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.btte.net</span><br><span class="line"> * epel: mirrors.ustc.edu.cn</span><br><span class="line"> * extras: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.btte.net</span><br><span class="line">可安装的软件包</span><br><span class="line">ceph.x86_64                       1:0.80.7-0.10.el7                        epel</span><br><span class="line">ceph.x86_64                       1:11.2.0-0.el7                           ceph</span><br></pre></td></tr></table></figure>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>解决了上面的问题，但是又有如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">错误：软件包：1:ceph-osd-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：libleveldb.so.1()(64bit)</span><br><span class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：libbabeltrace.so.1()(64bit)</span><br><span class="line">错误：软件包：1:librbd1-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：liblttng-ust.so.0()(64bit)</span><br><span class="line">错误：软件包：1:ceph-mon-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：libleveldb.so.1()(64bit)</span><br><span class="line">错误：软件包：1:librados2-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：liblttng-ust.so.0()(64bit)</span><br><span class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：libleveldb.so.1()(64bit)</span><br><span class="line">错误：软件包：1:ceph-common-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：libbabeltrace-ctf.so.1()(64bit)</span><br><span class="line">错误：软件包：1:ceph-base-11.2.0-0.el7.x86_64 (ceph)</span><br><span class="line">          需要：liblttng-ust.so.0()(64bit)</span><br><span class="line"> 您可以尝试添加 --skip-broken 选项来解决该问题</span><br><span class="line"> 您可以尝试执行：rpm -Va --nofiles --nodigest</span><br></pre></td></tr></table></figure>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>依赖软件包的下载版本不一致，修改epel yum源即可，如果没有epel源，创建它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/epel.repo</span><br><span class="line">[epel]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line"></span><br><span class="line">[epel-debuginfo]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br><span class="line"></span><br><span class="line">[epel-source]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure>
<p>以上！</p>
<p>此时，ceph指定的版本就可以顺利的安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph -v</span><br><span class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux command day day up]]></title>
      <url>http://xiaqunfeng.cc/2017/09/21/linux-command-day-day-up/</url>
      <content type="html"><![CDATA[<p>This article is aim to record some not commonly used linux command which used in the work.<br><a id="more"></a></p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>该命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<p><strong>1、文件测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e 文件名</td>
<td>如果文件存在则为真</td>
</tr>
<tr>
<td>-r 文件名</td>
<td>如果文件存在且可读则为真</td>
</tr>
<tr>
<td>-w 文件名</td>
<td>如果文件存在且可写则为真</td>
</tr>
<tr>
<td>-x 文件名</td>
<td>如果文件存在且可执行则为真</td>
</tr>
<tr>
<td>-s 文件名</td>
<td>如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td>-d 文件名</td>
<td>如果文件存在且为目录则为真</td>
</tr>
<tr>
<td>-f 文件名</td>
<td>如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td>-c 文件名</td>
<td>如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td>-b 文件名</td>
<td>如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<p>比如，测试该系统是否含有某一个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat test.sh</span><br><span class="line">if test -f /etc/redhat-release ; then</span><br><span class="line">    echo &quot;this system is centos&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;this system is unbuntu&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>在centos系统上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sh test.sh</span><br><span class="line">this system is centos</span><br></pre></td></tr></table></figure>
<p>centos上<code>test -f /etc/redhat-release</code> 返回真，ubuntu系统上返回假。</p>
<p><strong>2、字符串测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于则为真</td>
</tr>
<tr>
<td>!=</td>
<td>不相等则为真</td>
</tr>
<tr>
<td>-z 字符串</td>
<td>字符串的长度为零则为真</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>字符串的长度不为零则为真</td>
</tr>
</tbody>
</table>
<p><strong>3、数值测试</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>等于则为真</td>
</tr>
<tr>
<td>-ne</td>
<td>不等于则为真</td>
</tr>
<tr>
<td>-gt</td>
<td>大于则为真</td>
</tr>
<tr>
<td>-ge</td>
<td>大于等于则为真</td>
</tr>
<tr>
<td>-lt</td>
<td>小于则为真</td>
</tr>
<tr>
<td>-le</td>
<td>小于等于则为真</td>
</tr>
</tbody>
</table>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># type cd</span><br><span class="line">cd 是 shell 内嵌</span><br><span class="line"># type date</span><br><span class="line">date 是 /usr/bin/date</span><br><span class="line"># type if</span><br><span class="line">if 是 shell 关键字</span><br><span class="line"># type mysql</span><br><span class="line">-bash: type: mysql: 未找到</span><br><span class="line"># type ll</span><br><span class="line">ll 是 `ls -l --color=auto&apos; 的别名</span><br><span class="line"># type yum</span><br><span class="line">yum 是 /usr/bin/yum</span><br><span class="line"># type apt-get</span><br><span class="line">-bash: type: apt-get: 未找到</span><br></pre></td></tr></table></figure>
<p>一些选项：</p>
<ul>
<li>-t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”； </li>
<li>-p：如果给出的指令为外部指令，则显示其绝对路径； </li>
<li>-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># type -t cd</span><br><span class="line">builtin</span><br><span class="line"># type -t ll</span><br><span class="line">alias</span><br><span class="line"># type -t yum</span><br><span class="line">file</span><br><span class="line"># type -t if</span><br><span class="line">keyword</span><br><span class="line">#################</span><br><span class="line"># type -p yum</span><br><span class="line">/usr/bin/yum</span><br><span class="line">#################</span><br><span class="line"># type -a cd</span><br><span class="line">cd 是 shell 内嵌</span><br><span class="line">cd 是 /usr/bin/cd</span><br><span class="line"># type -a date</span><br><span class="line">date 是 /usr/bin/date</span><br><span class="line"># type -a yum</span><br><span class="line">yum 是 /usr/bin/yum</span><br></pre></td></tr></table></figure>
<h2 id="TO-BE-ADD"><a href="#TO-BE-ADD" class="headerlink" title="TO BE ADD"></a>TO BE ADD</h2><p>TODO</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[awk学习笔记]]></title>
      <url>http://xiaqunfeng.cc/2017/09/19/awk-study-notes/</url>
      <content type="html"><![CDATA[<p>The awk study notes from working.<br><a id="more"></a></p>
<p>先从计算每个osd中分别有多少个pg的脚本入手，解析awk用法。见实例一。</p>
<h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>用于以下测试的待处理的文件 <code>test.txt</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PG_STAT OBJECTS MISSING_ON_PRIMARY DEGRADED MISPLACED UNFOUND BYTES LOG  DISK_LOG STATE        STATE_STAMP                VERSION   REPORTED   UP      UP_PRIMARY ACTING  ACTING_PRIMARY LAST_SCRUB SCRUB_STAMP                LAST_DEEP_SCRUB DEEP_SCRUB_STAMP</span><br><span class="line">14.2          23                  0        0         0       0     0 3011     3011 active+clean 2017-09-18 17:03:38.392203 57&apos;639918  57:989384 [4,3,0]          4 [4,3,0]              4  56&apos;635514 2017-09-18 17:03:38.392149       56&apos;616858 2017-09-14 19:36:02.937121</span><br><span class="line">#1.7           2                  0        0         0       0    92    6        6 active+clean 2017-09-18 19:30:20.206806      29&apos;6  57:232942 [3,4,1]          3 [3,4,1]              3       29&apos;6 2017-09-18 19:30:20.206744            29&apos;6 2017-09-14 20:35:14.294297</span><br></pre></td></tr></table></figure>
<p>想要学习的awk代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;</span><br><span class="line"> /^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3><p>1、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># awk &apos;/^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125; END &#123; printf(&quot;col=%d\n&quot;, col) &#125;&apos; test.txt</span><br><span class="line">col=15</span><br></pre></td></tr></table></figure>
<p>从 <code>PG_STAT</code> 开始，直到遇到 <code>UP</code> 时结束，计算得到 <code>UP</code> 后的列号。</p>
<p>2、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># awk &apos;/^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0 &#125; END &#123; printf(&quot;pool=%s, RSTART=%s, RLENGTH=%s\n&quot;, pool, RSTART, RLENGTH) &#125;&apos; test.txt</span><br><span class="line">pool=14, RSTART=1, RLENGTH=2</span><br></pre></td></tr></table></figure>
<p>解释一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[0-9a-f]+\.[0-9a-f]+/  ——  这个表示匹配开头格式是 X.X 的字符串，X表示一个或多个[0-9a-f]的数字字符</span><br></pre></td></tr></table></figure>
<p>关于match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match($0,/^[0-9a-f]+/)  ——  从第一列中匹配开头为 [0-9a-f] 的一个或多个数字字符</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RSTART，RLENGTH在match成功之后会自动被设置成第一个匹配部分的起始位置和长度，没匹配上就是0，-1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool=substr($0, RSTART, RLENGTH)  ——  得到pool的值</span><br></pre></td></tr></table></figure>
<p>3、运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># awk &apos;/^PG_STAT/ &#123; col=1; while($col!=&quot;UP&quot;) &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; printf(&quot;up=%s, RSTART=%s, RLENGTH=%s\n&quot;, up, RSTART,RLENGTH); t=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH); printf(&quot;osd=%s\n&quot;,t) &#125; &#125;&apos; test.txt</span><br><span class="line">up=[4,3,0], RSTART=2, RLENGTH=1</span><br><span class="line">osd=4</span><br><span class="line">up=,3,0], RSTART=2, RLENGTH=1</span><br><span class="line">osd=3</span><br><span class="line">up=,0], RSTART=2, RLENGTH=1</span><br><span class="line">osd=0</span><br></pre></td></tr></table></figure>
<p>得到 <code>ACTING</code> 列的OSD列表，用于统计每个pool在每个osd上的pg数。</p>
<h2 id="AWK模块"><a href="#AWK模块" class="headerlink" title="AWK模块"></a>AWK模块</h2><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substr( String, M, [ N ] )</span><br></pre></td></tr></table></figure>
<p>返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。</p>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match( String, Ere )</span><br></pre></td></tr></table></figure>
<p>在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。</p>
]]></content>
      
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph PGs per Pool Calculator]]></title>
      <url>http://xiaqunfeng.cc/2017/09/18/ceph-PGs-per-Pool-Calculator/</url>
      <content type="html"><![CDATA[<p>根据集群相关信息计算每个pool的pg数量。<br><a id="more"></a></p>
<p>在前一篇文章<a href="http://xiaqunfeng.cc/2017/09/15/too-many-PGs-per-OSD/">too-many-PGs-per-OSD</a>中，简单讲了pg数目的设定，这里再深入介绍一下计算方法。</p>
<h2 id="计算PG-Count的公式"><a href="#计算PG-Count的公式" class="headerlink" title="计算PG Count的公式"></a>计算PG Count的公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PoolPGCount=(TargetPGsPerOSD ∗ OSDNumber ∗ DataPercent) / PoolReplicateSize</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数释义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PoolPGCount</td>
<td>该pool的PG数量</td>
<td></td>
</tr>
<tr>
<td>TargetPGsPerOSD</td>
<td>每个OSD的PG数量</td>
<td>该值根据如下规则来进行设置：<br>1. 如果未来集群的OSD数量基本不再增长，Target PGs per OSD =100 <br>2. 如果未来集群的OSD数量可能增长到目前规模的2倍以内，Target PGs per OSD =200<br>3. 如果未来集群的OSD数量增长规模大于当前2倍且小于3倍，Target PGs per OSD =300</td>
</tr>
<tr>
<td>OSDNumber</td>
<td>OSD数目</td>
<td>默认是所有的OSD, 具体看OSD所属的rule<br>一般会通过CRUSH rules划分SSD和SATA两个ruleset，此时单独填写pool所在的对应rule的OSD数量</td>
</tr>
<tr>
<td>DataPercent</td>
<td>该pool占用所在OSD集群容量百分比</td>
<td>需要预估</td>
</tr>
<tr>
<td>PoolReplicateSize</td>
<td>该pool的副本数</td>
<td>replicate size，默认是3<br>如果是EC pool，该值为 m+n</td>
</tr>
</tbody>
</table>
<h2 id="结果取值"><a href="#结果取值" class="headerlink" title="结果取值"></a>结果取值</h2><p>1、如果上述计算结果小于 <code>OSDNumber/PoolReplicateSize</code> ，那就使用值 <code>OSDNumber/PoolReplicateSize</code> 。这是为了确保每个Pool的每个OSD至少分配一个Primary或Secondary PG来确保均匀加载/数据。</p>
<p>2、计算的最终结果应该是与计算结果相邻的2的幂次方。</p>
<blockquote>
<p>采用2的幂次方是因为了提高CRUSH算法的效率</p>
</blockquote>
<p>3、如果结果超过较小2次幂数值的25%则选择较大的2次幂作为最终结果，反之则选择较小的那个2次幂数值。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>1、计算公式的目的是为了确保整个集群拥有足够多的PG从而实现数据均匀分布在各个OSD上，同时能够有效避免在Recovery 和Backfill 的时候因为PG/OSD比值过高所造成的问题。 </p>
<p>2、如果集群中存在空pool或者其他non-active的pool，这些pool并不影响现有集群的数据分布，但是这些pool仍然会消耗集群的内存和CPU资源。</p>
<p>官网参考信息：<a href="http://ceph.com/pgcalc/" target="_blank" rel="noopener">http://ceph.com/pgcalc/</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[too many PGs per OSD]]></title>
      <url>http://xiaqunfeng.cc/2017/09/15/too-many-PGs-per-OSD/</url>
      <content type="html"><![CDATA[<p>ceph告警问题：”too many PGs per OSD” 的解决方法，以及pg数量的合理设定<br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">     health HEALTH_WARN	</span><br><span class="line">            too many PGs per OSD (412 &gt; max 300)</span><br><span class="line">     monmap e2: 3 mons at &#123;ceph0=172.21.1.21:6789/0,ceph1=172.21.1.22:6789/0,ceph2=172.21.1.23:6789/0&#125;</span><br><span class="line">            election epoch 1780, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">        mgr active: ceph0 standbys: ceph1, ceph2</span><br><span class="line">     osdmap e94: 6 osds: 6 up, 6 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v161317: 824 pgs, 10 pools, 30201 MB data, 8642 objects</span><br><span class="line">            90831 MB used, 181 GB / 269 GB avail</span><br><span class="line">                 824 active+clean</span><br><span class="line">  client io 34800 B/s wr, 0 op/s rd, 9 op/s wr</span><br></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>集群osd 数量较少</li>
<li>搭建rgw网关、OpenStack、容器组件等，pool创建较多，每个pool默认需要占用一些pg，pool中pg数目设置不合理，导致集群 total pg 数过多</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>调整每个osd默认pg数，参数为 <code>mon_pg_warn_max_per_osd</code> ，当前默认参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph --show-config  | grep mon_pg_warn_max_per_osd</span><br><span class="line">mon_pg_warn_max_per_osd = 300</span><br></pre></td></tr></table></figure>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、修改ceph配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd /etc/ceph</span><br><span class="line"># vim ceph.conf</span><br><span class="line">[global]</span><br><span class="line">.......</span><br><span class="line">mon_pg_warn_max_per_osd = 500</span><br></pre></td></tr></table></figure>
<p>2、将配置文件推到mon所在的其他节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph-deploy --overwrite-conf config push ceph1 ceph2</span><br></pre></td></tr></table></figure>
<p>3、重启mon进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart ceph-mon.target</span><br></pre></td></tr></table></figure>
<p>重启成功后，再次查看配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph --show-config  | grep mon_pg_warn_max_per_osd</span><br><span class="line">mon_pg_warn_max_per_osd = 500</span><br></pre></td></tr></table></figure>
<p>此时集群状态ok</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e2: 3 mons at &#123;ceph0=172.21.1.21:6789/0,ceph1=172.21.1.22:6789/0,ceph2=172.21.1.23:6789/0&#125;</span><br><span class="line">            election epoch 1780, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">        mgr active: ceph0 standbys: ceph1, ceph2</span><br><span class="line">     osdmap e94: 6 osds: 6 up, 6 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v161317: 824 pgs, 10 pools, 30201 MB data, 8642 objects</span><br><span class="line">            90831 MB used, 181 GB / 269 GB avail</span><br><span class="line">                 824 active+clean</span><br><span class="line">  client io 34800 B/s wr, 0 op/s rd, 9 op/s wr</span><br></pre></td></tr></table></figure>
<h2 id="pg数目的设定"><a href="#pg数目的设定" class="headerlink" title="pg数目的设定"></a>pg数目的设定</h2><h3 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h3><p>1、查看当前osd数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd ls | wc -l</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>2、查看当前有多少个pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool ls | wc -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>3、查看 replication pool 的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd dump | grep repli</span><br><span class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 31 flags hashpspool stripe_width 0</span><br><span class="line">pool 1 &apos;.rgw.root&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 14 flags hashpspool stripe_width 0</span><br><span class="line">pool 2 &apos;default.rgw.control&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 16 flags hashpspool stripe_width 0</span><br><span class="line">pool 3 &apos;default.rgw.data.root&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 19 flags hashpspool stripe_width 0</span><br><span class="line">pool 4 &apos;default.rgw.gc&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 20 flags hashpspool stripe_width 0</span><br><span class="line">pool 5 &apos;default.rgw.lc&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 21 flags hashpspool stripe_width 0</span><br><span class="line">pool 6 &apos;default.rgw.log&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 23 flags hashpspool stripe_width 0</span><br><span class="line">pool 7 &apos;default.rgw.users.uid&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 26 flags hashpspool stripe_width 0</span><br><span class="line">pool 8 &apos;kube&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 36 flags hashpspool stripe_width 0</span><br><span class="line">pool 9 &apos;stage&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 256 pgp_num 256 last_change 54 flags hashpspool stripe_width 0</span><br></pre></td></tr></table></figure>
<p>可以看到，每个pool都是 3 副本（<code>replicated size 3</code>）</p>
<h3 id="total-pg-num"><a href="#total-pg-num" class="headerlink" title="total pg num"></a>total pg num</h3><p>公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total PGs = (Total_number_of_OSD * 100) / max_replication_count</span><br></pre></td></tr></table></figure>
<p>结果必须取最接近该数的 2 的幂</p>
<p>比如，根据以上信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total_number_of_OSD = 6</span><br><span class="line">max_replication_count = 3</span><br><span class="line">Total PGs = 200</span><br></pre></td></tr></table></figure>
<p>最接近 200 的 2 的幂是 256。所以推荐的集群最大 total PGs 数为 256。</p>
<h3 id="pool-pg-num"><a href="#pool-pg-num" class="headerlink" title="pool pg num"></a>pool pg num</h3><p>每个 pool 的 pg 数目计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total PGs = ((Total_number_of_OSD * 100) / max_replication_count) / pool_count</span><br></pre></td></tr></table></figure>
<p>结果同样要取最接近的 2 的幂。</p>
<p>对应该例，每个 pool 的 pg num 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool_count = 10</span><br><span class="line">Total PGs = 200 / 10 = 20</span><br></pre></td></tr></table></figure>
<p>所以每个 pool 的平均分配 pg num 为 16。</p>
<h3 id="pg-num-command"><a href="#pg-num-command" class="headerlink" title="pg num command"></a>pg num command</h3><p>得到和设置指定 pool 中的 pg_num 和 pgp_num</p>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ceph osd pool create &lt;pool-name&gt; &lt;pg-number&gt; &lt;pgp-number&gt;</code></td>
<td>To create a new pool</td>
</tr>
<tr>
<td><code>ceph osd pool get &lt;pool-name&gt; &lt;pg_num&gt;</code></td>
<td>To get number of PG in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool get &lt;pool-name&gt; &lt;pgp_num&gt;</code></td>
<td>To get number of PGP in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool set &lt;pool-name&gt; &lt;pg_num number&gt;</code></td>
<td>To increase number of PG in a pool</td>
</tr>
<tr>
<td><code>ceph osd pool set &lt;pool-name&gt; &lt;pgp_num number&gt;</code></td>
<td>To increase number of PGP in a pool</td>
</tr>
</tbody>
</table>
<p>创建pool时如果不指定 pg_num，默认为8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph --show-config  | grep osd_pool_default_pg_num</span><br><span class="line">osd_pool_default_pg_num = 8</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令-lsblk]]></title>
      <url>http://xiaqunfeng.cc/2017/08/30/linux-cmd-lsblk/</url>
      <content type="html"><![CDATA[<p>介绍lsblk命令的详细用法。<br><a id="more"></a></p>
<h2 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h2><p>功能：列出块设备</p>
<p>描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsblk lists information about all available or the specified block devices.  The lsblk command reads the sysfs filesystem to gather information.</span><br><span class="line"></span><br><span class="line">The command prints all block devices (except RAM disks) in a tree-like format by default.  Use lsblk --help to get a list of all available columns.</span><br><span class="line"></span><br><span class="line">The default output, as well as the default output from options like --fs and --topology, is subject to change.  So whenever possible, you should avoid using default out‐puts in your scripts.  Always explicitly define expected columns by using --output columns-list in environments where a stable output is required.</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk [选项] [&lt;设备&gt; ...]</span><br></pre></td></tr></table></figure>
<p>-a 是默认选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1  436K  0 rom</span><br><span class="line">vda    253:0    0   20G  0 disk</span><br><span class="line">├─vda1 253:1    0    2M  0 part</span><br><span class="line">├─vda2 253:2    0  500M  0 part /boot</span><br><span class="line">└─vda3 253:3    0 19.5G  0 part /</span><br><span class="line">vdb    253:16   0   20G  0 disk</span><br><span class="line">├─vdb1 253:17   0  9.3G  0 part</span><br><span class="line">└─vdb2 253:18   0  9.3G  0 part </span><br><span class="line">vdc    253:32   0   10G  0 disk</span><br><span class="line">└─vdc1 253:33   0  9.3G  0 part</span><br></pre></td></tr></table></figure>
<h3 id="head说明"><a href="#head说明" class="headerlink" title="head说明"></a>head说明</h3><table>
<thead>
<tr>
<th>HEAD</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td>块设备名</td>
</tr>
<tr>
<td>MAJ:MIN</td>
<td>主要和次要设备号</td>
</tr>
<tr>
<td>RM</td>
<td>设备是否可移动设备(1为可移动)</td>
</tr>
<tr>
<td>SIZE</td>
<td>设备的容量大小信息</td>
</tr>
<tr>
<td>RO</td>
<td>设备是否为只读(1表示只读)</td>
</tr>
<tr>
<td>TYPE</td>
<td>块设备是否是磁盘或磁盘上的一个分区(disk表示是磁盘，part表示是分区, rom表示只读存储)</td>
</tr>
<tr>
<td>MOUNTPOINT</td>
<td>设备挂载的挂载点</td>
</tr>
</tbody>
</table>
<h3 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">选项：</span><br><span class="line"> -a, --all            打印所有设备</span><br><span class="line"> -b, --bytes          以字节为单位而非易读的格式来打印 SIZE</span><br><span class="line"> -d, --nodeps         不打印从属设备(slave)或占位设备(holder)</span><br><span class="line"> -D, --discard        打印时丢弃能力</span><br><span class="line"> -e, --exclude &lt;列表&gt; 根据主设备号排除设备(默认：内存盘)</span><br><span class="line"> -I, --include &lt;列表&gt; 只显示有指定主设备号的设备</span><br><span class="line"> -f, --fs             输出文件系统信息</span><br><span class="line"> -h, --help           使用信息(此信息)</span><br><span class="line"> -i, --ascii          只使用 ascii 字符</span><br><span class="line"> -m, --perms          输出权限信息</span><br><span class="line"> -l, --list           使用列表格式的输出</span><br><span class="line"> -n, --noheadings     不打印标题</span><br><span class="line"> -o, --output &lt;列表&gt;  输出列</span><br><span class="line"> -p, --paths          打印完整设备路径</span><br><span class="line"> -P, --pairs          使用 key=“value” 输出格式</span><br><span class="line"> -r, --raw            使用原生输出格式</span><br><span class="line"> -s, --inverse        反向依赖</span><br><span class="line"> -t, --topology       输出拓扑信息</span><br><span class="line"> -S, --scsi           输出有关 SCSI 设备的信息</span><br><span class="line"></span><br><span class="line"> -h, --help     显示此帮助并退出</span><br><span class="line"> -V, --version  输出版本信息并退出</span><br></pre></td></tr></table></figure>
<h2 id="选项示例"><a href="#选项示例" class="headerlink" title="选项示例"></a>选项示例</h2><h3 id="b"><a href="#b" class="headerlink" title="-b"></a>-b</h3><p>以字节为单位而非易读的格式来打印 SIZE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -b</span><br><span class="line">NAME   MAJ:MIN RM        SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1      446464  0 rom</span><br><span class="line">vda    253:0    0 21474836480  0 disk</span><br><span class="line">├─vda1 253:1    0     2097152  0 part</span><br><span class="line">├─vda2 253:2    0   524288000  0 part /boot</span><br><span class="line">└─vda3 253:3    0 20947402752  0 part /</span><br><span class="line">vdb    253:16   0 21474836480  0 disk</span><br><span class="line">├─vdb1 253:17   0  9999220736  0 part</span><br><span class="line">└─vdb2 253:18   0  9999220736  0 part </span><br><span class="line">vdc    253:32   0 10737418240  0 disk</span><br><span class="line">└─vdc1 253:33   0  9999220736  0 part</span><br></pre></td></tr></table></figure>
<h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>不打印从属设备(slave)或占位设备(holder)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -d</span><br><span class="line">NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0   11:0    1  436K  0 rom</span><br><span class="line">vda  253:0    0   20G  0 disk</span><br><span class="line">vdb  253:16   0   20G  0 disk</span><br><span class="line">vdc  253:32   0   10G  0 disk</span><br></pre></td></tr></table></figure>
<h3 id="f"><a href="#f" class="headerlink" title="-f"></a>-f</h3><p>输出文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -f</span><br><span class="line">NAME   FSTYPE  LABEL    UUID                                 MOUNTPOINT</span><br><span class="line">sr0    iso9660 config-2 2017-05-19-09-35-17-00</span><br><span class="line">vda</span><br><span class="line">├─vda1 vfat    BOOT     9485-0659</span><br><span class="line">├─vda2 xfs              4931e9cc-324d-43f1-9c77-c283add1d38d /boot</span><br><span class="line">└─vda3 xfs              8b9001aa-126c-489f-b23d-98ea539ee204 /</span><br><span class="line">vdb</span><br><span class="line">├─vdb1</span><br><span class="line">└─vdb2 xfs              824f74a5-0cd5-411a-a77f-8b42f398bb44 </span><br><span class="line">vdc</span><br><span class="line">└─vdc1 xfs              5389e17f-7613-48b1-a905-3115a43288e9</span><br></pre></td></tr></table></figure>
<h3 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h3><p>输出权限信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -m</span><br><span class="line">NAME    SIZE OWNER GROUP MODE</span><br><span class="line">sr0     436K root  cdrom brw-rw----</span><br><span class="line">vda      20G root  disk  brw-rw----</span><br><span class="line">├─vda1    2M root  disk  brw-rw----</span><br><span class="line">├─vda2  500M root  disk  brw-rw----</span><br><span class="line">└─vda3 19.5G root  disk  brw-rw----</span><br><span class="line">vdb      20G root  disk  brw-rw----</span><br><span class="line">├─vdb1  9.3G root  disk  brw-rw----</span><br><span class="line">└─vdb2  9.3G ceph  ceph  brw-rw----</span><br><span class="line">vdc      10G root  disk  brw-rw----</span><br><span class="line">└─vdc1  9.3G ceph  ceph  brw-rw----</span><br></pre></td></tr></table></figure>
<h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p>使用列表格式的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -l</span><br><span class="line">NAME MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0   11:0    1  436K  0 rom</span><br><span class="line">vda  253:0    0   20G  0 disk</span><br><span class="line">vda1 253:1    0    2M  0 part</span><br><span class="line">vda2 253:2    0  500M  0 part /boot</span><br><span class="line">vda3 253:3    0 19.5G  0 part /</span><br><span class="line">vdb  253:16   0   20G  0 disk</span><br><span class="line">vdb1 253:17   0  9.3G  0 part</span><br><span class="line">vdb2 253:18   0  9.3G  0 part </span><br><span class="line">vdc  253:32   0   10G  0 disk</span><br><span class="line">vdc1 253:33   0  9.3G  0 part</span><br></pre></td></tr></table></figure>
<h3 id="P"><a href="#P" class="headerlink" title="-P"></a>-P</h3><p>使用 key=“value” 输出格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -P</span><br><span class="line">NAME=&quot;sr0&quot; MAJ:MIN=&quot;11:0&quot; RM=&quot;1&quot; SIZE=&quot;436K&quot; RO=&quot;0&quot; TYPE=&quot;rom&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vda&quot; MAJ:MIN=&quot;253:0&quot; RM=&quot;0&quot; SIZE=&quot;20G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vda1&quot; MAJ:MIN=&quot;253:1&quot; RM=&quot;0&quot; SIZE=&quot;2M&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vda2&quot; MAJ:MIN=&quot;253:2&quot; RM=&quot;0&quot; SIZE=&quot;500M&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/boot&quot;</span><br><span class="line">NAME=&quot;vda3&quot; MAJ:MIN=&quot;253:3&quot; RM=&quot;0&quot; SIZE=&quot;19.5G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/&quot;</span><br><span class="line">NAME=&quot;vdb&quot; MAJ:MIN=&quot;253:16&quot; RM=&quot;0&quot; SIZE=&quot;20G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vdb1&quot; MAJ:MIN=&quot;253:17&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vdb2&quot; MAJ:MIN=&quot;253:18&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/var/lib/ceph/osd/ceph-2&quot;</span><br><span class="line">NAME=&quot;vdc&quot; MAJ:MIN=&quot;253:32&quot; RM=&quot;0&quot; SIZE=&quot;10G&quot; RO=&quot;0&quot; TYPE=&quot;disk&quot; MOUNTPOINT=&quot;&quot;</span><br><span class="line">NAME=&quot;vdc1&quot; MAJ:MIN=&quot;253:33&quot; RM=&quot;0&quot; SIZE=&quot;9.3G&quot; RO=&quot;0&quot; TYPE=&quot;part&quot; MOUNTPOINT=&quot;/var/lib/ceph/osd/ceph-4&quot;</span><br></pre></td></tr></table></figure>
<h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><p>输出拓扑信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -t</span><br><span class="line">NAME   ALIGNMENT MIN-IO OPT-IO PHY-SEC LOG-SEC ROTA SCHED RQ-SIZE   RA WSAME</span><br><span class="line">sr0            0   2048      0    2048    2048    1 cfq       128  128    0B</span><br><span class="line">vda            0    512      0     512     512    1           128 4096    0B</span><br><span class="line">├─vda1         0    512      0     512     512    1           128 4096    0B</span><br><span class="line">├─vda2         0    512      0     512     512    1           128 4096    0B</span><br><span class="line">└─vda3         0    512      0     512     512    1           128 4096    0B</span><br><span class="line">vdb            0    512      0     512     512    1           128 4096    0B</span><br><span class="line">├─vdb1         0    512      0     512     512    1           128 4096    0B</span><br><span class="line">└─vdb2         0    512      0     512     512    1           128 4096    0B</span><br><span class="line">vdc            0    512      0     512     512    1           128 4096    0B</span><br><span class="line">└─vdc1         0    512      0     512     512    1           128 4096    0B</span><br></pre></td></tr></table></figure>
<p>其中 <code>SCHED</code> 是调度算法，有 cfq、deadline 等等。</p>
<h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>输出有关 SCSI 设备的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -S</span><br><span class="line">NAME HCTL       TYPE VENDOR   MODEL             REV TRAN</span><br><span class="line">sr0  1:0:1:0    rom  QEMU     QEMU DVD-ROM     2.1. ata</span><br></pre></td></tr></table></figure>
<h3 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h3><p>输出列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -o FSTYPE /dev/vdb2</span><br><span class="line">FSTYPE</span><br><span class="line">xfs</span><br></pre></td></tr></table></figure>
<h3 id="n"><a href="#n" class="headerlink" title="-n"></a>-n</h3><p>不打印标题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># lsblk -n -o FSTYPE /dev/vdb2</span><br><span class="line">xfs</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Syntax error: '(' unexpected]]></title>
      <url>http://xiaqunfeng.cc/2017/08/29/Syntax-error-unexpected/</url>
      <content type="html"><![CDATA[<p>一个shell脚本在centos和ubuntu上执行的问题。<br><a id="more"></a></p>
<p>今天发现一个奇怪的现象，原先在centos上写的可用的shell脚本，今天在ubuntu上突然运行就报错了。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>脚本部分内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">array_osd=(2 3 4 5)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>执行脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh test.sh</span><br></pre></td></tr></table></figure>
<p>报的错误是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Syntax error: &quot;(&quot; unexpected</span><br></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>通过 <code>sh</code> 来执行脚本时，内核实际上执行的是 <code>/bin/sh</code></p>
<p>但是，在ubuntu上，<code>/bin/sh</code> 是 dash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 16.04.2 LTS</span><br><span class="line">Release:	16.04</span><br><span class="line">Codename:	xenial</span><br><span class="line"># ll /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4 Aug 22 16:24 /bin/sh -&gt; dash*</span><br></pre></td></tr></table></figure>
<p>而，在centos上，<code>/bin/sh</code> 是 bash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsb_release -a</span><br><span class="line">LSB Version:	:core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID:	CentOS</span><br><span class="line">Description:	CentOS Linux release 7.3.1611 (Core)</span><br><span class="line">Release:	7.3.1611</span><br><span class="line">Codename:	Core</span><br><span class="line"># ll /bin/sh</span><br><span class="line">lrwxrwxrwx. 1 root root 4 4月  20 11:52 /bin/sh -&gt; bash</span><br></pre></td></tr></table></figure>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>脚本中已经加了 <code>!/bin/bash</code> ，所以，直接执行的话，是用 bash 来执行，用 <code>sh</code> 会覆盖默认的bash。</p>
<p>所以，可以执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh</span><br><span class="line">$ ./test.sh</span><br></pre></td></tr></table></figure>
<p>OK，这时候就没有错误了</p>
]]></content>
      
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph osd相关操作]]></title>
      <url>http://xiaqunfeng.cc/2017/08/17/ceph-osd-operate/</url>
      <content type="html"><![CDATA[<p>ceph osd的相关操作，包括osd的部署（自动和手动部署）、OSD操作、journal软链、uuid等。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是之前笔记的一个整理，基于ceph jewel版本。</p>
<ul>
<li>自动部署osd可以采用 <code>ceph-deploy</code> ，也可以采用 <code>ceph-disk</code> 命令</li>
<li>luminous版本中，删除OSD可以直接使用 <code>ceph osd purge</code> 命令，比较省心</li>
<li>生产环节中磁盘的挂载尽量采用uuid/partuuid</li>
</ul>
<h2 id="添加OSD"><a href="#添加OSD" class="headerlink" title="添加OSD"></a>添加OSD</h2><p>查看当前挂载情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   200G  0 disk </span><br><span class="line">└─vdb1 253:17   0 186.3G  0 part /var/lib/ceph/osd/ceph-0</span><br><span class="line">vdc    253:32   0   200G  0 disk </span><br><span class="line">└─vdc1 253:33   0 186.3G  0 part /var/lib/ceph/osd/ceph-1</span><br></pre></td></tr></table></figure>
<p>在三个机器上：ceph-0, ceph-1, ceph-2 上每个机器挂两块盘，自动添加方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy osd prepare ceph-0:/dev/vdb1 ceph-0:/dev/vdc1</span><br><span class="line">chown ceph:ceph /dev/vdb1 /dev/vdc1</span><br><span class="line">ceph-deploy osd activate ceph-0:/dev/vdb1 ceph-0:/dev/vdc1</span><br><span class="line"></span><br><span class="line">ceph-deploy osd prepare ceph-1:/dev/vdb1 ceph-1:/dev/vdc1</span><br><span class="line">ssh ceph-1 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1&apos;</span><br><span class="line">ceph-deploy osd activate ceph-1:/dev/vdb1 ceph-1:/dev/vdc1</span><br><span class="line"></span><br><span class="line">ceph-deploy osd prepare ceph-2:/dev/vdb1 ceph-2:/dev/vdc1</span><br><span class="line">ssh ceph-2 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1&apos;</span><br><span class="line">ceph-deploy osd activate ceph-2:/dev/vdb1 ceph-2:/dev/vdc1</span><br></pre></td></tr></table></figure>
<p>这种方式添加完以后，OSD的状态就已经是 up 和 in 的状态了。</p>
<h2 id="手动部署OSD"><a href="#手动部署OSD" class="headerlink" title="手动部署OSD"></a>手动部署OSD</h2><h3 id="手动添加一个OSD过程"><a href="#手动添加一个OSD过程" class="headerlink" title="手动添加一个OSD过程"></a>手动添加一个OSD过程</h3><p>可以使用UUID来创建OSD，也可以不用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># uuidgen</span><br><span class="line">334d3f46-938c-41b7-9dc9-edc7e3036cbe</span><br><span class="line"># ceph osd create 334d3f46-938c-41b7-9dc9-edc7e3036cbe</span><br></pre></td></tr></table></figure>
<p>如果没有事先创建OSD的话，也可以在后面创建</p>
<p><strong>1、创建OSD目录，并把磁盘挂载到该目录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/ceph/osd/ceph-0</span><br><span class="line">mkfs -t xfs -d name=/dev/sda1 -f</span><br><span class="line">mount -noatime /dev/sda1 /var/lib/ceph/osd/ceph-0/</span><br></pre></td></tr></table></figure>
<p>查看挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount | egrep sda</span><br><span class="line">/dev/sda1 on /var/lib/ceph/osd/ceph-0 type xfs (rw)</span><br></pre></td></tr></table></figure>
<p><strong>2、初始化OSD数据目录</strong></p>
<p>不带uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-osd -i 0 --mkfs --mkkey</span><br></pre></td></tr></table></figure>
<p>带uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-osd -i 0 --mkfs --mkkey --osd-uuid 334d3f46-938c-41b7-9dc9-edc7e3036cbe</span><br></pre></td></tr></table></figure>
<p><strong>3、注册OSD的key权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph auth add osd.0 osd &apos;allow *&apos; mon &apos;allow profile osd&apos; -i /var/lib/ceph/osd/ceph-0/keyring</span><br></pre></td></tr></table></figure>
<p><strong>4、添加OSD节点到 crush map中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush add-bucket ceph01 host</span><br><span class="line">ceph osd crush move ceph01 root=default</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph create osd		// 如果之前没有创建OSD，那在加入crush map前要调用该命令创建OSD</span><br><span class="line">ceph osd crush add osd.0 1.0 host=ceph01</span><br></pre></td></tr></table></figure>
<p><strong>5、启动OSD</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start ceph-osd id=0</span><br></pre></td></tr></table></figure>
<h3 id="shell脚本示例"><a href="#shell脚本示例" class="headerlink" title="shell脚本示例"></a>shell脚本示例</h3><p>在节点data01上部署osd 0，1，2，3（不包含目录的创建、磁盘格式化和挂载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">host_name=data01</span><br><span class="line"># 以下两条命令一个节点执行一次就好了，不需要每添加一个OSD执行一次</span><br><span class="line">ceph osd crush add-bucket $host_name host		</span><br><span class="line">ceph osd crush move $host_name root=default		</span><br><span class="line"></span><br><span class="line">for osd_num in $(seq 0 3)</span><br><span class="line">do</span><br><span class="line">    ceph-osd -i $osd_num --mkfs --mkkey</span><br><span class="line">    ceph auth add osd.$osd_num osd &apos;allow *&apos; mon &apos;allow rwx&apos; -i /var/lib/ceph/osd/ceph-$osd_num/keyring</span><br><span class="line">    ceph osd create</span><br><span class="line">    ceph osd crush add osd.$osd_num 1.0 host=$host_name</span><br><span class="line">    ceph osd in $osd_num</span><br><span class="line">    chown -R ceph:ceph /var/lib/ceph/osd/ceph-$osd_num</span><br><span class="line">    start ceph-osd id=$osd_num</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>注：手动添加方式还可以参考<a href="http://docs.ceph.org.cn/rados/operations/add-or-rm-osds/" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="将挂载信息写入fstab"><a href="#将挂载信息写入fstab" class="headerlink" title="将挂载信息写入fstab"></a>将挂载信息写入fstab</h2><blockquote>
<p>好处是重启以后不需要再去手动mount。</p>
</blockquote>
<p>在 <code>/etc/fstab</code> 末尾添加如下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/vdb1	/var/lib/ceph/osd/ceph-0	xfs	defaults	0	2</span><br><span class="line">/dev/vdc1	/var/lib/ceph/osd/ceph-1	xfs	defaults	0	2</span><br></pre></td></tr></table></figure>
<p>然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<p>没有任何输出，表示挂载成功。</p>
<p>查看挂载信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">udev             2009636      12   2009624   1% /dev</span><br><span class="line">tmpfs             404696     552    404144   1% /run</span><br><span class="line">/dev/vda3       20027260 3009144  15977732  16% /</span><br><span class="line">none                   4       0         4   0% /sys/fs/cgroup</span><br><span class="line">none                5120       0      5120   0% /run/lock</span><br><span class="line">none             2023472      16   2023456   1% /run/shm</span><br><span class="line">none              102400       0    102400   0% /run/user</span><br><span class="line">/dev/vda2         463844   44634    390743  11% /boot</span><br><span class="line">/dev/vdb1      195216252 5282432 189933820   3% /var/lib/ceph/osd/ceph-0</span><br><span class="line">/dev/vdc1      195216252 5281204 189935048   3% /var/lib/ceph/osd/ceph-1</span><br></pre></td></tr></table></figure>
<h2 id="启动OSD"><a href="#启动OSD" class="headerlink" title="启动OSD"></a>启动OSD</h2><p>比如机器重启后，OSD处于 down 和 out 的状态，还没运行，必须先启动 OSD 它才能收数据。（前提是已经挂载好了）</p>
<p>在 Debian/Ubuntu 上用 Upstart。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo start ceph-osd id=&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>在 CentOS/RHEL 上用 sysvinit 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ceph start osd.&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>一旦你启动了 OSD ，其状态就由 down 变成 up。</p>
<p>注：必须去OSD所在节点上执行该命令才可以成功。好像不是的</p>
<h2 id="踢出和加入集群"><a href="#踢出和加入集群" class="headerlink" title="踢出和加入集群"></a>踢出和加入集群</h2><p>把 OSD 踢出集群</p>
<p>删除 OSD 前，它通常是 up 且 in 的，要先把它踢出集群，以使 Ceph 启动重新均衡、把数据拷贝到其他 OSD 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd out &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，把OSD加入集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd in &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<h2 id="停止OSD"><a href="#停止OSD" class="headerlink" title="停止OSD"></a>停止OSD</h2><p>把 OSD 踢出集群后，它可能仍在运行，就是说其状态为 up 且 out 。删除前要先停止 OSD 进程。</p>
<p>CentOS下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh &#123;osd-host&#125;</span><br><span class="line">sudo /etc/init.d/ceph stop osd.&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>ubuntu下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop ceph-osd id=&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>停止 OSD 后，状态变为 down 。</p>
<h2 id="删除OSD"><a href="#删除OSD" class="headerlink" title="删除OSD"></a>删除OSD</h2><p>此步骤依次把一个 OSD 移出集群 CRUSH 图、删除认证密钥、删除 OSD 图条目、删除 ceph.conf 条目。如果主机有多个硬盘，每个硬盘对应的 OSD 都得重复此步骤。</p>
<p>1、删除 CRUSH 图的对应 OSD 条目，它就不再接收数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush remove &#123;name&#125;		// ex: name = osd.0</span><br></pre></td></tr></table></figure>
<p>2、删除 OSD 认证密钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph auth del osd.&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>3、ceph-{osd-num} 路径里的 ceph 值是 $cluster-$id ，如果集群名字不是 ceph ，这里要更改。</p>
<p>删除 OSD 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd rm &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>如果将OSD相关的配置文件写到ceph配置文件中，那接下来还要删除配置文件中相关信息：</p>
<p>登录到保存 ceph.conf 主拷贝的主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh &#123;admin-host&#125;</span><br><span class="line">cd /etc/ceph</span><br><span class="line">vim ceph.conf</span><br></pre></td></tr></table></figure>
<p>从 ceph.conf 配置文件里删除对应条目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[osd.1]</span><br><span class="line">        host = &#123;hostname&#125;</span><br></pre></td></tr></table></figure>
<p>从保存 ceph.conf 主拷贝的主机，把更新过的 ceph.conf 拷贝到集群其他主机的 /etc/ceph 目录下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf config push &#123;hostname1&#125; &#123;hostname2&#125;</span><br></pre></td></tr></table></figure>
<p>完整的删除流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）ceph osd crush reweight osd.x 0.0  </span><br><span class="line">... 等待平衡结束....  </span><br><span class="line">2）ceph osd out osd.x  </span><br><span class="line">3）service ceph stop osd.x</span><br><span class="line"></span><br><span class="line">4）ceph osd crush remove osd.x  </span><br><span class="line">5）ceph auth del osd.x  </span><br><span class="line">6）ceph osd rm X</span><br></pre></td></tr></table></figure>
<h2 id="调整osd的权重"><a href="#调整osd的权重" class="headerlink" title="调整osd的权重"></a>调整osd的权重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush reweight osd.&#123;osd-no&#125; 1.000</span><br></pre></td></tr></table></figure>
<p>一般 1T 盘的权重为1.0，按照这个基准来调整OSD的权重。</p>
<h2 id="清除ceph信息"><a href="#清除ceph信息" class="headerlink" title="清除ceph信息"></a>清除ceph信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先停掉ceph相关进程</span><br><span class="line">rm /etc/ceph/*</span><br><span class="line">rm /var/lib/ceph/*</span><br></pre></td></tr></table></figure>
<p>格式化和挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount /var/lib/ceph/osd/ceph-26</span><br><span class="line">mkfs -t xfs -d name=/dev/sdf14 -f</span><br><span class="line">mount -noatime /dev/sdf14 /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题：运行osd启动命令后发现 osd还是down的状态</p>
<p>查看日志：<code>vim /var/log/ceph/ceph-osd.x.log</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-04-05 08:52:30.292249 7fe3789f1800  0 set uid:gid to 64045:64045 (ceph:ceph)</span><br><span class="line">2017-04-05 08:52:30.292263 7fe3789f1800  0 ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367), process ceph-osd, pid 27926</span><br><span class="line">2017-04-05 08:52:30.293056 7fe3789f1800  0 pidfile_write: ignore empty --pid-file</span><br><span class="line">2017-04-05 08:52:30.310394 7fe3789f1800 -1 filestore(/var/lib/ceph/osd/ceph-0) FileStore::mount: unable to access basedir &apos;/var/lib/ceph/osd/ceph-0&apos;: (13) Permission denied</span><br><span class="line">2017-04-05 08:52:30.310408 7fe3789f1800 -1 osd.0 0 OSD:init: unable to mount object store</span><br><span class="line">2017-04-05 08:52:30.310414 7fe3789f1800 -1  ** ERROR: osd init failed: (13) Permission denied</span><br></pre></td></tr></table></figure>
<p>权限的问题，修改osd目录权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R ceph:ceph /var/lib/ceph/osd</span><br></pre></td></tr></table></figure>
<h2 id="journal软链接"><a href="#journal软链接" class="headerlink" title="journal软链接"></a>journal软链接</h2><p>将ceph集群OSD对应的journal软链接到SSD的一个分区，提高journal速度。给每个OSD的journal配置独立的SSD分区有两种方式</p>
<h3 id="第一种是创建OSD的时候指定分区"><a href="#第一种是创建OSD的时候指定分区" class="headerlink" title="第一种是创建OSD的时候指定分区"></a>第一种是创建OSD的时候指定分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy osd prepare ceph-4:/dev/vdb1:/dev/vde1  //前面的是数据盘，后面的是日志盘</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="第二种就是软链接"><a href="#第二种就是软链接" class="headerlink" title="第二种就是软链接"></a>第二种就是软链接</h3><p>以下以 osd.0 为例，使用uuid</p>
<p>1、设置noout标志，防止集群进行数据恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd set noout</span><br></pre></td></tr></table></figure>
<p>2、停止OSD进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop ceph-osd id=0</span><br></pre></td></tr></table></figure>
<p>3、下刷journal到OSD中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-osd -i 0 --flush-journal</span><br></pre></td></tr></table></figure>
<p>4、移除旧的journal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal</span><br></pre></td></tr></table></figure>
<p>5、将新的journal链接到原来的位置</p>
<p>查看要链接的SSD分区uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/disk/by-partuuid/ | grep sdb1</span><br><span class="line">lrwxrwxrwx 1 root root  10 Apr  5 11:26 bcb81c86-5c98-4f65-9102-a0da5d1e5241 -&gt; ../../sdb1</span><br></pre></td></tr></table></figure>
<p>链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /dev/disk/by-partuuid/bcb81c86-5c98-4f65-9102-a0da5d1e5241 /var/lib/ceph/osd/ceph-0/journal</span><br></pre></td></tr></table></figure>
<p>修改权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br></pre></td></tr></table></figure>
<p>保存uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo bcb81c86-5c98-4f65-9102-a0da5d1e5241 &gt; /var/lib/ceph/osd/ceph-0/journal_uuid</span><br></pre></td></tr></table></figure>
<p>6、创建journal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-osd -i 0 --mkjournal</span><br></pre></td></tr></table></figure>
<p>7、启动osd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start ceph-osd id=0</span><br></pre></td></tr></table></figure>
<p>8、去除noout标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd unset noout</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候为了图省事，不用uuid，直接使用分区名称，也可以，生产环境中必须用uuid，切记！！</p>
</blockquote>
<h3 id="脚本列表"><a href="#脚本列表" class="headerlink" title="脚本列表"></a>脚本列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ceph osd set noout</span><br><span class="line">stop ceph-osd id=0</span><br><span class="line">ceph-osd -i 0 --flush-journal </span><br><span class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal </span><br><span class="line">ln -s /dev/sdf1 /var/lib/ceph/osd/ceph-0/journal	</span><br><span class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br><span class="line">chown -R ceph:ceph /dev/sdf1</span><br><span class="line">ceph-osd --mkjournal -i 0</span><br><span class="line">start ceph-osd id=0</span><br><span class="line">ceph osd unset noout</span><br></pre></td></tr></table></figure>
<p>注意，在软链的时候 <code>ln -s</code> 前面的参数是设备名称 <code>/dev/sdf1</code> ，而不是其所挂载的目录 <code>/mnt/journal/ceph-0</code></p>
<blockquote>
<p>注意，也要修改软链设备的权限</p>
</blockquote>
<h2 id="persistent-block-device-naming"><a href="#persistent-block-device-naming" class="headerlink" title="persistent block device naming"></a>persistent block device naming</h2><p>如果你的机器上有不止一个 SATA, SCSI 或 IDE 磁盘控制器，那么它们所对应的设备节点将会依随机次序添加。这样就可能导致每次引导时设备的名字如 <code>/dev/sda</code> 与 <code>/dev/sdb</code> 互换了，最终导致系统不可引导、kernel panic、或者设备不可见。持久化命名法可以解决这些问题。</p>
<p>有四种持久化命名方案：<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">by-label</a>#by-label)、<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">by-uuid</a>#by-uuid)、<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">by-id 和 by-path</a>#by-id_.E5.92.8C_by-path)。对于那些使用<a href="https://wiki.archlinux.org/index.php/GUID_Partition_Table" target="_blank" rel="noopener">GUID 分区表(GPT)</a>的磁盘，还有额外的两种方案，<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">by-partlabel</a>#by-partlabel) 和 <a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">by-partuuid</a>#by-partuuid)。你也可以<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">使用 Udev 静态设备名</a>#.E4.BD.BF.E7.94.A8_Udev_.E9.9D.99.E6.80.81.E8.AE.BE.E5.A4.87.E5.90.8D)方案。</p>
<p>GPT分区表的系统应用应该用 <code>blkid</code> 命令查看，列出的uuid和使用 <code>ll /dev/disk/by-uuid</code> 得到的结果一样。</p>
<blockquote>
<p>注：by-uuid 和 by-partuuid 得到的结果不一样，使用其中一种命名方式即可</p>
</blockquote>
<h3 id="by-uuid"><a href="#by-uuid" class="headerlink" title="by-uuid"></a>by-uuid</h3><p>UUID是一种给每个文件系统唯一标识符的机制。 这些标识符由文件系统实用程序（例如，mkfs。*）生成，当分区被格式化并和设计时不太可能发生冲突。 所有GNU / Linux文件系统（包括原始加密设备的交换和LUKS头）都支持UUID。 FAT和NTFS文件系统（上面的fat和windows标签）不支持UUID，但仍然列在 <code>/dev/disk/by-uuid</code> 中，具有较短的UID（唯一标识符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure>
<p>使用UUID方法的优点是名称冲突发生的可能性远远小于标签。 此外，它在文件系统的创建时自动生成。 例如，即使设备插入另一个系统（可能具有相同标签的设备），它将保持独特。<br>缺点是UUID使得很长的代码行难以读取和中断许多配置文件（例如fstab或crypttab）中的格式化。 每次分区<strong>重新调整大小</strong>或<strong>重新格式化</strong>时，都会生成一个新的UUID，并且必须调整配置（手动）。<br>提示：如果swap分区没有分配UUID，则需要使用mkswap实用程序重置交换分区。</p>
<h3 id="by-partuuid"><a href="#by-partuuid" class="headerlink" title="by-partuuid"></a>by-partuuid</h3><p>注意：此方法仅涉及具有GUID分区表（GPT）的磁盘。<br>像GPT分区标签一样，GPT分区UUID在GPT磁盘上的分区条目中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/disk/by-partuuid/</span><br></pre></td></tr></table></figure>
<p>关于其他的使用方式详见<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">wiki</a>)</p>
<h2 id="关于UUID"><a href="#关于UUID" class="headerlink" title="关于UUID"></a>关于UUID</h2><p>UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。</p>
<p>使用UUID和使用/dev/sda5这种直接引用分区的方法的一个优点就是，当硬盘中增加了新的分区，或者分区的顺序改变后，仍然能够保证系统加载分区到正确的加载点。插拔盘并不会改变uuid。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /dev/disk/by-</span><br><span class="line">by-id/           by-parttypeuuid/ by-path/         </span><br><span class="line">by-partlabel/    by-partuuid/     by-uuid/</span><br></pre></td></tr></table></figure>
<p>查看uuid的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># blkid</span><br><span class="line">/dev/vda1: SEC_TYPE=&quot;msdos&quot; LABEL=&quot;BOOT&quot; UUID=&quot;9485-0659&quot; TYPE=&quot;vfat&quot; </span><br><span class="line">/dev/vda2: UUID=&quot;30cb52e3-c54e-468c-944a-b27f2fe2dc4f&quot; TYPE=&quot;ext4&quot; </span><br><span class="line">/dev/vda3: UUID=&quot;012def77-c10e-47df-a669-85143d2e8073&quot; TYPE=&quot;ext4&quot; </span><br><span class="line">/dev/vdb1: UUID=&quot;cad11e23-e104-419d-9b61-3a1b6dc27fc9&quot; TYPE=&quot;xfs&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># blkid /dev/vdb1</span><br><span class="line">/dev/vdb1: UUID=&quot;cad11e23-e104-419d-9b61-3a1b6dc27fc9&quot; TYPE=&quot;xfs&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/disk/by-uuid/ | grep vdb1</span><br><span class="line">lrwxrwxrwx 1 root root  10 Apr  1 16:13 cad11e23-e104-419d-9b61-3a1b6dc27fc9 -&gt; ../../vdb1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令和功能]]></title>
      <url>http://xiaqunfeng.cc/2017/08/07/git-usage/</url>
      <content type="html"><![CDATA[<p>总结记录自己最常用的git命令，然后将一些命令分类，便于翻阅。<br><a id="more"></a></p>
<h2 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h2><p>1、下载一个项目和它的整个代码历史</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>
<p>2、分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 切换到指定分支，并更新工作区</span><br><span class="line">git checkout [branch-name]	</span><br><span class="line"></span><br><span class="line">// 新建一个分支，并切换到该分支	</span><br><span class="line">git checkout -b [branch-name]	</span><br><span class="line"></span><br><span class="line">// 将名称为[branch-name]的分支合并到master</span><br><span class="line">git checkout master</span><br><span class="line">git merge [branch-name]</span><br></pre></td></tr></table></figure>
<p>3、显示有变更的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>4、添加文件到暂存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add [file1] [file2] ...	// 添加指定文件到暂存区</span><br><span class="line">git add [dir]				// 添加指定目录到暂存区，包括子目录</span><br><span class="line">git add -A					// 添加所有git status显示有变更的文件</span><br></pre></td></tr></table></figure>
<p>5、提交暂存区到仓库区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>
<p>6、恢复暂存区文件到工作区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file]		// 恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout .			// 恢复暂存区的所有文件到工作区</span><br></pre></td></tr></table></figure>
<h2 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库 - repository"></a>仓库 - repository</h2><p>初始化目录为git仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>下载远程仓库的所有变动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote]</span><br></pre></td></tr></table></figure>
<p>取回远程仓库的变化，并与本地分支合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>
<p>查看远程仓库地址和名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>推送本地分支到远程仓库，首次提交需要加-u</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push –u origin branch</span><br></pre></td></tr></table></figure>
<p>创建远程分支(本地分支push到远程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;local_branch&gt;	// 创建远程分支， origin是远程仓库名</span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; // 提交本地分支作为远程的分支</span><br></pre></td></tr></table></figure>
<p>删除远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;repository&gt;</span><br></pre></td></tr></table></figure>
<h2 id="分支-branch"><a href="#分支-branch" class="headerlink" title="分支 - branch"></a>分支 - branch</h2><p>列出所有本地分支和远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<p>查看远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<p>查看本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>创建新分支并立即切换到新分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [name]</span><br></pre></td></tr></table></figure>
<p>基于远程分支创建本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout   -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>
<p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [name]</span><br></pre></td></tr></table></figure>
<p>删除远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :heads/[name]</span><br></pre></td></tr></table></figure>
<p>先删除本地分支(<code>git br -d &lt;branch&gt;</code>)，然后再push删除远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>
<p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [name] ----将名称为[name]的分支与当前分支合并</span><br></pre></td></tr></table></figure>
<h2 id="版本-tag"><a href="#版本-tag" class="headerlink" title="版本 - tag"></a>版本 - tag</h2><p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>创建版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [name]</span><br></pre></td></tr></table></figure>
<p>删除版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d [name]</span><br></pre></td></tr></table></figure>
<p>查看远程版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -r</span><br></pre></td></tr></table></figure>
<p>创建远程版本(本地版本push到远程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [name]</span><br></pre></td></tr></table></figure>
<p>删除远程版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/[name]</span><br></pre></td></tr></table></figure>
<p>checkout远程tags到本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_branch_name&gt; &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
<h2 id="日志-log"><a href="#日志-log" class="headerlink" title="日志 - log"></a>日志 - log</h2><p>查看历史版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p>查看提交统计信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>
<p>查看最近一次详细修改内容的diff</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -1		// -p 是显示详细信息的意思</span><br></pre></td></tr></table></figure>
<p>查看某个文件的提交记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>显示指定文件是什么人在什么时间修改过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame [file]</span><br></pre></td></tr></table></figure>
<p>显示今天你写了多少行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>比较当前文件和暂存区文件差异</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [commit]</span><br></pre></td></tr></table></figure>
<p>暂时将未提交的变化移除，稍后再移入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>显示某次提交时，某个文件的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>
<p>删除所有untracked文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean</span><br></pre></td></tr></table></figure>
<h2 id="同步fork"><a href="#同步fork" class="headerlink" title="同步fork"></a>同步fork</h2><p>fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？本文将给你解答。</p>
<h3 id="Configuring-a-remote-for-a-fork"><a href="#Configuring-a-remote-for-a-fork" class="headerlink" title="Configuring a remote for a fork"></a>Configuring a remote for a fork</h3><ul>
<li>给 fork 配置一个 remote</li>
<li>主要使用 <code>git remote -v</code> 查看远程状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</span><br><span class="line"># origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</span><br></pre></td></tr></table></figure>
<ul>
<li>添加一个将被同步给 fork 远程的上游仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure>
<ul>
<li>再次查看状态确认是否配置成功。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)</span><br><span class="line"># origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)</span><br><span class="line"># upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)</span><br><span class="line"># upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)</span><br></pre></td></tr></table></figure>
<h3 id="Syncing-a-fork"><a href="#Syncing-a-fork" class="headerlink" title="Syncing a fork"></a>Syncing a fork</h3><ul>
<li>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/master<br><code>git fetch upstream</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line"># remote: Counting objects: 75, done.</span><br><span class="line"># remote: Compressing objects: 100% (53/53), done.</span><br><span class="line"># remote: Total 62 (delta 27), reused 44 (delta 9)</span><br><span class="line"># Unpacking objects: 100% (62/62), done.</span><br><span class="line"># From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</span><br><span class="line">#  * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure>
<ul>
<li>切换到本地主分支(如果不在的话)<br><code>git checkout master</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"># Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br><code>git merge upstream/master</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br><span class="line"># Updating a422352..5fdff0f</span><br><span class="line"># Fast-forward</span><br><span class="line">#  README                    |    9 -------</span><br><span class="line">#  README.md                 |    7 ++++++</span><br><span class="line">#  2 files changed, 7 insertions(+), 9 deletions(-)</span><br><span class="line">#  delete mode 100644 README</span><br><span class="line">#  create mode 100644 README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想更新到 GitHub 的 fork 上，直接 <code>git push origin master</code> 就好了。</li>
</ul>
<p>该部分参考：<a href="https://gaohaoyang.github.io/2015/04/12/Syncing-a-fork/" target="_blank" rel="noopener">syncing a fork</a></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>比如，配置全局用户名和邮箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br><span class="line">$ git config --global user.name &quot;yourname&quot;</span><br></pre></td></tr></table></figure>
<p>为某个仓库配置的话，在该仓库目录下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.email &quot;email@example.com&quot;</span><br><span class="line">$ git config user.name &quot;yourname&quot;</span><br></pre></td></tr></table></figure>
<h2 id="将已有项目添加到github"><a href="#将已有项目添加到github" class="headerlink" title="将已有项目添加到github"></a>将已有项目添加到github</h2><blockquote>
<p>已有本地项目，文件夹名为gitRepo</p>
</blockquote>
<p>1、初始化本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd gitRepo</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>2、添加全部文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .      // git add -A</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有README.md，可以创建一个先</p>
</blockquote>
<p>3、提交说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;xxxxx&apos;</span><br></pre></td></tr></table></figure>
<p>4、github上创建仓库</p>
<p>在github上新建仓库，名称为<code>gitRepo</code>，必须和文件夹同名！</p>
<p>5、添加远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:yourgithubID/gitRepo.git</span><br></pre></td></tr></table></figure>
<p>6、将本地仓库push到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>以上。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ git checkout v12.1.4</span><br><span class="line">warning: refname &apos;v12.1.4&apos; is ambiguous.</span><br><span class="line">Switched to branch &apos;v12.1.4&apos;</span><br></pre></td></tr></table></figure>
<p>原因：这个branch的名称是危险的，因为这是可能是一个标识名、tag名等。所以，rename一下就好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">▶ git branch -m v12.1.4 v12.1.4-local</span><br></pre></td></tr></table></figure>
<p><strong>Q2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>
<p>参考链接: <a href="https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories" target="_blank" rel="noopener">git refusing to merge unrelated histories</a></p>
<p>解决方法：在执行命令后加上选项 <code>--allow-unrelated-histories</code></p>
<p><strong>Q3</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining</span><br><span class="line">git clone error: RPC failed; curl 56 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>Errno 56，是由于大文件造成的提交或者拉取失败。增大缓存配置，比如下面就是配置提交缓存为 500M。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config http.postBuffer 524288000</span><br><span class="line">git config https.postBuffer 524288000</span><br></pre></td></tr></table></figure>
<p>还太大的话，在clone的时候加上depth</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 xxx.git</span><br></pre></td></tr></table></figure>
<p>再不行就重新安装一下git试试：brew install git</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python3 OS module]]></title>
      <url>http://xiaqunfeng.cc/2017/08/05/python3-OS-module/</url>
      <content type="html"><![CDATA[<p>python3 OS 模块学习笔记<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用的时候需要导入OS模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br></pre></td></tr></table></figure>
<h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><p>1、<strong>os.path.split(path)  </strong></p>
<p>功能：将path分割成目录和文件名二元组返回</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;test/iostat.jpg&apos;)</span><br><span class="line">(&apos;test&apos;, &apos;iostat.jpg&apos;)</span><br></pre></td></tr></table></figure>
<p>2、<strong>os.path.dirname(path) </strong></p>
<p>功能：返回path的目录名。其实就是os.path.split(path)的第一个元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.dirname(&apos;test/iostat.jpg&apos;)</span><br><span class="line">&apos;test&apos;</span><br></pre></td></tr></table></figure>
<p>3、<strong>os.path.basename(path)</strong></p>
<p>功能：返回path最后的文件名。即os.path.split(path)的第二个元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.basename(&apos;test/iostat.jpg&apos;)</span><br><span class="line">&apos;iostat.jpg&apos;</span><br></pre></td></tr></table></figure>
<p>4、<strong>.os.path.splitext(path)</strong></p>
<p>功能：分离文件名与扩展名。默认返回(fname,fextension)元组，可做分片操作。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;test/iostat.jpg&apos;)</span><br><span class="line">(&apos;test/iostat&apos;, &apos;.jpg&apos;)</span><br></pre></td></tr></table></figure>
<p>5、<strong>os.path.join(path1[, path2[, …]])</strong></p>
<p>功能：将多个路径组合后返回，第一个绝对路径之前的参数将被忽略。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.join(&apos;test/iostat.jpg&apos;)</span><br><span class="line">&apos;test/iostat.jpg&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;test/iostat.jpg&apos;, &apos;hahaha&apos;)</span><br><span class="line">&apos;test/iostat.jpg/hahaha&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;test&apos;, &apos;hello&apos;)</span><br><span class="line">&apos;test/hello&apos;</span><br></pre></td></tr></table></figure>
<p>6、<strong>os.path.isdir(path)</strong></p>
<p>功能：如果path是一个存在的目录，则返回True。否则返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.isdir(&apos;test&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.isdir(&apos;xqf&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>7、<strong>os.path.isfile(path)</strong></p>
<p>功能：如果path是一个存在的文件，返回True。否则返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.isfile(&apos;test/iostat.jpg&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.isfile(&apos;test/hello.jpg&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>8、<strong>os.path.abspath(path)</strong>   </p>
<p>功能：返回path规范化的绝对路径。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;test/hello.jpg&apos;)</span><br><span class="line">&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一步其实已经包含 os.path.normpath(path) 的操作</p>
</blockquote>
<p>9、<strong>os.path.isabs(path) </strong></p>
<p>功能：如果path是绝对路径，返回True。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.isabs(&apos;test/hello.jpg&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.isabs(&apos;/Users/xiaqunfeng/helloworld&apos;)		// helloworld并不存在</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数只返回是不是绝对路径，不判断路径是否存在</p>
</blockquote>
<p>10、<strong>os.path.exists(path) </strong></p>
<p>功能：如果path存在，返回True；如果path不存在，返回False。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/helloworld&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/python/show-me-the-code/0005/test/hello.jpg&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.exists(&apos;test/hello.jpg&apos;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; os.path.exists(&apos;test&apos;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; os.path.exists(&apos;/Users/xiaqunfeng/python/show-me-the-code/&apos;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只判断路径是否存在，不能是具体的文件</p>
</blockquote>
<p>11、<strong>os.path.getsize(path) </strong></p>
<p>功能：返回path的文件的大小（字节）</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.getsize(&apos;test/iostat.jpg&apos;)</span><br><span class="line">237491</span><br></pre></td></tr></table></figure>
<p>12、<strong>os.path.getatime(path)</strong> &amp;&amp; <strong>os.path.getmtime(path)</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.path.getatime(path)          # 返回path所指向的文件或者目录的最后存取时间</span><br><span class="line">os.path.getmtime(path)          # 返回path所指向的文件或者目录的最后修改时间</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.getatime(&apos;test/iostat.jpg&apos;)</span><br><span class="line">1499659865.0</span><br><span class="line">&gt;&gt;&gt; os.path.getmtime(&apos;test/iostat.jpg&apos;)</span><br><span class="line">1499655924.0</span><br></pre></td></tr></table></figure>
<p>这里得到的是一个浮点数的timestamp，如果有小数位，小数位表示毫秒数。</p>
<p>可是看不懂哇。所以这里需要进行转换，将timestamp转换为datetime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; atime = 1499659865.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(atime))</span><br><span class="line">2017-07-10 12:11:05</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; mtime = 1499655924.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(mtime))</span><br><span class="line">2017-07-10 11:05:24</span><br></pre></td></tr></table></figure>
<p>13、<strong>os.path.normpath()</strong></p>
<p>功能：返回正常路径，可以解决双斜杆、对目录的多重引用的问题等。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;test//hello.jpg&apos;)</span><br><span class="line">&apos;test/hello.jpg&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/../test/hello.jpg&apos;)</span><br><span class="line">&apos;test/hello.jpg&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/test/hello.jpg&apos;)			// 该目录不存在</span><br><span class="line">&apos;test/test/hello.jpg&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.normpath(&apos;test/../test/../result/../test/hello.jpg&apos;)</span><br><span class="line">&apos;test/hello.jpg&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅规范化目录，不能判断目录是否存在</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么对于企业NAS来说NFS-ganesha是一个更好的NFS server]]></title>
      <url>http://xiaqunfeng.cc/2017/08/03/nfs-ganesha/</url>
      <content type="html"><![CDATA[<p>如题，介绍了ganesha，同时对比了用户态下的nfs server(ganesha)和内核态下传统nfs server。<br><a id="more"></a></p>
<h2 id="What-is-NFS-Ganesha"><a href="#What-is-NFS-Ganesha" class="headerlink" title="What is NFS-Ganesha?"></a>What is NFS-Ganesha?</h2><p>1、是NFS server用户态层面的实现</p>
<p>支持 NFS V2, V3, V4, V4.1, V4.2</p>
<p>2、可以管理庞大的元数据和数据缓存</p>
<p>3、能够访问不同的数据集</p>
<p>4、规定开发 FS 的具体特性</p>
<p>5、能够同时为多个不同类型的文件系统服务</p>
<p>6、能够同时服务多个协议</p>
<p>7、可以作为一个 Proxy server 并导出一个远端的 NFSv4 server</p>
<p>8、不感知集群管理</p>
<p>同时拥有一个小但是在成长中的社区</p>
<p>积极参与者有：IBM, Panasas, Redhat, LinuxBox, CES</p>
<h2 id="Enterprise-NAS"><a href="#Enterprise-NAS" class="headerlink" title="Enterprise NAS"></a>Enterprise NAS</h2><p>1、通过集群配置可靠、冗余和故障安全。</p>
<p>2、通过多个协议服务结构化和非机构化数据。</p>
<p>3、在容量和性能上可扩展</p>
<ul>
<li>灵活的 scale-up 和 scale-out</li>
<li>能够支持大量客户端</li>
</ul>
<p>4、企业级特性：tiering, de-dup, multi-tenancy, multi-protocol 等</p>
<p>5、灵活的运行在多个平台并服务于异构数据集</p>
<p>6、支持复杂的安全配置</p>
<p>7、QoS - 服务质量（Quality of Service）</p>
<h2 id="Kernel-vs-User-Space-Server"><a href="#Kernel-vs-User-Space-Server" class="headerlink" title="Kernel vs User Space Server"></a>Kernel vs User Space Server</h2><p>1、内核级服务需要提供更多的up-calls</p>
<ul>
<li>Mounted和exportfs信息</li>
<li>ID映射</li>
<li>GSS API</li>
<li>客户端ID跟踪</li>
<li>Statd 相互作用</li>
<li>集群相关的服务</li>
</ul>
<p>2、为什么用户空间更好</p>
<ul>
<li>用户空间比内核空间更灵活</li>
<li>实现 restarts, failover, failback 更容易</li>
<li>不需要实现系统调用</li>
<li>和用户空间的服务的交互没有 up-calls </li>
<li>clustering变得自然而简单</li>
<li>有针对性和侵略性的缓存功能</li>
<li>灵活和插件式的 FSAL（可以利用的 FS 的特定功能）</li>
<li>可以通过支持通用的 DLM 分布式锁管理来支持 multi-Protocol</li>
<li>易于实现的 multi-tenancy</li>
<li>易于监控和控制资源消耗，甚至扩展至强制执行QoS</li>
<li>可管理性和调试能力是重要的加分项</li>
</ul>
<p>3、内核服务没有优点吗？优点在这</p>
<ul>
<li>文件句柄：最近才有的主要优势，现在有了开放式的支持</li>
<li>性能：用户空间差一点，但可以通过集群FS，积极缓存，自定义RPC，以及积极的线程/并行执行来抵消</li>
<li>所有权/权限：每一个处理都通过 setfsuid。但是其他可能需要执行多个系统调用或特殊的 FS 接口来实现，如VFS，Luster，GPFS，但实CEPH，Gluster 可以接受lib库实现</li>
<li>多次系统调用由于WCC的原因需要 perform, write/getattr</li>
<li>没有重复的缓存和零拷贝读写，降低了复杂性</li>
</ul>
<h2 id="Clustering-with-NFS-Ganesha"><a href="#Clustering-with-NFS-Ganesha" class="headerlink" title="Clustering with NFS-Ganesha"></a>Clustering with NFS-Ganesha</h2><p>1、建议 Cluster Manager Abstraction Layer (CMAL) ，使集群不感知</p>
<p>2、故障转移和IP移动处理</p>
<p>3、集群感知DRC</p>
<p>4、跨集群的DLM</p>
<p>5、集群范围的宽限期管理</p>
<h2 id="Cluster-Manager-Abstraction-Layer-CMAL"><a href="#Cluster-Manager-Abstraction-Layer-CMAL" class="headerlink" title="Cluster Manager Abstraction Layer (CMAL)"></a>Cluster Manager Abstraction Layer (CMAL)</h2><p>1、为集群管理提供了一个抽象的支持</p>
<p>2、管理集群节点中节点内的通信</p>
<p>3、通用性足以实现 cDRC, DLM等特性的多个集群交互</p>
<p>4、集群管理不可知。容易插入任何集群管理中</p>
<p>5、模仿FSAL</p>
<p>6、CMAL层将具有基于集群管理的功能指针</p>
<p>7、能够提供pNFS配置文件中DS和MDS节点间的集群通信</p>
<h2 id="Cluster-DRC"><a href="#Cluster-DRC" class="headerlink" title="Cluster DRC"></a>Cluster DRC</h2><p>1、DRC帮助server识别非幂等操作的重复请求，并进行相应处理</p>
<p>2、识别back-up节点以备份DRC，或在集群/中心位置的所有节点上备份</p>
<p>3、通过CMAL存储和获取DRC entries</p>
<p>4、接口</p>
<ul>
<li>init_drc_cmal(server-ip)：初始化CMAL接口，设置server-ip的备份节点。</li>
<li>add_drc_entry(xid, entry, server-ip)：在集群中存储DRC entry。</li>
<li>retrieve_drc_entries(server-ip)：检索特定服务节点的所有entry</li>
<li>shutdown_drc_cmal(server-ip)：关闭指定 server-ip 的CMAL接口</li>
</ul>
<h2 id="Failover-IP-Move"><a href="#Failover-IP-Move" class="headerlink" title="Failover/IP Move"></a>Failover/IP Move</h2><p>1、NLM使其非常复杂，但NFS-Ganesha架构面临挑战。</p>
<p>2、在第一次加锁和最后一次解锁时，Ganesha调用集群管理提供的接口去register(monitor)/unregister(unmonitor) the client-ip, server-ip pair</p>
<p>3、当IP被移动（手动或者失败），CM发送 sm_notify 给影响 server-ip的客户端</p>
<p>4、CM为相应的服务器节点生成事件，release-ip，take-ip，所以状态应该从源节点释放，在目的节点获取</p>
<p>5、根据锁的粒度，相应的锁/文件系统，或者整个集群应该优雅的进入</p>
<h2 id="Distributed-Lock-manager"><a href="#Distributed-Lock-manager" class="headerlink" title="Distributed Lock manager"></a>Distributed Lock manager</h2><p>1、NFS-Ganesha的架构支持DLM</p>
<p>DLM可以用不同的方式实现</p>
<p>2、允许管理集群范围锁</p>
<p>3、通过 NFS, CIFS和其他协议共享状态管理</p>
<p>4、最小化失败带来影响的能力（Targeted Grace）</p>
<h2 id="FSAL-Enhancements-and-new-features"><a href="#FSAL-Enhancements-and-new-features" class="headerlink" title="FSAL Enhancements and new features"></a>FSAL Enhancements and new features</h2><p>1、动态exports</p>
<p>2、delegations</p>
<p>3、FSAL 增强</p>
<ul>
<li>支持ACL</li>
<li>开放升级支持</li>
<li>解决POSIX语义</li>
<li>用户libraries可以轻松插入（protecTIER, GlusterFS）</li>
<li>可堆叠的FSALs</li>
<li>PseudoFS作为FSAL的第一个类</li>
</ul>
<p>4、LTTng集成</p>
<p>5、通过libmooshika支持RDMA</p>
<h2 id="NFS-Ganesha-links"><a href="#NFS-Ganesha-links" class="headerlink" title="NFS-Ganesha links"></a>NFS-Ganesha links</h2><p>1、NFS-Ganesha is available under the terms of the LGPLv3 license.<br>2、NFS-Ganesha Project homepage on github<br> <a href="https://github.com/nfs-ganesha/nfs-ganesha/wiki" target="_blank" rel="noopener">https://github.com/nfs-ganesha/nfs-ganesha/wiki</a><br>3、Github:<br> <a href="https://github.com/nfs-ganesha/nfs-ganesh" target="_blank" rel="noopener">https://github.com/nfs-ganesha/nfs-ganesh</a><br>4、Download page<br> <a href="http://sourceforge.net/projects/nfs-ganesha/files" target="_blank" rel="noopener">http://sourceforge.net/projects/nfs-ganesha/files</a><br>5、Mailing lists</p>
<ul>
<li> <a href="mailto:nfs-ganesha-devel@lists.sourceforge.net" target="_blank" rel="noopener">nfs-ganesha-devel@lists.sourceforge.net</a></li>
<li> <a href="mailto:nfs-ganesha-support@lists.sourceforge.net" target="_blank" rel="noopener">nfs-ganesha-support@lists.sourceforge.net</a></li>
<li> <a href="mailto:nfs-ganesha-announce@lists.sourceforge.net" target="_blank" rel="noopener">nfs-ganesha-announce@lists.sourceforge.net</a></li>
</ul>
<p>本文翻译自：<a href="http://events.linuxfoundation.org/sites/events/files/slides/Collab14_nfsGanesha.pdf" target="_blank" rel="noopener">Why is it a better NFS server for Enterprise NAS</a></p>
<blockquote>
<p>部分晦涩的地方直接引用英文原文</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph peering过程分析]]></title>
      <url>http://xiaqunfeng.cc/2017/08/01/ceph-peering-analysis/</url>
      <content type="html"><![CDATA[<p>总结分析peering过程中的一些笔记，介绍peering的各个阶段和状态转换。<br><a id="more"></a></p>
<p>peering过程使得一个PG内的OSD达成一个一致状态。当主从副本达成一个一致状态后，PG处于active状态，peering过程的状态就结束了。但此时该PG的三个OSD的数据副本上的数据并非完全一致。</p>
<p>互为副本的副本数个 PG 的元数据达到一致的过程。官方解释</p>
<blockquote>
<p>the process of bringing all of the OSDs that store a Placement Group (PG) into agreement about the state of all of the objects (and their metadata) in that PG. Note that agreeing on the state does not mean that they all have the latest contents.</p>
</blockquote>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>当系统初始化时，OSD重新启动导致PG重新加载，或者PG创建时，PG会发生一次peering过程。</p>
<p>当有OSD失效，OSD的增加或者删除等导致PG的acting set发生了变化，该PG就会重新发起一次peering过程。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>acting set 和 up set</p>
<p>临时 PG</p>
<p>权威日志olog</p>
<p>up_thru</p>
<h2 id="peering状态转换图"><a href="#peering状态转换图" class="headerlink" title="peering状态转换图"></a>peering状态转换图</h2><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p><img src="http://oow6unnib.bkt.clouddn.com/FullSizeRender%204.jpg" alt="FullSizeRender 4"></p>
<p>过程如下：</p>
<ul>
<li><p>当进入primary/peering状态后，就进入默认子状态getinfo中</p>
</li>
<li><p>状态getinfo接收事件gotinfo后，转移到getlog状态中</p>
</li>
<li><p>如果状态getlog接收到isIncomplete事件后，跳转到incomplete状态</p>
</li>
<li><p>如果getlog接收到事件gotlog后，就转入getmissing状态</p>
</li>
<li><p>状态getmissing接收到事件activate事件，转入状态active</p>
</li>
</ul>
<h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><p>由状态转换过程可知，peering过程基本分为以下三个步骤</p>
<ul>
<li><p><strong>步骤一：GetInfo</strong></p>
<p>​PG的主OSD通过发送消息获取所有从OSD的pg_info信息。</p>
</li>
<li><p><strong>步骤二：GetLog</strong></p>
<p>​根据各个副本获取的pg_info信息的比较，选择一个拥有权威日志的OSD。如果主OSD不是拥有权威日志的OSD，就从该OSD上拉取权威日志。主OSD完成拉取权威日志后也就拥有了权威日志。</p>
</li>
<li><p><strong>步骤三：GetMissing</strong></p>
<p>​主OSD拉取其他OSD的PG日志。通过与本地权威日志的比较，来计算该OSD上缺失的object信息，作为后续recover操作过程的依据。</p>
</li>
</ul>
<p>最后通过active操作激活主OSD，并发送notify通知消息，激活相应的从OSD。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p> <img src="http://oow6unnib.bkt.clouddn.com/peering.png" alt="peering"></p>
<h2 id="GetInfo"><a href="#GetInfo" class="headerlink" title="GetInfo"></a>GetInfo</h2><p>获取该PG在其他OSD上的 pg_info 信息。</p>
<p>其他OSD：当前PG的活跃OSD，以及past interval期间该PG所有处于up 状态的OSD。</p>
<p>Past_interval 是 epoch 的一个序列。在该序列内一个PG的 acting set 和 up set不会变化。current_interval 也是一个特殊的 past_interval，它是当前最新的一个没有变化的序列。</p>
<ul>
<li><p>1、调用函数 generate_past_intervals 计算 past intervals 的值</p>
<p>​选取一个epoch区间，对区间内的每个epoch计算其对应的acting set、acting primary、up set、up primary，将相同的结果作为一个interval（一个interval中 acting set 和up set 不会变化）；</p>
<p>​判断每个interval，将up状态的osd加入到prior set；同时将当前的（current interval）acting set和up set加入到prior set；</p>
</li>
<li><p>2、调用函数 build_prior 构造获取 pg_info_t 信息的OSD 列表</p>
<p>​向prior_set中的每个up状态的osd发送Query INFO请求，并等待接收应答，将接收到的请求保存到peer_info中；</p>
</li>
<li><p>3、调用函数 get_infos 给参与的OSD 发送获取请求</p>
<p>​收到最后一个应答后，状态机post event到GotInfo状态；如果在此期间有一个接收请求的osd down掉，这个PG的状态将持续等待，直到对应的osd恢复；</p>
</li>
</ul>
<h2 id="GetLog"><a href="#GetLog" class="headerlink" title="GetLog"></a>GetLog</h2><p>当PG的主OSD获取到所有从OSD，以及past interval期间的所有参与该PG且目前仍处于active状态的OSD的 pg_info 信息后，就跳转到 GetLog 状态。</p>
<ul>
<li>1、遍历peer_info，查找best info，将其作为authoritative log；将acting set/peer_info中将处于complete状态的pg以及up set的所有pg存入acting_backfill；</li>
<li>2、如果计算出的authoritative log对应的pg是自身，直接post event到GotLog；否则，向其所在的osd发送Query Log请求；</li>
<li>3、接收请求的osd应答，并将获取的log merge到本地，状态机post event到GetMissing；如果收不到应答，状态将持续等待；</li>
</ul>
<h3 id="olog的选择"><a href="#olog的选择" class="headerlink" title="olog的选择"></a>olog的选择</h3><p>函数 find_best_info 选取拥有权威日志的OSD：必须是非 incomplete 的OSD，必须拥有最大的 last_epoch_strated，其他选择优先顺序如下：</p>
<p>1、具有最新的 last_update 的OSD；</p>
<p>2、如果条件 1 相同，选择日志更长的；</p>
<p>3、如果 1、2条件都相同，选择当前的主OSD；</p>
<p>经过该阶段，PG的主OSD已经获取了权威日志，以及pg_info的权威信息。</p>
<h2 id="GetMissing"><a href="#GetMissing" class="headerlink" title="GetMissing"></a>GetMissing</h2><p>首先拉取各个从OSD上的有效日志</p>
<p>用主OSD上的权威日志与各个从OSD日志进行对比，计算出各个从OSD上不一致的对象并保存在对应的 pg_missing_t 结构中，作为后续数据修复的依据。</p>
<p>主OSD上不一致的对象信息，已经在合并权威日志的过程中计算过了。</p>
<ul>
<li>1、遍历acting_backfill，向与primary pg log有交集的pg所在的osd发送Query Log请求；将剩余没有交集的pg放入peer_missing，生成missing set用于后续recovery；</li>
<li>2、将收到的每一个应答merge到本地，如果在此期间有osd down掉，这个PG的状态将持续等待；收到所有的应答后，当前pg的状态机进入Activate状态，peering过程结束；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个peering过程主要分为三个阶段，GetInfo -&gt; GetLog -&gt; GetMissing</p>
<ul>
<li>首先向prior set、acting set、up set中的每个osd请求pg infos, 选出authoritative log对应的pg</li>
<li>其次向authoritative log所在的osd请求authoritative log</li>
<li>最后获取recovery过程需要的missing set</li>
</ul>
<p>peering时间的长短并不可控，主要是在于请求的osd是否能够及时响应；如果这个阶段某个osd down掉，很可能导致部分pg一直处在peering状态，即所有分布到这个pg上的IO都会阻塞。</p>
<h3 id="后续active操作"><a href="#后续active操作" class="headerlink" title="后续active操作"></a>后续active操作</h3><p>getmissing操作成功后，就跳转到activate状态。到本阶段为止，peering的主要工作已完成，这里是后续处理，激活各个副本。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了减少peering过程对client造成的影响，社区提出Faster Peering，该plan主要有以下两点：</p>
<p>1）向最近prior set interval中的osd请求log+missing，跳过GetLog阶段；</p>
<p>2）向acting set和up set中的osd请求log+missing，跳过GetMissing阶段；</p>
<p>部分参考资料：<a href="https://www.ustack.com/blog/ceph%EF%BC%8Dpg-peering/" target="_blank" rel="noopener">Ceph：pg peering过程分析</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph placement group]]></title>
      <url>http://xiaqunfeng.cc/2017/07/28/ceph-placement-group/</url>
      <content type="html"><![CDATA[<p>从PG的命名开始介绍，利用一个对象详细演练PG各个状态的变化，并介绍PG状态列表及意义。<br><a id="more"></a></p>
<h2 id="PG命名"><a href="#PG命名" class="headerlink" title="PG命名"></a>PG命名</h2><h3 id="PG唯一标识符"><a href="#PG唯一标识符" class="headerlink" title="PG唯一标识符"></a>PG唯一标识符</h3><p>归置组 ID 包含存储池号（不是存储池名字），后面跟一个点（ . ），然后是归置组 ID，一个十六进制数字。用 <code>ceph osd lspools</code> 可查看存储池号及其名字，默认存储池rbd 对应的存储池号是 0  。完整的归置组 ID 格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;pool-num&#125;.&#123;pg-id&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.1f</span><br></pre></td></tr></table></figure>
<p>系统默认生成的<code>rbd</code>池的id号为<code>0</code>，所以 rbd 池内的所有PG都会以<code>0.</code>开头。</p>
<h3 id="查看osd目录里pg"><a href="#查看osd目录里pg" class="headerlink" title="查看osd目录里pg"></a>查看osd目录里pg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/ceph/osd/ceph-0/</span><br><span class="line">activate.monmap  ceph_fsid        fsid             journal_uuid     magic            store_version    systemd          whoami</span><br><span class="line">active           current/         journal          keyring          ready            superblock       type</span><br></pre></td></tr></table></figure>
<p><code>osd.0</code>下<code>current</code>目录的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/ceph/osd/ceph-0/current/</span><br><span class="line">0.0_head   0.1d_head  0.34_head  0.45_head  0.4e_head</span><br></pre></td></tr></table></figure>
<p>每个OSD的<code>current</code>目录下都保存了部分的PG，而rbd池的PG以<code>0.xxx_head</code>的目录形式存在！</p>
<h2 id="PG状态"><a href="#PG状态" class="headerlink" title="PG状态"></a>PG状态</h2><p>查看所有归置组状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg stat</span><br><span class="line">v614916: 128 pgs: 128 active+clean; 27194 kB data, 185 MB used, 15141 MB / 15326 MB avail; 56023 B/s rd, 0 B/s wr, 89 op/s</span><br></pre></td></tr></table></figure>
<p>有一些问题的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg stat</span><br><span class="line">v2167: 120 pgs: 120 active+undersized+degraded; 1799 bytes data, 86476 kB used, 10133 MB / 10217 MB avail; 173/519 objects degraded (33.333%)</span><br></pre></td></tr></table></figure>
<p>或者这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg stat</span><br><span class="line">v1468117: 5440 pgs: 4 active+clean+scrubbing+deep, 77 active+remapped+backfilling, 5359 active+clean; 33452 GB data, 68799 GB used, 43742 GB / 109 TB avail; 134 kB/s rd, 154 op/s; 6668502/138960328 objects misplaced (4.799%); 40810 kB/s, 81 objects/s recovering</span><br></pre></td></tr></table></figure>
<h2 id="获取PG列表"><a href="#获取PG列表" class="headerlink" title="获取PG列表"></a>获取PG列表</h2><p>用下列命令获取归置组列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg dump</span><br></pre></td></tr></table></figure>
<p>你也可以让它输出到 JSON 格式，并保存到文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg dump -o &#123;filename&#125; --format=json</span><br></pre></td></tr></table></figure>
<p>要查询某个归置组，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg &#123;poolnum&#125;.&#123;pg-id&#125; query</span><br></pre></td></tr></table></figure>
<p>Ceph 会输出成 JSON 格式</p>
<h2 id="写一个object"><a href="#写一个object" class="headerlink" title="写一个object"></a>写一个object</h2><p>1、新建一个文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat xinfanyang.txt</span><br><span class="line">xin fan yang have delicious food</span><br></pre></td></tr></table></figure>
<p>2、查看数据在pool中默认保存的份数、最小保存份数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool get rbd size</span><br><span class="line">size: 3</span><br><span class="line"># ceph osd pool get rbd min_size</span><br><span class="line">min_size: 2</span><br></pre></td></tr></table></figure>
<p>3、写一个文件，在集群中保存对象名为 <code>xfy</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rados -p rbd put xfy xinfanyang.txt</span><br></pre></td></tr></table></figure>
<p>4、查看文件保存的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e47 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,2,0], p1) acting ([1,2,0], p1)</span><br></pre></td></tr></table></figure>
<p>文件保存在pg（0.2f）中，pg位于OSD的[1，2，0]中，其中OSD1是主，其他是从。</p>
<p>5、查看内容</p>
<p>在三台机器的三个OSD上，输出内容一致。举例 osd.2，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ll /var/lib/ceph/osd/ceph-2/current/0.2f*</span><br><span class="line">/var/lib/ceph/osd/ceph-2/current/0.2f_head:</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r--. 1 ceph ceph  0 6月  21 15:45 __head_0000002F__0</span><br><span class="line">-rw-r--r--. 1 ceph ceph 33 7月  27 19:35 xfy__head_0C76C82F__0</span><br><span class="line"></span><br><span class="line">/var/lib/ceph/osd/ceph-2/current/0.2f_TEMP:</span><br><span class="line">总用量 0</span><br></pre></td></tr></table></figure>
<p>实际对象内容存在 <code>xfy__head_0C76C82F__0</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</span><br><span class="line">xin fan yang have delicious food</span><br></pre></td></tr></table></figure>
<p>osd分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY</span><br><span class="line">-1 0.05457 root default</span><br><span class="line">-2 0.01819     host ceph-1</span><br><span class="line"> 0 0.00909         osd.0        up  1.00000          1.00000</span><br><span class="line"> 3 0.00909         osd.3        up  1.00000          1.00000</span><br><span class="line">-3 0.01819     host ceph-0</span><br><span class="line"> 2 0.00909         osd.2        up  1.00000          1.00000</span><br><span class="line"> 4 0.00909         osd.4        up  1.00000          1.00000</span><br><span class="line">-4 0.01819     host ceph-2</span><br><span class="line"> 1 0.00909         osd.1        up  1.00000          1.00000</span><br><span class="line"> 5 0.00909         osd.5        up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h2 id="PG状态变化"><a href="#PG状态变化" class="headerlink" title="PG状态变化"></a>PG状态变化</h2><p><strong>1、查看 pg[0.2f] 的状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p><strong>2、挂掉一台机器挂</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop ceph-osd@2</span><br></pre></td></tr></table></figure>
<p>这时降为两副本了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e54 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0], p1) acting ([1,0], p1)</span><br></pre></td></tr></table></figure>
<p>查看pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br><span class="line">0.0	active+undersized+degraded	[1,0]	1	[1,0]	1</span><br></pre></td></tr></table></figure>
<p>因为之前设置的最小副本数是2，所以没影响，可以正常读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rados -p rbd get xfy 111</span><br><span class="line"># cat 111</span><br><span class="line">xin fan yang have delicious food</span><br></pre></td></tr></table></figure>
<p><strong>3、osd out</strong></p>
<p>将 osd.2 out</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd out 2</span><br><span class="line">marked out osd.2.</span><br></pre></td></tr></table></figure>
<p>如果osd out出集群了，那么 crush 算法就会重新分配一个osd进来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e103 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0,4], p1) acting ([1,0,4], p1)</span><br></pre></td></tr></table></figure>
<p>当然，也可以不out，默认 600s 后自动out，具体时间可调，默认配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph daemon osd.1 config show | grep mon_osd_down_out_interval</span><br><span class="line">    &quot;mon_osd_down_out_interval&quot;: &quot;600&quot;,</span><br></pre></td></tr></table></figure>
<p>重新将 osd.2 加入集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd in 2</span><br><span class="line">marked in osd.2.</span><br></pre></td></tr></table></figure>
<p>这时候该对象的分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e117 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,0], p1) acting ([1,0,4], p1)</span><br></pre></td></tr></table></figure>
<p>可以看到，pg最终的分布是 [1,0]，当前的acting分布是 [1,0,4]</p>
<p><strong>4、挂掉两台机器</strong></p>
<p>down掉主副本所在的 osd.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop ceph-osd@1</span><br></pre></td></tr></table></figure>
<p>此时只有一个副本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e56 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([0], p0) acting ([0], p0)</span><br></pre></td></tr></table></figure>
<p>查看pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br><span class="line">0.2f    undersized+degraded+peered   [0]          0    [0]              0</span><br></pre></td></tr></table></figure>
<p>此时再去get这个对象的话，会一直得不到返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rados -p rbd get xfy 222</span><br><span class="line">...							// 一直在等待</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原因：当对象的副本数小于设定的最小数（min_size）时，ceph不响应对应object的IO请求</p>
</blockquote>
<p><strong>5、启动 osd.1</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start ceph-osd@1</span><br></pre></td></tr></table></figure>
<p>此时，会发现，上面卡着的那个命令返回了，并且得到的内容正确。</p>
<p>查看当前pg分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e76 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,4], p1) acting ([1,4], p1)</span><br></pre></td></tr></table></figure>
<p>pg状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br><span class="line">0.2f    active+undersized+degraded [1,4]          1   [1,4]              1</span><br></pre></td></tr></table></figure>
<p>注意，这里一个有意思的事情是，在第三步的时候只有一个副本在 osd.0 上，因为 osd.1 是主副本</p>
<p>启动的时候，4 作为临时pg加入，然后等 1 恢复完以后</p>
<p><strong>6、启动 osd.2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start ceph-osd@2</span><br></pre></td></tr></table></figure>
<p>此时，pg 映射恢复正常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map rbd xfy</span><br><span class="line">osdmap e83 pool &apos;rbd&apos; (0) object &apos;xfy&apos; -&gt; pg 0.c76c82f (0.2f) -&gt; up ([1,2,0], p1) acting ([1,2,0], p1)</span><br></pre></td></tr></table></figure>
<p>pg的状态开始变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br><span class="line">0.2f               active+remapped [1,2]          1 [1,2,4]              1</span><br></pre></td></tr></table></figure>
<p>直至OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg dump_stuck |egrep ^0.2f</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h2 id="PG修复"><a href="#PG修复" class="headerlink" title="PG修复"></a>PG修复</h2><p><strong>1、我修改一下 osd.1 中对象 xfy 主副本的内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</span><br><span class="line">xin fan yang have delicious food</span><br><span class="line">// 改为</span><br><span class="line"># cat /var/lib/ceph/osd/ceph-2/current/0.2f_head/xfy__head_0C76C82F__0</span><br><span class="line">xin fan yang have food</span><br></pre></td></tr></table></figure>
<p>2、扫描这个PG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg scrub 0.2f</span><br><span class="line">instructing pg 0.2f on osd.1 to scrub</span><br></pre></td></tr></table></figure>
<p><strong>3、读这个对象</strong></p>
<p>这时候会不会发生读到改过的错误内容呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rados -p rbd get xfy 333</span><br><span class="line"># cat 333</span><br><span class="line">xin fan yang have delicious food</span><br></pre></td></tr></table></figure>
<p>并没有，读到的仍然是正确的内容</p>
<p><strong>4、查看ceph状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">     health HEALTH_ERR</span><br><span class="line">            1 pgs inconsistent</span><br><span class="line">            1 scrub errors</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>报的错误是：有一个pg inconsistent，就是内容不一致。那么具体是哪个pg scurb errors了呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph health detail</span><br><span class="line">HEALTH_ERR 1 pgs inconsistent; 1 scrub errors</span><br><span class="line">pg 0.2f is active+clean+inconsistent, acting [1,2,0]</span><br><span class="line">1 scrub errors</span><br></pre></td></tr></table></figure>
<p>可以看到，正是我们修改的那个pg</p>
<p><strong>5、修复PG</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph pg repair 0.2f</span><br><span class="line">instructing pg 0.2f on osd.1 to repair</span><br></pre></td></tr></table></figure>
<p><strong>6、此时内容已被纠正过来</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat  /var/lib/ceph/osd/ceph-1/current/0.2f_head/xfy__head_0C76C82F__0</span><br><span class="line">xin fan yang have delicious food</span><br></pre></td></tr></table></figure>
<p>此时，集群状态OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph health detail</span><br><span class="line">HEALTH_OK</span><br></pre></td></tr></table></figure>
<h2 id="PG状态列表"><a href="#PG状态列表" class="headerlink" title="PG状态列表"></a>PG状态列表</h2><p><strong>1、peering</strong></p>
<p>Ceph 为归置组建立互联时，会让存储归置组副本的 OSD 之间就其中的对象和元数据状态达成一致。 Ceph 完成了互联，也就意味着存储着归置组的 OSD 就其当前状态达成了一致。然而，互联过程的完成并不能表明各副本都有了数据的最新版本。</p>
<p><strong>2、active</strong></p>
<p>peering完成后，一归置组状态会变为 active 。 active 状态意味着数据已完好地保存到了主归置组和副本归置组。</p>
<p><strong>3、clean</strong></p>
<p>某一归置组处于 clean 状态时，主 OSD 和副本 OSD 已成功互联，并且没有偏离的归置组。 Ceph 已把归置组中的对象复制了规定次数。</p>
<p><strong>4、degraded</strong></p>
<p>当客户端向主 OSD 写入数据时，由主 OSD 负责把数据副本写入其余副本 OSD 。主 OSD 把对象写入存储器后，在副本 OSD 创建完对象副本并报告给主 OSD 之前，主 OSD 会一直停留在 degraded 状态。</p>
<ul>
<li>归置组状态可以处于 active+degraded 状态，原因在于一 OSD 即使尚未持有所有对象也可以处于 active 状态。如果一 OSD 挂了， Ceph 会把分配到此 OSD 的归置组都标记为 degraded ；那个 OSD 重生后，它们必须重新互联。然而，客户端仍可以向处于 degraded 状态的归置组写入新对象，只要它还在 active 状态。</li>
<li>如果一 OSD 挂了，且老是处于 degraded 状态， Ceph 会把 down 的 OSD 标记为在集群外（ out ）、并把那个 down 掉的 OSD 上的数据重映射到其它 OSD 。从标记为 down 到 out 的时间间隔由 mon osd down out interval 控制，默认是 300 秒。</li>
<li>归置组也会被降级（ degraded ），因为 Ceph 找不到本应存在于此归置组中的一或多个对象，这时，你不能读写找不到的对象，但仍能访问位于降级归置组中的其它对象。</li>
</ul>
<p><strong>5、recovering</strong></p>
<p>Ceph 被设计为可容错，可抵御一定规模的软、硬件问题。当某 OSD 挂了（ down ）时，其内的归置组会落后于别的归置组副本；此 OSD 重生（ up ）时，归置组内容必须更新到当前状态；在此期间， OSD 处于 recovering 状态。</p>
<blockquote>
<p>恢复并非总是这些小事，因为一次硬件失败可能牵连多个 OSD 。比如一个机柜或房间的网络交换机失败了，这会导致多个主机上的 OSD 落后于集群的当前状态，故障恢复后每一个 OSD 都必须恢复。</p>
</blockquote>
<p>Ceph 提供了几个选项来均衡资源竞争，如新服务请求、恢复数据对象和恢复归置组到当前状态。</p>
<ul>
<li><code>osd recovery delay start</code> 选项允许一 OSD 在开始恢复进程前，先重启、重建互联、甚至处理一些重放请求；</li>
<li><code>osd recovery threads</code> 选项限制恢复进程的线程数，默认为 1 线程； </li>
<li><code>osd recovery thread timeout</code> 设置线程超时，因为多个 OSD 可能交替失败、重启和重建互联； </li>
<li><code>osd recovery max active</code> 选项限制一 OSD 最多同时接受多少请求，以防它压力过大而不能正常服务； </li>
<li><code>osd recovery max chunk</code> 选项限制恢复数据块尺寸，以防网络拥塞。</li>
</ul>
<p><strong>6、backfilling</strong></p>
<p>有新 OSD 加入集群时， CRUSH 会把现有集群内的部分归置组重分配给它。强制新 OSD 立即接受重分配的归置组会使之过载，用归置组回填可使这个过程在后台开始。只要回填顺利完成，新 OSD 就可以对外服务了。</p>
<p>在回填运转期间，你可能见到以下几种状态之一： </p>
<ul>
<li>backfill_wait 表明一回填操作在等待时机，尚未开始； </li>
<li>backfill 表明一回填操作正在进行； </li>
<li>backfill_too_full 表明需要进行回填，但是因存储空间不足而不能完成。</li>
<li>incomplete 状态表明某归置组不能回填</li>
</ul>
<p>Ceph 提供了多个选项来解决重分配归置组给一 OSD （特别是新 OSD ）时相关的负载问题。</p>
<ul>
<li>默认，<code>osd_max_backfills</code> 把双向的回填并发量都设置为 10 ； </li>
<li><code>osd backfill full \ ratio</code> 可让一 OSD 在接近占满率（默认 85% ）时拒绝回填请求，如果一 OSD 拒绝了回填请求，在 <code>osd backfill retry interval</code> 间隔之后将重试（默认 10 秒）； </li>
<li>OSD 也能用 <code>osd backfill scan min</code> 和 <code>osd backfill scan max</code> 来管理扫描间隔（默认 64 和 512 ）。</li>
</ul>
<p><strong>7、remapped</strong></p>
<p>负责维护某一归置组的 Acting Set 变更时，数据要从旧集合迁移到新的。新的主 OSD 要花费一些时间才能提供服务，所以老的主 OSD 还要持续提供服务、直到归置组迁移完。数据迁移完后，运行图会包含新 acting set 里的主 OSD 。</p>
<p><strong>8、stale</strong></p>
<p>虽然 Ceph 用心跳来保证主机和守护进程在运行，但是 ceph-osd 仍有可能进入 stuck 状态，它们没有按时报告其状态（如网络瞬断）。默认， OSD 守护进程每半秒（ 0.5 ）会一次报告其归置组、出流量、引导和失败统计状态，此频率高于心跳阀值。如果一归置组的主 OSD 所在的 acting set 没能向监视器报告、或者其它监视器已经报告了那个主 OSD 已 down ，监视器们就会把此归置组标记为 stale 。</p>
<blockquote>
<p>启动集群时，会经常看到 stale 状态，直到互联完成。集群运行一阵后，如果还能看到有归置组位于 stale 状态，就说明那些归置组的主 OSD 挂了（ down ）、或没在向监视器报告统计信息。</p>
</blockquote>
<p><strong>9、undersized</strong></p>
<p>PG的副本数比pool的配置中副本数少。</p>
<p>可以通过如下命令查看指定pool的副本数，默认是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool get &#123;poolname&#125; size</span><br></pre></td></tr></table></figure>
<p><strong>10、peered</strong></p>
<p>PG已经peered，但是副本数少于pool配置中指定的最小副本数，不能向client提供IO操作。在这种状态下会出发 recovery 操作，所以 pg 最终会愈合到最小副本数。</p>
<p>可通过如下命令得到指定pool的最小副本数，默认是2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool get &#123;poolname&#125; min_size</span><br></pre></td></tr></table></figure>
<p><strong>11、incomplete</strong></p>
<p>ceph检测到一个PG缺少可能已经发生的写入信息，或没有任何健康的副本。如果看到此状态，请尝试启动任何可能包含所需信息的失败的OSD，或暂时调整min_size以允许恢复。</p>
<p><strong>其他：</strong></p>
<p>一个归置组状态不是 active+clean 时未必有问题。一般来说，归置组卡住时 Ceph 的自修复功能往往无能为力，卡住的状态细分为：</p>
<ul>
<li>Unclean: 归置组里有些对象的副本数未达到期望次数，它们应该在恢复中；</li>
<li>Inactive: 归置组不能处理读写请求，因为它们在等着一个持有最新数据的 OSD 回到 up 状态；</li>
<li>Stale: 归置组们处于一种未知状态，因为存储它们的 OSD 有一阵子没向监视器报告了（由 mon osd report timeout 配置）。</li>
</ul>
<p>找出卡住的归置组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph pg dump_stuck [unclean|inactive|stale|undersized|degraded]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Remove Big RBD Image]]></title>
      <url>http://xiaqunfeng.cc/2017/07/28/Remove-Big-RBD-Image/</url>
      <content type="html"><![CDATA[<p>对较大的RBD image采用两种方法进行移除实验，并给出结果对比。<br><a id="more"></a></p>
<p>创建一个容量疯狂大的磁盘很有趣，但是有一点难移除。</p>
<center><img src="http://cephnotes.ksperis.com/images/img012.png" alt="img"></center>

<p>这里有一个移除特别大image的小技巧（谨慎使用！），使用 <code>rm rbd</code> 命令（如果image没有初始化，或者没有填充满）。</p>
<h2 id="Image-format-1"><a href="#Image-format-1" class="headerlink" title="Image format 1 :"></a>Image format 1 :</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rbd info rbdbigsize</span><br><span class="line">rbd image &apos;rbdbigsize&apos;:</span><br><span class="line">    size 1862 PB in 500000000000 objects</span><br><span class="line">    order 22 (4096 kB objects)</span><br><span class="line">    block_name_prefix: rb.0.47aa.74b0dc51</span><br><span class="line">    format: 1</span><br></pre></td></tr></table></figure>
<p>删除头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rados -p rbd rm rbdbigsize.rbd</span><br></pre></td></tr></table></figure>
<p>删除所有rbd数据：(这可能需要一些时间，取决于块设备上已经使用的空间)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rados -p rbd ls | grep &apos;^rb.0.47aa.74b0dc51&apos; | xargs -n 200  rados -p rbd rm</span><br></pre></td></tr></table></figure>
<p>最后，从rbd list中删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rbd rm rbdbigsize</span><br><span class="line">2014-06-12 16:27:20.838596 7fd86dff3760 -1 librbd::ImageCtx: error finding header: (2) No such file or directory</span><br><span class="line">Removing image: 100% complete...done.</span><br></pre></td></tr></table></figure>
<h2 id="Image-format-2"><a href="#Image-format-2" class="headerlink" title="Image format 2 :"></a>Image format 2 :</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  rbd info rbdbigsize</span><br><span class="line">rbd image &apos;rbdbigsize&apos;:</span><br><span class="line">        size 1024 TB in 268435456 objects</span><br><span class="line">        order 22 (4096 kB objects)</span><br><span class="line">        block_name_prefix: rbd_data.81d12ae8944a</span><br><span class="line">        format: 2</span><br><span class="line">        features: layering</span><br></pre></td></tr></table></figure>
<p>删除头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rados -p rbd rm rbd_id.rbdbigsize </span><br><span class="line">$ rados -p rbd rm rbd_header.81d12ae8944a</span><br></pre></td></tr></table></figure>
<p>删除所有rbd 数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | xargs -n 200  rados -p rbd rm</span><br></pre></td></tr></table></figure>
<p>从 rbd list中删除 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rbd rm rbdbigsize</span><br><span class="line">2014-06-12 17:37:24.483587 7f413506c760 -1 librbd::ImageCtx: error finding header: (2) No such file or directory</span><br><span class="line">Removing image: 100% complete...done.</span><br></pre></td></tr></table></figure>
<h2 id="时间对比"><a href="#时间对比" class="headerlink" title="时间对比"></a>时间对比</h2><p>1PB 已格式化块设备删除时间示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rbd create rbdbigsize --size=1073741824 --image-format=2</span><br><span class="line">$ rbd map rbdbigsize</span><br><span class="line">$ mkfs.xfs /dev/rbd0</span><br><span class="line">$ rbd unmap /dev/rbd0</span><br><span class="line"></span><br><span class="line">$ rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | wc -l</span><br><span class="line">1536</span><br></pre></td></tr></table></figure>
<p>块设备仅由 1536 个块组成，可以通过 <code>rados rm</code> 快速删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ time rados -p rbd ls | grep &apos;^rbd_data.81d12ae8944a.&apos; | xargs -n 200  rados -p rbd rm</span><br><span class="line">real    0m10.073s</span><br><span class="line">user    0m1.244s</span><br><span class="line">sys 0m0.228s</span><br></pre></td></tr></table></figure>
<p>对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time rbd rm rbdbigsize</span><br><span class="line">Removing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line">real    1123m5.409s</span><br><span class="line">user    686m19.924s</span><br><span class="line">sys     229m56.596s</span><br></pre></td></tr></table></figure>
<center><img src="http://cephnotes.ksperis.com/images/img010.png" alt="img"></center>

<h2 id="Fully-initialized-image"><a href="#Fully-initialized-image" class="headerlink" title="Fully initialized image :"></a>Fully initialized image :</h2><p>当然，删除一个完全初始化的 image 使用 <code>rbd rm</code> 更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ rbd create rbdbigsize --size 1048576</span><br><span class="line">$ rbd map rbdbigsize; dd if=/dev/zero of=/dev/rbd0; rbd unmap /dev/rbd0;</span><br><span class="line">$ time (rados -p rbd ls | grep `rbd info rbdbigsize | grep block_name_prefix | grep -o &apos;rb.*$&apos;` | xargs -n 200  rados -p rbd rm; rados -p rbd rm rbdbigsize.rbd; rbd rm rbdbigsize)</span><br><span class="line"></span><br><span class="line">real    143m6.373s</span><br><span class="line">user    2m49.100s</span><br><span class="line">sys     0m22.080s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ rbd create rbdbigsize --size 1048576</span><br><span class="line">$ rbd map rbdbigsize; dd if=/dev/zero of=/dev/rbd0; rbd unmap /dev/rbd0;</span><br><span class="line">$ time rbd rm rbdbigsize</span><br><span class="line"></span><br><span class="line">real   88m44.121s</span><br><span class="line">user    1m5.464s</span><br><span class="line">sys     0m25.244s</span><br></pre></td></tr></table></figure>
<center><img src="http://cephnotes.ksperis.com/images/img011.png" alt="img"></center>

<p>本文为译文，原文链接：<a href="http://cephnotes.ksperis.com/blog/2014/07/04/remove-big-rbd-image" target="_blank" rel="noopener">Remove Big RBD Image</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos下ceph部署]]></title>
      <url>http://xiaqunfeng.cc/2017/07/17/centos-deploy-ceph/</url>
      <content type="html"><![CDATA[<p>前一篇文章讲了整个ceph的部署全过程，不过是基于ubuntu的，这里基于centos再分享一下部署过程。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系统环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.3.1611 (Core)</span><br><span class="line"># uname -r</span><br><span class="line">3.10.0-514.16.1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>1、关闭防火墙和selinux</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop firewalld </span><br><span class="line"># systemctl disable firewalld</span><br><span class="line"># sed -i &apos;s/SELINUX=enforcing/SELINUX=disabled/g&apos; /etc/selinux/config</span><br><span class="line"># setenforce 0</span><br></pre></td></tr></table></figure>
<p><strong>2、打开ceph需要的端口</strong></p>
<p>如果关闭了防火墙，这里就不需要打开端口了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone=public --add-port=6789/tcp --permanent</span><br><span class="line"># firewall-cmd --zone=public --add-port=6800-7100/tcp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p><strong>3、安装EPEL软件源</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</span><br><span class="line"># yum -y update</span><br><span class="line"># yum -y upgrade</span><br></pre></td></tr></table></figure>
<p><strong>4、安装 ntp 时间同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>
<p><strong>5、设置免密登录</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id XXX</span><br></pre></td></tr></table></figure>
<p><strong>6、使用国内源安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rpm -Uvh http://mirrors.163.com/ceph/rpm-kraken/el7/noarch/ceph-release-1-1.el7.noarch.rpm</span><br><span class="line"># yum update -y</span><br></pre></td></tr></table></figure>
<p><strong>7、安装ceph-deploy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rpm -Uvh http://mirrors.163.com/ceph/rpm-kraken/el7/noarch/ceph-deploy-1.5.37-0.noarch.rpm </span><br><span class="line"># yum update -y</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install ceph-deploy -y</span><br></pre></td></tr></table></figure>
<p><strong>8、让ceph-deploy使用国内源安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/rpm-kraken/el7</span><br><span class="line">export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc</span><br></pre></td></tr></table></figure>
<p><strong>9、安装ceph</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install ceph0 ceph1 ceph2</span><br></pre></td></tr></table></figure>
<p><strong>10、mon安装</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OSD安装和ubuntu上一样</p>
</blockquote>
<h2 id="几个启动方式的不同"><a href="#几个启动方式的不同" class="headerlink" title="几个启动方式的不同"></a>几个启动方式的不同</h2><p>先列举两个：</p>
<p>1、启动mon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ceph-mon@ceph0.service</span><br></pre></td></tr></table></figure>
<p>2、启动osd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ceph-osd@&#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>更多cento 7 上操纵集群命令详见文章：<a href="http://xiaqunfeng.cc/2017/06/16/centos-7%E4%B8%8B%E6%93%8D%E7%BA%B5ceph%E8%BF%9B%E7%A8%8B/">centos 7下操纵ceph进程</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph部署完全手册]]></title>
      <url>http://xiaqunfeng.cc/2017/07/17/ceph-deploy-manual/</url>
      <content type="html"><![CDATA[<p>从零开始，一步一步搭建一个ceph集群。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是以前的一个笔记，整理并分享出来，给有需要的人。</p>
<p><strong>环境：</strong></p>
<p>主机系统：ubuntu14.04</p>
<p>ceph版本：ceph jewel</p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><h3 id="1-1-硬件资源"><a href="#1-1-硬件资源" class="headerlink" title="1.1 硬件资源"></a>1.1 硬件资源</h3><p>​    <strong>硬件配置</strong>：5台云主机，4核4G内存，Ubuntu14系统，每台挂载1 块100G 的SSD 和3 块200G 的SATA 盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk </span><br><span class="line">vdc    253:32   0   200G  0 disk </span><br><span class="line">vdd    253:48   0   200G  0 disk </span><br><span class="line">vde    253:64   0   200G  0 disk</span><br></pre></td></tr></table></figure>
<p>​    <strong>磁盘分区</strong></p>
<p>​    ceph-mon可以和osd节点混布，但要物理隔离。单台机器可以由多个osd进程，每个osd的数据盘和journal盘分别处于独立分区，为了高性能，建议journal放在在ssd盘，分区大小10G即可(更精确的大小计算参见<a href="http://docs.ceph.com/docs/jewel/rados/configuration/osd-config-ref/#journal-settings" target="_blank" rel="noopener">这里</a>, 大致的计算原则是 磁盘的吞吐osd持久化间隔的两倍，默认的持久化间隔是5s，按照磁盘吞吐200M计算，2G空间就够了)。<br>​    以上述的推荐举个例子：<br>​    某机器上含有4T的sata盘/dev/sdb, /dev/sdc, /dev/sdc。ssd盘480G，/dev/sdd。使用lsscsi可以看到磁盘的类型(sata or ssd)，fdisk -l可以查看磁盘容量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># lsscsi</span><br><span class="line">[0:0:0:0]    disk    SEAGATE  ST300MM0006      0003  /dev/sda</span><br><span class="line">[0:0:1:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdb</span><br><span class="line">[0:0:2:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdc</span><br><span class="line">[0:0:3:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sdd</span><br><span class="line">[0:0:4:0]    disk    ATA      ST4000NM0033-9ZM SN06  /dev/sde</span><br><span class="line">[0:0:5:0]    disk    ATA      INTEL SSDSC2BB48 0150  /dev/sdf</span><br><span class="line">[0:0:6:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdg</span><br><span class="line">[0:0:7:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdh</span><br><span class="line">[0:0:8:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdi</span><br><span class="line">[0:0:9:0]    disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdj</span><br><span class="line">[0:0:10:0]   disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdk</span><br><span class="line">[0:0:11:0]   disk    ATA      TOSHIBA MG03ACA4 FL1A  /dev/sdl</span><br><span class="line">[0:0:12:0]   disk    ATA      INTEL SSDSC2BB48 0150  /dev/sdm</span><br><span class="line">[0:0:13:0]   enclosu PMCSIERA SXP 24Sx12G      RevB  -</span><br></pre></td></tr></table></figure>
<p>可以使用parted工具进行分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted  -s  /dev/sdb  mklabel gpt #对/dev/sdb分区</span><br><span class="line">parted /dev/sdb mkpart primary ext4 1 1000000 # 第一个分区占用1M到1000000M。</span><br></pre></td></tr></table></figure>
<p>对于ssd盘，可以创建多个分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parted  -s  /dev/sdd  mklabel gpt #对/dev/sdb分区</span><br><span class="line">parted /dev/sdb mkpart primary ext4 1 10000 # 第一个分区占用1M到10000M。</span><br><span class="line">parted /dev/sdb mkpart primary ext4 10000 20000# </span><br><span class="line">第二个分区占用10000M到20000M。</span><br><span class="line">parted /dev/sdb mkpart primary ext4 20000 30000 # </span><br><span class="line">第三个分区占用20000M到30000M，剩余的分区可以由你自由分配。</span><br></pre></td></tr></table></figure>
<p>​    <strong>实际分区部署操作</strong></p>
<p>​    分区的时候这里仅针对SSD分3个区，每个区给挂载在该主机上的3个SATA盘使用。</p>
<blockquote>
<p>为ceph准备好磁盘分区，仅作分区，不需要挂载和建立文件系统，部署osd节点时，ceph自己会做这个工作。</p>
</blockquote>
<p>​    将SSD分为3个主分区，SATA盘一个分区，独立挂载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# parted -s /dev/vdb mklabel gpt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 0 40G</span><br><span class="line">Warning: The resulting partition is not properly aligned for best performance.</span><br><span class="line">Ignore/Cancel? Cancel </span><br><span class="line">#生成的分区没有正确地对齐以实现最佳性能。忽略/取消？</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正确对齐分区的快速分步指南：</p>
<p>​    首先获得你阵列的alignment参数：</p>
<p>root@ceph0:~# cat /sys/block/vdb/queue/optimal_io_size<br>0<br>root@ceph0:~# cat /sys/block/vdb/queue/minimum_io_size<br>512<br>root@ceph0:~# cat /sys/block/vdb/alignment_offset<br>0<br>root@ceph0:~# cat /sys/block/vdb/queue/physical_block_size<br>512</p>
<p>​    其次，把optimal_io_size的值与alignment_offset的值相加，之后除以physical_block_size的值。在我的例子中是：(512 + 0) / 512 = 1。这个数值是分区起始的扇区。</p>
<p>​    最后，新的parted命令应该写成类似下面这样</p>
<p>mkpart primary 1s 100%</p>
<p>​    字母s是很有意义的：它告诉parted，你的输入是1个扇区，而不是1个字节，也不是1兆字节。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 1 40G</span><br><span class="line">Information: You may need to update /etc/fstab.  </span><br><span class="line"></span><br><span class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 40G 70G</span><br><span class="line">Information: You may need to update /etc/fstab.                           </span><br><span class="line"></span><br><span class="line">root@ceph0:~# parted /dev/vdb mkpart primary ext4 70G 100G</span><br><span class="line">Information: You may need to update /etc/fstab.  </span><br><span class="line"></span><br><span class="line"># 不需要update。parted命令是实时生效的，分区命令完成后已经将分区表数据写入了硬盘。</span><br><span class="line"># /etc/fstab文件，是系统的自动挂载分区的配置。目的是让系统重启后，能够自动将某个分区挂载到指定挂载点，而不用再手动mount。</span><br></pre></td></tr></table></figure>
<p>​    SATA盘需要一个主分区，200G大小，分区过程同上。</p>
<p>​    分区后的磁盘挂载树状结构图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk </span><br><span class="line">├─vdb1 253:17   0  37.3G  0 part </span><br><span class="line">├─vdb2 253:18   0    28G  0 part </span><br><span class="line">└─vdb3 253:19   0    28G  0 part </span><br><span class="line">vdc    253:32   0   200G  0 disk </span><br><span class="line">└─vdc1 253:33   0 186.3G  0 part </span><br><span class="line">vdd    253:48   0   200G  0 disk </span><br><span class="line">└─vdd1 253:49   0 186.3G  0 part </span><br><span class="line">vde    253:64   0   200G  0 disk </span><br><span class="line">└─vde1 253:65   0 186.3G  0 part</span><br></pre></td></tr></table></figure>
<p>​    对其他主机上挂载的SSD和SATA盘操作同上。</p>
<h3 id="1-2-设置ssh免密登录-仅主控节点"><a href="#1-2-设置ssh免密登录-仅主控节点" class="headerlink" title="1.2 设置ssh免密登录(仅主控节点)"></a>1.2 设置ssh免密登录(仅主控节点)</h3><p>​    选定一个节点作为主控节点（这里选的ceph0主机），建立从主控节点到其他节点的免密登录。主控节点也可以安装ceph。</p>
<p><strong>1 生成秘钥：ssh-keygen</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# ssh-keygen</span><br></pre></td></tr></table></figure>
<p><strong>2 拷贝密钥：ssh-copy-id your_dst_node</strong></p>
<p>​    输入密码即可，如果不知道密码，则把~/.ssh/id_rsa.pub加入到目标机器的~/.ssh/authorized_keys中亦可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# ssh-copy-id root@172.20.0.197</span><br></pre></td></tr></table></figure>
<p>​    然后就可以免密登录了，直接 <strong>ssh + IP</strong> 就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# ssh 172.20.0.197</span><br></pre></td></tr></table></figure>
<p>​    对其他机台机器的操作同上。<strong>注意：也要对本机设置免密登录。</strong></p>
<p>​    有了免密登录，可以批量的执行命令。</p>
<p><strong>3 设置主控节点通过ssh访问其他节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       localhost       ceph0</span><br><span class="line">127.0.1.1       host-192-168-112-190.openstacklocal     host-192-168-112-190</span><br><span class="line"></span><br><span class="line">172.20.0.196    ceph0</span><br><span class="line">172.20.0.197    ceph1</span><br><span class="line">172.20.0.198    ceph2</span><br><span class="line">172.20.0.199    ceph3</span><br><span class="line">172.20.0.200    ceph4</span><br><span class="line"></span><br><span class="line"># The following lines are desirable for IPv6 capable hosts</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">~                                                                                                                                                      </span><br><span class="line">~                                                                                                                                                   </span><br><span class="line">&quot;/etc/hosts&quot; 14L, 340C</span><br></pre></td></tr></table></figure>
<h3 id="1-3-防火墙及安全设置（所有节点）"><a href="#1-3-防火墙及安全设置（所有节点）" class="headerlink" title="1.3 防火墙及安全设置（所有节点）"></a>1.3 防火墙及安全设置（所有节点）</h3><p><strong>1 防火墙相关</strong></p>
<p>​    Ceph Monitors 之间默认使用 6789 端口通信， OSD 之间默认用 6800:7300 这个范围内的端口通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=6789/tcp --permanent</span><br><span class="line">如果提示命令不存在，则可以批量安装</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# sudo firewall-cmd --zone=public --add-port=6789/tcp --permanent</span><br><span class="line">sudo: unable to resolve host ceph0</span><br><span class="line">sudo: firewall-cmd: command not found</span><br></pre></td></tr></table></figure>
<p><strong>2 selinux相关</strong><br>​    设置selinux，如果报命令不存在，可以忽略这一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# sudo setenforce 0</span><br><span class="line">sudo: setenforce: command not found</span><br></pre></td></tr></table></figure>
<p>​    如果命令存在，执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo setenforce 0</span><br></pre></td></tr></table></figure>
<p>​    如果希望永久生效，则修改 /etc/selinux/config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This file controls the state of SELinux on the system.</span><br><span class="line">SELINUX= can take one of these three values:</span><br><span class="line">	enforcing - SELinux security policy is enforced.</span><br><span class="line">	permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">    disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=disabled</span><br><span class="line">SELINUXTYPE= can take one of these two values:</span><br><span class="line">    targeted - Targeted processes are protected,</span><br><span class="line">    minimum - Modification of targeted policy. Only selected </span><br><span class="line">processes are protected.</span><br><span class="line">    mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>
<h3 id="1-4-添加ceph用户，并设置权限（所有节点）"><a href="#1-4-添加ceph用户，并设置权限（所有节点）" class="headerlink" title="1.4 添加ceph用户，并设置权限（所有节点）"></a>1.4 添加ceph用户，并设置权限（所有节点）</h3><p>1、在各 Ceph 节点创建新用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# sudo useradd -d /home/ceph -m ceph</span><br><span class="line">sudo: unable to resolve host ceph0</span><br></pre></td></tr></table></figure>
<p>​    第一条命令执行后的告警没关系，如果想消除，可以参考<a href="http://blog.csdn.net/ichuzhen/article/details/8241847" target="_blank" rel="noopener">这里</a>。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#然后再localhost后面加上当前的主机名，这里是ceph0</span><br><span class="line">127.0.0.1       localhost       ceph0</span><br></pre></td></tr></table></figure>
<p>2、确保各 Ceph 节点上新创建的用户都有 sudo 权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# echo &quot;ceph ALL = (root) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/ceph</span><br><span class="line">ceph ALL = (root) NOPASSWD:ALL</span><br><span class="line">root@ceph0:~# sudo chmod 0440 /etc/sudoers.d/ceph</span><br></pre></td></tr></table></figure>
<h3 id="1-5-安装ntp服务（所有节点）"><a href="#1-5-安装ntp服务（所有节点）" class="headerlink" title="1.5 安装ntp服务（所有节点）"></a>1.5 安装ntp服务（所有节点）</h3><p>​    主要是用于ceph-mon之间的时间同步。在所有 Ceph 节点上安装 NTP 服务（特别是 Ceph Monitor 节点），以免因时钟漂移导致故障。确保在各 Ceph 节点上启动了 NTP 服务，并且要使用同一个 NTP 服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以暂时不设置，一般公司的服务器会校准时间，如果需要的话，时间服务器网上百度一下，自行设置即可。</p>
</blockquote>
<h3 id="1-6-添加ceph安装源（所有节点）"><a href="#1-6-添加ceph安装源（所有节点）" class="headerlink" title="1.6 添加ceph安装源（所有节点）"></a>1.6 添加ceph安装源（所有节点）</h3><p>​    顺序执行以下命令：</p>
<p>​    <strong>注</strong>：建议这里的源直接写国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; | sudo apt-key add -</span><br><span class="line">echo deb https://download.ceph.com/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br></pre></td></tr></table></figure>
<p>​    国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># wget -q -O- &apos;http://mirrors.163.com/ceph/keys/release.asc&apos; &gt; test.asc</span><br><span class="line"># vim test.asc </span><br><span class="line"># apt-key add test.asc </span><br><span class="line">OK</span><br><span class="line"># echo deb http://mirrors.163.com/ceph/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br><span class="line">deb https://mirrors.163.com/ceph/debian-jewel/ trusty main</span><br></pre></td></tr></table></figure>
<p>​    <strong>实际执行情况</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; | sudo apt-key add -</span><br><span class="line">apt-key add: command not found</span><br></pre></td></tr></table></figure>
<p>​    很诡异，不知道为啥不行，换一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# wget -q -O- &apos;https://download.ceph.com/keys/release.asc&apos; &gt; test.asc</span><br><span class="line">root@ceph0:~# apt-key add  test.asc </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# echo deb https://download.ceph.com/debian-jewel/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br><span class="line">deb https://download.ceph.com/debian-jewel/ trusty main</span><br></pre></td></tr></table></figure>
<h3 id="1-7-安装ceph-deploy部署工具-仅主控节点"><a href="#1-7-安装ceph-deploy部署工具-仅主控节点" class="headerlink" title="1.7 安装ceph-deploy部署工具(仅主控节点)"></a>1.7 安装ceph-deploy部署工具(仅主控节点)</h3><p>​    更新你的仓库，并安装 ceph-deploy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</span><br></pre></td></tr></table></figure>
<p>​    <strong>实际执行情况</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</span><br><span class="line">E: Type &apos;deb https://download.ceph.com/debian-jewel/ trusty&apos; is not known on line 1 in source list /etc/apt/sources.list.d/ceph.list</span><br><span class="line">E: The list of sources could not be read.</span><br></pre></td></tr></table></figure>
<p>​    替换ceph国内源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# vi /etc/apt/sources.list.d/ceph.list</span><br><span class="line"></span><br><span class="line">修改内容如下：</span><br><span class="line">#deb http://download.ceph.com/debian-jewel/ trusty main </span><br><span class="line">deb http://mirrors.163.com/ceph/debian-jewel trusty main</span><br></pre></td></tr></table></figure>
<p>​    然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install ceph-deploy</span><br></pre></td></tr></table></figure>
<h2 id="2-启动ceph-mon"><a href="#2-启动ceph-mon" class="headerlink" title="2 启动ceph-mon"></a>2 启动ceph-mon</h2><h3 id="2-1-安装ceph"><a href="#2-1-安装ceph" class="headerlink" title="2.1 安装ceph"></a>2.1 安装ceph</h3><p>使用国内源加快安装速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-jewel </span><br><span class="line">export CEPH_DEPLOY_GPG_URL=http://mirrors.163.com/ceph/keys/release.asc</span><br></pre></td></tr></table></figure>
<p>###2.2 创建部署的目录，目录内会生成ceph的配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-cluster &amp;&amp; cd my-cluster/</span><br></pre></td></tr></table></figure>
<h3 id="2-3-配置新节点"><a href="#2-3-配置新节点" class="headerlink" title="2.3 配置新节点"></a>2.3 配置新节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy new your-node-list</span><br></pre></td></tr></table></figure>
<p>例如：<code>ceph-deploy new ceph-0 ceph-1 ceph-2 [other node…]</code></p>
<p>此时会在my-cluster目录下生成几个文件，如ceph.conf;ceph.mon.keyring等</p>
<p>设置ceph.conf，增加一行<code>public network = xxx.xxx.xxx.0/24</code>[取决于实际的网络]</p>
<p><strong>实际配置操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph-deploy new ceph0 ceph1 ceph2</span><br><span class="line">root@ceph0:~/my-cluster# ls</span><br><span class="line">ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring  release.asc</span><br></pre></td></tr></table></figure>
<p>​    看一下网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr fa:16:3e:89:b2:7f  </span><br><span class="line">          inet addr:172.20.0.196  Bcast:172.20.255.255  Mask:255.255.0.0</span><br></pre></td></tr></table></figure>
<p>​    我这里新增加的一行为：public network = xxx.xxx.xxx.0/16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# vim ceph.conf</span><br><span class="line">[global]</span><br><span class="line">fsid = 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</span><br><span class="line">mon_initial_members = ceph0, ceph1, ceph2</span><br><span class="line">mon_host = 172.20.0.196,172.20.0.197,172.20.0.198</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line"></span><br><span class="line">public network = 172.20.0.0/16</span><br></pre></td></tr></table></figure>
<p>###2.4 安装该节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install ceph-0 ceph-2 ceph-2 [other node...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph-deploy install ceph0 ceph1 ceph2</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">[ceph2][INFO  ] Running command: ceph --version</span><br><span class="line">[ceph2][DEBUG ] ceph version 10.2.3 (ecc23778eb545d8dd55e2e4735b53cc93f92e65b)</span><br><span class="line"># ceph0,ceph1,ceph2都出现上面这两行输出表示安装完成</span><br></pre></td></tr></table></figure>
<p>###2.5 配置并启动ceph-mon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>
<p>​    然后运行 ceph -s可以看到当前集群的状态，3个mon，暂时没有osd，有个pool，pool的pg数目是64个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph -s</span><br><span class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</span><br><span class="line">     health HEALTH_ERR</span><br><span class="line">            no osds</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</span><br><span class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">     osdmap e1: 0 osds: 0 up, 0 in</span><br><span class="line">            flags sortbitwise</span><br><span class="line">      pgmap v2: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            0 kB used, 0 kB / 0 kB avail</span><br><span class="line">                  64 creating</span><br></pre></td></tr></table></figure>
<h2 id="3-添加ceph-osd节点"><a href="#3-添加ceph-osd节点" class="headerlink" title="3 添加ceph-osd节点"></a>3 添加ceph-osd节点</h2><h3 id="3-1-安装ceph到osd节点"><a href="#3-1-安装ceph到osd节点" class="headerlink" title="3.1 安装ceph到osd节点"></a>3.1 安装ceph到osd节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --release &#123;release-name&#125; node-list</span><br></pre></td></tr></table></figure>
<p>​    这里把之前装monitor前没装的主机装上，我这里还剩ceph3, ceph4没装，执行如下（其实命令里选择版本号这个可以去掉，因为默认的下载源已经指定了版本）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --release jewel ceph3 ceph4</span><br></pre></td></tr></table></figure>
<h3 id="3-2-设置并启动osd"><a href="#3-2-设置并启动osd" class="headerlink" title="3.2 设置并启动osd"></a>3.2 设置并启动osd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy osd prepare ceph-4:/dev/vdb1:/dev/vde1 ceph-4:/dev/vdc1:/dev/vde2 ceph-4:/dev/vdd1:/dev/vde3 #磁盘准备</span><br><span class="line">ssh ceph-4 &apos;chown ceph:ceph /dev/vdb1 /dev/vdc1 /dev/vdd1 /dev/vde1 /dev/vde2 /dev/vde3&apos; # 设置权限</span><br><span class="line">ceph-deploy osd activate ceph-4:/dev/vdb1:/dev/vde1 ceph-4:/dev/vdc1:/dev/vde2 ceph-4:/dev/vdd1:/dev/vde3 #启动osd</span><br></pre></td></tr></table></figure>
<p>​    上述代码会在ceph-4机器创建三个osd进程，磁盘组合/dev/vdb1:/dev/vde1的vdb1作为第一个osd的数据盘，vde1作为journal盘。然后运行ceph -s，可以看到osd节点已经加入。</p>
<p>具体执行如下：</p>
<p><strong>1 磁盘准备</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph-deploy osd prepare ceph0:/dev/vdc1:/dev/vdb1 ceph0:/dev/vdd1:/dev/vdb2 ceph0:/dev/vde1:/dev/vdb3</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">[ceph0][INFO  ] checking OSD status...</span><br><span class="line">[ceph0][DEBUG ] find the location of an executable</span><br><span class="line">[ceph0][INFO  ] Running command: /usr/bin/ceph --cluster=ceph osd stat --format=json</span><br><span class="line">[ceph_deploy.osd][DEBUG ] Host ceph0 is now ready for osd use.</span><br></pre></td></tr></table></figure>
<p><strong>2 设置权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ssh ceph0 &apos;chown ceph:ceph /dev/vdb1 /dev/vdb2 /dev/vdb3 /dev/vdc1 /dev/vdd1 /dev/vde1&apos;</span><br></pre></td></tr></table></figure>
<p><strong>3 启动OSD</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph-deploy osd activate ceph0:/dev/vdc1:/dev/vdb1 ceph0:/dev/vdd1:/dev/vdb2 ceph0:/dev/vde1:/dev/vdb3</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">[ceph0][INFO  ] checking OSD status...</span><br><span class="line">[ceph0][DEBUG ] find the location of an executable</span><br><span class="line">[ceph0][INFO  ] Running command: /usr/bin/ceph --cluster=ceph osd stat --format=json</span><br></pre></td></tr></table></figure>
<p>​    其他四台主机上的OSD设置同上，注意SSD盘符和SATA盘符的不同。</p>
<p>​    所有五台机器设置完后，运行ceph -s，可以看到15个osd节点已经加入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~/my-cluster# ceph -s</span><br><span class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (12 &lt; min 30)</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</span><br><span class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">     osdmap e80: 15 osds: 15 up, 15 in</span><br><span class="line">            flags sortbitwise</span><br><span class="line">      pgmap v181: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            525 MB used, 2792 GB / 2792 GB avail</span><br><span class="line">                  64 active+clean</span><br></pre></td></tr></table></figure>
<p><strong>4 设置使集群处于健康状态</strong></p>
<p><strong>注意上面的ceph 处于 HEALTH_WARN 状态</strong></p>
<p>查看副本数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph osd dump | grep &apos;replicated size&apos;</span><br><span class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</span><br></pre></td></tr></table></figure>
<p>查看已经存在的pools</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph osd lspools</span><br><span class="line">0 rbd,</span><br></pre></td></tr></table></figure>
<p>查看rbd pool中的 pg_num 和 pgp_num 属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph osd pool get rbd pg_num</span><br><span class="line">pg_num: 64</span><br><span class="line">root@ceph0:/etc/ceph# ceph osd pool get rbd pgp_num</span><br><span class="line">pgp_num: 64</span><br></pre></td></tr></table></figure>
<p>健康的 pg_num 和 pgp_num 计算方法：</p>
<p>​    关于pgmap的数目，<strong>osd_num *100 / replica_num</strong>，<strong>向上取2的幂</strong>。比如15个osd，三备份，15 *100/3=500，得到pg_num = 512，线上重新设定这个数值时会引起数据迁移，请谨慎处理。</p>
<p>设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph osd pool set rbd pg_num 512</span><br><span class="line">set pool 0 pg_num to 512</span><br><span class="line">root@ceph0:/etc/ceph# ceph osd pool set rbd pgp_num 512</span><br><span class="line">set pool 0 pgp_num to 512</span><br><span class="line">root@ceph0:/etc/ceph#</span><br></pre></td></tr></table></figure>
<p>再次查看 ceph 集群状态，HEALTH_OK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph -s</span><br><span class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</span><br><span class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">     osdmap e84: 15 osds: 15 up, 15 in</span><br><span class="line">            flags sortbitwise</span><br><span class="line">      pgmap v226: 512 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            561 MB used, 2792 GB / 2792 GB avail</span><br><span class="line">                 512 active+clean</span><br><span class="line">root@ceph0:/etc/ceph#</span><br></pre></td></tr></table></figure>
<h2 id="4-设置ceph的rbd块存储设备"><a href="#4-设置ceph的rbd块存储设备" class="headerlink" title="4 设置ceph的rbd块存储设备"></a>4 设置ceph的rbd块存储设备</h2><p>​    确保ceph存储集群处于 active + clean 的状态，这样才能使用块设备。</p>
<h3 id="4-1-建立主控机器到rbd所在设备的ssh免密登录关系"><a href="#4-1-建立主控机器到rbd所在设备的ssh免密登录关系" class="headerlink" title="4.1 建立主控机器到rbd所在设备的ssh免密登录关系"></a>4.1 建立主控机器到rbd所在设备的ssh免密登录关系</h3><p>​    参见上文：章节1.2。</p>
<h3 id="4-2-安装ceph环境，并授予权限"><a href="#4-2-安装ceph环境，并授予权限" class="headerlink" title="4.2 安装ceph环境，并授予权限"></a>4.2 安装ceph环境，并授予权限</h3><p>​    假设rbd所在机器的hostname为 ceph-cli（这里新建一台主机，名为ceph-cli）。在<strong>主控节点上</strong>的 /etc/ceph 目录下执行操作。</p>
<p>​    1 在ceph0上使用ceph-deploy 工具ceph二进制程序安装到ceph-cli上面</p>
<p>​    注意：在 ceph-cli 主机上将ceph 源改为国内源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ceph/ # 主控节点</span><br><span class="line">ceph-deploy install ceph-cli</span><br></pre></td></tr></table></figure>
<p>​    2 将ceph配置文件（ceph.conf）复制到ceph-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy config push ceph-cli</span><br></pre></td></tr></table></figure>
<p>​    3 客户机需要ceph密钥去访问ceph集群。ceph创建了一个默认用户 client.admin，它有足够的权限去访问ceph集群。不建议把client.admin共享到所有其他客户端节点。更好的做法是用分开的密钥创建一个新的ceph用户去访问特定的存储池。</p>
<p>​    这里，创建了一个ceph用户 client.rbd，它拥有访问rbd存储池的权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph auth get-or-create client.rbd mon &apos;allow r&apos; osd &apos;allow class-read object_prefix rbd_children, allow rwx pool=rbd&apos;</span><br><span class="line">[client.rbd]</span><br><span class="line">	key = AQAmVzVYzXDjBhAAWlcdtEnQ6XBscmU58ZljAw==</span><br></pre></td></tr></table></figure>
<p>​    4 为ceph-cli上的client.rbd用户添加密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ceph auth get-or-create client.rbd | ssh ceph-cli &apos;sudo tee /etc/ceph/ceph.client.rbd.keyring&apos;</span><br><span class="line">sudo: unable to resolve host ceph-cli</span><br><span class="line">[client.rbd]</span><br><span class="line">	key = AQAmVzVYzXDjBhAAWlcdtEnQ6XBscmU58ZljAw==</span><br></pre></td></tr></table></figure>
<p>​    5 至此，ceph-cli 应该准备好充当ceph客户端了。通过提供用户名和密钥在 ceph-cli 上检查集群的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:/etc/ceph# ssh ceph-cli &apos;cat /etc/ceph/ceph.client.rbd.keyring &gt;&gt; /etc/ceph/keyring&apos;</span><br><span class="line"></span><br><span class="line">root@ceph0:/etc/ceph# ssh ceph-cli &apos;ceph -s --name client.rbd&apos;</span><br><span class="line">    cluster 4d7e1b04-2a4c-45aa-b6fe-a98241db0c2f</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph0=172.20.0.196:6789/0,ceph1=172.20.0.197:6789/0,ceph2=172.20.0.198:6789/0&#125;</span><br><span class="line">            election epoch 4, quorum 0,1,2 ceph0,ceph1,ceph2</span><br><span class="line">     osdmap e84: 15 osds: 15 up, 15 in</span><br><span class="line">            flags sortbitwise</span><br><span class="line">      pgmap v232: 512 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            547 MB used, 2792 GB / 2792 GB avail</span><br><span class="line">                 512 active+clean</span><br></pre></td></tr></table></figure>
<p>​    至此，ceph客户端已经配置完毕。接下来在客户端上创建块设备。</p>
<h3 id="4-3-创建ceph块设备"><a href="#4-3-创建ceph块设备" class="headerlink" title="4.3 创建ceph块设备"></a>4.3 创建ceph块设备</h3><p>​    1 创建一个102400M 大小的RADOS 块设备，取名 rbd1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# rbd create rbd1 --size 102400 --name client.rbd --image-feature layering</span><br><span class="line"># 14.04的内核只支持layering，增加不支持的特性会导致后续的map失败。</span><br></pre></td></tr></table></figure>
<p>​    2 列出RBD 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# rbd ls --name client.rbd</span><br><span class="line">rbd1</span><br></pre></td></tr></table></figure>
<p>​    3 检查rbd 镜像的细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# rbd --image rbd1 info --name client.rbd</span><br><span class="line">rbd image &apos;rbd1&apos;:</span><br><span class="line">	size 102400 MB in 25600 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.10912ae8944a</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<h3 id="4-4-映射块设备并初始化"><a href="#4-4-映射块设备并初始化" class="headerlink" title="4.4 映射块设备并初始化"></a>4.4 映射块设备并初始化</h3><p>​    1 映射块设备到 ceph-cli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# rbd map --image rbd1 --name client.rbd</span><br><span class="line">/dev/rbd0</span><br></pre></td></tr></table></figure>
<p>​    2 检查被映射的块设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# rbd showmapped --name client.rbd</span><br><span class="line">id pool image snap device    </span><br><span class="line">0  rbd  rbd1  -    /dev/rbd0</span><br></pre></td></tr></table></figure>
<p>​    3 要使用这个块设备，我们需要创建并挂载一个文件系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# fdisk -l /dev/rbd0</span><br><span class="line"></span><br><span class="line">#创建文件系统</span><br><span class="line">root@ceph-cli:~# mkfs.ext4 /dev/rbd0</span><br><span class="line"></span><br><span class="line">#创建文件夹 ceph-disk1，并将块设备 rbd0 挂载在该目录下</span><br><span class="line">root@ceph-cli:~# mkdir /mnt/ceph-disk1 &amp;&amp; mount /dev/rbd0 /mnt/ceph-disk1</span><br><span class="line"></span><br><span class="line">root@ceph-cli:~# df -h /mnt/ceph-disk1</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/rbd0        99G   60M   94G   1% /mnt/ceph-disk1</span><br></pre></td></tr></table></figure>
<h3 id="4-5-测试块设备"><a href="#4-5-测试块设备" class="headerlink" title="4.5 测试块设备"></a>4.5 测试块设备</h3><p>​    接下来就可以开始对这个块存储进行任意读写了。可以使用dd或者fio进行性能测试，注意fio是破坏性测试，会毁坏数据甚至文件系统。不过破坏了也没关系，删除rbd设备后，重新添加rbd设备，格式化即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ceph-cli:~# dd if=/dev/zero of=/mnt/ceph-disk1/file1 count=100 bs=1M</span><br><span class="line">100+0 records in</span><br><span class="line">100+0 records out</span><br><span class="line">104857600 bytes (105 MB) copied, 0.12931 s, 811 MB/s</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fio测试ceph]]></title>
      <url>http://xiaqunfeng.cc/2017/07/12/fio-test-ceph/</url>
      <content type="html"><![CDATA[<p>包含三块内容：fio测试RBD，fio测试ceph filestore，fio测试ceph bluestore。<br><a id="more"></a></p>
<h2 id="fio测试RBD"><a href="#fio测试RBD" class="headerlink" title="fio测试RBD"></a>fio测试RBD</h2><p>fio测试工具扩展了一个对 <code>librbd</code> 的支持模块，并使用您选择的IO模式测试Ceph RBD集群。安装librbd开发包（例如librbd-dev或librbd-dev和依赖关系），或者将库及其头放在指定位置即可。</p>
<h3 id="安装fio及依赖包"><a href="#安装fio及依赖包" class="headerlink" title="安装fio及依赖包"></a>安装fio及依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># git clone git://git.kernel.dk/fio.git</span><br><span class="line"># cd fio/</span><br><span class="line"># ./configure</span><br><span class="line">...</span><br><span class="line">Rados Block Device engine     no</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里显示不支持RBD engine，configure检查编译环境缺少依赖导致的，安装 <code>ceph-devel</code> 包即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ceph-devel -y</span><br></pre></td></tr></table></figure>
<p>重新编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ./configure</span><br><span class="line">...</span><br><span class="line">Rados Block Device engine     yes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看当前 fio 已支持的 IO 引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># fio --enghelp</span><br><span class="line">Available IO engines:</span><br><span class="line">	cpuio</span><br><span class="line">	mmap</span><br><span class="line">	sync</span><br><span class="line">	psync</span><br><span class="line">	vsync</span><br><span class="line">	pvsync</span><br><span class="line">	null</span><br><span class="line">	net</span><br><span class="line">	netsplice</span><br><span class="line">	libaio</span><br><span class="line">	rdma</span><br><span class="line">	posixaio</span><br><span class="line">	falloc</span><br><span class="line">	e4defrag</span><br><span class="line">	splice</span><br><span class="line">	rbd</span><br><span class="line">	mtd</span><br><span class="line">	sg</span><br><span class="line">	binject</span><br></pre></td></tr></table></figure>
<p>此时，已支持 RBD engine。</p>
<h3 id="测试librbd"><a href="#测试librbd" class="headerlink" title="测试librbd"></a>测试librbd</h3><p>1、创建一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd -p rbd create --size 2048 fio_test</span><br></pre></td></tr></table></figure>
<p>2、撰写 job file：<code>rbd.fio</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">######################################################################</span><br><span class="line"># Example test for the RBD engine.</span><br><span class="line">#</span><br><span class="line"># Runs a 4k random write test agains a RBD via librbd</span><br><span class="line">#</span><br><span class="line"># NOTE: Make sure you have either a RBD named &apos;fio_test&apos; or change</span><br><span class="line">#       the rbdname parameter.</span><br><span class="line">######################################################################</span><br><span class="line">[global]</span><br><span class="line">#logging</span><br><span class="line">#write_iops_log=write_iops_log</span><br><span class="line">#write_bw_log=write_bw_log</span><br><span class="line">#write_lat_log=write_lat_log</span><br><span class="line">ioengine=rbd</span><br><span class="line">clientname=admin</span><br><span class="line">pool=rbd</span><br><span class="line">rbdname=fio_test</span><br><span class="line">invalidate=0    # mandatory</span><br><span class="line">rw=randwrite</span><br><span class="line">bs=4k</span><br><span class="line"></span><br><span class="line">[rbd_iodepth32]</span><br><span class="line">iodepth=32</span><br></pre></td></tr></table></figure>
<p>以上 job file 将执行整个RBD大小的100％随机写入测试（将通过librbd确定），Ceph用户 <code>admin</code> 使用Ceph 默认 pool <code>rbd</code>和刚刚创建的空的 RBD fio_test，写的 blocksize 为 4k 和 iodepth 为32 。 引擎正在使用异步IO。</p>
<p>当前实施限制：</p>
<ul>
<li>invalidate = 0 现在是强制需要的，engine 现在没有这个会返回失败。 </li>
<li>测试完成后 <code>rbd</code> 引擎不会被清除。完成测试运行后，给定的RBD将被填充。（我们现在使用它进行预填充测试，并在需要时重新创建RBD。）</li>
</ul>
<p>部分参考：<a href="http://telekomcloud.github.io/ceph/2014/02/26/ceph-performance-analysis_fio_rbd.html" target="_blank" rel="noopener">Ceph Performance Analysis: fio and RBD</a></p>
<p>3、测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio rbd.fio</span><br></pre></td></tr></table></figure>
<h3 id="测试kernel-RBD"><a href="#测试kernel-RBD" class="headerlink" title="测试kernel RBD"></a>测试kernel RBD</h3><p>1、创建一个image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd -p rbd create --size 2048 fio_test</span><br></pre></td></tr></table></figure>
<p>2、将image map到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rbd map rbd/fio_test</span><br><span class="line">/dev/rbd0</span><br><span class="line"># mkfs.xfs /dev/rbd0 -f</span><br></pre></td></tr></table></figure>
<p>3、撰写 job file：<code>rbd.fio</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">ioengine=libaio</span><br><span class="line">direct=1</span><br><span class="line">thread=1</span><br><span class="line">runtime=100</span><br><span class="line">size=100G</span><br><span class="line">group_reporting</span><br><span class="line">ramp_time=6</span><br><span class="line">userspace_reap</span><br><span class="line">numjobs=1</span><br><span class="line">iodepth=128</span><br><span class="line">time_based</span><br><span class="line"></span><br><span class="line">[randwrite-4k]</span><br><span class="line">filename=/dev/rbd0</span><br><span class="line">bs=4k</span><br><span class="line">rw=randwrite</span><br><span class="line">rwmixwrite=20</span><br><span class="line">stonewall</span><br></pre></td></tr></table></figure>
<h2 id="fio测试filestore"><a href="#fio测试filestore" class="headerlink" title="fio测试filestore"></a>fio测试filestore</h2><p>TODO</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos7上安装python3]]></title>
      <url>http://xiaqunfeng.cc/2017/07/07/centos7-install-python3/</url>
      <content type="html"><![CDATA[<p>之前一直使用python2，现在转python3，安装了一下，记录之。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>python所有版本的下载地址: <a href="https://www.python.org/ftp/python/" target="_blank" rel="noopener">https://www.python.org/ftp/python/</a></p>
<p>最新的已经到3.6.2版本了，不过还是RC，这里安装3.6.1<br>有两个文件可以选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python-3.6.1.tar.xz</span><br><span class="line">Python-3.6.1.tgz</span><br></pre></td></tr></table></figure></p>
<p>两种都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz</span><br><span class="line">tar -zxvf Python-3.6.1.tar.xz</span><br><span class="line">cd Python-3.6.1</span><br><span class="line">./configure --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>此时两个版本共存，默认是2.7.5版本，可以通过 <code>python3</code> 命令来使用Python 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python --version</span><br><span class="line">Python 2.7.5</span><br></pre></td></tr></table></figure>
<h2 id="修改默认为python-3"><a href="#修改默认为python-3" class="headerlink" title="修改默认为python 3"></a>修改默认为python 3</h2><blockquote>
<p>不推荐这么做，直接使用命令 python3 来调用挺好的</p>
</blockquote>
<p>1、首先备份原先的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br></pre></td></tr></table></figure></p>
<p>2、创建python3的软链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure></p>
<p>此时python3为默认版本了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python --version</span><br><span class="line">Python 3.6.1</span><br></pre></td></tr></table></figure>
<h3 id="yum-问题"><a href="#yum-问题" class="headerlink" title="yum 问题"></a>yum 问题</h3><p>yum使用Python 2，默认 <code>python</code> 替换Python 3后无法正常工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># yum</span><br><span class="line">  File &quot;/usr/bin/yum&quot;, line 30</span><br><span class="line">    except KeyboardInterrupt, e:</span><br><span class="line">                            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>修改配置文件：<code>/usr/bin/yum</code></p>
<p>将默认的python替换为python2.7，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">替换为</span><br><span class="line">#!/usr/bin/python2.7</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XFS vs EXT4]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/XFS-vs-EXT4/</url>
      <content type="html"><![CDATA[<p>ceph默认的文件系统是XFS，centos7之前的版本默认文件系统是EXT4，现在是XFS，这里对比了一下，然后针对4k大小的随机读写进行了小小的测试。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux操作系统有很多不同的文件系统选择，所有现有的默认文件系统都是ext4。 通常文件系统被用来处理当程序不再使用信息之后如何保存信息，如何管理信息的可访问性，其他信息（元数据）与数据本身如何相关联等。</p>
<h2 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h2><p>Ext4是第四代扩展文件系统的缩写，它是2008年推出的。它是一个真正可靠的文件系统，它几乎在过去几年的大部分发行版中一直是默认选项，它是由比较老的代码生成的。它是一个日志文件系统，意味着它会对文件在磁盘中的位置以及任何其它对磁盘的更改做记录。如果系统崩溃，得益于journal技术，文件系统很少会损坏。</p>
<p>最大单个文件大小可以从16 GB到16 TB<br>最大文件系统大小为1EB（exabyte）<br>最大值包含64,000个子目录（ext3中的32,000个）</p>
<h2 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h2><p>XFS是由SGI为其IRIX平台设计的高性能64位日志文件系统。 XFS具有各种改进，使其能够在文件系统群体列表中脱颖而出，例如用于元数据操作的日志记录，可扩展/并行I / O，挂起/恢复I / O，在线碎片整理，延迟性能分配，等等</p>
<p>大概在2002年，XFS被合入Linux内核，2009年RHEL Linux版本5.4使用了XFS文件系统。 由于其高性能，架构可扩展性和鲁棒性，XFS一直是很多企业系统的首选，特别是拥有大量数据的企业系统。 现在，RHEL / CentOS 7和Oracle Linux使用XFS作为其默认文件系统。</p>
<p>最大单个文件大小可以是16 TB到16 Exabytes<br>最大文件系统大小为8EB（exabyte）<br>缺点：XFS文件系统不能缩小，当删除大量文件时会性能下降。</p>
<h2 id="更多对比"><a href="#更多对比" class="headerlink" title="更多对比"></a>更多对比</h2><ul>
<li>ext4不支持透明压缩、重复数据删除或者透明加密。技术上支持了快照，但该功能还处于实验性阶段。xfs也不能压缩，XFS 是基于B+ Ttree 管理元数据，即将支持reflink, dedupe等高级特性。</li>
<li>Ext4受限制于磁盘结构和兼容问题，可扩展性和scalability不如XFS。</li>
<li>虽然Ext4 目录索引采用了Hash Index Tree, 但是依然限制高度为2。</li>
<li>由于历史磁盘结构原因Ext4 的inode 个数限制(32位数)最多只能有大概40多亿文件。而且Ext4的单个文件大小最大只能支持到16T(4K block size) ，目前来说已经是瓶颈。XFS使用64位管理空间，文件系统规模可以达到EB级别。</li>
</ul>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>测试了一下4k随机读写的性能，direct=1，numjobs=20，iodepth=128</p>
<p>磁盘信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sdc1: 4000.8 GB, 4000785104896 bytes, 7814033408 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>
<p>测试数据</p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>4k-randread</th>
<th>4k-read</th>
<th>4k-randwrite</th>
<th>4k-write</th>
</tr>
</thead>
<tbody>
<tr>
<td>XFS</td>
<td>iops=426</td>
<td>iops=42773</td>
<td>iops=313</td>
<td>iops=24732</td>
</tr>
<tr>
<td>EXT4</td>
<td>iops=430</td>
<td>iops=41636</td>
<td>iops=315</td>
<td>iops=19095</td>
</tr>
</tbody>
</table>
<p>在4k这个量级上IOPS基本没啥区别，4k随机写XFS略好于EXT4。</p>
<p>性能方面的对比：<a href="http://www.cnblogs.com/tommyli/p/3201047.html" target="_blank" rel="noopener">ext3，ext4，xfs和btrfs文件系统性能对比</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext3/4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Create a file system</td>
<td>mkfs.ext4 or mkfs.ext3</td>
<td>mkfs.xfs</td>
</tr>
<tr>
<td>File system check</td>
<td>e2fsck</td>
<td>xfs_repair</td>
</tr>
<tr>
<td>Resizing a file system</td>
<td>resize2fs</td>
<td>xfs_growfs</td>
</tr>
<tr>
<td>Save an image of a file system</td>
<td>e2image</td>
<td>xfs_metadump and xfs_mdrestore</td>
</tr>
<tr>
<td>Label or tune a file system</td>
<td>tune2fs</td>
<td>xfs_admin</td>
</tr>
<tr>
<td>Backup a file system</td>
<td>dump and restore</td>
<td>xfsdump and xfsrestore</td>
</tr>
</tbody>
</table>
<h2 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h2><table>
<thead>
<tr>
<th><strong>Task</strong></th>
<th><strong>ext4</strong></th>
<th><strong>XFS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Quota</td>
<td>quota</td>
<td>xfs_quota</td>
</tr>
<tr>
<td>File mapping</td>
<td>filefrag</td>
<td>xfs_bmap</td>
</tr>
</tbody>
</table>
<p>文件系统之间更多的参数和功能的对比：<a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems" target="_blank" rel="noopener">Comparison of file systems</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph luminous新命令探索]]></title>
      <url>http://xiaqunfeng.cc/2017/07/06/ceph-luminous-new-cmd/</url>
      <content type="html"><![CDATA[<p>在luminous版本中有好多新命令，来逐一探索一下。<br><a id="more"></a></p>
<h2 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h2><p>这个命令之前就说过了，这个来个对比吧。</p>
<p>luminous版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</span><br><span class="line">    mgr: luminous0(active)</span><br><span class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</span><br><span class="line">    osd: 6 osds: 6 up, 6 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   10 pools, 192 pgs</span><br><span class="line">    objects: 251 objects, 10685 bytes</span><br><span class="line">    usage:   9156 MB used, 41538 MB / 50694 MB avail</span><br><span class="line">    pgs:     192 active+clean</span><br></pre></td></tr></table></figure></p>
<p>kraken版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e2: 3 mons at &#123;test0=172.20.2.235:6789/0,test1=172.20.2.236:6789/0,test2=172.20.2.237:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 test0,test1,test2</span><br><span class="line">        mgr active: test2 standbys: test1, test0</span><br><span class="line">     osdmap e28: 6 osds: 6 up, 6 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v11414: 320 pgs, 2 pools, 149 MB data, 68 objects</span><br><span class="line">            609 MB used, 30044 MB / 30653 MB avail</span><br><span class="line">                 320 active+clean</span><br></pre></td></tr></table></figure></p>
<h2 id="CEPH-OSD"><a href="#CEPH-OSD" class="headerlink" title="CEPH OSD"></a>CEPH OSD</h2><h3 id="ceph-osd-ls-tree"><a href="#ceph-osd-ls-tree" class="headerlink" title="ceph osd ls-tree"></a>ceph osd ls-tree</h3><p>功能：</p>
<p>将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd ls-tree &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd ls-tree default</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd ls-tree default~ssd</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="ceph-osd-add-rm-noout-noin-nodown-noup"><a href="#ceph-osd-add-rm-noout-noin-nodown-noup" class="headerlink" title="ceph osd {add, rm} - {noout, noin, nodown, noup}"></a>ceph osd {add, rm} - {noout, noin, nodown, noup}</h3><p>功能：</p>
<p>允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd &#123;add, rm&#125;-&#123;noout, noin, nodown, noup&#125; &lt;ids&gt; [&lt;ids&gt;...]</span><br></pre></td></tr></table></figure>
<p>意义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark osd(s) &lt;id&gt; [&lt;id&gt;...] as &#123;noout, noin, nodown, noup&#125;, or use &lt;all|any|*&gt; to mark all osds as &#123;noout, noin, nodown, noup&#125;</span><br><span class="line">allow osd(s) &lt;id&gt; [&lt;id&gt;...] to be marked &#123;out, in, down, up&#125; (if they are currently marked as noout, noin, nodown, noup),can use &lt;all|any|*&gt; to automatically filter out all nodown osds</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd add-noout 1 4</span><br><span class="line"># ceph osd rm-noout 1 4</span><br><span class="line"># ceph osd add-noout all</span><br><span class="line"># ceph osd rm-noout any</span><br></pre></td></tr></table></figure>
<p>查看某一个osd的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd dump 1</span><br><span class="line">epoch 1</span><br><span class="line">fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">created 2017-06-29 15:34:07.310885</span><br><span class="line">modified 2017-06-29 15:34:07.310885</span><br><span class="line">flags sortbitwise</span><br><span class="line">crush_version 1</span><br><span class="line">full_ratio 0.95</span><br><span class="line">backfillfull_ratio 0.9</span><br><span class="line">nearfull_ratio 0.85</span><br><span class="line">require_min_compat_client jewel</span><br><span class="line">min_compat_client jewel</span><br><span class="line">pool 0 &apos;rbd&apos; replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</span><br><span class="line">max_osd 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里其实并不会显示标记</p>
</blockquote>
<p><strong>原先的标记命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd &#123;set, unset&#125; &#123;noout, noin, nodown, noup&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ceph-osd-crush-swap-bucket"><a href="#ceph-osd-crush-swap-bucket" class="headerlink" title="ceph osd crush swap-bucket"></a>ceph osd crush swap-bucket</h3><p>功能：</p>
<p>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush swap-bucket &lt;source&gt; &lt;dest&gt; &#123;--yes-i-really-mean-it&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap existing bucket contents from (orphan) bucket &lt;source&gt; and &lt;target&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ceph-osd-destroy"><a href="#ceph-osd-destroy" class="headerlink" title="ceph osd destroy"></a>ceph osd destroy</h3><p>功能：</p>
<p>将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。简单来说</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd destroy &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</span><br></pre></td></tr></table></figure>
<p>解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mark osd as being destroyed. Keeps the ID intact (allowing reuse), but removes cephx keys,config-key data and lockbox keys, rendering data permanently unreadable.</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd destroy 1</span><br><span class="line">Error EPERM: Are you SURE? This will mean real, permanent data loss, as well as cephx and lockbox keys. Pass --yes-i-really-mean-it if you really do.</span><br><span class="line"></span><br><span class="line"># ceph osd destroy 1 --yes-i-really-mean-it</span><br><span class="line">Error EBUSY: osd.1 is not `down`.</span><br><span class="line"></span><br><span class="line"># ceph osd down 1</span><br><span class="line">marked down osd.1.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有个奇怪的现象，执行 ceph osd down 发现osd 还是 up的状态，一直无果，最终还是停掉进程使其 down</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop ceph-osd@1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd destroy 1 --yes-i-really-mean-it</span><br><span class="line">destroyed osd.1</span><br></pre></td></tr></table></figure>
<p>此时，osd.1 还在集群中，只不过已经清理了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd stat</span><br><span class="line">6 osds: 5 up, 5 in</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line"> -1 0.05699 root default</span><br><span class="line"> -2 0.01900     host luminous0</span><br><span class="line">  1 0.00999         osd.1             down        0          1.00000</span><br><span class="line">  5 0.00999         osd.5               up  1.00000          1.00000</span><br><span class="line"> -3 0.01900     host luminous2</span><br><span class="line">  0 0.00999         osd.0               up  1.00000          1.00000</span><br><span class="line">  4 0.00999         osd.4               up  1.00000          1.00000</span><br><span class="line"> -4 0.01900     host luminous1</span><br><span class="line">  2 0.00999         osd.2               up  1.00000          1.00000</span><br><span class="line">  3 0.00999         osd.3               up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h3 id="ceph-osd-purge"><a href="#ceph-osd-purge" class="headerlink" title="ceph osd purge"></a>ceph osd purge</h3><p>功能：</p>
<p>将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd purge &lt;osdname (id|osd.id)&gt; &#123;--yes-i-really-mean-it&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">purge all osd data from the monitors. Combines `osd destroy`, `osd rm`, and `osd crush rm`</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd purge 1 --yes-i-really-mean-it</span><br><span class="line">purged osd.1</span><br></pre></td></tr></table></figure>
<p>此时发现osd已经不再集群中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd stat</span><br><span class="line">5 osds: 5 up, 5 in</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">-1 0.04799 root default</span><br><span class="line"> -2 0.00999     host luminous0</span><br><span class="line">  5 0.00999         osd.5               up  1.00000          1.00000</span><br><span class="line"> -3 0.01900     host luminous2</span><br><span class="line">  0 0.00999         osd.0               up  1.00000          1.00000</span><br><span class="line">  4 0.00999         osd.4               up  1.00000          1.00000</span><br><span class="line"> -4 0.01900     host luminous1</span><br><span class="line">  2 0.00999         osd.2               up  1.00000          1.00000</span><br><span class="line">  3 0.00999         osd.3               up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h3 id="ceph-osd-rewightn"><a href="#ceph-osd-rewightn" class="headerlink" title="ceph osd rewightn"></a>ceph osd rewightn</h3><blockquote>
<p>该命令没试验成功！！</p>
</blockquote>
<p>功能：</p>
<p>在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code>命令。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd reweightn &lt;weights&gt;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</span><br></pre></td></tr></table></figure>
<p>单个osd的rewight命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph osd reweight &lt;osdname (id|osd.id)&gt; &lt;float[0.0-1.0]&gt;</span><br><span class="line">explain: reweight osd to 0.0 &lt; &lt;weight&gt; &lt; 1.0</span><br></pre></td></tr></table></figure>
<p>我当前osd状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line"> -1 0.05699 root default</span><br><span class="line"> -2 0.01900     host luminous0</span><br><span class="line">  1 0.00999         osd.1               up  1.00000          1.00000</span><br><span class="line">  5 0.00999         osd.5               up  1.00000          1.00000</span><br><span class="line"> -3 0.01900     host luminous2</span><br><span class="line">  0 0.00999         osd.0               up  1.00000          1.00000</span><br><span class="line">  4 0.00999         osd.4               up  1.00000          1.00000</span><br><span class="line"> -4 0.01900     host luminous1</span><br><span class="line">  2 0.00999         osd.2               up  1.00000          1.00000</span><br><span class="line">  3 0.00999         osd.3               up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd reweightn &#123;5:0.02, 4:0.03, 2:0.01&#125;</span><br><span class="line">Invalid command:  unused arguments: [u&apos;4:0.03,&apos;, u&apos;2:0.01&#125;&apos;]</span><br><span class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</span><br><span class="line">Error EINVAL: invalid command</span><br><span class="line"></span><br><span class="line"># ceph osd reweightn 5:0.02</span><br><span class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;5:0.02&apos;</span><br><span class="line"></span><br><span class="line"># ceph osd reweightn &#123;5:0.02&#125;</span><br><span class="line">Error EINVAL: unable to parse &apos;weights&apos; value &apos;&#123;5:0.02&#125;&apos;</span><br><span class="line"></span><br><span class="line"># ceph osd reweightn osd.5  0.02</span><br><span class="line">Invalid command:  unused arguments: [u&apos;0.02&apos;]</span><br><span class="line">osd reweightn &lt;weights&gt; :  reweight osds with &#123;&lt;id&gt;: &lt;weight&gt;,...&#125;)</span><br><span class="line">Error EINVAL: invalid command</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该命令好像有问题，没有get到正确的姿势，有知道的请指正</p>
</blockquote>
<h2 id="ceph-log-last-n"><a href="#ceph-log-last-n" class="headerlink" title="ceph log last [n]"></a>ceph log last [n]</h2><p>输出集群日志的最后 n 行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph log last 10</span><br><span class="line">2017-06-30 17:13:14.216738 osd.3 osd.3 172.20.2.244:6804/38283 4 : cluster [INF] 0.d scrub ok</span><br><span class="line">2017-06-30 17:14:32.906853 osd.1 osd.1 172.20.2.243:6801/43997 5 : cluster [INF] 0.f scrub starts</span><br><span class="line">2017-06-30 17:14:32.908231 osd.1 osd.1 172.20.2.243:6801/43997 6 : cluster [INF] 0.f scrub ok</span><br><span class="line">2017-06-30 17:26:28.012607 osd.4 osd.4 172.20.2.245:6804/38814 5 : cluster [INF] 6.6 scrub starts</span><br><span class="line">2017-06-30 17:26:28.017546 osd.4 osd.4 172.20.2.245:6804/38814 6 : cluster [INF] 6.6 scrub ok</span><br><span class="line">2017-06-30 17:28:13.016525 osd.5 osd.5 172.20.2.243:6805/45058 3 : cluster [INF] 0.28 scrub starts</span><br><span class="line">2017-06-30 17:28:13.017914 osd.5 osd.5 172.20.2.243:6805/45058 4 : cluster [INF] 0.28 scrub ok</span><br><span class="line">2017-06-30 17:28:13.026468 osd.4 osd.4 172.20.2.245:6804/38814 7 : cluster [INF] 0.33 deep-scrub starts</span><br><span class="line">2017-06-30 17:28:13.027690 osd.4 osd.4 172.20.2.245:6804/38814 8 : cluster [INF] 0.33 deep-scrub ok</span><br><span class="line">2017-06-30 17:32:53.687436 mon.luminous0 mon.0 172.20.2.243:6789/0 357 : audit [INF] from=&apos;client.? 172.20.2.243:0/3812708038&apos; entity=&apos;client.admin&apos; cmd=[&#123;&quot;prefix&quot;: &quot;log last&quot;, &quot;num&quot;: 5&#125;]: dispatch</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是显示集群的最近 n 条日志，不是某一个日志文件里的，比如 <code>/var/log/ceph/ceph.log</code> 等。</p>
</blockquote>
<p>这对调试比较有用，不用去打开日志查看了</p>
<h2 id="ceph-features"><a href="#ceph-features" class="headerlink" title="ceph features"></a>ceph features</h2><p>查询所有连接的守护进程和客户端的支持特性和版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># ceph features</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mon&quot;: &#123;</span><br><span class="line">        &quot;group&quot;: &#123;</span><br><span class="line">            &quot;features&quot;: 1152323339925389307,</span><br><span class="line">            &quot;release&quot;: &quot;luminous&quot;,</span><br><span class="line">            &quot;num&quot;: 14</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mds&quot;: &#123;</span><br><span class="line">        &quot;group&quot;: &#123;</span><br><span class="line">            &quot;features&quot;: 1152323339925389307,</span><br><span class="line">            &quot;release&quot;: &quot;luminous&quot;,</span><br><span class="line">            &quot;num&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;osd&quot;: &#123;</span><br><span class="line">        &quot;group&quot;: &#123;</span><br><span class="line">            &quot;features&quot;: 1152323339925389307,</span><br><span class="line">            &quot;release&quot;: &quot;luminous&quot;,</span><br><span class="line">            &quot;num&quot;: 6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;client&quot;: &#123;</span><br><span class="line">        &quot;group&quot;: &#123;</span><br><span class="line">            &quot;features&quot;: 1152323339925389307,</span><br><span class="line">            &quot;release&quot;: &quot;luminous&quot;,</span><br><span class="line">            &quot;num&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ceph-mgr-dump"><a href="#ceph-mgr-dump" class="headerlink" title="ceph mgr dump"></a>ceph mgr dump</h2><p>dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ceph mgr dump</span><br><span class="line">&#123;</span><br><span class="line">    &quot;epoch&quot;: 15,</span><br><span class="line">    &quot;active_gid&quot;: 34310,</span><br><span class="line">    &quot;active_name&quot;: &quot;luminous0&quot;,</span><br><span class="line">    &quot;active_addr&quot;: &quot;172.20.2.243:6800/71321&quot;,</span><br><span class="line">    &quot;available&quot;: true,</span><br><span class="line">    &quot;standbys&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ceph-config-key"><a href="#ceph-config-key" class="headerlink" title="ceph config-key"></a>ceph config-key</h2><p>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config-key del &lt;key&gt;						delete &lt;key&gt;</span><br><span class="line">config-key dump 							dump keys and values</span><br><span class="line">config-key exists &lt;key&gt;						check for &lt;key&gt;&apos;s existence</span><br><span class="line">config-key get &lt;key&gt; 						get &lt;key&gt;</span><br><span class="line">config-key list 							list keys</span><br><span class="line">config-key put &lt;key&gt; &#123;&lt;val&gt;&#125;				put &lt;key&gt;, value &lt;val&gt;</span><br><span class="line">config-key rm &lt;key&gt; 						rm &lt;key&gt;</span><br></pre></td></tr></table></figure>
<p>比如，dump出config-key entries及其内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph config-key dump</span><br><span class="line">&#123;</span><br><span class="line">    &quot;initial_mon_keyring&quot;: &quot;AQDfMxVZAAAAABAAA1za9TC3Z2kmEdlVZL6gGQ==&quot;,</span><br><span class="line">    &quot;mgr/dashboard/server_addr&quot;: &quot;172.20.2.243&quot;,</span><br><span class="line">    &quot;mgr/dashboard/server_port&quot;: &quot;7000&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list，只dump出key，不包含value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph config-key list</span><br><span class="line">[</span><br><span class="line">    &quot;initial_mon_keyring&quot;,</span><br><span class="line">    &quot;mgr/dashboard/server_addr&quot;,</span><br><span class="line">    &quot;mgr/dashboard/server_port&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="ceph-mon-feature-list"><a href="#ceph-mon-feature-list" class="headerlink" title="ceph mon feature list"></a>ceph mon feature list</h2><p>列出MonMap中记录的monitor功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ceph mon feature list</span><br><span class="line">all features</span><br><span class="line">	supported: [kraken,luminous]</span><br><span class="line">	persistent: [kraken,luminous]</span><br><span class="line">on current monmap (epoch 1)</span><br><span class="line">	persistent: [kraken,luminous]</span><br><span class="line">	required: [kraken,luminous]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous新功能之crush class]]></title>
      <url>http://xiaqunfeng.cc/2017/07/04/ceph-Luminous-crush-class/</url>
      <content type="html"><![CDATA[<p>cursh class为新增的管理设备类的功能，可以将特定一组设备指定为类，创建rule的时候直接指定class即可，以前也可以实现该功能，只不过需要编辑crushmap，手动添加class。该功能只需要命令行就可以实现。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集群情况和上一篇文章一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</span><br><span class="line">    mgr: luminous0(active)</span><br><span class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</span><br><span class="line">    osd: 6 osds: 6 up, 6 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   7 pools, 112 pgs</span><br><span class="line">    objects: 240 objects, 3359 bytes</span><br><span class="line">    usage:   9245 MB used, 51587 MB / 60833 MB avail</span><br><span class="line">    pgs:     112 active+clean</span><br></pre></td></tr></table></figure>
<h2 id="关于之前的crush"><a href="#关于之前的crush" class="headerlink" title="关于之前的crush"></a>关于之前的crush</h2><h3 id="完全手动管理crush"><a href="#完全手动管理crush" class="headerlink" title="完全手动管理crush"></a>完全手动管理crush</h3><p>1、在 <code>ceph.conf</code> 配置中将挂钩关掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osd_crush_update_on_start = false</span><br></pre></td></tr></table></figure>
<p>2、部署OSD</p>
<p>3、手动创建所有的 CRUSH buckets</p>
<p>4、手动在每个 buckets 中放置 OSD</p>
<p>每当新加入、移除一个节点，或者将OSD从一个 host 移到另一个 host 时，也必须手动更改 CRUSH map。</p>
<h3 id="CEPH-CRUSH-LOCATION-挂钩"><a href="#CEPH-CRUSH-LOCATION-挂钩" class="headerlink" title="CEPH-CRUSH-LOCATION 挂钩"></a>CEPH-CRUSH-LOCATION 挂钩</h3><p>定义 osd_crush_location_hook，它可以让你定义一个路径去执行脚本，允许你自动处理以上过程。</p>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myhook --cluster &lt;cluster_name&gt; --id &lt;id&gt; --type osd</span><br></pre></td></tr></table></figure>
<p>集群名通常是 ceph ， id 是守护进程标识符（ OSD 号）。</p>
<h2 id="CRUSH-devices-class"><a href="#CRUSH-devices-class" class="headerlink" title="CRUSH devices class"></a>CRUSH devices class</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这么做的目的是为ceph不同类型的设备（HDD,SSD,NVMe）提供一个合理的默认，以便用户不必自己手动编辑指定。这相当于给磁盘组一个统一的class标签，根据class创建rule，然后根据role创建pool，整个操作不需要手动修改crushmap。</p>
<h3 id="创建两个-class"><a href="#创建两个-class" class="headerlink" title="创建两个 class"></a>创建两个 class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd crush class ls</span><br><span class="line">[]</span><br><span class="line"># ceph osd crush class create hdd</span><br><span class="line">created class hdd with id 0 to crush map</span><br><span class="line"># ceph osd crush class create ssd</span><br><span class="line">created class ssd with id 1 to crush map</span><br><span class="line"># ceph osd crush class ls</span><br><span class="line">[</span><br><span class="line">    &quot;hdd&quot;,</span><br><span class="line">    &quot;ssd&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>根据class，可以对osd进行以下两种操作：</p>
<p>1、部署OSD时指定 class，比如，指定部署磁盘所在的 OSD 到指定 class 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-disk prepare --crush-device-class &lt;class&gt; /dev/XXX</span><br></pre></td></tr></table></figure>
<p>2、将现有 osd 加入到指定 class 中，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd crush set-device-class osd.&lt;id&gt; &lt;class&gt;</span><br></pre></td></tr></table></figure>
<p><strong> 以下对第二种操作进行实验，也是使用最多的。</strong></p>
<h3 id="当前OSD-分布"><a href="#当前OSD-分布" class="headerlink" title="当前OSD 分布"></a>当前OSD 分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">ID WEIGHT  TYPE NAME          UP/DOWN REWEIGHT PRIMARY-AFFINITY</span><br><span class="line">-1 0.05814 root default</span><br><span class="line">-2 0.01938     host luminous0</span><br><span class="line"> 1 0.00969         osd.1           up  1.00000          1.00000</span><br><span class="line"> 5 0.00969         osd.5           up  1.00000          1.00000</span><br><span class="line">-3 0.01938     host luminous2</span><br><span class="line"> 0 0.00969         osd.0           up  1.00000          1.00000</span><br><span class="line"> 4 0.00969         osd.4           up  1.00000          1.00000</span><br><span class="line">-4 0.01938     host luminous1</span><br><span class="line"> 2 0.00969         osd.2           up  1.00000          1.00000</span><br><span class="line"> 3 0.00969         osd.3           up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h3 id="为class添加osd"><a href="#为class添加osd" class="headerlink" title="为class添加osd"></a>为class添加osd</h3><p>将0、1、2分到hdd class，3、4、5分到ssd class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># for i in 0 1 2; do ceph osd crush set-device-class osd.$i hdd; done</span><br><span class="line">set-device-class item id 3 name &apos;osd.0&apos; device_class hdd</span><br><span class="line">set-device-class item id 4 name &apos;osd.1&apos; device_class hdd</span><br><span class="line">set-device-class item id 5 name &apos;osd.2&apos; device_class hdd</span><br><span class="line"># for i in 3 4 5; do ceph osd crush set-device-class osd.$i ssd; done</span><br><span class="line">set-device-class item id 3 name &apos;osd.3&apos; device_class ssd</span><br><span class="line">set-device-class item id 4 name &apos;osd.4&apos; device_class ssd</span><br><span class="line">set-device-class item id 5 name &apos;osd.5&apos; device_class ssd</span><br></pre></td></tr></table></figure>
<h3 id="再查看osd分布"><a href="#再查看osd分布" class="headerlink" title="再查看osd分布"></a>再查看osd分布</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">ID  WEIGHT  TYPE NAME              UP/DOWN REWEIGHT PRIMARY-AFFINITY</span><br><span class="line">-12 0.02907 root default~ssd</span><br><span class="line"> -9 0.00969     host luminous0~ssd</span><br><span class="line">  5 0.00969         osd.5               up  1.00000          1.00000</span><br><span class="line">-10 0.00969     host luminous2~ssd</span><br><span class="line">  4 0.00969         osd.4               up  1.00000          1.00000</span><br><span class="line">-11 0.00969     host luminous1~ssd</span><br><span class="line">  3 0.00969         osd.3               up  1.00000          1.00000</span><br><span class="line"> -8 0.02907 root default~hdd</span><br><span class="line"> -5 0.00969     host luminous0~hdd</span><br><span class="line">  1 0.00969         osd.1               up  1.00000          1.00000</span><br><span class="line"> -6 0.00969     host luminous2~hdd</span><br><span class="line">  0 0.00969         osd.0               up  1.00000          1.00000</span><br><span class="line"> -7 0.00969     host luminous1~hdd</span><br><span class="line">  2 0.00969         osd.2               up  1.00000          1.00000</span><br><span class="line"> -1 0.05814 root default</span><br><span class="line"> -2 0.01938     host luminous0</span><br><span class="line">  1 0.00969         osd.1               up  1.00000          1.00000</span><br><span class="line">  5 0.00969         osd.5               up  1.00000          1.00000</span><br><span class="line"> -3 0.01938     host luminous2</span><br><span class="line">  0 0.00969         osd.0               up  1.00000          1.00000</span><br><span class="line">  4 0.00969         osd.4               up  1.00000          1.00000</span><br><span class="line"> -4 0.01938     host luminous1</span><br><span class="line">  2 0.00969         osd.2               up  1.00000          1.00000</span><br><span class="line">  3 0.00969         osd.3               up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h3 id="创建rule"><a href="#创建rule" class="headerlink" title="创建rule"></a>创建rule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd crush rule create-simple hdd-rule default~ssd host firstn</span><br><span class="line">Invalid command:  invalid chars ~ in default~ssd</span><br><span class="line">osd crush rule create-simple &lt;name&gt; &lt;root&gt; &lt;type&gt; &#123;firstn|indep&#125; :  create crush rule &lt;name&gt; to start from &lt;root&gt;, replicate across buckets of type &lt;type&gt;, using a choose mode of &lt;firstn|indep&gt; (default firstn; indep best for erasure pools)</span><br><span class="line">Error EINVAL: invalid command</span><br></pre></td></tr></table></figure>
<p>这里出现错误，我在想，是不是 class name 不用带上 <code>default~</code> 这个符号，于是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd crush rule create-simple hdd-rule ssd host firstn</span><br><span class="line">Error ENOENT: root item ssd does not exist</span><br></pre></td></tr></table></figure>
<p>依然出错，这是个<a href="http://tracker.ceph.com/issues/20446" target="_blank" rel="noopener">bug</a>，还在 <a href="https://github.com/ceph/ceph/pull/16027" target="_blank" rel="noopener">merge 中</a></p>
<blockquote>
<p>先跳过这个直接创建rule关联class的命令，后续BUG修复了再来实验</p>
</blockquote>
<h3 id="手动来创建rule"><a href="#手动来创建rule" class="headerlink" title="手动来创建rule"></a>手动来创建rule</h3><p>首先查看当前rule的状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd crush rule ls</span><br><span class="line">[</span><br><span class="line">    &quot;replicated_rule&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>只有一个默认的rule</p>
<p><strong> 第一步：获取crushmap </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd getcrushmap -o c1</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
<p><strong>第二步：反编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># crushtool -d c1 -o c2.txt</span><br></pre></td></tr></table></figure>
<p>编辑crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim c2.txt</span><br></pre></td></tr></table></figure>
<p>在 <code># rule</code> 那一栏 <code>replicated_rule</code> 的后面添加 <code>hdd_rule</code> 和 <code>ssd_rule</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># rules</span><br><span class="line">rule replicated_rule &#123;</span><br><span class="line">        ruleset 0</span><br><span class="line">        type replicated</span><br><span class="line">        min_size 1</span><br><span class="line">        max_size 10</span><br><span class="line">        step take default</span><br><span class="line">        step chooseleaf firstn 0 type host</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule hdd_rule &#123;</span><br><span class="line">        ruleset 1</span><br><span class="line">        type replicated</span><br><span class="line">        min_size 1</span><br><span class="line">        max_size 10</span><br><span class="line">        step take default class hdd</span><br><span class="line">        step chooseleaf firstn 0 type osd</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule ssd_rule &#123;</span><br><span class="line">        ruleset 2</span><br><span class="line">        type replicated</span><br><span class="line">        min_size 1</span><br><span class="line">        max_size 10</span><br><span class="line">        step take default class ssd</span><br><span class="line">        step chooseleaf firstn 0 type osd</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三步：编译crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># crushtool -c c2.txt -o c1.new</span><br></pre></td></tr></table></figure>
<p><strong>第四步：注入crushmap</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd setcrushmap -i c1.new</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>此时，查看rule</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd crush rule ls</span><br><span class="line">[</span><br><span class="line">    &quot;replicated_rule&quot;,</span><br><span class="line">    &quot;hdd_rule&quot;,</span><br><span class="line">    &quot;ssd_rule&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>有了新创建的两个rule</p>
<h2 id="测试一下，rule-绑定-class是否成功"><a href="#测试一下，rule-绑定-class是否成功" class="headerlink" title="测试一下，rule 绑定 class是否成功"></a>测试一下，rule 绑定 class是否成功</h2><p>1、在 ssd_rule 上创建一个 pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create testpool 64 64 ssd_rule</span><br><span class="line">pool &apos;testpool&apos; created</span><br></pre></td></tr></table></figure>
<p>2、写一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rados -p testpool put object1 c2.txt</span><br></pre></td></tr></table></figure>
<p>3、查看对象的osdmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd map testpool object1</span><br><span class="line">osdmap e46 pool &apos;testpool&apos; (7) object &apos;object1&apos; -&gt; pg 7.bac5debc (7.3c) -&gt; up ([5,3,4], p5) acting ([5,3,4], p5)</span><br></pre></td></tr></table></figure>
<p>发现对象确实只写在 ssd class 所对应的 3个OSD（osd.3 osd.4 osd.5）上，rule绑定成功。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph Luminous dashboard初探]]></title>
      <url>http://xiaqunfeng.cc/2017/06/29/ceph-Luminous/</url>
      <content type="html"><![CDATA[<p>体验ceph luminous，并初步探测ceph luminous的相关功能，这里先来看看官方标配的仪表盘长啥样。<br><a id="more"></a></p>
<p>就冲这句话：Ceph now has a simple, built-in web-based dashboard for monitoring<br>cluster status，来一探究竟。</p>
<h2 id="Luminous集群"><a href="#Luminous集群" class="headerlink" title="Luminous集群"></a>Luminous集群</h2><p><strong>物理环境</strong></p>
<p>3个 host ，每个 host 含有 2 个OSD</p>
<p><strong>查看ceph版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph -v</span><br><span class="line">ceph version 12.1.0 (262617c9f16c55e863693258061c5b25dea5b086) luminous (dev)</span><br></pre></td></tr></table></figure>
<h3 id="ceph-s"><a href="#ceph-s" class="headerlink" title="ceph -s"></a>ceph -s</h3><p>查看集群状态，这里发现 <code>ceph -s</code> 信息和之前的不一样。（更多新的命令后续探索后奉上）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">  cluster:</span><br><span class="line">    id:     4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum luminous0,luminous1,luminous2</span><br><span class="line">    mgr: luminous0(active)</span><br><span class="line">    mds: 1/1/1 up &#123;0=luminous0=up:active&#125;</span><br><span class="line">    osd: 6 osds: 6 up, 6 in</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   7 pools, 112 pgs</span><br><span class="line">    objects: 208 objects, 3359 bytes</span><br><span class="line">    usage:   6341 MB used, 54492 MB / 60833 MB avail</span><br><span class="line">    pgs:     112 active+clean</span><br></pre></td></tr></table></figure>
<p>这里我在机器 luminous0 上还部署了 mgr 和 mds。</p>
<blockquote>
<p>注意：mgr是高可用的，如果配置多个的话，会有standbys。我这里只配了一个 mgr，所以就只有active，没有standby。访问的时候，务必使用 active 进程所在节点的 IP ！！</p>
</blockquote>
<h2 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h2><h3 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h3><p>在所有运行了 ceph-mgr 守护进程的机器上编辑ceph配置文件 <code>/etc/ceph/ceph.conf</code> ，以启用 dashboard。</p>
<p>添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mgr]</span><br><span class="line">mgr_modules = dashboard</span><br></pre></td></tr></table></figure>
<p>注意：不要重启 ceph-mgr 进程，还有其他的配置要做。</p>
<h3 id="配置IP和端口"><a href="#配置IP和端口" class="headerlink" title="配置IP和端口"></a>配置IP和端口</h3><p>服务器地址和可选端口必须配置为 config-key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph config-key put mgr/dashboard/server_addr 172.20.2.243</span><br><span class="line">set mgr/dashboard/server_addr</span><br></pre></td></tr></table></figure>
<p>查看，发现<strong>默认端口是 7000</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netstat -antpl | grep ceph-mgr | grep LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:6800            0.0.0.0:*               LISTEN      57645/ceph-mgr</span><br><span class="line">tcp        0      0 172.20.2.243:7000       0.0.0.0:*               LISTEN      57645/ceph-mgr</span><br></pre></td></tr></table></figure>
<p>当然，可以改为指定端口号，使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph config-key put mgr/dashboard/server_port 8888</span><br></pre></td></tr></table></figure>
<h3 id="重启ceph-mgr"><a href="#重启ceph-mgr" class="headerlink" title="重启ceph-mgr"></a>重启ceph-mgr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart ceph-mgr@luminous0</span><br></pre></td></tr></table></figure>
<p>这时候就可以访问了。</p>
<h3 id="访问界面"><a href="#访问界面" class="headerlink" title="访问界面"></a>访问界面</h3><p><strong>1、主界面</strong>（Cluster health）</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-0.jpg" alt="dashboard"></p>
<p><strong>2、Servers界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-2.jpg" alt="servers"></p>
<p><strong>3、cephfs界面</strong></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/luminous-1.jpg" alt="ceph-fs"></p>
<h2 id="使用后感想"><a href="#使用后感想" class="headerlink" title="使用后感想"></a>使用后感想</h2><p>1、这仅仅只是一个展示的界面，不能进行相关操作</p>
<p>2、关于 MONITORS 和 OSDS 的信息不能详细展开，更不能看到每台机器的情况</p>
<p>3、比起ceph周边的监控软件：calamari、VSM、inkscope、grafana等，相去甚远，当然，可以简单展示基本信息，还是不错的。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph v12.1.0 Luminous RC released]]></title>
      <url>http://xiaqunfeng.cc/2017/06/28/Ceph-v12-1-0-Luminous-RC-released/</url>
      <content type="html"><![CDATA[<p>ceph L 版本终于出了一个候选release版本。来看看都有哪些新功能吧。<br><a id="more"></a></p>
<p>本文翻译自官网：<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/" target="_blank" rel="noopener">v12.1.0 Luminous RC released</a></p>
<p>Github：<a href="https://github.com/ceph/ceph/tree/luminous" target="_blank" rel="noopener">https://github.com/ceph/ceph/tree/luminous</a></p>
<h2 id="v12-1-0-Luminous-RC-released"><a href="#v12-1-0-Luminous-RC-released" class="headerlink" title="v12.1.0 Luminous RC released"></a>v12.1.0 Luminous RC released</h2><p>这是Luminous的第一个候选版本，下一个长期的稳定release。</p>
<p>Ceph Luminous将是下一个长期的稳定release系列的基础。 自Kraken（v11.2.z）和jewel（v10.2.z）以来，发生了重大的变化。</p>
<h2 id="Major-Changes-from-Kraken"><a href="#Major-Changes-from-Kraken" class="headerlink" title="Major Changes from Kraken"></a>Major Changes from Kraken</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>Ceph目前拥有一个简单的、内置的基于Web的仪表板，用于监控群集状态。</p>
<h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><p><strong>BlueStore</strong></p>
<ul>
<li>ceph-osd的新后端存储BlueStore已经稳定，并且是新建OSD的默认设置。 BlueStore通过直接管理物理磁盘（HDD或SSD）而不使用XFS之类的中间文件系统来管理存储在每个OSD上的数据，这提供了更好的性能和特性。</li>
<li>BlueStore对于通过ceph存储的数据支持完整数据和元数据校验。</li>
<li>BlueStore支持zlib、snappy或LZ4的在线压缩。（Ceph还支持zstd进行RGW压缩，但由于性能原因，不推荐BlueStore使用zstd）。<br>EC pools现在完全支持覆盖写，允许它们与RBD和CephFS一起使用。<a href="http://ceph.com/releases/rados/operations/erasure-code/#erasure-coding-with-overwrites" target="_blank" rel="noopener">Read more about EC overwrites**</a></li>
</ul>
<p><strong>ceph-mgr</strong></p>
<ul>
<li>ceph-mgr是一个新的进程，它是任何Ceph部署所必须的一部分。虽然当ceph-mgr停止时，可以继续下发IO，但是度量不会刷新，并且某些与度量相关的请求（如：ceph df）可能会阻塞。为了可靠性，我们建议部署ceph-mgr的多个实例。查看这里的注释<a href="http://ceph.com/releases/v12-1-0-luminous-rc-released/#id1" target="_blank" rel="noopener"><code>Upgrading</code>_</a> </li>
<li>ceph-mgr进程包括一个基于REST的管理API。 API仍然处于实验阶段，并有一定的限制，但未来将成为Ceph基于API管理的基础。</li>
</ul>
<p>集群的总体可扩展性有所提高。我们已经成功测试了多达10,000个OSD节点的集群。</p>
<ul>
<li>目前，每个OSD都具有与其相关联的设备类（例如，hdd或ssd），允许CRUSH规则将数据简单地映射到系统中的设备的子集。通常不需要手动编写CRUSH规则或手动编辑CRUSH。</li>
<li>现在可以优化CRUSH权重，以保持OSD之间数据的近乎完美的分布。</li>
<li>还有一个新的upmap异常处理机制，允许单个PG移动以实现完美的分布（这需要luminous的客户端）。</li>
<li>目前每个OSD可以根据后端设备是HDD还是SSD来调整其默认配置。一般不需要手动调整。</li>
<li>mclock QoS排队算法原型现在是可用的；</li>
<li>现在有一种 backoff 机制，可以防止OSD出现对当前不能处理IO的对象或PG的请求出现过载。</li>
<li>简化了OSD更换过程，并且更加鲁棒。</li>
<li>您可以使用 <code>ceph features</code> 来查询所有连接的守护进程和客户端的支持特性和版本。</li>
<li>您可以配置你想要最旧的Ceph客户端版本，并通过 <code>ceph osd set-require-min-compat-client</code> 命令连接到集群，Ceph将阻止您启用会破坏与这些客户端兼容性的特性。</li>
<li>一些 <code>sleep</code> 的设置，包括 <code>osd_recovery_sleep</code>，<code>osd_snap_trim_sleep</code> 和 <code>osd_scrub_sleep</code> 已经被重新实现，并且可以有效地工作。（这些在某些情况下用于解决问题，限制后台工作。）</li>
</ul>
<p><strong>RGW:</strong></p>
<ul>
<li>ElasticSearch支持的RGW元数据搜索现在通过RGW本身支持最终用户请求服务，并且还支持自定义元数据字段。查询语言是一组RESTful API，用户可以通过其元数据来搜索对象。还添加了允许自定义元数据字段控制的新API。</li>
<li>RGW支持动态存储桶索引分片（bucket index sharding）。随着桶中的对象数量的增加，RGW将自动重新构建桶索引。不需要用户干预或桶大小容量规划。</li>
<li>RGW引入了上传对象的服务器端加密，用于管理加密密钥的三个选项有：自动加密（仅推荐用于测试设置），客户提供的类似于Amazon SSE-C规范的密钥，以及通过使用外部密钥管理服务 （OpenstackBarbician）类似于Amazon SSE-KMS规范。</li>
<li>RGW具有初步的类似AWS的存储桶策略API支持。现在，策略是一种表达一系列新授权概念的方式。未来，这将成为附加身份验证功能的基础，例如STS和组策略等。</li>
<li>RGW通过使用rados命名空间合并了几个元数据索引池。</li>
</ul>
<p><strong>RBD:</strong></p>
<ul>
<li>RBD目前通过<code>rbd create</code>新的<code>--data-pool</code>选项，对EC pools有全面稳定的支持。</li>
<li>RBD镜像的rbd-mirror守护进程现在是高可用的。我们建议部署rbd-mirror的多个实例来实现可靠性。</li>
<li>在创建集群期间，不再自动创建默认的 <code>rbd</code> 存储池。另外，当没有指定池时，rbd CLI 使用的默认池的名称可以通过新的 <code>rbd default pool = &lt;pool name&gt;</code> 配置选项来覆盖。</li>
<li>通过新的 <code>rbd trash</code>  CLI命令初步支持延迟 image 删除。images，即使是由克隆主动使用的镜像，也可以移动到垃圾桶，并在以后删除。</li>
<li>新的管理池级别的命令 <code>rbd mirror pool promote</code> 和 <code>rbd mirror pool demote</code>可以批量提升/降级一个pool内所有的mirrored images。</li>
<li>mirroring 现在可以通过 <code>rbd mirroring replay delay = &lt;seconds&gt;</code> 配置选项支持可选择的配置复制延迟。</li>
<li>当对象map 特性启用时，可以提升丢弃处理功能。</li>
<li>rbd CLI <code>import</code> 和 <code>copy</code> 命令现在可以检测稀疏并保留稀疏区域。</li>
<li>snapshots现在将包含创建时间戳。</li>
</ul>
<p><strong>CephFS:</strong></p>
<ul>
<li>现在，多个活动的MDS守护进程是稳定的。活动的MDS服务器的数量可以基于活动的CephFS文件系统进行上下调整。</li>
<li>CephFS目录分片现在是稳定的，并且在新的文件系统上默认启用。要使其在现有的文件系统上启动，使用命令 <code>ceph fs set&lt;fs_name&gt; allow_dirfrags</code>。大的或非常繁忙的目录被分割并（可能）自动分布在多个MDS守护进程中。</li>
<li>在自动负载均衡不需要和无效的情况下，目录子树可以明确固定到特定的MDS守护进程。</li>
</ul>
<p><strong>Miscellaneous:</strong> </p>
<p>Debian Stretch现在正在构建版本包。我们现在构建的发行版包括： </p>
<ul>
<li>CentOS 7 (x86_64and aarch64)</li>
<li>Debian 8 Jessie(x86_64)</li>
<li>Debian 9 Stretch(x86_64)</li>
<li>Ubuntu 16.04 Xenial(x86_64 and aarch64)</li>
<li>Ubuntu 14.04Trusty (x86_64)</li>
</ul>
<p>注意 QA 仅限于 CentOS 和 Ubuntu (xenialand trusty).</p>
<p><strong>CLI 变化</strong></p>
<ul>
<li><code>ceph -s</code> 或者 <code>ceph status</code> 命令焕然一新。</li>
<li><code>ceph {osd，mds，mon} versions</code> 总结了运行中守护进程的版本。</li>
<li><code>ceph {osd，mds，mon} count-metadata &lt;property&gt;</code> 类似地列出通过 <code>ceph {osd，mds，mon} metadata</code> 命令可见的任何其他守护进程元数据。</li>
<li><code>ceph features</code> 总结了连接的客户端和守护进程的特性和版本。</li>
<li><code>ceph osd require-osd-release &lt;release&gt;</code> 替换旧的<code>require_RELEASE_osds</code> flags。</li>
<li><code>ceph osd pg-upmap</code>，<code>ceph osdrm-pg-upmap</code>，<code>ceph osd pg-upmap-items</code>，<code>ceph osdrm-pg-upmap-items</code>可以明确地管理upmap项目。</li>
<li><code>ceph osd getcrushmap</code>在stderr上返回一个crush map版本号，如果版本匹配，<code>ceph osd setcrushmap [version]</code> 将只会注入更新的crush map。这允许crush map进行离线更新，然后重新注入到群集中，而不用担心颠覆性的变化（例如，通过其他管理员新添加和修改osds）。</li>
<li><code>ceph osd create</code> 已被 <code>ceph osd new</code> 所替换。大多数用户应该使用像 <code>ceph-disk</code> 这样面向用户的工具来隐藏这个。</li>
<li><code>ceph osd destroy</code> 将标记一个OSD被损坏，并删除其cephx和lockbox keys。但其OSD id和CRUS map entry 将保留不动，允许使用最少数据重新平衡的替换设备重新使用该 ID。</li>
<li><code>ceph osd purge</code> 将从集群中删除OSD的所有痕迹，包括其cephx加密密钥，dm-crypt lockbox秘钥，OSD ID和crush map entry。</li>
<li><code>ceph osd ls-tree &lt;name&gt;</code> 将在给定的CRUSH名称（如主机或机架名称）下输出OSD id列表。这对于为整个子树应用更改信息非常有用。例如，<code>ceph osd down</code> ，<code>ceph osd ls-tree rack1</code>。</li>
<li><code>ceph osd {add，rm} - {noout，noin，nodown，noup}</code> 允许<code>noout</code>，<code>nodown</code>，<code>noin</code>和<code>noup</code> 标志应用于指定的的OSD。</li>
<li><code>ceph log last [n]</code> 将输出集群日志的最后n行。</li>
<li><code>ceph mgr dump</code> 将dump出MgrMap，包括当前活动的和任何 standbys 的 ceph-mgr守护进程。</li>
<li><code>ceph osd crush swap-bucket &lt;src&gt; &lt;dest&gt;</code>将交换层次结构中两个CRUSH buckets的内容，同时保留buckets的id。这允许替换整个设备子树（例如，用新imaged的BlueStore OSD替换整个主机的FileStore OSD），而不会中断跨越相邻设备的数据分布。</li>
<li><code>ceph osd set-require-min-compat-client &lt;release&gt;</code> 可以配置支持群集的最旧的客户端版本。其他更改，如CRUSH可调参数，如果违反此设置，将会失败并显示错误。如果当前连接到集群的客户端版本比指定版本还老旧，则更改此设置也将失败。</li>
<li><code>ceph config-key dump</code> dump出config-key entries及其内容。（已有的 <code>ceph config-key ls</code> 仅dump密钥名称，而不是值。）</li>
<li><code>ceph osd set-{full，nearfull，backfillfull}-ratio</code> 将集群范围的比例设置为各种全阈值（例如：当集群拒绝IO时，当集群警告接近满时，当OSD延迟PG重新平衡到本身时）。</li>
<li><code>ceph osd reweightn</code> 将在单个命令中指定多个OSD的 <code>reweight</code> 值。这相当于一系列 <code>ceph osd rewight</code> 命令。</li>
<li><code>ceph crush class {create,rm,ls}</code> 管理新的CRUSH设备类功能。 <code>ceph crush set-device-class &lt;osd&gt; &lt;class&gt;</code> 将为特定设备设置class。</li>
<li><code>ceph mon feature list</code> 将列出MonMap中记录的monitor功能。<code>ceph mon feature set</code> 将设置一个可选功能（这些功能尚未存在）。</li>
</ul>
<h2 id="Major-Changes-from-Jewel"><a href="#Major-Changes-from-Jewel" class="headerlink" title="Major Changes from Jewel"></a>Major Changes from Jewel</h2><p><strong>RADOS</strong></p>
<ul>
<li>我们现在默认使用AsyncMessenger（ms type = async），而不是传统的SimpleMessenger。 最明显的区别是，我们现在使用固定大小的线程池进行网络连接（而不是使用SimpleMessenger每个socket两个线程）。</li>
<li>现在几乎可以马上检测到一些OSD故障，而之前的心跳超时（默认为20秒）必须过期。 当host保持up状态，但ceph-osd进程不再运行的故障出现时，可以防止IO长时间阻塞。</li>
<li>编码OSDMaps的大小已经减少了。</li>
<li>当recovery或rebalancing进行时，OSD现在会静止scrubbing。</li>
</ul>
<p><strong>RGW</strong></p>
<ul>
<li>RGW现在支持 S3 多部分对象部分复制（multipart object copy-part）API。</li>
<li>现在离线resharding一个现有的bucket是可能的。离线resharding bucket当前需要所有到这个指定bucket的IO（特别是writes）是静止的。（为了自动在线resharding，看上面Luminous的新特性）</li>
<li>RGW现在支持对对象的数据压缩。</li>
<li>Civetweb版本已经更新到1.8。</li>
<li>支持Swift静态网站API（之前的版本就已经支持S3）</li>
<li>S3 bucket生命周期 API 已添加。注意当前只支持对象到期。</li>
<li>支持用户自定义搜索过滤器已添加到 LDAP 认证实现中。</li>
<li>对NFS版本3的支持已添加到RGW NFS网关</li>
<li>已经为librgw创建了一个Python绑定</li>
</ul>
<p><strong>RBD</strong></p>
<ul>
<li>rbd-mirror守护进程现在支持从主image到非主image复制动态image特征更新和image元数据密钥/值对。</li>
<li>Image快照的数量可以可选地限制在可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<p><strong>CephFS</strong></p>
<ul>
<li>libcephfs函数定义已更改，以启用适当的uid / gid控件。library版本已经增加，以反映界面的变化。</li>
<li>standby replay MDS守护程序现在在执行删除的工作负载上消耗更少的内存。</li>
<li>Scrub 现在修复回溯，通常使用 <code>damage ls</code> 发现错误。</li>
<li>新 <code>pg_files</code> 子命令<code>cephfs-data-scan</code>可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性警告 <code>failing to respond to cache pressure</code> 已被修复。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[wget批量下载http目录及文件]]></title>
      <url>http://xiaqunfeng.cc/2017/06/23/wget-download-http-dir/</url>
      <content type="html"><![CDATA[<p>有时候看到好的镜像，想保存下来，不可能一个个通过url手动来下载，这时候就需要批量下载了。<br><a id="more"></a></p>
<p>举个例子，我要下载的地址和内容如下：<br><img src="http://oow6unnib.bkt.clouddn.com/wget-http.jpg" alt="wget-http"></p>
<h2 id="得到页面的index-html"><a href="#得到页面的index-html" class="headerlink" title="得到页面的index.html"></a>得到页面的index.html</h2><p>我就在 <code>/root</code> 目录下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -m http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/</span><br></pre></td></tr></table></figure>
<p>得到<code>index.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># cat /root/mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/index.html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;h1&gt;Index of /ceph/rpm-jewel/el7/SRPMS/&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a href=&quot;../&quot;&gt;../&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;repodata/&quot;&gt;repodata/&lt;/a&gt;                                          11-Apr-2017 03:06       -</span><br><span class="line">&lt;a href=&quot;ceph-10.1.0-0.el7.src.rpm&quot;&gt;ceph-10.1.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</span><br><span class="line">&lt;a href=&quot;ceph-10.1.1-0.el7.src.rpm&quot;&gt;ceph-10.1.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</span><br><span class="line">&lt;a href=&quot;ceph-10.1.2-0.el7.src.rpm&quot;&gt;ceph-10.1.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.0-0.el7.src.rpm&quot;&gt;ceph-10.2.0-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.1-0.el7.src.rpm&quot;&gt;ceph-10.2.1-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      9M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.2-0.el7.src.rpm&quot;&gt;ceph-10.2.2-0.el7.src.rpm&lt;/a&gt;                          15-Jun-2016 08:47      8M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.3-0.el7.src.rpm&quot;&gt;ceph-10.2.3-0.el7.src.rpm&lt;/a&gt;                          17-Oct-2016 20:29      9M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.4-0.el7.src.rpm&quot;&gt;ceph-10.2.4-0.el7.src.rpm&lt;/a&gt;                          07-Dec-2016 05:39     10M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.5-0.el7.src.rpm&quot;&gt;ceph-10.2.5-0.el7.src.rpm&lt;/a&gt;                          05-Jan-2017 02:49     10M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.6-0.el7.src.rpm&quot;&gt;ceph-10.2.6-0.el7.src.rpm&lt;/a&gt;                          08-Mar-2017 21:55     11M</span><br><span class="line">&lt;a href=&quot;ceph-10.2.7-0.el7.src.rpm&quot;&gt;ceph-10.2.7-0.el7.src.rpm&lt;/a&gt;                          11-Apr-2017 02:53     11M</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.29-0.src.rpm&quot;&gt;ceph-deploy-1.5.29-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.30-0.src.rpm&quot;&gt;ceph-deploy-1.5.30-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.31-0.src.rpm&quot;&gt;ceph-deploy-1.5.31-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.32-0.src.rpm&quot;&gt;ceph-deploy-1.5.32-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.33-0.src.rpm&quot;&gt;ceph-deploy-1.5.33-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     91K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.34-0.src.rpm&quot;&gt;ceph-deploy-1.5.34-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     94K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.35-0.src.rpm&quot;&gt;ceph-deploy-1.5.35-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.36-0.src.rpm&quot;&gt;ceph-deploy-1.5.36-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</span><br><span class="line">&lt;a href=&quot;ceph-deploy-1.5.37-0.src.rpm&quot;&gt;ceph-deploy-1.5.37-0.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53     95K</span><br><span class="line">&lt;a href=&quot;ceph-release-1-1.el7.src.rpm&quot;&gt;ceph-release-1-1.el7.src.rpm&lt;/a&gt;                       11-Apr-2017 02:53    4186</span><br><span class="line">&lt;a href=&quot;radosgw-agent-1.2.5-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.5-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</span><br><span class="line">&lt;a href=&quot;radosgw-agent-1.2.6-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.6-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</span><br><span class="line">&lt;a href=&quot;radosgw-agent-1.2.7-0.el7.src.rpm&quot;&gt;radosgw-agent-1.2.7-0.el7.src.rpm&lt;/a&gt;                  11-Apr-2017 02:53     29K</span><br><span class="line">&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h2><p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -nc -B http://mirrors.163.com/ceph/rpm-jewel/el7/SRPMS/ -F -nH --cut-dirs=3 -i index.html</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-nc</td>
<td>下载时跳过已经存在的文件</td>
</tr>
<tr>
<td>-B</td>
<td>使用 -F -i 文件选项时，在相对链接前添加指定的 URL</td>
</tr>
<tr>
<td>-nH</td>
<td>不创建主机名目录</td>
</tr>
<tr>
<td>-i</td>
<td>下载从指定文件中找到的 URL</td>
</tr>
<tr>
<td>-v</td>
<td>显示信息</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
<tr>
<td>-l</td>
<td>最大递归深度(inf 或 0 表示无限)</td>
</tr>
<tr>
<td>-F</td>
<td>以 HTML 方式处理输入文件</td>
</tr>
<tr>
<td>–cut-dir=num</td>
<td>忽略远程目录中指定数目的目录层</td>
</tr>
<tr>
<td>-E</td>
<td>将所有 MIME 类型为 text/html 的文件都加上 .html 扩展文件名</td>
</tr>
</tbody>
</table>
<p>更多关于参数的问题详见：<a href="http://jiaxl.blog.51cto.com/3064605/1191196" target="_blank" rel="noopener">wget参数介绍</a></p>
<p>然后就开始下载，直至完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">FINISHED --2017-06-23 18:11:54--</span><br><span class="line">Total wall clock time: 7m 31s</span><br><span class="line">Downloaded: 24 files, 103M in 7m 29s (234 KB/s)</span><br></pre></td></tr></table></figure></p>
<p>下载完成后列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ll</span><br><span class="line">总用量 105264</span><br><span class="line">-rw-r--r--. 1 root root  8894228 6月  15 2016 ceph-10.1.0-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  8942739 6月  15 2016 ceph-10.1.1-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  8961123 6月  15 2016 ceph-10.1.2-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  8967492 6月  15 2016 ceph-10.2.0-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  8996472 6月  15 2016 ceph-10.2.1-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  8876099 6月  15 2016 ceph-10.2.2-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root  9044336 10月 17 2016 ceph-10.2.3-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root 10849625 12月  7 2016 ceph-10.2.4-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root 10795514 1月   5 02:49 ceph-10.2.5-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root 11215646 3月   8 21:55 ceph-10.2.6-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root 11245006 4月  11 02:53 ceph-10.2.7-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    92710 4月  11 02:53 ceph-deploy-1.5.29-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    92915 4月  11 02:53 ceph-deploy-1.5.30-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    92953 4月  11 02:53 ceph-deploy-1.5.31-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    93493 4月  11 02:53 ceph-deploy-1.5.32-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    93323 4月  11 02:53 ceph-deploy-1.5.33-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    96664 4月  11 02:53 ceph-deploy-1.5.34-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    97010 4月  11 02:53 ceph-deploy-1.5.35-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    96998 4月  11 02:53 ceph-deploy-1.5.36-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    97146 4月  11 02:53 ceph-deploy-1.5.37-0.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root     4186 4月  11 02:53 ceph-release-1-1.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root     3189 6月  23 18:01 index.html</span><br><span class="line">-rw-r--r--. 1 root root    30175 4月  11 02:53 radosgw-agent-1.2.5-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    29980 4月  11 02:53 radosgw-agent-1.2.6-0.el7.src.rpm</span><br><span class="line">-rw-r--r--. 1 root root    30044 4月  11 02:53 radosgw-agent-1.2.7-0.el7.src.rpm</span><br></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公有云和私有云的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/cloud-public-private/</url>
      <content type="html"><![CDATA[<p>介绍了一下公有云和私有云的区别，以及该如何选择。<br><a id="more"></a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/public-private-cloud.jpg" alt="public-private-cloud"></p>
<h2 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h2><p>这是一个可以存在于公司的托管数据中心的云主机解决方案，所有信息都在专用防火墙后面。一般来说，公司已经选择为其数据中心付出了相当大的代价，并仍然希望使用其已建立的基础设施。这是一个主要的优势，也是私有云与公共云的辩论在这个特定主题上如此激烈的一个重要原因。</p>
<p>然而，私有云的一个重大问题是维护、更新和整体管理数据中心所需的资源属于公司本身。这是在选择私有云时通常不能正确计算的费用。维护包括：一旦旧的服务器被不堪重负或过期，必须购买新的服务器，并通过公司本身来整合最新的技术。</p>
<p>当然，由于私有云的资源基本上与系统外的任何人都不共享，因此维护安全性要容易得多，这可能是选择公有云与私有云时的决定因素。</p>
<h2 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h2><p>公有云是在其网站上托管大量企业、个人和组织的公共云。公有云管理系统提供的最大优势是，企业或组织无需负责，由主办公司接管。你的所有数据都由提供商存储在他们的数据中心，并负责管理和更新。</p>
<p>这样做的优势是相当大的，因为这显著的降低了存储信息的成本。这对于没有广泛且已到位的基础设施的公司也是有利的。此外，降低了测试和推出新产品的交付时间。</p>
<p>然而，与私有云系统相比最大的缺点是缺乏安全性。这就是为什么许多企业正在讨论对公有、私有云计算的倾向，即使意味着更大的费用，也会倾向于安全。虽然公共云系统确实具有广泛的安全性，事实上，由于增加的公司数量是相当大的担忧，所以系统的任何攻击，违规或崩溃都会更大。</p>
<p>应该注意的是，每个公司的数据都是分开的，尽管过去几年的头条新闻中，公有云系统的安全漏洞也比较少见。这就是为什么在公有云 vs 私有云的辩论中，答案往往会归结为公司的需求和预算。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 7下操纵ceph进程]]></title>
      <url>http://xiaqunfeng.cc/2017/06/16/centos-7-handle-ceph-process/</url>
      <content type="html"><![CDATA[<p>分享一个以前的笔记。官网给的通过<code>/etc/init.d/ceph</code>stop、start等命令在centos7下不行，service命令也是不行的。现在都使用原生的 systemd 来管理ceph进程。<br><a id="more"></a></p>
<h2 id="操作集群"><a href="#操作集群" class="headerlink" title="操作集群"></a>操作集群</h2><p>在<a href="http://docs.ceph.org.cn/rados/operations/operating/" target="_blank" rel="noopener">官方文档</a>中给出了几种操作方法：</p>
<p><strong>1、用 UPSTART 控制 CEPH</strong></p>
<p>用 ceph-deploy 把 Ceph Cuttlefish 及更高版部署到 Ubuntu 之后，你可以用基于事件的 Upstart来启动、关闭 Ceph 节点上的守护进程。 Upstart 不要求你在配置文件里定义守护进程例程。</p>
<p><strong>2、通过 SYSVINIT 机制运行 CEPH</strong></p>
<p>在 CentOS 、 Redhat 、 Fedora 和 SLES 发行版上可以通过传统的 sysvinit 运行 Ceph ， Debian/Ubuntu 的较老的版本也可以用此方法。</p>
<p><strong>3、把 CEPH 当服务运行</strong></p>
<p>如果你是用 ceph-deploy 部署 Argonaut 或 Bobtail 的，那么 Ceph 可以作为服务运行（还可以用 sysvinit ）。</p>
<h2 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h2><p>但是，现在所有支持 systemd 的发行版（ CentOS 7 、 Fedora 、 Debian Jessie 8.x 、 SUSE ）都用原生的 systemd 文件来管理 ceph 守护进程，不再使用原来的 sysvinit 脚本了。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ceph.target       # start all daemons</span><br><span class="line">sudo systemctl status ceph-osd@12      # check status of osd.12</span><br></pre></td></tr></table></figure>
<p>罗列节点上 Ceph 的 systemd unit 用此命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status ceph\*.service ceph\*.target</span><br></pre></td></tr></table></figure>
<h3 id="启动所有守护进程"><a href="#启动所有守护进程" class="headerlink" title="启动所有守护进程"></a>启动所有守护进程</h3><p>要启动一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ceph.target</span><br></pre></td></tr></table></figure>
<h3 id="停止所有守护进程"><a href="#停止所有守护进程" class="headerlink" title="停止所有守护进程"></a>停止所有守护进程</h3><p>要停止一 Ceph 节点（任何类型）上的所有守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop ceph\*.service ceph\*.target</span><br></pre></td></tr></table></figure>
<h3 id="按类型启动所有守护进程"><a href="#按类型启动所有守护进程" class="headerlink" title="按类型启动所有守护进程"></a>按类型启动所有守护进程</h3><p>要启动一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ceph-osd.target</span><br><span class="line">sudo systemctl start ceph-mon.target</span><br><span class="line">sudo systemctl start ceph-mds.target</span><br></pre></td></tr></table></figure>
<h3 id="按类型停止所有守护进程"><a href="#按类型停止所有守护进程" class="headerlink" title="按类型停止所有守护进程"></a>按类型停止所有守护进程</h3><p>要停止一节点上的某一类守护进程，用下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop ceph-mon\*.service ceph-mon.target</span><br><span class="line">sudo systemctl stop ceph-osd\*.service ceph-osd.target</span><br><span class="line">sudo systemctl stop ceph-mds\*.service ceph-mds.target</span><br></pre></td></tr></table></figure>
<h3 id="启动单个进程"><a href="#启动单个进程" class="headerlink" title="启动单个进程"></a>启动单个进程</h3><p>要启动某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ceph-osd@&#123;id&#125;</span><br><span class="line">sudo systemctl start ceph-mon@&#123;hostname&#125;</span><br><span class="line">sudo systemctl start ceph-mds@&#123;hostname&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start ceph-osd@1</span><br><span class="line">sudo systemctl start ceph-mon@ceph-server</span><br><span class="line">sudo systemctl start ceph-mds@ceph-server</span><br></pre></td></tr></table></figure>
<h3 id="停止单个进程"><a href="#停止单个进程" class="headerlink" title="停止单个进程"></a>停止单个进程</h3><p>要停止某节点上的某个守护进程例程，用下列命令之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop ceph-osd@&#123;id&#125;</span><br><span class="line">sudo systemctl stop ceph-mon@&#123;hostname&#125;</span><br><span class="line">sudo systemctl stop ceph-mds@&#123;hostname&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop ceph-osd@1</span><br><span class="line">sudo systemctl stop ceph-mon@ceph-server</span><br><span class="line">sudo systemctl stop ceph-mds@ceph-server</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim移动光标]]></title>
      <url>http://xiaqunfeng.cc/2017/06/15/vim-move-cursor/</url>
      <content type="html"><![CDATA[<p>平常的基本编辑环境都是vim，因此总结了一些光标移动的命令，可以提高效率，使vim用起来不显得那么笨重。<br><a id="more"></a></p>
<h2 id="光标方向"><a href="#光标方向" class="headerlink" title="光标方向"></a>光标方向</h2><p>上下左右：<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code></p>
<p>支持数字前缀，比如<code>10j</code>可以向下移动10行</p>
<p><code>ctrl + o</code>返回上一个光标位置</p>
<p><code>ctrl + i</code>跳到下一个光标位置</p>
<h2 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h2><p><code>w</code>移动光标到下一个单词的词首</p>
<p><code>b</code>移动光标到上一个单词的词首</p>
<p><code>e</code>移动光标到光标所在单词的结尾</p>
<p><code>ge</code>移动光标到上一个单词的结尾</p>
<p>支持数字前缀，比如<code>4w</code>可以向后移动4个单词</p>
<p>以上单词的分割标准是：空格、特殊符号</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw: sudo apt-get -y install ceph</span><br></pre></td></tr></table></figure>
<p>这里 <code>:</code>  <code>-</code> 以及空格，都是分割符号</p>
<p><code>W</code>, <code>B</code>, <code>E</code> 功能同上，只不过它分隔单词的标准是空格，所以可以跳的更远，更方便，用的比较多。</p>
<h2 id="屏幕移动"><a href="#屏幕移动" class="headerlink" title="屏幕移动"></a>屏幕移动</h2><p><code>H</code>移动到屏幕的首行</p>
<p><code>L</code>到屏幕尾行</p>
<p><code>M</code>到屏幕中间</p>
<p><code>ctrl + f</code>向下翻页</p>
<p><code>ctrl + b</code>向上翻页</p>
<p><code>ctrl + e</code>逐行下滚</p>
<p><code>ctrl + y</code>逐行上滚</p>
<h2 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h2><p><code>^</code>到行首</p>
<p><code>$</code>到行尾</p>
<p><code>gg</code>移到文件首行</p>
<p><code>G</code>移到文件尾行</p>
<p><code>zt</code>置顶当前行</p>
<p><code>zz</code>将当前行移到屏幕中部</p>
<p><code>zb</code>将当前行移到底部</p>
<p>拷贝一行：<code>^y$</code>，也可以直接 <code>yy</code></p>
<p>拷贝整个文件：<code>ggyG</code></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Map RBD Devices on NBD]]></title>
      <url>http://xiaqunfeng.cc/2017/06/07/Map-RBD-Devices-on-NBD/</url>
      <content type="html"><![CDATA[<p>jewel及以后的版本支持rbd-nbd的特性，在需要map支持较多特性的rbd image时，可以使用此方法。<br><a id="more"></a></p>
<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><p>前一篇文章中说到在map特性比较丰富的rbd设备时，内核不支持，所以出现如如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># rbd nbd map rbd/image-1</span><br><span class="line">rbd: sysfs write failed</span><br><span class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</span><br></pre></td></tr></table></figure>
<p>所以行不通，于是寻求其他解决方案。</p>
<p>幸运的是，jewel及以后版本中，RBD支持将RBD image map为本地nbd设备，通过<code>rbd nbd map</code>命令即可映射为本地nbd设备。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>安装 rbd-nbd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rbd-nbd -y</span><br></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd nbd map rbd/image-1</span><br><span class="line">/dev/nbd0</span><br></pre></td></tr></table></figure>
<p>成功！</p>
<p>这时就可以格式化并挂载来使用该设备了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.xfs -f /dev/nbd0</span><br><span class="line"># mkdir /mnt/nbd0</span><br><span class="line"># mount -noatime /dev/nbd0 /mnt/nbd0</span><br><span class="line"># lsblk</span><br><span class="line">...</span><br><span class="line">nbd0    43:0    0    1G  0 disk /mnt/nbd0</span><br></pre></td></tr></table></figure>
<p>查看已映射的nbd设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd-nbd list-mapped</span><br><span class="line">/dev/nbd0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看已挂载的rbd设备的命令是：rbd showmapped</p>
</blockquote>
<p>那么，什么是nbd设备？</p>
<h2 id="NBD"><a href="#NBD" class="headerlink" title="NBD"></a>NBD</h2><p><strong>NBD</strong>(Network Block Device)让你可以将一个远程主机的磁盘空间，当作一个块设备来使用，就像一块硬盘一样。NBD是一个内核模块，大部分Linux发行版都包含它。</p>
<h3 id="和RBD比较"><a href="#和RBD比较" class="headerlink" title="和RBD比较"></a>和RBD比较</h3><p>ceph jewel版本中有一个特性，RBD的NBD驱动，它允许librbd对外提供一个内核级别的RBD。</p>
<p>与RBD内核驱动程序相比，NBD有许多优点：</p>
<ul>
<li>RBD-KO开发和特性的添加必须要经过稳定的内核</li>
<li>RBD-KO开发慢于librbd，如果要与librbd开发保持同步，需要时间和努力</li>
<li>NBD已经很好地集成到内核多年，是大多数现今的内核的一部分</li>
</ul>
<p>RBD-NBD依靠librbd的用户空间实现，该实现通过使用强大和完善的NBD（网络块设备）内核模块已经非常稳定。</p>
<p>参考：<a href="http://www.sebastien-han.fr/blog/2016/04/04/ceph-jewel-preview-map-rbd-devices-on-nbd/" target="_blank" rel="noopener">Ceph Jewel Preview: map RBD devices on NBD</a></p>
<h3 id="和NFS的区别"><a href="#和NFS的区别" class="headerlink" title="和NFS的区别"></a>和NFS的区别</h3><ul>
<li>NFS只是提供一个挂载点供客户端使用，客户端无法改变这个挂载点的分区格式</li>
<li>NBD提供的是一个块设备，客户端可以把这个块设备格式化成各种类型的分区，更便于用户的使用</li>
</ul>
<h2 id="RBD-NBD"><a href="#RBD-NBD" class="headerlink" title="RBD-NBD"></a>RBD-NBD</h2><p><strong>rbd-nbd</strong> 是个 RADOS 块设备（ rbd ）映像的客户端，与 rbd 内核模块类似。它可以把一个 rbd 映像映射为 nbd （ Network Block Device，网络块设备）设备，这样就可以当常规的本地块设备使用了。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rbd-nbd [-c conf] [–nbds_max limit] [–read-only] [–device nbd device] map image-spec | snap-spec</span><br><span class="line">rbd-nbd unmap nbd device</span><br><span class="line">rbd-nbd list-mapped</span><br></pre></td></tr></table></figure>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p>-c ceph.conf</p>
<p>指定 ceph.conf 配置文件，而不是用默认的 /etc/ceph/ceph.conf 来确定启动时需要的 monitor 地址。</p>
</li>
</ul>
<ul>
<li><p>–nbds_max <em>limit</em></p>
<p>载入 NBD 内核模块时覆盖其参数，用于限制 nbd 设备的数量。</p>
</li>
</ul>
<h3 id="映像名和快照名规则"><a href="#映像名和快照名规则" class="headerlink" title="映像名和快照名规则"></a>映像名和快照名规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image-spec is [pool-name]/image-name</span><br><span class="line">snap-spec is [pool-name]/image-name@snap-name</span><br></pre></td></tr></table></figure>
<h2 id="ceph-rbd"><a href="#ceph-rbd" class="headerlink" title="ceph rbd"></a>ceph rbd</h2><p>使用Ceph的块存储有两种路径：</p>
<p>一种是利用QEMU走librbd路径，另一种是使用kernel module，走kernel的路径，两种途径的接口实现不完全相同。就目前来说，前者是目前更稳定的途径，也是Ceph所有应用场景中最广泛使用的。</p>
<ul>
<li>librbd是用户态的，主要为虚拟机提供块存储设备，kvm对接的就是librbd</li>
<li>kernel rbd是内核态的，主要为Host提供块设备支持，内核直接与osd交互，性能优于用户态</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph rbd map failed]]></title>
      <url>http://xiaqunfeng.cc/2017/06/06/ceph-rbd-map-failed/</url>
      <content type="html"><![CDATA[<p>探索 kernel RBD map 失败的问题。<br><a id="more"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>搭完 rbd mirror后，想通过client往image里写一些数据，所以在client端map rbd设备，结果失败了。</p>
<blockquote>
<p>rbd mirror的image 需要两个属性：exclusive-lock, journaling</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="查看rbd-image-info"><a href="#查看rbd-image-info" class="headerlink" title="查看rbd image info"></a>查看rbd image info</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># rbd info rbd/image-1</span><br><span class="line">rbd image &apos;image-1&apos;:</span><br><span class="line">	size 1024 MB in 256 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.108b238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: exclusive-lock, journaling</span><br><span class="line">	flags:</span><br><span class="line">	journal: 108b238e1f29</span><br><span class="line">	mirroring state: enabled</span><br><span class="line">	mirroring global id: c603d9dc-6f8d-49e0-ab68-5944d348e527</span><br><span class="line">	mirroring primary: true</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rbd map rbd/image-1</span><br><span class="line">rbd: sysfs write failed</span><br><span class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</span><br><span class="line">rbd: map failed: (6) No such device or address</span><br></pre></td></tr></table></figure>
<p>然后dmesg看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># dmesg | tail</span><br><span class="line">[   64.808315] rbd: loaded (major 251)</span><br><span class="line">[   64.818369] libceph: mon2 172.20.2.160:6789 session established</span><br><span class="line">[   64.819187] libceph: client14167 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">[   64.836328] rbd: image image-1: image uses unsupported features: 0x40</span><br><span class="line">[  443.658569] libceph: mon1 172.20.2.161:6789 session established</span><br><span class="line">[  443.659143] libceph: client4313 fsid 4c7ec5af-cbd3-40fd-8c96-0615c77660d4</span><br><span class="line">[  443.683178] rbd: rbd0: capacity 10737418240 features 0x1</span><br><span class="line">[  978.502132] rbd: image image-1: image uses unsupported features: 0x40</span><br></pre></td></tr></table></figure>
<h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p><strong>image uses unsupported features: 0x40</strong></p>
<p>不支持特性 0x40 = 64，也就是不支持特性 <strong>journaling</strong></p>
<h2 id="关于内核支持的特性分析"><a href="#关于内核支持的特性分析" class="headerlink" title="关于内核支持的特性分析"></a>关于内核支持的特性分析</h2><p>查看内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -r</span><br><span class="line">3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>根据查阅资料和实践，发现：</p>
<ul>
<li>CentOS的3.10内核仅支持其中的layering 和 exclusive-lock，其他feature概不支持</li>
<li>内核4.6仍然只支持：layering、exclusive-lock和 striping 属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># rbd info rbd/test-map</span><br><span class="line">rbd image &apos;test-map&apos;:</span><br><span class="line">	size 512 MB in 128 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.10ca238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<p>map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd map rbd/test-map</span><br><span class="line">/dev/rbd1</span><br></pre></td></tr></table></figure>
<p>此时可以map成功。</p>
<h2 id="RBD特性解析"><a href="#RBD特性解析" class="headerlink" title="RBD特性解析"></a>RBD特性解析</h2><h3 id="特性一览表"><a href="#特性一览表" class="headerlink" title="特性一览表"></a>特性一览表</h3><p>RBD支持的特性，及具体BIT值的计算如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
<th>BIT码</th>
</tr>
</thead>
<tbody>
<tr>
<td>layering</td>
<td>支持分层</td>
<td>1</td>
</tr>
<tr>
<td>striping</td>
<td>支持条带化 v2</td>
<td>2</td>
</tr>
<tr>
<td>exclusive-lock</td>
<td>支持独占锁</td>
<td>4</td>
</tr>
<tr>
<td>object-map</td>
<td>支持对象映射（依赖 exclusive-lock ）</td>
<td>8</td>
</tr>
<tr>
<td>fast-diff</td>
<td>快速计算差异（依赖 object-map ）</td>
<td>16</td>
</tr>
<tr>
<td>deep-flatten</td>
<td>支持快照扁平化操作</td>
<td>32</td>
</tr>
<tr>
<td>journaling</td>
<td>支持记录 IO 操作（依赖独占锁）</td>
<td>64</td>
</tr>
</tbody>
</table>
<h3 id="ceph-kraken版本默认属性值"><a href="#ceph-kraken版本默认属性值" class="headerlink" title="ceph kraken版本默认属性值"></a>ceph kraken版本默认属性值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph --show-config|grep rbd|grep features</span><br><span class="line">rbd_default_features = 61</span><br></pre></td></tr></table></figure>
<p>为啥是61？我们创建一个默认配置的rbd看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># rbd create test-feature --size 64</span><br><span class="line"># rbd info rbd/test-feature</span><br><span class="line">rbd image &apos;test-feature&apos;:</span><br><span class="line">	size 65536 kB in 16 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.107d238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<p><strong>1+4+8+16+32 = 61</strong></p>
<p>就是说除了特性：striping 和 journaling 外都开启了。</p>
<h3 id="控制属性"><a href="#控制属性" class="headerlink" title="控制属性"></a>控制属性</h3><p>有三种方法来开启需要的特性</p>
<p>1、在创建image时，通过 <code>--image-feature</code> 来指定需要开启的特性</p>
<p>2、对已存在的image可以通过如下命令开启和关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rbd feature enable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</span><br><span class="line">rbd feature disable &lt;pool-name&gt;/&lt;image-name&gt; &lt;feature-name&gt;</span><br></pre></td></tr></table></figure>
<p>3、当然，每次通过enable和disable来不是很便捷，可以通过修改配置文件来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ceph/ceph.conf</span><br><span class="line">...</span><br><span class="line">rbd_default_features = 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>具体该设为多少可以通过上面BIT值查表计算得出。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph mon时钟偏移问题]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/ceph-mon-clock-deviation/</url>
      <content type="html"><![CDATA[<p>之前记录的关于时钟漂移的解决过程和心得，这里分享一下。<br><a id="more"></a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>查看集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            clock skew detected on mon.xs734</span><br><span class="line">            Monitor clock skew detected</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>根据提示，发现这是一个明显的时钟漂移的问题</p>
<h2 id="配置NTP"><a href="#配置NTP" class="headerlink" title="配置NTP"></a>配置NTP</h2><p>第一反应就是ntp同步，配置ntp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp ntpdate -y</span><br><span class="line">ntpdate pool.ntp.org</span><br><span class="line">systemctl restart ntpdate.service</span><br><span class="line">systemctl restart ntpd.service</span><br><span class="line">systemctl enable ntpdate.service</span><br><span class="line">systemctl enable ntpd.service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每台机器上重复如上过程</p>
</blockquote>
<p>此时，查看集群的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># for x in xs732 xs733 xs734; do ssh $x &apos;date&apos;; done</span><br><span class="line">Thu May 05 17:51:26 CST 2017</span><br><span class="line">Thu May 05 17:51:27 CST 2017</span><br><span class="line">Thu May 05 17:51:27 CST 2017</span><br></pre></td></tr></table></figure>
<p>说明时间基本已经同步了。<strong>一般情况下问题就已经解决了，但这里还有问题。</strong></p>
<h2 id="进一步跟踪集群状态"><a href="#进一步跟踪集群状态" class="headerlink" title="进一步跟踪集群状态"></a>进一步跟踪集群状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            clock skew detected on mon.xs734</span><br><span class="line">            Monitor clock skew detected</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这时候问题来了，发现集群还是处于 WARN 的状态，进一步看问题出在哪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph -w</span><br><span class="line">...</span><br><span class="line">2017-05-26 10:27:14.325856 mon.0 [WRN] mon.2 10.34.57.27:6789/0 clock skew 0.0556591s &gt; max 0.05s</span><br><span class="line">2017-05-26 10:27:44.292273 mon.0 [INF] HEALTH_WARN; clock skew detected on mon.xs733, mon.xs734; Monitor clock skew detected</span><br></pre></td></tr></table></figure>
<p><strong>问题所在：0.0556591s &gt; max 0.05s 漂移的时间略大于默认的0.05秒</strong></p>
<blockquote>
<p>很少出现这种大于0.05秒的情况</p>
</blockquote>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><p>在 <code>/etc/ceph/ceph.conf</code> 中添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mon]</span><br><span class="line">mon_clock_drift_allowed = 0.10</span><br><span class="line">mon clock drift warn backoff = 10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>亲测，参数名称要不要下划线都可以</p>
</blockquote>
<p>改完后将配置推到集群所有的机器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf config push xs732 xs733 xs734</span><br></pre></td></tr></table></figure>
<h3 id="关于这两个参数"><a href="#关于这两个参数" class="headerlink" title="关于这两个参数"></a>关于这两个参数</h3><p>mon clock drift allowed</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>监视器间允许的时钟漂移量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>.050</td>
</tr>
</tbody>
</table>
<p>mon clock drift warn backoff</p>
<table>
<thead>
<tr>
<th>描述:</th>
<th>时钟偏移警告的退避指数。</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型:</td>
<td>Float</td>
</tr>
<tr>
<td>默认值:</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>链接：<a href="http://docs.ceph.org.cn/rados/configuration/mon-config-ref/" target="_blank" rel="noopener">http://docs.ceph.org.cn/rados/configuration/mon-config-ref/</a></p>
<h3 id="查看此时运行的ceph配置"><a href="#查看此时运行的ceph配置" class="headerlink" title="查看此时运行的ceph配置"></a>查看此时运行的ceph配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</span><br><span class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.05&quot;,</span><br><span class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;5&quot;,</span><br><span class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</span><br></pre></td></tr></table></figure>
<p>发现还是默认的 0.05 和 5，说明更改的配置根本没生效。</p>
<h3 id="重启monitor"><a href="#重启monitor" class="headerlink" title="重启monitor"></a>重启monitor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ceph-mon@xs732.service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，每台机器上都重启一下</p>
</blockquote>
<p>然后再查看，发现生效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@xs732:~/my-custer# ceph daemon mon.xs732 config show | grep clock</span><br><span class="line">    &quot;mon_clock_drift_allowed&quot;: &quot;0.10&quot;,</span><br><span class="line">    &quot;mon_clock_drift_warn_backoff&quot;: &quot;10&quot;,</span><br><span class="line">    &quot;clock_offset&quot;: &quot;0&quot;,</span><br></pre></td></tr></table></figure>
<p>再次查看ceph集群状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster f01fb68c-58c6-4707-8adb-b7ac88172340</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e2: 3 mons at &#123;xs732=10.34.57.25:6789/0,xs733=10.34.57.26:6789/0,xs734=10.34.57.27:6789/0&#125;</span><br><span class="line">            election epoch 12, quorum 0,1,2 xs732,xs733,xs734</span><br><span class="line">        mgr active: xs733 standbys: xs734, xs732</span><br><span class="line">     osdmap e50: 9 osds: 9 up, 9 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v113: 256 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            46397 MB used, 4423 GB / 4469 GB avail</span><br><span class="line">                 256 active+clean</span><br></pre></td></tr></table></figure>
<p>OK，问题解决！</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPG key retrieval failure]]></title>
      <url>http://xiaqunfeng.cc/2017/05/26/GPG-key-retrieval-failure/</url>
      <content type="html"><![CDATA[<p>在centos 7.31611上遇到的问题，记录一下解决方法，并附下载链接。<br><a id="more"></a></p>
<h2 id="我的epel源"><a href="#我的epel源" class="headerlink" title="我的epel源"></a>我的epel源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/yum.repos.d</span><br><span class="line">[epel]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line"></span><br><span class="line">[epel-debuginfo]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br><span class="line"></span><br><span class="line">[epel-source]</span><br><span class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</span><br><span class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</span><br><span class="line">mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">gpgcheck=1</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>更新yum源的时候出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPG key retrieval failed: [Errno 14] curl#37 - &quot;Couldn&apos;t open file /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7&quot;</span><br></pre></td></tr></table></figure>
<p>查看一下，确实没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ceph0:~# ls /etc/pki/rpm-gpg/</span><br><span class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-ZABBIX</span><br></pre></td></tr></table></figure>
<h2 id="网上解决方案"><a href="#网上解决方案" class="headerlink" title="网上解决方案"></a>网上解决方案</h2><p>这是个bug，没啥好的办法</p>
<p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1237057" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=1237057</a></p>
<h2 id="原因-amp-解决尝试"><a href="#原因-amp-解决尝试" class="headerlink" title="原因&amp;解决尝试"></a>原因&amp;解决尝试</h2><p>看了下输出，就是缺少 <code>RPM-GPG-KEY-EPEL-7</code> 嘛，补上是不是就可以了呢？</p>
<p>带着这个疑问，实践一下：</p>
<p>1、在原先成功的机器上，查看是否有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph3 yum.repos.d]# ls /etc/pki/rpm-gpg/</span><br><span class="line">RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Debug-7  RPM-GPG-KEY-CentOS-SIG-Virtualization  RPM-GPG-KEY-CentOS-Testing-7  RPM-GPG-KEY-EPEL-7</span><br></pre></td></tr></table></figure>
<p>发现果然有</p>
<p>2、将 <code>RPM-GPG-KEY-EPEL-7</code> 拷贝到现在的机器上</p>
<p>3、这时再执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure>
<p>可以成功，问题解决！</p>
<p align="center"><strong>附上<code>RPM-GPG-KEY-EPEL-7</code>下载链接，给有需要的人</strong></p>

<p align="center"><a href="http://oow6unnib.bkt.clouddn.com/RPM-GPG-KEY-EPEL-7" target="_blank" rel="noopener">点此下载</a></p>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sudo rpm -Uvh https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</span><br><span class="line">Retrieving https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</span><br><span class="line">curl: (7) Failed connect to dl.fedoraproject.org:443; Connection refused</span><br><span class="line">error: skipping https://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm - transfer failed</span><br><span class="line">You have new mail in /var/spool/mail/root</span><br></pre></td></tr></table></figure>
<p>这个问题的原因是网站无法访问</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac上实现vim的markdown预览]]></title>
      <url>http://xiaqunfeng.cc/2017/05/25/mac-vim-markdown-preview/</url>
      <content type="html"><![CDATA[<p>有时候在vim下创建了一个markdown文件，比如 <code>README.md</code> ，因为不能实时预览，所以要离开vim，用编辑器去编辑，比较麻烦。所以这里配置使能在vim编辑器上预览markdown文件。<br><a id="more"></a></p>
<p>这里分享两个插件</p>
<h2 id="vim-instant-markdown"><a href="#vim-instant-markdown" class="headerlink" title="vim-instant-markdown"></a><strong>vim-instant-markdown</strong></h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>github：<a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="noopener">https://github.com/suan/vim-instant-markdown</a></p>
<p>下载zip文件，解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls vim-instant-markdown-master/</span><br><span class="line">CHANGELOG.md README.md    after</span><br></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>注意：需要依赖 node.js 和 npm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install npm</span><br><span class="line">sudo npm -g install instant-markdown-d</span><br></pre></td></tr></table></figure>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv ~/.vim/after/ftplugin/markdown/</span><br><span class="line">sudo cp after/ftplugin/markdown/instant-markdown.vim ~/.vim/after/ftplugin/markdown/</span><br></pre></td></tr></table></figure>
<p>注意：保证在 <code>~/.vimrc</code> 中 <code>filetype plugin on</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype plugin indent on     &quot; required!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般是on的，特别是之前配置过vim插件的时候，已经打开了。</p>
</blockquote>
<h2 id="markdown-preview-vim"><a href="#markdown-preview-vim" class="headerlink" title="markdown-preview.vim"></a><strong>markdown-preview.vim</strong></h2><p>Github：<a href="https://github.com/iamcco/markdown-preview.vim" target="_blank" rel="noopener">https://github.com/iamcco/markdown-preview.vim</a></p>
<p>相比较上面一种方法，这种比较轻量级，推荐此方法。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>第一步：在 <code>~/.vimrc</code> 中的插件部分添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;iamcco/markdown-preview.vim&apos;</span><br></pre></td></tr></table></figure>
<p>第二步：安装插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim		# 或者：sudo mvim</span><br><span class="line">:BundleInstall</span><br></pre></td></tr></table></figure>
<h3 id="设置chrome为预览浏览器"><a href="#设置chrome为预览浏览器" class="headerlink" title="设置chrome为预览浏览器"></a>设置chrome为预览浏览器</h3><p>在 <code>~/.vimrc</code> 的末尾添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:mkdp_path_to_chrome = &quot;open -a Google\\ Chrome&quot;</span><br></pre></td></tr></table></figure>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>在编辑markdown的vim界面上敲如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:MarkdownPreview</span><br></pre></td></tr></table></figure>
<p>这时候就会在浏览器中出现markdown的预览界面</p>
<h3 id="退出预览"><a href="#退出预览" class="headerlink" title="退出预览"></a>退出预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:MarkdownPreviewStop</span><br></pre></td></tr></table></figure>
<p>文件退出vim编辑的时候也会自动关闭和退出预览。</p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>如果不是用mac自带的bash，而是自己装的zsh，需要注意以下两点：</p>
<p>1、保证在安装 instant-markdown-d 的时候添加了选项 <code>npm -g install</code></p>
<p>2、在 <code>~/.vimrc</code> 的末尾添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set shell=bash\ -i</span><br></pre></td></tr></table></figure>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>第二种方法较第一种比较轻量级，而且不需要依赖node.js，不需要下载外部依赖，只需要支持python2/3就可以了，同时支持滚动。</p>
<p>这种配置在配合 mvim + hexo + markdown 的时候特别爽，可以实时显示，都省了先执行<code>hexo s</code>，然后登陆<code>localhost:4000</code> 去查看了。</p>
<p>本篇博客的实时预览截图如下：（可以看到，端口为9183）<br><img src="http://oow6unnib.bkt.clouddn.com/markdown-preview.png" alt="markdown-preview"></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph日志迁移]]></title>
      <url>http://xiaqunfeng.cc/2017/05/23/ceph-log-migration/</url>
      <content type="html"><![CDATA[<p>将ceph日志从默认的位置移动到SSD的一个分区，比较常用。<br><a id="more"></a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、停止osd</p>
<p>2、将该osd的日志下盘</p>
<p>3、移除原有日志</p>
<p>4、将osd的日志软链到SSD的分区</p>
<p>5、创建新的journal</p>
<p>6、启动osd</p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>系统：centos 7.3</p>
<p>以 osd 0 、/dev/sdb1 为例，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># stop osd</span><br><span class="line">systemctl stop ceph-osd@0</span><br><span class="line"></span><br><span class="line"># flush journal</span><br><span class="line">ceph-osd --flush-journal -i 0</span><br><span class="line"></span><br><span class="line"># remove old journal</span><br><span class="line">rm -rf /var/lib/ceph/osd/ceph-0/journal</span><br><span class="line"></span><br><span class="line"># create symlink to partition</span><br><span class="line">ln -s /dev/sdb1 /var/lib/ceph/osd/ceph-0/journal</span><br><span class="line"></span><br><span class="line"># create new journal</span><br><span class="line">ceph-osd --mkjournal -i 0</span><br><span class="line"></span><br><span class="line"># start osd</span><br><span class="line">systemctl start ceph-osd@0</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>确认日志和磁盘分区的权限，如果不是ceph，会出现访问失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R ceph:ceph /var/lib/ceph/osd/ceph-0/journal</span><br><span class="line">chown -R ceph:ceph /dev/sdb1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cpu拓扑及ceph使用时的优化]]></title>
      <url>http://xiaqunfeng.cc/2017/05/11/cpu-top/</url>
      <content type="html"><![CDATA[<p>先将在ceph层面的调优，再介绍cpu的拓扑结构。<br><a id="more"></a></p>
<h2 id="ceph优化之CPU"><a href="#ceph优化之CPU" class="headerlink" title="ceph优化之CPU"></a>ceph优化之CPU</h2><p>NUMA的思路就是讲内存和CPU分割成多个区域，每个区域叫node，然后将node高速互联。node内CPU与内存的访问速度快于访问其他node的内存，NUMA可能会在某些情况下影响ceph-osd。</p>
<p>ceph目前未对NUMA架构的内存做过多优化，在日常使用过程中，通常为 2~4 颗CPU，这时候选择SMP架构的内存在效率上会高一些，如果条件允许，可以通过进程绑定的方法，在保证CPU能尽可能访问自身内存的前提下，使用NUMA架构。</p>
<h3 id="解决方案一："><a href="#解决方案一：" class="headerlink" title="解决方案一："></a>解决方案一：</h3><p><strong>通过BIOS关闭NUMA。</strong></p>
<ul>
<li>在os层numa关闭时，打开bios层的numa会影响性能，QPS会下降15-30%。</li>
<li>在bios层面numa关闭时，无论os层面的numa是否打开，都不会影响性能。</li>
</ul>
<p>通过命令判断bios层是否开启numa：</p>
<p>1、开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># grep -i numa /var/log/dmesg</span><br><span class="line">[    0.000000] NUMA: Initialized distance table, cnt=2</span><br><span class="line">[    0.000000] NUMA: Node 0 [mem 0x00000000-0x7fffffff] + [mem 0x100000000-0x47fffffff] -&gt; [mem 0x00000000-0x47fffffff]</span><br><span class="line">[    0.000000] Enabling automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl</span><br><span class="line">[    0.593086] pci_bus 0000:00: on NUMA node 0</span><br><span class="line">[    0.598672] pci_bus 0000:80: on NUMA node 1</span><br></pre></td></tr></table></figure>
<p>2、未开启状态输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep -i numa /var/log/dmesg</span><br><span class="line">[    0.000000] No NUMA configuration found</span><br></pre></td></tr></table></figure>
<p>查看机器的NUMA拓扑结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># numastat</span><br><span class="line">                           node0           node1</span><br><span class="line">numa_hit             83549806562     18182486371</span><br><span class="line">numa_miss               54084897     15540366583</span><br><span class="line">numa_foreign         15540366583        54084897</span><br><span class="line">interleave_hit             14109           14168</span><br><span class="line">local_node           83549670098     18182734455</span><br><span class="line">other_node              54221361     15540118499</span><br></pre></td></tr></table></figure>
<p>当发现numa_miss数值比较高时，说明需要对分配策略进行调整。例如将指定进程关联绑定到指定的CPU上，从而提高内存命中率。</p>
<p>在运行程序的时候使用<code>numactl</code> <code>-m</code>和<code>-physcpubind</code>就能制定将这个程序运行在哪个cpu和哪个memory中。</p>
<p>numa的陷阱：当你的服务器还有内存的时候，发现它已经在开始使用swap了，甚至已经导致机器出现停滞的现象。这个就有可能是由于numa的限制，如果一个进程限制它只能使用自己的numa节点的内存，那么当自身numa node内存使用光之后，就不会去使用其他numa node的内存了，会开始使用swap，甚至更糟的情况，机器没有设置swap的时候，可能会直接死机。所以可以使用<code>numactl --interleave=all</code>来取消numa node的限制。</p>
<p>根据具体业务决定NUMA的使用：</p>
<ul>
<li>如果你的程序是会占用大规模内存的，你大多应该选择关闭numa node的限制（或从硬件关闭numa）。因为这个时候你的程序很有几率会碰到numa陷阱。</li>
<li>如果你的程序并不占用大内存，而是要求更快的程序运行时间。你大多应该选择限制只访问本numa node的方法来进行处理。</li>
</ul>
<h3 id="解决方案二："><a href="#解决方案二：" class="headerlink" title="解决方案二："></a>解决方案二：</h3><p>通过cgroup将ceph-osd进程与某一个 CPU core 以及同一个 node下的内存进行绑定。</p>
<p>绑定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /dys/fs/cgroup/cpuset/ceph</span><br><span class="line"># cup number : 0,1,2,3 = 0-3</span><br><span class="line">echo 0,4 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.cpus</span><br><span class="line"># NUMA node</span><br><span class="line">echo 0 &gt; /sys/fs/cgroup/cpuset/ceph/cpuset.mems</span><br><span class="line">osd-pid-list=$(ps aux | grep osd | grep -v grep | awk &apos;&#123;print $2&#125;&apos;)</span><br><span class="line">for osd-pid in $(osd-pid-list)</span><br><span class="line">do</span><br><span class="line">    echo $(osd-pid) &gt; /sys/fs/cgroup/cpuset/ceph/cgroup.procs</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>注意的问题：</p>
<p>· 防止进程跨CPU核心迁移，以更好的利用缓存；</p>
<p>· 防止进程跨物理CPU迁移，以更好的利用内存和缓存；</p>
<p>· Ceph进程和其他进程会互相抢占资源，使用Cgroups做好隔离措施；</p>
<p>· 为Ceph进程预留足够多的CPU和内存资源，防止影响性能或产生OOM。尤其是高性能环境中并不能完全满足Ceph进程的开销，在高性能场景（全SSD）下，每个OSD进程可能需要高达6GHz的CPU和4GB以上的内存。</p>
<h2 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h2><p>cpu相关的信息都在 <code>/proc/cpuinfo</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># lscpu</span><br><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                32</span><br><span class="line">On-line CPU(s) list:   0-31</span><br><span class="line">Thread(s) per core:    2</span><br><span class="line">Core(s) per socket:    8</span><br><span class="line">座：                 2</span><br><span class="line">NUMA 节点：         2</span><br><span class="line">厂商 ID：           GenuineIntel</span><br><span class="line">CPU 系列：          6</span><br><span class="line">型号：              63</span><br><span class="line">型号名称：        Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz</span><br><span class="line">步进：              2</span><br><span class="line">CPU MHz：             1200.585</span><br><span class="line">BogoMIPS：            4800.30</span><br><span class="line">虚拟化：           VT-x</span><br><span class="line">L1d 缓存：          32K</span><br><span class="line">L1i 缓存：          32K</span><br><span class="line">L2 缓存：           256K</span><br><span class="line">L3 缓存：           20480K</span><br><span class="line">NUMA 节点0 CPU：    0-7,16-23</span><br><span class="line">NUMA 节点1 CPU：    8-15,24-31</span><br></pre></td></tr></table></figure>
<p>两种不同的CPU硬件体系架构：</p>
<ul>
<li>NUMA（Non-Uniform Memory Access，非一致性内存访问）</li>
<li>SMP（Symmetric Multi-Processor，对称多处理器系统）</li>
</ul>
<p>SMP的主要特征是共享，所有的CPU共享使用全部资源，例如内存、总线和I/O，多个CPU对称工作，彼此之间没有主次之分，平等地访问共享的资源，这样势必引入资源的竞争问题，且如果内存访问达到瓶颈的时候，性能就不能随之增加。每个CPU通过总线访问内存，当CPU数量不断增加以后，总线的压力不断增加，导致CPU的处理能力大大降低。</p>
<p>NUMA技术将CPU划分成不同的组（Node)，每个Node由多个CPU组成，并且有独立的本地内存、I/O等资源。Node之间通过互联模块连接和沟通，因此除了本地内存外，每个CPU仍可以访问远端Node的内存，不过效率会比访问本地内存差一些，我们用Node之间的距离（Distance，抽象的概念）来定义各个Node之间互访资源的开销。</p>
<p>NUMA架构旨在超越SMP架构的可扩展性限制。 使用代表对称多处理的SMP，所有存储器访问都被发布到相同的共享存储器总线。 这对于相对较少数量的CPU来说可行，但是当您有数十个甚至数百个CPU竞争访问共享内存总线时，会出现共享总线的问题。 NUMA通过限制任何一个存储器总线上的CPU数量以及通过高速互连连接各个节点来减轻这些瓶颈。</p>
<p>在NUMA盒上，访问非本地内存的成本很高。 如果您运行的是不支持NUMA的软件，那么它不会小心节点正在托管刚刚分配的内存，并没有利用NUMA架构的优势。 根据实施情况和平台，这种处罚可以忽略不计，压倒一切。</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>如果你只知道CPU这么一个概念，那么是无法理解CPU的拓扑的。事实上，在NUMA架构下，CPU的概念从大到小依次是：Node、Socket、Core、Processor。</p>
<p>随着多核技术的发展，我们将多个CPU封装在一起，这个封装一般被称为Socket（插槽的意思，也有人称之为Packet），而Socket中的每个核心被称为Core。为了进一步提升CPU的处理能力，Intel又引入了HT（Hyper-Threading，超线程)的技术，一个Core打开HT之后，在OS看来就是两个核，当然这个核是逻辑上的概念，所以也被称为Logical Processor，本文简称为Processor。</p>
<p>综上所述，一个NUMA Node可以有一个或者多个Socket，一个多核Socket显然包含多个Core，一个Core如果打开HT则变成两个Logical Processor。Logical processor只是OS内部看到的，实际上两个Processor还是位于同一个Core上，所以频繁的调度仍可能导致资源竞争，影响性能。</p>
<p>NUMA相关的策略</p>
<p>1、每个进程（或线程）都会从父进程继承NUMA策略，并分配有一个优先node。如果NUMA策略允许的话，进程可以调用其他node上的资源。</p>
<p>2、NUMA的CPU分配策略有cpunodebind、physcpubind。cpunodebind规定进程运行在某几个node之上，而physcpubind可以更加精细地规定运行在哪些核上。</p>
<p>3、NUMA的内存分配策略有localalloc、preferred、membind、interleave。</p>
<p>localalloc规定进程从当前node上请求分配内存；</p>
<p>而preferred比较宽松地指定了一个推荐的node来获取内存，如果被推荐的node上没有足够内存，进程可以尝试别的node。</p>
<p>membind可以指定若干个node，进程只能从这些指定的node上请求分配内存。</p>
<p>interleave规定进程从指定的若干个node上以RR（Round Robin 轮询调度）算法交织地请求分配内存。</p>
<p>因为NUMA默认的内存分配策略是优先在进程所在CPU的本地内存中分配，会导致CPU节点之间内存分配不均衡，当某个CPU节点的内存不足时，会导致swap产生，而不是从远程节点分配内存。这就是所谓的swap insanity 现象。</p>
<h2 id="查看CPU拓扑"><a href="#查看CPU拓扑" class="headerlink" title="查看CPU拓扑"></a>查看CPU拓扑</h2><p><strong>Node -&gt; Socket -&gt; Core -&gt; Processor</strong></p>
<h3 id="查看Numa-Node"><a href="#查看Numa-Node" class="headerlink" title="查看Numa Node"></a>查看Numa Node</h3><p>安装numactl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install numactl -y</span><br></pre></td></tr></table></figure>
<p>numactl是设定进程NUMA策略的命令行工具，也可以用来查看当前的Nuwa node：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</span><br><span class="line">node 0 size: 16263 MB</span><br><span class="line">node 0 free: 168 MB</span><br><span class="line">node 1 cpus: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</span><br><span class="line">node 1 size: 16384 MB</span><br><span class="line">node 1 free: 263 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  21</span><br><span class="line">  1:  21  10</span><br></pre></td></tr></table></figure>
<h3 id="查看socket"><a href="#查看socket" class="headerlink" title="查看socket"></a>查看socket</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos;</span><br><span class="line"> 0</span><br><span class="line"> 1</span><br><span class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>查看每个socket对应几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;print $2&#125;&apos; | sort | uniq -c</span><br><span class="line">     16  0</span><br><span class="line">     16  1</span><br></pre></td></tr></table></figure>
<p>查看socket对应哪几个processor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># awk -F: &apos;&#123;</span><br><span class="line">&gt;     if ($1 ~ /processor/) &#123;</span><br><span class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</span><br><span class="line">&gt;         p_id=$2;</span><br><span class="line">&gt;     &#125; else if ($1 ~ /physical id/)&#123;</span><br><span class="line">&gt;         gsub(/ /,&quot;&quot;,$2);</span><br><span class="line">&gt;         s_id=$2;</span><br><span class="line">&gt;         arr[s_id]=arr[s_id] &quot; &quot; p_id</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; END&#123;</span><br><span class="line">&gt;     for (i in arr)</span><br><span class="line">&gt;         print arr[i];</span><br><span class="line">&gt; &#125;&apos; /proc/cpuinfo | cut -c2-</span><br><span class="line">0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</span><br><span class="line">8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</span><br></pre></td></tr></table></figure>
<h3 id="查看core"><a href="#查看core" class="headerlink" title="查看core"></a>查看core</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/cpuinfo | grep &apos;core&apos;  | sort -u</span><br><span class="line">core id		: 0</span><br><span class="line">core id		: 1</span><br><span class="line">core id		: 2</span><br><span class="line">core id		: 3</span><br><span class="line">core id		: 4</span><br><span class="line">core id		: 5</span><br><span class="line">core id		: 6</span><br><span class="line">core id		: 7</span><br><span class="line">cpu cores	: 8</span><br></pre></td></tr></table></figure>
<h3 id="查看processor"><a href="#查看processor" class="headerlink" title="查看processor"></a>查看processor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep &apos;processor&apos; /proc/cpuinfo | wc -l</span><br><span class="line">32</span><br></pre></td></tr></table></figure>
<p>每个socket中有几个processor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep &apos;siblings&apos; /proc/cpuinfo | sort -u</span><br><span class="line">siblings	: 16</span><br></pre></td></tr></table></figure>
<h2 id="所有CPU拓扑信息"><a href="#所有CPU拓扑信息" class="headerlink" title="所有CPU拓扑信息"></a>所有CPU拓扑信息</h2><p>shell脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"># cat cpu-topology.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"># Simple print cpu topology</span><br><span class="line"></span><br><span class="line">function get_nr_processor()</span><br><span class="line">&#123;</span><br><span class="line">    grep &apos;^processor&apos; /proc/cpuinfo | wc -l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_nr_socket()</span><br><span class="line">&#123;</span><br><span class="line">    grep &apos;physical id&apos; /proc/cpuinfo | awk -F: &apos;&#123;</span><br><span class="line">            print $2 | &quot;sort -un&quot;&#125;&apos; | wc -l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_nr_siblings()</span><br><span class="line">&#123;</span><br><span class="line">    grep &apos;siblings&apos; /proc/cpuinfo | awk -F: &apos;&#123;</span><br><span class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function get_nr_cores_of_socket()</span><br><span class="line">&#123;</span><br><span class="line">    grep &apos;cpu cores&apos; /proc/cpuinfo | awk -F: &apos;&#123;</span><br><span class="line">            print $2 | &quot;sort -un&quot;&#125;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &apos;===== CPU Topology Table =====&apos;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo &apos;+--------------+---------+-----------+&apos;</span><br><span class="line">echo &apos;| Processor ID | Core ID | Socket ID |&apos;</span><br><span class="line">echo &apos;+--------------+---------+-----------+&apos;</span><br><span class="line"></span><br><span class="line">while read line; do</span><br><span class="line">    if [ -z &quot;$line&quot; ]; then</span><br><span class="line">        printf &apos;| %-12s | %-7s | %-9s |\n&apos; $p_id $c_id $s_id</span><br><span class="line">        echo &apos;+--------------+---------+-----------+&apos;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if echo &quot;$line&quot; | grep -q &quot;^processor&quot;; then</span><br><span class="line">        p_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if echo &quot;$line&quot; | grep -q &quot;^core id&quot;; then</span><br><span class="line">        c_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if echo &quot;$line&quot; | grep -q &quot;^physical id&quot;; then</span><br><span class="line">        s_id=`echo &quot;$line&quot; | awk -F: &apos;&#123;print $2&#125;&apos; | tr -d &apos; &apos;` </span><br><span class="line">    fi</span><br><span class="line">done &lt; /proc/cpuinfo</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">awk -F: &apos;&#123; </span><br><span class="line">    if ($1 ~ /processor/) &#123;</span><br><span class="line">        gsub(/ /,&quot;&quot;,$2);</span><br><span class="line">        p_id=$2;</span><br><span class="line">    &#125; else if ($1 ~ /physical id/)&#123;</span><br><span class="line">        gsub(/ /,&quot;&quot;,$2);</span><br><span class="line">        s_id=$2;</span><br><span class="line">        arr[s_id]=arr[s_id] &quot; &quot; p_id</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    for (i in arr) </span><br><span class="line">        printf &quot;Socket %s:%s\n&quot;, i, arr[i];</span><br><span class="line">&#125;&apos; /proc/cpuinfo</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &apos;===== CPU Info Summary =====&apos;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">nr_processor=`get_nr_processor`</span><br><span class="line">echo &quot;Logical processors: $nr_processor&quot;</span><br><span class="line"></span><br><span class="line">nr_socket=`get_nr_socket`</span><br><span class="line">echo &quot;Physical socket: $nr_socket&quot;</span><br><span class="line"></span><br><span class="line">nr_siblings=`get_nr_siblings`</span><br><span class="line">echo &quot;Siblings in one socket: $nr_siblings&quot;</span><br><span class="line"></span><br><span class="line">nr_cores=`get_nr_cores_of_socket`</span><br><span class="line">echo &quot;Cores in one socket: $nr_cores&quot;</span><br><span class="line"></span><br><span class="line">let nr_cores*=nr_socket</span><br><span class="line">echo &quot;Cores in total: $nr_cores&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$nr_cores&quot; = &quot;$nr_processor&quot; ]; then</span><br><span class="line">    echo &quot;Hyper-Threading: off&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Hyper-Threading: on&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &apos;===== END =====&apos;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># sh cpu-topology.sh</span><br><span class="line">===== CPU Topology Table =====</span><br><span class="line"></span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| Processor ID | Core ID | Socket ID |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 0            | 0       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 1            | 1       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 2            | 2       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 3            | 3       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 4            | 4       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 5            | 5       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 6            | 6       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 7            | 7       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 8            | 0       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 9            | 1       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 10           | 2       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 11           | 3       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 12           | 4       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 13           | 5       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 14           | 6       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 15           | 7       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 16           | 0       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 17           | 1       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 18           | 2       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 19           | 3       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 20           | 4       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 21           | 5       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 22           | 6       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 23           | 7       | 0         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 24           | 0       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 25           | 1       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 26           | 2       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 27           | 3       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 28           | 4       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 29           | 5       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 30           | 6       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line">| 31           | 7       | 1         |</span><br><span class="line">+--------------+---------+-----------+</span><br><span class="line"></span><br><span class="line">Socket 0: 0 1 2 3 4 5 6 7 16 17 18 19 20 21 22 23</span><br><span class="line">Socket 1: 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31</span><br><span class="line"></span><br><span class="line">===== CPU Info Summary =====</span><br><span class="line"></span><br><span class="line">Logical processors: 32</span><br><span class="line">Physical socket: 2</span><br><span class="line">Siblings in one socket:  16</span><br><span class="line">Cores in one socket:  8</span><br><span class="line">Cores in total: 16</span><br><span class="line">Hyper-Threading: on</span><br><span class="line"></span><br><span class="line">===== END =====</span><br></pre></td></tr></table></figure>
<h2 id="工具hwloc"><a href="#工具hwloc" class="headerlink" title="工具hwloc"></a>工具hwloc</h2><p>hwloc可以显示CPU拓扑，比较方面地查看CPU各级缓存以及各个核、物理CPU之间，可以共享哪一级别的CPU cache。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"># hwloc-ls</span><br><span class="line">Machine (94GB total)</span><br><span class="line">  NUMANode L#0 (P#0 47GB)</span><br><span class="line">    Package L#0 + L3 L#0 (20MB)</span><br><span class="line">      L2 L#0 (256KB) + L1d L#0 (32KB) + L1i L#0 (32KB) + Core L#0</span><br><span class="line">        PU L#0 (P#0)</span><br><span class="line">        PU L#1 (P#16)</span><br><span class="line">      L2 L#1 (256KB) + L1d L#1 (32KB) + L1i L#1 (32KB) + Core L#1</span><br><span class="line">        PU L#2 (P#1)</span><br><span class="line">        PU L#3 (P#17)</span><br><span class="line">      L2 L#2 (256KB) + L1d L#2 (32KB) + L1i L#2 (32KB) + Core L#2</span><br><span class="line">        PU L#4 (P#2)</span><br><span class="line">        PU L#5 (P#18)</span><br><span class="line">      L2 L#3 (256KB) + L1d L#3 (32KB) + L1i L#3 (32KB) + Core L#3</span><br><span class="line">        PU L#6 (P#3)</span><br><span class="line">        PU L#7 (P#19)</span><br><span class="line">      L2 L#4 (256KB) + L1d L#4 (32KB) + L1i L#4 (32KB) + Core L#4</span><br><span class="line">        PU L#8 (P#4)</span><br><span class="line">        PU L#9 (P#20)</span><br><span class="line">      L2 L#5 (256KB) + L1d L#5 (32KB) + L1i L#5 (32KB) + Core L#5</span><br><span class="line">        PU L#10 (P#5)</span><br><span class="line">        PU L#11 (P#21)</span><br><span class="line">      L2 L#6 (256KB) + L1d L#6 (32KB) + L1i L#6 (32KB) + Core L#6</span><br><span class="line">        PU L#12 (P#6)</span><br><span class="line">        PU L#13 (P#22)</span><br><span class="line">      L2 L#7 (256KB) + L1d L#7 (32KB) + L1i L#7 (32KB) + Core L#7</span><br><span class="line">        PU L#14 (P#7)</span><br><span class="line">        PU L#15 (P#23)</span><br><span class="line">    HostBridge L#0</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L#0 &quot;enp1s0f0&quot;</span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L#1 &quot;enp1s0f1&quot;</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L#2 &quot;enp4s0f0&quot;</span><br><span class="line">        PCI 8086:1521</span><br><span class="line">          Net L#3 &quot;enp4s0f1&quot;</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 1000:0097</span><br><span class="line">          Block(Disk) L#4 &quot;sda&quot;</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L#5 &quot;enp8s0f0&quot;</span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L#6 &quot;enp8s0f1&quot;</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCIBridge</span><br><span class="line">          PCI 1a03:2000</span><br><span class="line">            GPU L#7 &quot;card0&quot;</span><br><span class="line">            GPU L#8 &quot;controlD64&quot;</span><br><span class="line">  NUMANode L#1 (P#1 47GB)</span><br><span class="line">    Package L#1 + L3 L#1 (20MB)</span><br><span class="line">      L2 L#8 (256KB) + L1d L#8 (32KB) + L1i L#8 (32KB) + Core L#8</span><br><span class="line">        PU L#16 (P#8)</span><br><span class="line">        PU L#17 (P#24)</span><br><span class="line">      L2 L#9 (256KB) + L1d L#9 (32KB) + L1i L#9 (32KB) + Core L#9</span><br><span class="line">        PU L#18 (P#9)</span><br><span class="line">        PU L#19 (P#25)</span><br><span class="line">      L2 L#10 (256KB) + L1d L#10 (32KB) + L1i L#10 (32KB) + Core L#10</span><br><span class="line">        PU L#20 (P#10)</span><br><span class="line">        PU L#21 (P#26)</span><br><span class="line">      L2 L#11 (256KB) + L1d L#11 (32KB) + L1i L#11 (32KB) + Core L#11</span><br><span class="line">        PU L#22 (P#11)</span><br><span class="line">        PU L#23 (P#27)</span><br><span class="line">      L2 L#12 (256KB) + L1d L#12 (32KB) + L1i L#12 (32KB) + Core L#12</span><br><span class="line">        PU L#24 (P#12)</span><br><span class="line">        PU L#25 (P#28)</span><br><span class="line">      L2 L#13 (256KB) + L1d L#13 (32KB) + L1i L#13 (32KB) + Core L#13</span><br><span class="line">        PU L#26 (P#13)</span><br><span class="line">        PU L#27 (P#29)</span><br><span class="line">      L2 L#14 (256KB) + L1d L#14 (32KB) + L1i L#14 (32KB) + Core L#14</span><br><span class="line">        PU L#28 (P#14)</span><br><span class="line">        PU L#29 (P#30)</span><br><span class="line">      L2 L#15 (256KB) + L1d L#15 (32KB) + L1i L#15 (32KB) + Core L#15</span><br><span class="line">        PU L#30 (P#15)</span><br><span class="line">        PU L#31 (P#31)</span><br><span class="line">    HostBridge L#7</span><br><span class="line">      PCIBridge</span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L#9 &quot;enp132s0f0&quot;</span><br><span class="line">        PCI 8086:10fb</span><br><span class="line">          Net L#10 &quot;enp132s0f1&quot;</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br><span class="line">  Misc(MemoryModule)</span><br></pre></td></tr></table></figure>
<p>如果是桌面环境，则会弹窗一个窗口：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/hwloc.png" alt="hwloc"></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
            <tag> os </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[firewalld和iptables]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/firewalld%E5%92%8Ciptables/</url>
      <content type="html"><![CDATA[<p>centos7上关于打开和关闭防火墙及端口略有区别，记录之~<br><a id="more"></a><br>Centos升级到7之后，使用firewalld代替了原来的iptables，控制Linuxs的端口。firewalld是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。</p>
<h2 id="防火墙的设置"><a href="#防火墙的设置" class="headerlink" title="防火墙的设置"></a>防火墙的设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld 		# 停止firewall</span><br><span class="line">systemctl disable firewalld 	# 禁止firewall开机启动</span><br><span class="line">systemctl start firewalld 		# 开启防火墙</span><br></pre></td></tr></table></figure>
<h2 id="端口操作"><a href="#端口操作" class="headerlink" title="端口操作"></a>端口操作</h2><p>查看已开放的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --list-ports</span><br><span class="line">6789/tcp 6800-7100/tcp</span><br></pre></td></tr></table></figure>
<p>开启端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>命令含义：<br>–zone #作用域<br>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent   #永久生效，没有此参数重启后失效</p>
<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>查询9200端口是否打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=9200/tcp</span><br></pre></td></tr></table></figure>
<h2 id="使用iptables"><a href="#使用iptables" class="headerlink" title="使用iptables"></a>使用iptables</h2><p>如果你要改用iptables的话，需要安装iptables服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install iptables-services</span><br><span class="line">sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables</span><br><span class="line">sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[S.M.A.R.T--磁盘健康状态监测工具]]></title>
      <url>http://xiaqunfeng.cc/2017/05/07/S-M-A-R-T-device-healthy-monitor/</url>
      <content type="html"><![CDATA[<p>介绍磁盘状态监测工具：S.M.A.R.T。<br><a id="more"></a></p>
<h2 id="S-M-A-R-T"><a href="#S-M-A-R-T" class="headerlink" title="S.M.A.R.T."></a>S.M.A.R.T.</h2><p><strong>S.M.A.R.T.</strong>，全称为“Self-Monitoring Analysis and Reporting Technology”，即“自我监测、分析及报告技术”，是一种自动的硬盘状态检测与预警系统和规范。通过在硬盘硬件内的检测指令对硬盘的硬件如磁头、盘片、马达、电路的运行情况进行监控、记录并与厂商所设定的预设安全值进行比较，若监控情况将或已超出预设安全值的安全范围，就可以通过主机的监控硬件或软件自动向用户作出警告并进行轻微的自动修复，以提前保障硬盘数据的安全。</p>
<p>软件包 <strong>smartmontools</strong> 它通过使用自我监控(Self-Monitoring)、分析(Analysis)和报告(Reporting)三种技术（缩写为S.M.A.R.T或SMART）来管理和监控存储硬件。如今大部分的ATA/SATA、SCSI/SAS和固态硬盘都搭载内置的SMART系统。SMART的目的是监控硬盘的可靠性、预测磁盘故障和执行各种类型的磁盘自检。smartmontools由smartctl和smartd两部分工具程序组成，它们一起为Linux平台提供对磁盘退化和故障的高级警告。</p>
<blockquote>
<p>文章内容大部分为转载，硬盘信息和配置部分为自己实验所得。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install smartmontools</span><br></pre></td></tr></table></figure>
<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">smartctl -a  &lt;device&gt;    		显示硬盘所有SMART信息。</span><br><span class="line">smartctl -i &lt;device&gt;   			显示硬盘model number, serial number,是否开启SMART等信息。</span><br><span class="line">smartctl -s on &lt;device&gt;    		如果没有打开SMART技术，使用该命令打开SMART技术。</span><br><span class="line">smartctl -t short &lt;device&gt;    	后台检测硬盘，消耗时间短</span><br><span class="line">smartctl -t long &lt;device&gt;      	后台检测硬盘，消耗时间长</span><br><span class="line">smartctl -C -t short &lt;device&gt; 	前台检测硬盘，消耗时间短</span><br><span class="line">smartctl -C -t long &lt;device&gt;  	前台检测硬盘，消耗时间长</span><br><span class="line">smartctl -X &lt;device&gt;  			中断后台检测硬盘。</span><br><span class="line">smartctl -l selftest &lt;device&gt;  	显示硬盘检测日志。</span><br><span class="line">smartctl -l error &lt;device&gt; 		显示硬盘错误汇总。</span><br></pre></td></tr></table></figure>
<p>列出和系统相连的硬盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev | grep -E &apos;sd|hd&apos;</span><br></pre></td></tr></table></figure>
<h2 id="显示出某个指定硬盘的信息"><a href="#显示出某个指定硬盘的信息" class="headerlink" title="显示出某个指定硬盘的信息"></a>显示出某个指定硬盘的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># smartctl --info /dev/sdc</span><br><span class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</span><br><span class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">=== START OF INFORMATION SECTION ===</span><br><span class="line">Device Model:     TOSHIBA MG03ACA400</span><br><span class="line">Serial Number:    565BK4CXF</span><br><span class="line">LU WWN Device Id: 5 000039 70bc0043a</span><br><span class="line">Firmware Version: FL1A</span><br><span class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</span><br><span class="line">Sector Size:      512 bytes logical/physical</span><br><span class="line">Rotation Rate:    7200 rpm</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</span><br><span class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</span><br><span class="line">Local Time is:    Sun May  7 15:10:58 2017 CST</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled</span><br></pre></td></tr></table></figure>
<h2 id="检测某个硬盘的健康状况"><a href="#检测某个硬盘的健康状况" class="headerlink" title="检测某个硬盘的健康状况"></a>检测某个硬盘的健康状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"># smartctl -s on -a /dev/sdc</span><br><span class="line">smartctl 6.2 2013-07-26 r3841 [x86_64-linux-4.9.23-26.el7.x86_64] (local build)</span><br><span class="line">Copyright (C) 2002-13, Bruce Allen, Christian Franke, www.smartmontools.org</span><br><span class="line"></span><br><span class="line">=== START OF INFORMATION SECTION ===</span><br><span class="line">Device Model:     TOSHIBA MG03ACA400</span><br><span class="line">Serial Number:    565BK4CXF</span><br><span class="line">LU WWN Device Id: 5 000039 70bc0043a</span><br><span class="line">Firmware Version: FL1A</span><br><span class="line">User Capacity:    4,000,787,030,016 bytes [4.00 TB]</span><br><span class="line">Sector Size:      512 bytes logical/physical</span><br><span class="line">Rotation Rate:    7200 rpm</span><br><span class="line">Device is:        Not in smartctl database [for details use: -P showall]</span><br><span class="line">ATA Version is:   ATA8-ACS (minor revision not indicated)</span><br><span class="line">SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)</span><br><span class="line">Local Time is:    Sun May  7 15:12:44 2017 CST</span><br><span class="line">SMART support is: Available - device has SMART capability.</span><br><span class="line">SMART support is: Enabled</span><br><span class="line"></span><br><span class="line">=== START OF ENABLE/DISABLE COMMANDS SECTION ===</span><br><span class="line">SMART Enabled.</span><br><span class="line"></span><br><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br><span class="line"></span><br><span class="line">General SMART Values:</span><br><span class="line">Offline data collection status:  (0x82)	Offline data collection activity</span><br><span class="line">					was completed without error.</span><br><span class="line">					Auto Offline Data Collection: Enabled.</span><br><span class="line">Self-test execution status:      (   0)	The previous self-test routine completed</span><br><span class="line">					without error or no self-test has ever</span><br><span class="line">					been run.</span><br><span class="line">Total time to complete Offline</span><br><span class="line">data collection: 		(  120) seconds.</span><br><span class="line">Offline data collection</span><br><span class="line">capabilities: 			 (0x5b) SMART execute Offline immediate.</span><br><span class="line">					Auto Offline data collection on/off support.</span><br><span class="line">					Suspend Offline collection upon new</span><br><span class="line">					command.</span><br><span class="line">					Offline surface scan supported.</span><br><span class="line">					Self-test supported.</span><br><span class="line">					No Conveyance Self-test supported.</span><br><span class="line">					Selective Self-test supported.</span><br><span class="line">SMART capabilities:            (0x0003)	Saves SMART data before entering</span><br><span class="line">					power-saving mode.</span><br><span class="line">					Supports SMART auto save timer.</span><br><span class="line">Error logging capability:        (0x01)	Error logging supported.</span><br><span class="line">					General Purpose Logging supported.</span><br><span class="line">Short self-test routine</span><br><span class="line">recommended polling time: 	 (   2) minutes.</span><br><span class="line">Extended self-test routine</span><br><span class="line">recommended polling time: 	 ( 616) minutes.</span><br><span class="line">SCT capabilities: 	       (0x003d)	SCT Status supported.</span><br><span class="line">					SCT Error Recovery Control supported.</span><br><span class="line">					SCT Feature Control supported.</span><br><span class="line">					SCT Data Table supported.</span><br><span class="line"></span><br><span class="line">SMART Attributes Data Structure revision number: 16</span><br><span class="line">Vendor Specific SMART Attributes with Thresholds:</span><br><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</span><br><span class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</span><br><span class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</span><br><span class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</span><br><span class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</span><br><span class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</span><br><span class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</span><br><span class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</span><br><span class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</span><br><span class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</span><br><span class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</span><br><span class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</span><br><span class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</span><br><span class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</span><br><span class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</span><br><span class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</span><br><span class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</span><br><span class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</span><br><span class="line"></span><br><span class="line">SMART Error Log Version: 1</span><br><span class="line">No Errors Logged</span><br><span class="line"></span><br><span class="line">SMART Self-test log structure revision number 1</span><br><span class="line">No self-tests have been logged.  [To run self-tests, use: smartctl -t]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SMART Selective self-test log data structure revision number 1</span><br><span class="line"> SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS</span><br><span class="line">    1        0        0  Not_testing</span><br><span class="line">    2        0        0  Not_testing</span><br><span class="line">    3        0        0  Not_testing</span><br><span class="line">    4        0        0  Not_testing</span><br><span class="line">    5        0        0  Not_testing</span><br><span class="line">Selective self-test flags (0x0):</span><br><span class="line">  After scanning selected spans, do NOT read-scan remainder of disk.</span><br><span class="line">If Selective self-test is pending on power-up, resume after 0 minute delay.</span><br></pre></td></tr></table></figure>
<p>其中，”READ SMART DATA”部分显示出硬盘的整体健康状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=== START OF READ SMART DATA SECTION ===</span><br><span class="line">SMART overall-health self-assessment test result: PASSED</span><br></pre></td></tr></table></figure>
<h2 id="SMART属性表"><a href="#SMART属性表" class="headerlink" title="SMART属性表"></a>SMART属性表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE</span><br><span class="line">  1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  2 Throughput_Performance  0x0005   100   100   050    Pre-fail  Offline      -       0</span><br><span class="line">  3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       7416</span><br><span class="line">  4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       12</span><br><span class="line">  5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  7 Seek_Error_Rate         0x000b   100   100   050    Pre-fail  Always       -       0</span><br><span class="line">  8 Seek_Time_Performance   0x0005   100   100   050    Pre-fail  Offline      -       0</span><br><span class="line">  9 Power_On_Hours          0x0032   092   092   000    Old_age   Always       -       3390</span><br><span class="line"> 10 Spin_Retry_Count        0x0033   100   100   030    Pre-fail  Always       -       0</span><br><span class="line"> 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       12</span><br><span class="line">191 G-Sense_Error_Rate      0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       4</span><br><span class="line">193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       118</span><br><span class="line">194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       25 (Min/Max 15/35)</span><br><span class="line">196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">197 Current_Pending_Sector  0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0</span><br><span class="line">199 UDMA_CRC_Error_Count    0x0032   200   200   000    Old_age   Always       -       0</span><br><span class="line">220 Disk_Shift              0x0002   100   100   000    Old_age   Always       -       0</span><br><span class="line">222 Loaded_Hours            0x0032   098   098   000    Old_age   Always       -       1112</span><br><span class="line">223 Load_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0</span><br><span class="line">224 Load_Friction           0x0022   100   100   000    Old_age   Always       -       0</span><br><span class="line">226 Load-in_Time            0x0026   100   100   000    Old_age   Always       -       595</span><br><span class="line">240 Head_Flying_Hours       0x0001   100   100   001    Pre-fail  Offline      -       0</span><br></pre></td></tr></table></figure>
<p>SMART属性表列出了制造商在硬盘中定义好的属性值，以及这些属性相关的故障阈值。这个表由驱动固件自动生成和更新。</p>
<ul>
<li><strong>ID</strong>：属性ID，通常是一个1到255之间的十进制或十六进制的数字。</li>
<li><strong>ATTRIBUTE_NAME</strong>：硬盘制造商定义的属性名。</li>
<li><strong>FLAG</strong>：属性操作标志（可以忽略）。</li>
<li><strong>VALUE</strong>：这是表格中最重要的信息之一，代表给定属性的标准化值，在1到253之间。253意味着最好情况，1意味着最坏情况。取决于属性和制造商，初始化VALUE可以被设置成100或200.</li>
<li><strong>WORST</strong>：所记录的最小VALUE。</li>
<li><strong>THRESH</strong>：在报告硬盘FAILED状态前，WORST可以允许的最小值。</li>
<li><strong>TYPE</strong>：属性的类型（Pre-fail或Old<em>age）。Pre-fail类型的属性可被看成一个关键属性，表示参与磁盘的整体SMART健康评估（PASSED/FAILED）。如果任何Pre-fail类型的属性故障，那么可视为磁盘将要发生故障。另一方面，Old</em>age类型的属性可被看成一个非关键的属性（如正常的磁盘磨损），表示不会使磁盘本身发生故障。</li>
<li><strong>UPDATED</strong>：表示属性的更新频率。Offline代表磁盘上执行离线测试的时间。</li>
<li><strong>WHEN_FAILED</strong>：如果VALUE小于等于THRESH，会被设置成“FAILING_NOW”；如果WORST小于等于THRESH会被设置成“In_the_past”；如果都不是，会被设置成“-”。在“FAILING_NOW”情况下，需要尽快备份重要文件，特别是属性是Pre-fail类型时。“In_the_past”代表属性已经故障了，但在运行测试的时候没问题。“-”代表这个属性从没故障过。</li>
<li><strong>RAW_VALUE</strong>：制造商定义的原始值，从VALUE派生。</li>
</ul>
<h2 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h2><p>编辑smartctl的配置文件(/etc/default/smartmontools)以便在系统启动时启动smartd，并以秒为单位指定间隔时间（如7200 = 2小时）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_smartd=yes</span><br><span class="line">smartd_opts=&quot;--interval=7200&quot;</span><br></pre></td></tr></table></figure>
<p>编辑smartd的配置文件，添加以下行内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/smartmontools/smartd</span><br><span class="line">smartd.conf        smartd_warning.d/  smartd_warning.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda -m myemail@mydomain.com -M test</span><br></pre></td></tr></table></figure>
<p><strong>-m </strong>：指定发送测试报告到某个电子邮件地址。这里可以是系统用户比如root，或者如果服务器已经配置成发送电子邮件到系统外部，则是类似于<a href="mailto:myemail@mydomain.com" target="_blank" rel="noopener">myemail@mydomain.com</a>的邮件地址。</p>
<p><strong>-M </strong>：指定发送邮件报告的期望类型。</p>
<ul>
<li><strong>once</strong>：为检测到的每种磁盘问题只发送一封警告邮件。</li>
<li><strong>daily</strong>：为检测到的每种磁盘问题每隔一天发送一封额外的警告提醒邮件。</li>
<li><strong>diminishing</strong>：为检测到的每种问题发送一封额外的警告提醒邮件，开始是每隔一天，然后每隔两天，每隔四天，以此类推。每个间隔是前一次间隔的2倍。</li>
<li><strong>test</strong>：只要smartd一启动，立即发送一封测试邮件。</li>
<li><strong>exec PATH</strong>：取代默认的邮件命令，运行PATH路径下的可执行文件。PATH必须指向一个可执行的二进制文件或脚本。当检测到一个问题时，可以指定执行一个期望的动作（闪烁控制台、关闭系统等等）。</li>
</ul>
<p>保存改动并重启smartd。</p>
<p>可以使用“-s”标志和形如“T/MM/DD/d/HH”的正则表达式按照想要的调度方案执行测试，其中：</p>
<p>正则表达式中的T代表测试的类型：</p>
<ul>
<li>L：长测试</li>
<li>S：短测试</li>
<li>C：传输测试（仅限ATA）</li>
<li>O：离线测试（仅限ATA）</li>
</ul>
<p>其它的字符代表测试执行的日期和时间：</p>
<ul>
<li>MM是一年中的月份。</li>
<li>DD是一月中的天份。</li>
<li>HH是一天中的小时。</li>
<li>d是一个星期中的某天（从1=周一到7=周日）。</li>
<li>MM、DD和HH使用两位十进制数字表示。</li>
</ul>
<p>在上述表达中的小圆点表示所有可能的值。形如’(A|B|C)’在圆括号里的表达式表示三个可能值A、B和C中的任意一个。形如[1-5]在方括号中的表达式表示1到5的范围（包含5）.</p>
<p>例如，想要在每个工作日的下午一点为所有的磁盘执行一次长测试，在/etc/smartd.conf中添加如下行内容。确保编辑完重启smartd。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEVICESCAN -s (L/../../[1-5]/13)</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/S.M.A.R.T" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/S.M.A.R.T</a>.</p>
<p><a href="https://linux.cn/article-4461-1.html" target="_blank" rel="noopener">使用 smartmontools 查看硬盘的健康状态</a></p>
]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2配色--zsh & oh-my-zsh]]></title>
      <url>http://xiaqunfeng.cc/2017/05/04/iterm2-color/</url>
      <content type="html"><![CDATA[<p>给iterm2进行配色，炫酷一点。<br><a id="more"></a></p>
<h3 id="Solarized"><a href="#Solarized" class="headerlink" title="Solarized"></a>Solarized</h3><p>目前网络上最流行的配色解决方案：<a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">Solarized</a></p>
<p>Solarized Dark 官方网站: <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">http://ethanschoonover.com/solarized</a></p>
<p>Solarized Dark github 地址: <a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">https://github.com/altercation/solarized</a></p>
<p>下载下来后会看到琳琅满目的配色解决方案，其中有一个目录 <code>iterm2-colors-solarized</code> 是为 iterm2 准备的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls iterm2-colors-solarized/</span><br><span class="line">.md</span><br><span class="line">Solarized Dark.itermcolors</span><br><span class="line">Solarized Light.itermcolors</span><br></pre></td></tr></table></figure>
<p>进入目录能看到 3个文件 (1个 md说明文件,2个配色文件) </p>
<p>我们使用其中一个 Solarized Dark.itermcolors</p>
<p>然后 preferences -&gt; colors -&gt; import 即可。</p>
<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>众所周知在Unix/Linux系统下是存在很多不同的shell，常见的就有bash, csh，ksh，zsh等等。在Linux和MAC OS系统中，默认使用的是bash。这里介绍功能更加强大的 <strong>zsh</strong>。</p>
<p>1、通过homebrew安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure>
<p>2、将zsh设置成系统默认shell，以代替bash</p>
<p>用编辑器打开<code>/etc/shells</code>，在末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/zsh</span><br></pre></td></tr></table></figure>
<p> 在终端中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/local/bin/zsh</span><br></pre></td></tr></table></figure>
<p>然后重新启动iTerm2，zsh就已经被配置成默认的shell了。</p>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p>github：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></p>
<p>1、安装</p>
<p> <strong>on-my-zsh</strong>的安装支持自动和手动，为了省去麻烦，我建议优先使用自动，如果要使用手动安装，请查看安装说明。这里只说一下自动安装。 在终端里，如果你有<code>curl</code>，则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://install.ohmyz.sh | sh</span><br></pre></td></tr></table></figure>
<p>如果你使用<code>wget</code>,则在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate http://install.ohmyz.sh -O - | sh</span><br></pre></td></tr></table></figure>
<p>这样oh-my-zsh就安装完成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/.oh-my-zsh  master ✔                                                              1d</span><br><span class="line">▶ ls</span><br><span class="line">CONTRIBUTING.md cache           log             templates</span><br><span class="line">LICENSE.txt     custom          oh-my-zsh.sh    themes</span><br><span class="line">README.md       lib             plugins         tools</span><br></pre></td></tr></table></figure>
<p>2、配置</p>
<p>zsh的配置在<code>~/.zshrc</code>下面这</p>
<p>主题的配置</p>
<p>在<code>~/.oh-my-zsh/themes</code>存在各式各样的主题文件，每个主题可以通过：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a> 进行查看。选好样式后，</p>
<p>在<code>.zshrc</code>中的 <code>ZSH_THEME</code>设置成你所选用的主题，重启iTerm2，就可以看到相应的效果。我这里用的 <strong>avit</strong>。上面哪个oh-my-zsh 文件夹目录的列表就是用的这个主题。</p>
<p>如果使用agnoster主题的话还需要装字体包，如下：</p>
<p><a href="https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher" target="_blank" rel="noopener">https://github.com/Lokaltog/vim-powerline/tree/develop/fontpatcher</a></p>
<p><a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p>
<h3 id="更多的配色方案"><a href="#更多的配色方案" class="headerlink" title="更多的配色方案"></a>更多的配色方案</h3><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener">https://github.com/mbadolato/iTerm2-Color-Schemes</a></p>
<p>可以根据自己的喜好来选择主题了。</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line">echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc</span><br><span class="line">source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure>
<p>在 .zshrc 尾部添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx使用和配置]]></title>
      <url>http://xiaqunfeng.cc/2017/05/03/nginx-usage/</url>
      <content type="html"><![CDATA[<p>简单介绍nginx，特别是反向代理和负载均衡部分，并用通过实战加深理解。<br><a id="more"></a></p>
<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<p>架设服务器均衡负载方式有多种，Nginx、LVS、HAProxy+Keepalived是目前使用最广泛的三种方案。其中Keepalived+HAProxy是一个高可用性方案。</p>
<p>nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。</p>
<ul>
<li>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</li>
<li>多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。基本的网络事件，在worker进程中处理。</li>
</ul>
<p>nginx模块一般被分成三大类：handler、filter和upstream。</p>
<p>使用<code>Nginx</code>的方法就是写配置文件，配置文件能完全控制<code>Nginx</code>，使<code>Nginx</code>按照我们的需求进行运行。</p>
<blockquote>
<p>关于nginx的配置文件，需要深入了解和使用的可以去学习一下。</p>
</blockquote>
<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>OS: CentOS 7.3</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>
<p>关闭防火墙和selinux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop firewalld</span><br><span class="line"># systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"># setenforce 0</span><br><span class="line">setenforce: SELinux is disabled</span><br><span class="line"># getenforce</span><br><span class="line">Disabled</span><br></pre></td></tr></table></figure>
<p>添加至服务列表，开机自动启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># chkconfig --add nginx</span><br><span class="line"># chkconfig nginx on </span><br><span class="line"># chkconfig nginx --list</span><br></pre></td></tr></table></figure>
<p>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># service nginx start</span><br><span class="line">Redirecting to /bin/systemctl start  nginx.service</span><br></pre></td></tr></table></figure>
<p>查看端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ntlp | grep :80</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      16858/nginx: master</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      16858/nginx: master</span><br></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-welcome.png" alt="nginx-welcome"></p>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line">或者</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>1、代理</p>
<p>所谓代理，就是在客户端和服务端之间强行添加了一层，用来实现流量转发的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------------+         +---------------+        +--------------+</span><br><span class="line">|                |         |               |        |              |</span><br><span class="line">|                |         |               |        |              |</span><br><span class="line">|                |  http   |               | http   |              |</span><br><span class="line">|    client      &lt;---------&gt;    proxy      &lt;--------&gt;   server     |</span><br><span class="line">|                |  https  |               | https  |              |</span><br><span class="line">|                |         |               |        |              |</span><br><span class="line">|                |         |               |        |              |</span><br><span class="line">+----------------+         +---------------+        +--------------+</span><br></pre></td></tr></table></figure>
<p>2、正向代理</p>
<p>用于代理客户端。</p>
<p>比如：我是一个用户，我访问不了某网站（例如google），但是我能访问一个代理服务器，这个代理服务器能访问google，于是我先连上代理服务器，告诉他我需要访问google的内容，代理服务器去取回来，然后返回给我。自此，一次正向代理顺利完成。</p>
<p>3、反向代理</p>
<p>用来代理服务端。</p>
<p>依然拿google举例，网站每秒钟要处理很多请求，如果仅仅让一台单一的服务器处理，肯定应付不过来。所以采用多台服务器来处理这些请求，减少每台服务器的压力。但是多个服务器那就产生了多个Server，我的一个<code>google.com</code>就不能解析到这些服务器上，而且用多个二级域名比如<code>server1.google.com</code>，<code>server2.google.com</code>等等也给用户造成了使用上的不便，通过反向代理可以很好的解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+-------------+                                             |      |                   |</span><br><span class="line">|             +----------+                                  |      |                   |</span><br><span class="line">|  client 1   |          |                                  |      +-------------------+</span><br><span class="line">|             |          |                                  |</span><br><span class="line">+-------------+          |                                  |</span><br><span class="line">                         |         +------------------+     |      +-------------------+</span><br><span class="line">                         |         |                  |     |      |                   |</span><br><span class="line">+-------------+          |         |                  |     |      |   server 2        |</span><br><span class="line">|             |          |         |                  +------------&gt;                   |</span><br><span class="line">|  clent 2    +--------------------&gt;  reverse proxy   |     |      |                   |</span><br><span class="line">|             |          |         |                  |     |      +-------------------+</span><br><span class="line">+-------------+          |         |                  |     |</span><br><span class="line">                         |         |                  |     |               .</span><br><span class="line">      .                  |         |                  |     |               .</span><br><span class="line">      .                  |         +------------------+     |               .</span><br><span class="line">      .                  |                                  |</span><br><span class="line">                         |                                  |      +--------------------+</span><br><span class="line">+-------------+          |                                  |      |                    |</span><br><span class="line">|             |          |                                  |      |   server m         |</span><br><span class="line">|  client n   +----------+                                  +------&gt;                    |</span><br><span class="line">|             |                                                    |                    |</span><br><span class="line">+-------------+                                                    +--------------------+</span><br></pre></td></tr></table></figure>
<p> 结论就是，客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>
<p>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>
<p>代理模块的指令有很多我这里只讲解重要的proxy_pass，这个模块可以转发请求到其他的服务器。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>一台机器装有Nginx，两台测试机装httpd</p>
<h4 id="测试机httpd配置"><a href="#测试机httpd配置" class="headerlink" title="测试机httpd配置"></a>测试机httpd配置</h4><p>1、安装httpd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd -y</span><br></pre></td></tr></table></figure>
<p>2、提供页面测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ceph0机器</span><br><span class="line">echo &quot;&lt;h1&gt;ceph0.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</span><br><span class="line"># ceph1机器</span><br><span class="line">echo &quot;&lt;h1&gt;ceph1.test.com&lt;/h1&gt;&quot; &gt; /var/www/html/index.html</span><br></pre></td></tr></table></figure>
<p>3、启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure>
<p>如果启动失败的话注意查看是否80端口被占用</p>
<p>4、web上登录ceph0和ceph1机器IP查看</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph0.png" alt="ceph0"></p>
<p><img src="http://oow6unnib.bkt.clouddn.com/nginx-httpd-ceph1.png" alt="ceph1"></p>
<p>注意：Nginx和httpd都监听在80端口，https监听在443端口</p>
<p>如果要修改httpd的监听端口的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/httpd/conf/httpd.conf</span><br><span class="line">...</span><br><span class="line">Listen 80		# 修改这一行</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="nginx配置和测试"><a href="#nginx配置和测试" class="headerlink" title="nginx配置和测试"></a>nginx配置和测试</h4><p>设置配置文件，设置完后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/nginx/conf.d/test.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://123.59.204.185:80;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">nginx -s reload</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># curl 127.0.0.1:8000</span><br><span class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>去ceph0机器上查看日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph0 ~]# tail /var/log/httpd/access_log</span><br><span class="line">180.168.57.238 - - [03/May/2017:10:27:17 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&quot;</span><br><span class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</span><br><span class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</span><br><span class="line">180.168.57.238 - - [03/May/2017:10:28:24 +0800] &quot;-&quot; 408 - &quot;-&quot; &quot;-&quot;</span><br><span class="line">123.59.185.23 - - [03/May/2017:11:25:30 +0800] &quot;GET / HTTP/1.1&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</span><br><span class="line">123.59.185.23 - - [03/May/2017:11:29:40 +0800] &quot;GET / HTTP/1.0&quot; 200 24 &quot;-&quot; &quot;curl/7.29.0&quot;</span><br></pre></td></tr></table></figure>
<p>注意这里 HTTP/1.1和HTTP/1.0的区别</p>
<p>proxy_pass模块可以转发请求到其他的服务器。nginx为浏览器发送HTTP/1.1，为后端服务器发送HTTP/1.0。</p>
<p>HTTP/1.0无法使用keepalive（后端服务器将为每个请求创建并且删除连接），这样浏览器就可以为浏览器处理keepalive。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>upstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>Nginx的负载均衡模块目前支持4种调度算法，下面进行分别介绍，其中后两项属于第三方调度算法。  </p>
<ul>
<li>轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight 指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li>ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。（一般电子商务网站用的比较多）</li>
<li>fair。这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li>url_hash。此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。</li>
</ul>
<blockquote>
<p>在 ip_hash 策略中，用于进行 hash 运算的 key，是 client 的 C 类 IP 地址（C 类 IP 地址就是范围在 192.0.0.0 到 223.255.255.255 之间，前三段号码表示子网，第四段号码为本地主机的 IP 地址类别）。这样的方式保证一个 client 每次请求都将到达同一个 backend。当然，如果所 hash 到的 backend 当前不可用，则请求会被转移到其他 backend。</p>
</blockquote>
<h3 id="upstream-支持的状态参数"><a href="#upstream-支持的状态参数" class="headerlink" title="upstream 支持的状态参数"></a>upstream 支持的状态参数</h3><p>在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：      </p>
<ul>
<li>down，表示当前的server暂时不参与负载均衡。</li>
<li>weight 默认为1。weight越大，负载的权重就越大。</li>
<li>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。</li>
<li>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。</li>
<li>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</li>
</ul>
<blockquote>
<p>注，当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>
<p>如果负载均衡把请求分配到backup服务器上，就不能能访问到期望的页面了。</p>
<p>weight和 ip_hash是不同的策略。</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream itest &#123;</span><br><span class="line">    server 123.59.204.185:80 weight=1 max_fails=2 fial_timeout=2;</span><br><span class="line">    server 123.59.204.193:80 down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server 185的权重为1，当请求失败的次数为2时，返回错误，并暂停服务2秒。</p>
<p>Server 193 down了，不会被访问到。</p>
<h3 id="配置负载均衡服务器"><a href="#配置负载均衡服务器" class="headerlink" title="配置负载均衡服务器"></a>配置负载均衡服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cat conf.d/test.conf</span><br><span class="line">upstream itest &#123;</span><br><span class="line">    server 123.59.204.185:80;</span><br><span class="line">    server 123.59.204.193:80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name itest.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://itest;</span><br><span class="line">#        proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nginx]# curl 127.0.0.1:8000</span><br><span class="line">&lt;h1&gt;ceph0.test.com&lt;/h1&gt;</span><br><span class="line">[root@nginx]# curl 127.0.0.1:8000</span><br><span class="line">&lt;h1&gt;ceph1.test.com&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>百分之50的概率读取到一台机器</p>
<p>注，upstream是定义在server{ }之外的，不能定义在server{ }内部。定义好upstream之后，用proxy_pass引用一下即可。</p>
<h2 id="备份服务器"><a href="#备份服务器" class="headerlink" title="备份服务器"></a>备份服务器</h2><p>配置nginx文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/nginx/conf.d/test.conf</span><br><span class="line">upstream itest &#123;</span><br><span class="line">    server 123.59.204.185:80;</span><br><span class="line">    server 123.59.204.193:80;</span><br><span class="line">    server 127.0.0.1:8000 backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name itest.com;</span><br><span class="line">    root /root/errorpage;</span><br><span class="line">    index index.html;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://itest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件夹和index文件的建立</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /root/errorpage</span><br><span class="line"># cat index.html</span><br><span class="line">&lt;h1&gt;Sorry, all ceph node is down! Please try again later!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>另外两台机器上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service httpd stop</span><br></pre></td></tr></table></figure>
<p>然后再访问的话就会访问到备份服务器，输出index.html的内容。</p>
<p>附一个关于nginx的好系列文章：<a href="http://blog.csdn.net/poechant/article/details/7213546" target="_blank" rel="noopener">高性能Web服务器Nginx的配置与部署研究</a></p>
<p>有空学习，mark之。</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iterm2快捷键的使用]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/iterm2-shortcut-key-usage/</url>
      <content type="html"><![CDATA[<p>mac下终端神器iterm2，非常的好用，极大提高了效率，这里将自己使用过的快捷键总结如下。<br><a id="more"></a></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>新建tab：⌘ + t</p>
<p>切换 tab：    ⌘+←, ⌘+→</p>
<p>​            ⌘+{, ⌘+}</p>
<p>​            ⌘ + Num</p>
<p>切换全屏：⌘ + enter</p>
<p>关闭tab：⌘ + w</p>
<h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p>
<p>切换Tab中的pane：⌘ + [ / ]</p>
<p>按方向切换 pane：⌘+Option+方向键</p>
<p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p>
<p>关闭panel：⌘ + w</p>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>智能查找，支持正则查找：⌘+f</p>
<p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p>
<p>自动填充：⌘ + ； 命令补全提示 </p>
<p>打开最近目录： ⌘ + alt + /</p>
<p>窗口太多，快速定位到光标所在位置：⌘ + / </p>
<p>鼠标所在行高亮显示： ⌘ + alt + ； </p>
<p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p>
<p>⌘+Shift+h弹出历史记录窗口</p>
<p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p>
<p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p>
<h2 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h2><p>可以拖拽选中的字符串</p>
<p>可以点击 url：调用默认浏览器访问该网址</p>
<p>可以点击文件：调用默认程序打开文件</p>
<p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p>
<p>点击文件夹：在 finder 中打开该文件夹</p>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>设置标记：⌘ + shift + m </p>
<p>跳转到上个标记：⌘ + shift + j</p>
<p>多个标记切换：⌘ + shift + arrow(上下)</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>置空屏幕: clear </p>
<p>​        ctrl + l </p>
<p>​        ⌘ + k</p>
<p>清空屏幕: command + k/r</p>
<p>字体调大:  command + +</p>
<p>字体调小:  command + -</p>
<p>清除当前行：ctrl + u</p>
<p>到行首：ctrl + a</p>
<p>到行尾：ctrl + e</p>
<p>从光标处删至字首/尾：ctrl + w / k</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VSM部署]]></title>
      <url>http://xiaqunfeng.cc/2017/05/02/ceph-VSM/</url>
      <content type="html"><![CDATA[<p>本文介在已有ceph集群机器上部署VSM的过程，涵盖centos和ubuntu两种系统。<br><a id="more"></a></p>
<h2 id="VSM-Virtual-Storage-Manager"><a href="#VSM-Virtual-Storage-Manager" class="headerlink" title="VSM - Virtual Storage Manager"></a>VSM - Virtual Storage Manager</h2><p>最新发布的release版本为2.1，pre-release版本为2.2，已不再更新和维护（因为负责人<a href="mailto:yaguang.wang@intel.com" target="_blank" rel="noopener">yaguang.wang@intel.com</a> or <a href="mailto:ferber.dan@intel.com" target="_blank" rel="noopener">ferber.dan@intel.com</a>已经从intel离职了）。</p>
<p>从2.1版本开始，VSM支持在已有ceph集群上部署，正是因为这个原因，才开始尝试部署VSM。</p>
<p>VSM 2.1的代码组件分为四个：</p>
<ul>
<li>vsm-dashboard：VSM的管理与监控web界面</li>
<li>python-vsmclient：调用restapi的client</li>
<li>vsm：VSM的核心组件（包括api、scheduler、conductor、agent等）</li>
<li>vsm-deploy：ceph部署工具</li>
</ul>
<p>代码基于Python语言，使用了wsgi、django等技术框架。</p>
<p>Git主页：<br><a href="https://github.com/01org/virtual-storage-manager" target="_blank" rel="noopener">https://github.com/01org/virtual-storage-manager</a></p>
<p>vsm-dependencies：<br><a href="https://github.com/01org/vsm-dependencies" target="_blank" rel="noopener">https://github.com/01org/vsm-dependencies</a></p>
<p>VSM系统有两个角色，一个是vsm-controller，另外一个是vsm-agent：</p>
<ul>
<li>vsm-agent部署在ceph节点上</li>
<li>vsm-controller部署在单独的任意节点（也可以部署在ceph节点上）</li>
</ul>
<p>架构图如下：<img src="http://oow6unnib.bkt.clouddn.com/vsm-architecture.png" alt="vsm-architecture"></p>
<h2 id="centos上部署"><a href="#centos上部署" class="headerlink" title="centos上部署"></a>centos上部署</h2><p>OS：CentOS 7.2</p>
<p>VSM：v2.1 released</p>
<p>4台机器，一个作为controller，三台ceph集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">172.20.2.76     ceph0</span><br><span class="line">172.20.2.77     ceph1</span><br><span class="line">172.20.2.79     ceph2</span><br><span class="line">172.20.2.81     controller</span><br></pre></td></tr></table></figure>
<p>1、从controller机器上设置到ceph集群机器和自己的免密登录</p>
<p>2、关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl disable firewalld</span><br><span class="line"># systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p>3、关闭selinux</p>
<p>临时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>永久</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/selinux/config | grep -v &quot;#&quot;</span><br><span class="line"></span><br><span class="line">SELINUX=disabled</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>
<h3 id="下载VSM："><a href="#下载VSM：" class="headerlink" title="下载VSM："></a>下载VSM：</h3><p>在controller机器上执行如下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336_centos7.tar.gz</span><br><span class="line"># tar -zxvf 2.1.0-336_centos7.tar.gz</span><br><span class="line"># cd 2.1.0-336</span><br><span class="line"># ls</span><br><span class="line">CHANGELOG.md   INSTALL.pdf  manifest      RELEASE       vsm-dep-repo</span><br><span class="line">CHANGELOG.pdf  installrc    NOTICE        rpms.lst      vsm-dep.repo</span><br><span class="line">get_pass.sh    install.sh   prov_node.sh  uninstall.sh  vsmrepo</span><br><span class="line">INSTALL.md     LICENSE      README.md     VERSION       vsm.repo</span><br></pre></td></tr></table></figure>
<h3 id="配置文件installrc"><a href="#配置文件installrc" class="headerlink" title="配置文件installrc"></a>配置文件installrc</h3><p>设置控制节点和代理节点的地址，设置完如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat installrc | egrep -v &quot;#|^$&quot;</span><br><span class="line">AGENT_ADDRESS_LIST=&quot;172.20.2.76 172.20.2.77 172.20.2.79&quot;</span><br><span class="line">CONTROLLER_ADDRESS=&quot;172.20.2.81&quot;</span><br></pre></td></tr></table></figure>
<h3 id="配置manifest"><a href="#配置manifest" class="headerlink" title="配置manifest"></a>配置manifest</h3><p>在文件夹manifest中，分别创建以管理IP地址命名的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls manifest/</span><br><span class="line">172.20.2.76  172.20.2.79  cluster.manifest.sample</span><br><span class="line">172.20.2.77  172.20.2.81  server.manifest.sample</span><br></pre></td></tr></table></figure>
<p>将cluster.manifest.sample 文件复制到 172.20.2.81/cluster.manifest，编辑改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[management_addr]</span><br><span class="line">172.20.2.0/24</span><br><span class="line"></span><br><span class="line">[100.64.0.22ceph_public_addr]</span><br><span class="line">172.20.2.0/24</span><br><span class="line"></span><br><span class="line">[ceph_cluster_addr]</span><br><span class="line">172.20.2.0/24</span><br></pre></td></tr></table></figure>
<p>将server.manifest.sample 文件复制到 76、77、79文件夹下，重命名为server.manifest，改动如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vsm_controller_ip]</span><br><span class="line">172.20.2.81</span><br></pre></td></tr></table></figure>
<p>注：这里添加磁盘部分不用处理，因为是在已有ceph的集群上安装的。</p>
<p>manifest文件夹目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tree</span><br><span class="line">.</span><br><span class="line">├── 172.20.2.76</span><br><span class="line">│   └── server.manifest</span><br><span class="line">├── 172.20.2.77</span><br><span class="line">│   └── server.manifest</span><br><span class="line">├── 172.20.2.79</span><br><span class="line">│   └── server.manifest</span><br><span class="line">├── 172.20.2.81</span><br><span class="line">│   └── cluster.manifest</span><br><span class="line">├── cluster.manifest.sample</span><br><span class="line">└── server.manifest.sample</span><br></pre></td></tr></table></figure>
<h3 id="添加epel源"><a href="#添加epel源" class="headerlink" title="添加epel源"></a>添加epel源</h3><p>在ceph集群机器上添加epel源，一般在安装ceph集群的时候就应该已经添加了，如果没有添加的话这里加一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh -u cephuser -v 2.1 --check-dependence-package</span><br></pre></td></tr></table></figure>
<p>安装完成后，调用get_pass.sh提取管理密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ./get_pass.sh</span><br><span class="line">24195bcbce558aa7bd2c</span><br></pre></td></tr></table></figure>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录VSM仪表盘，地址：<a href="https://172.20.2.81:dashboard/vsm" target="_blank" rel="noopener">https://172.20.2.81:dashboard/vsm</a></p>
<p>用户名：admin</p>
<p>密码：24195bcbce558aa7bd2c</p>
<p>进入后界面如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/vsm-start.png" alt="vsm"></p>
<blockquote>
<p>注意：是https，不是http</p>
</blockquote>
<h2 id="ubuntu上部署"><a href="#ubuntu上部署" class="headerlink" title="ubuntu上部署"></a>ubuntu上部署</h2><p>OS：ubuntu 14.04</p>
<p>安装方法和centos上基本类似，不一样的地方有：</p>
<p>1、下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/01org/virtual-storage-manager/releases/download/v2.1.0/2.1.0-336-ubuntu14.tar.gz</span><br></pre></td></tr></table></figure>
<p>2、不需要添加epel源</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于在非ceph集群集群上安装并创建ceph集群后续有空补充。</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令清单]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/git-common-list/</url>
      <content type="html"><![CDATA[<p>转载的文章，里面git命令应有尽有，包含所有常用命令，mark之。<br><a id="more"></a></p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 在当前目录新建一个Git代码库</span><br><span class="line">&gt; $ git init</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个目录，将其初始化为Git代码库</span><br><span class="line">&gt; $ git init [project-name]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 下载一个项目和它的整个代码历史</span><br><span class="line">&gt; $ git clone [url]</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 显示当前的Git配置</span><br><span class="line">&gt; $ git config --list</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 编辑Git配置文件</span><br><span class="line">&gt; $ git config -e [--global]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 设置提交代码时的用户信息</span><br><span class="line">&gt; $ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">&gt; $ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 添加指定文件到暂存区</span><br><span class="line">&gt; $ git add [file1] [file2] ...</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 添加指定目录到暂存区，包括子目录</span><br><span class="line">&gt; $ git add [dir]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 添加当前目录的所有文件到暂存区</span><br><span class="line">&gt; $ git add .</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 添加每个变化前，都会要求确认</span><br><span class="line">&gt; # 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">&gt; $ git add -p</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">&gt; $ git rm [file1] [file2] ...</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">&gt; $ git rm --cached [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 改名文件，并且将这个改名放入暂存区</span><br><span class="line">&gt; $ git mv [file-original] [file-renamed]</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 提交暂存区到仓库区</span><br><span class="line">&gt; $ git commit -m [message]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 提交暂存区的指定文件到仓库区</span><br><span class="line">&gt; $ git commit [file1] [file2] ... -m [message]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">&gt; $ git commit -a</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 提交时显示所有diff信息</span><br><span class="line">&gt; $ git commit -v</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 使用一次新的commit，替代上一次提交</span><br><span class="line">&gt; # 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">&gt; $ git commit --amend -m [message]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">&gt; $ git commit --amend [file1] [file2] ...</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 列出所有本地分支</span><br><span class="line">&gt; $ git branch</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 列出所有远程分支</span><br><span class="line">&gt; $ git branch -r</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 列出所有本地分支和远程分支</span><br><span class="line">&gt; $ git branch -a</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个分支，但依然停留在当前分支</span><br><span class="line">&gt; $ git branch [branch-name]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个分支，并切换到该分支</span><br><span class="line">&gt; $ git checkout -b [branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个分支，指向指定commit</span><br><span class="line">&gt; $ git branch [branch] [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">&gt; $ git branch --track [branch] [remote-branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 切换到指定分支，并更新工作区</span><br><span class="line">&gt; $ git checkout [branch-name]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 切换到上一个分支</span><br><span class="line">&gt; $ git checkout -</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">&gt; $ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 合并指定分支到当前分支</span><br><span class="line">&gt; $ git merge [branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 选择一个commit，合并进当前分支</span><br><span class="line">&gt; $ git cherry-pick [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 删除分支</span><br><span class="line">&gt; $ git branch -d [branch-name]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 删除远程分支</span><br><span class="line">&gt; $ git push origin --delete [branch-name]</span><br><span class="line">&gt; $ git branch -dr [remote/branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 列出所有tag</span><br><span class="line">&gt; $ git tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个tag在当前commit</span><br><span class="line">&gt; $ git tag [tag]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个tag在指定commit</span><br><span class="line">&gt; $ git tag [tag] [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 删除本地tag</span><br><span class="line">&gt; $ git tag -d [tag]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 删除远程tag</span><br><span class="line">&gt; $ git push origin :refs/tags/[tagName]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 查看tag信息</span><br><span class="line">&gt; $ git show [tag]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 提交指定tag</span><br><span class="line">&gt; $ git push [remote] [tag]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 提交所有tag</span><br><span class="line">&gt; $ git push [remote] --tags</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个分支，指向某个tag</span><br><span class="line">&gt; $ git checkout -b [branch] [tag]</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 显示有变更的文件</span><br><span class="line">&gt; $ git status</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示当前分支的版本历史</span><br><span class="line">&gt; $ git log</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">&gt; $ git log --stat</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 搜索提交历史，根据关键词</span><br><span class="line">&gt; $ git log -S [keyword]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">&gt; $ git log [tag] HEAD --pretty=format:%s</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">&gt; $ git log [tag] HEAD --grep feature</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某个文件的版本历史，包括文件改名</span><br><span class="line">&gt; $ git log --follow [file]</span><br><span class="line">&gt; $ git whatchanged [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示指定文件相关的每一次diff</span><br><span class="line">&gt; $ git log -p [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示过去5次提交</span><br><span class="line">&gt; $ git log -5 --pretty --oneline</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示所有提交过的用户，按提交次数排序</span><br><span class="line">&gt; $ git shortlog -sn</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示指定文件是什么人在什么时间修改过</span><br><span class="line">&gt; $ git blame [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示暂存区和工作区的差异</span><br><span class="line">&gt; $ git diff</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示暂存区和上一个commit的差异</span><br><span class="line">&gt; $ git diff --cached [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">&gt; $ git diff HEAD</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示两次提交之间的差异</span><br><span class="line">&gt; $ git diff [first-branch]...[second-branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示今天你写了多少行代码</span><br><span class="line">&gt; $ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某次提交的元数据和内容变化</span><br><span class="line">&gt; $ git show [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某次提交发生变化的文件</span><br><span class="line">&gt; $ git show --name-only [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某次提交时，某个文件的内容</span><br><span class="line">&gt; $ git show [commit]:[filename]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示当前分支的最近几次提交</span><br><span class="line">&gt; $ git reflog</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 下载远程仓库的所有变动</span><br><span class="line">&gt; $ git fetch [remote]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示所有远程仓库</span><br><span class="line">&gt; $ git remote -v</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 显示某个远程仓库的信息</span><br><span class="line">&gt; $ git remote show [remote]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 增加一个新的远程仓库，并命名</span><br><span class="line">&gt; $ git remote add [shortname] [url]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">&gt; $ git pull [remote] [branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 上传本地指定分支到远程仓库</span><br><span class="line">&gt; $ git push [remote] [branch]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">&gt; $ git push [remote] --force</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 推送所有分支到远程仓库</span><br><span class="line">&gt; $ git push [remote] --all</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、保持fork分支更新"><a href="#九、保持fork分支更新" class="headerlink" title="九、保持fork分支更新"></a>九、保持fork分支更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. Clone your fork</span><br><span class="line">git clone git@github.com:YOUR-USERNAME/YOUR-FORKED-REPO.git</span><br><span class="line"></span><br><span class="line">2. Add remote from original repository in your forked repository</span><br><span class="line">cd into/cloned/fork-repo</span><br><span class="line">git remote add upstream git://github.com/ORIGINAL-DEV-USERNAME/REPO-YOU-FORKED-FROM.git</span><br><span class="line">git fetch upstream</span><br><span class="line"></span><br><span class="line">3. Updating your fork from original repo to keep up with their changes</span><br><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure>
<h2 id="十、撤销"><a href="#十、撤销" class="headerlink" title="十、撤销"></a>十、撤销</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 恢复暂存区的指定文件到工作区</span><br><span class="line">&gt; $ git checkout [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">&gt; $ git checkout [commit] [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 恢复暂存区的所有文件到工作区</span><br><span class="line">&gt; $ git checkout .</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">&gt; $ git reset [file]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">&gt; $ git reset --hard</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">&gt; $ git reset [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">&gt; $ git reset --hard [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">&gt; $ git reset --keep [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 新建一个commit，用来撤销指定commit</span><br><span class="line">&gt; # 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">&gt; $ git revert [commit]</span><br><span class="line">&gt;</span><br><span class="line">&gt; # 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">&gt; $ git stash</span><br><span class="line">&gt; $ git stash pop</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 生成一个可供发布的压缩包</span><br><span class="line">&gt; $ git archive</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>（完）</p>
<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a></p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解socket编程]]></title>
      <url>http://xiaqunfeng.cc/2017/03/24/socket/</url>
      <content type="html"><![CDATA[<p>理解socket编程的思想，介绍各个函数及其作用，文末有一个server和client的代码，可直接运行。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本地进程通信</strong></p>
<p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p><strong>网络进程通信</strong></p>
<p>但是网络中进程之间如何通信？</p>
<p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p>
<p>TCP/IP协议族已经帮我们解决了这个问题：</p>
<ul>
<li>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机</li>
<li>传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</li>
</ul>
<p>这样利用三元组<strong>（ip地址，协议，端口）</strong>就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。</p>
<h2 id="socket基本操作"><a href="#socket基本操作" class="headerlink" title="socket基本操作"></a>socket基本操作</h2><h3 id="1、socket-函数"><a href="#1、socket-函数" class="headerlink" title="1、socket()函数"></a>1、socket()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>
<p>socket函数对应于普通文件的<strong>打开</strong>操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong>用于创建一个<strong>socket描述符</strong>（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>socket函数的三个参数分别为：</p>
<ul>
<li>domain：即协议域，又称为协议族（family）。常用的协议族有，<strong>AF_INET</strong>、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li>type：指定socket类型。常用的socket类型有，<strong>SOCK_STREAM</strong>、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，<strong>IPPROTO_TCP</strong>、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li>
</ul>
<p>当我们调用<strong>socket()</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h3 id="2、bind-函数"><a href="#2、bind-函数" class="headerlink" title="2、bind()函数"></a>2、bind()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<p>三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># ipv4</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">    in_port_t      sin_port;   /* port in network byte order */</span><br><span class="line">    struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t       s_addr;     /* address in network byte order */</span><br><span class="line">&#125;;</span><br><span class="line"># ipv6对应的是： </span><br><span class="line">struct sockaddr_in6 &#123; </span><br><span class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </span><br><span class="line">    in_port_t       sin6_port;     /* port number */ </span><br><span class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </span><br><span class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </span><br><span class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in6_addr &#123; </span><br><span class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># Unix域对应的是： </span><br><span class="line">#define UNIX_PATH_MAX    108</span><br><span class="line">struct sockaddr_un &#123; </span><br><span class="line">    sa_family_t sun_family;               /* AF_UNIX */ </span><br><span class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
</blockquote>
<h3 id="3、listen-函数"><a href="#3、listen-函数" class="headerlink" title="3、listen()函数"></a>3、listen()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
<p>两个参数</p>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>backlog：相应socket可以排队的最大连接个数</li>
</ul>
<p>socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<h3 id="4、connect-函数"><a href="#4、connect-函数" class="headerlink" title="4、connect()函数"></a>4、connect()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：要监听的socket描述字</li>
<li>addr：服务器的socket地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<p>客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h3 id="5、accept-函数"><a href="#5、accept-函数" class="headerlink" title="5、accept()函数"></a>5、accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p>
<p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p>
<p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：服务器的socket描述字</li>
<li>addr：指向struct sockaddr *的指针，用于返回客户端的协议地址</li>
<li>addrlen：socket地址的长度</li>
</ul>
<blockquote>
<p>服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
</blockquote>
<h3 id="6、网络I-O"><a href="#6、网络I-O" class="headerlink" title="6、网络I/O"></a>6、网络I/O</h3><p>服务端：socket、bind、listen、accept</p>
<p>客户端：socket、connect</p>
<p>至此服务器与客户已经建立好连接，可以调用网络I/O进行读写操作，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure>
<p>recvmsg()/sendmsg()这两个函数是最通用的I/O函数。各函数需要对应的头文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">                      const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>
<h3 id="7、close-函数"><a href="#7、close-函数" class="headerlink" title="7、close()函数"></a>7、close()函数</h3><p>服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
</blockquote>
<p>以上参考了这篇文章：<a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">Linux Socket编程（不限Linux）</a>，写的很不错。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// server.c</span><br><span class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</span><br><span class="line">#include &lt;sys/types.h&gt;    	// socket</span><br><span class="line">#include &lt;sys/socket.h&gt;    	// socket</span><br><span class="line">#include &lt;stdio.h&gt;        	// printf</span><br><span class="line">#include &lt;stdlib.h&gt;        	// exit</span><br><span class="line">#include &lt;string.h&gt;        	// bzero</span><br><span class="line"></span><br><span class="line">#define SERVER_PORT    	6666 </span><br><span class="line">#define BUFFER_SIZE 	1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // server的socket地址结构server_addr,三元组(地址,协议,端口)</span><br><span class="line">    struct sockaddr_in server_addr;</span><br><span class="line">    bzero(&amp;server_addr,sizeof(server_addr)); //把一段内存区的内容全部设置为0</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    // socket描述符</span><br><span class="line">    int server_socket = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if( server_socket &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Create Socket Failed!&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给socket 描述符绑定一个地址，地址是我们上面定义好的</span><br><span class="line">    if( bind(server_socket,(struct sockaddr*)&amp;server_addr,sizeof(server_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Server Bind Port : %d Failed!&quot;, SERVER_PORT); </span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    // 监听这个socket, 第二个参数是排队的最大连接数</span><br><span class="line">    if ( listen(server_socket, 10) )</span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;Server Listen Failed!&quot;); </span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    while (1) </span><br><span class="line">    &#123;   </span><br><span class="line">        // 定义客户端的socket地址结构client_addr</span><br><span class="line">        struct sockaddr_in client_addr;</span><br><span class="line">        socklen_t len = sizeof(client_addr);</span><br><span class="line"></span><br><span class="line">        // 如果没有连接请求,就等待到有连接请求--这是accept函数的特性</span><br><span class="line">        // accept函数返回一个新的socket,这个socket(new_server_socket)用于同连接到的客户的通信，代表了服务器和客户端之间的一个通信通道</span><br><span class="line">        // accept函数把连接到的客户端信息填写到客户端的socket地址结构client_addr中</span><br><span class="line">        int new_server_socket = accept(server_socket,(struct sockaddr*)&amp;client_addr,&amp;len);</span><br><span class="line">        if ( new_server_socket &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Server Accept Failed!\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char buffer[BUFFER_SIZE];</span><br><span class="line">        bzero(buffer, BUFFER_SIZE);</span><br><span class="line">        // 接收从客户端来的请求</span><br><span class="line">        len = recv(new_server_socket,buffer,BUFFER_SIZE,0);</span><br><span class="line">        if (len &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Server Recieve Data Failed!\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[len] = &apos;\0&apos;;</span><br><span class="line">        printf(&quot;recv msg from client: %s\n&quot;, buffer);</span><br><span class="line">        close(new_server_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：socket() -&gt; connect() -&gt; I/O() -&gt; close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// client.c</span><br><span class="line">#include &lt;netinet/in.h&gt;    	// sockaddr_in</span><br><span class="line">#include &lt;sys/types.h&gt;    	// socket</span><br><span class="line">#include &lt;sys/socket.h&gt;    	// socket</span><br><span class="line">#include &lt;stdio.h&gt;        	// printf</span><br><span class="line">#include &lt;stdlib.h&gt;        	// exit</span><br><span class="line">#include &lt;string.h&gt;        	// bzero</span><br><span class="line"> </span><br><span class="line">#define SERVER_PORT 6666 </span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;Usage: ./%s ServerIPAddress\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    //创建socket描述符</span><br><span class="line">    int client_socket = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if( client_socket &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;Create Socket Failed!\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    //设置server的地址，三元组</span><br><span class="line">    struct sockaddr_in server_addr;</span><br><span class="line">    bzero(&amp;server_addr,sizeof(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    if(inet_aton(argv[1],&amp;server_addr.sin_addr) == 0) //服务器的IP地址来自程序的参数</span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;Server IP Address Error!\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    //向服务器发起连接,连接成功后client_socket代表了客户机和服务器的一个socket连接</span><br><span class="line">    if(connect(client_socket,(struct sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;Can Not Connect To %s!\n&quot;,argv[1]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    printf(&quot;send msg to server!\n&quot;);</span><br><span class="line">    char sendline[BUFFER_SIZE];</span><br><span class="line">    fgets(sendline, BUFFER_SIZE, stdin);</span><br><span class="line"></span><br><span class="line">	// 向服务器发送数据</span><br><span class="line">    if (send(client_socket, sendline, strlen(sendline), 0) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;send msg error!\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(client_socket);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc server.c -o s</span><br><span class="line">gcc client.c -o c</span><br><span class="line"></span><br><span class="line"># ./s</span><br><span class="line">recv msg from client: hello socket</span><br><span class="line"></span><br><span class="line"># ./c 127.0.0.1</span><br><span class="line">send msg to server!</span><br><span class="line">hello socket     		// 交互输入</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cow和row快照机制的区别]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/snapshoot-cow-row/</url>
      <content type="html"><![CDATA[<p>很清晰的讲解快照两种模式cow和row的区别。<br><a id="more"></a></p>
<p>所谓快照，是指某数据集在某一时刻一个完全可用的拷贝。也叫即时拷贝。注意是一个完全可用的。如果是在window环境下，则要结合VSS 机制，把应用程序的buffer,文件系统的buffer,操作系统的buffer全部刷向磁盘后，再做快照。﻿</p>
<p>当前快照有两种实现，分别是COW（Copy on first write） 和ROW(Redirect on first write).﻿﻿﻿</p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>假如有一个卷8个物理块，分别为1~8， 在某一个时刻做了快照，这时候生成了一个快照卷，快照卷也有8个块，和原始卷一样指向相同的物理块。这时候有一个新的io，修改原始卷的第8个物理块，对COW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、读取第8个物理块﻿</li>
<li>3、新读取的第8个物理块数据写入到第9个物理块。﻿</li>
<li>4、更新快照卷map,指向第9个物理块﻿</li>
<li>5、更新第8个物理块﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/cow.jpg" alt="COW"></p>
<p>从上面可以看出，本来写一个物理块，变成了1读3写。﻿</p>
<p>COW 优点：﻿</p>
<p>1、原始卷物理块连续。没有碎片。﻿</p>
<p>COW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成1读3写。﻿﻿﻿</p>
<h2 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h2><p>对ROW 而言，会依次做如下几步﻿</p>
<ul>
<li>1、分配一个新的物理块。我们称为第9个物理块﻿</li>
<li>2、数据写入到第9个物理块。﻿</li>
<li>3、更新原始卷map,指向第9个物理块﻿﻿</li>
</ul>
<p>﻿<img src="http://ojet8bprn.bkt.clouddn.com/row.jpg" alt="ROW"></p>
<p>从上面可以看出，本来写一个物理块，变成了2写。﻿</p>
<p>ROW 优点：﻿</p>
<p>1、性能比COW 好。﻿</p>
<p>ROW 缺点：﻿</p>
<p>1、写放大，本来一个写，变成2写。﻿</p>
<p>2、原始卷物理块不连续。没、有碎片。</p>
<blockquote>
<p>本文为转载，原始链接未找到</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(5、6、7)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/09/Machine-Learning-Yearning-5%E3%80%816/</url>
      <content type="html"><![CDATA[<p>第5、6、7三章，主要讲开发集和测试集，包括选型、大小、比例等。<br><a id="more"></a></p>
<p><strong>update 2019:</strong></p>
<p>所有56篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning" target="_blank" rel="noopener">https://github.com/xiaqunfeng/machine-learning-yearning</a></p>
<p>Setting up development and test sets</p>
<p>设置开发和测试集</p>
<h2 id="Chapter-5、Your-development-and-test-sets"><a href="#Chapter-5、Your-development-and-test-sets" class="headerlink" title="Chapter 5、Your development and test sets"></a>Chapter 5、Your development and test sets</h2><p><strong>您的开发和测试集</strong><br>​    让我们回到我们早期猫图片的那个例子：你运行一个移动app，用户正在上传很多不同事物的图片到该app中。你想自动找到猫的图片。<br>​    您的团队通过从不同网站上下载猫（positive examples，正样本）和非猫（negative examples，负样本）的图获得一个大的训练集。 他们将数据集按照比例70％/ 30％分成训练集/测试集。 使用这些数据，他们构建了一个在训练集和测试集上都表现很好的的猫检测器。<br>​    但是当你将这个分类器部署到移动app时，你发现表现真的很糟糕！</p>
<p><img src="http://img.blog.csdn.net/20161209012152300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p>
<p>​    发生了什么？<br>​    您发现用户上传的图片与您构建训练集的网站图片有所不同：用户上传的照片使用手机拍摄，这些照片往往分辨率较低，比较模糊，并且采光不好。 由于您的训练集/测试集是由网站图片构建的，您的算法没有很好的兼顾到你所关心的智能手机图片的实际分布。<br>​    在大数据的时代之前，在机器学习中使用随机的70％/ 30％来分割训练集和测试集是常见的规则。 这种做法可以工作，但在越来越多的应用程序，如训练集的分布（上面例子中的网站图像）不同于你最终关心的分布（手机图像），这是一个坏主意。</p>
<p>​    我们通常定义：</p>
<ul>
<li>训练集 - 学习算法运行在这上面。</li>
<li>Dev（开发）集 - 用于调整参数，选择特征，以及对学习算法做出其他决定。 有时也称为维持交叉验证集(hold-out cross validation set)。</li>
<li><p>测试集 - 用于评估算法的性能，但不要做出关于使用什么学习算法或参数的任何决定。</p>
<p>​你定义一个开发集和测试集，你的团队会尝试很多想法，如不同的学习算法参数，看看什么是最好的。 开发集和测试集能够使你的团队快速看到你的算法做得有多好。</p>
<p>​换句话说，开发和测试集的目的是指导你的团队对机器学习系统进行最重要的更改。<br>​所以，你应该做如下事情：</p>
</li>
<li><p>选择开发和测试集，以反映您期望在未来获得的数据，并希望做好。</p>
<p>​换句话说，您的测试集不应该只是可用数据的30％这么简单，特别是如果您期望您的未来数据（移动app图片）在性质上与您的训练集（网站图像）不同时。</p>
<p>​如果您尚未启动移动app，可能还没有任何用户，因此可能无法获取准确反映您未来需要做的更好的数据。 但你可能仍然尝试去靠近它。 例如，请你的朋友拍一些手机图片，并发送给你。 一旦app启动后，您可以使用实际的用户数据更新您的开发集/测试集。<br>​如果你真的没有任何方法来获得接近你期望的未来数据，也许你可以从使用网站图像开始。 但是你应该意识到这将导致系统不能一般化的很好的风险。<br>​我们需要判断去决定多少投资开发好的开发集和测试集。 但是不要假定你的训练分布与你的测试分布是一样的。 尝试选择反映您最终想要表现良好的测试样本，而不是训练遇到的任何数据。</p>
</li>
</ul>
<h2 id="Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution"><a href="#Chapter-6、Your-dev-and-test-sets-should-come-from-the-same-distribution" class="headerlink" title="Chapter 6、Your dev and test sets should come from the same distribution"></a>Chapter 6、Your dev and test sets should come from the same distribution</h2><p><strong>你的开发集和测试集应该来自相同的分布</strong></p>
<p>根据您最大的市场，将猫应用图片数据分为四个区域：（i）美国，（ii）中国，（iii）印度和（iv）其他。要想出一个开发集和一个测试集，我们可以随机分配这两个区域到开发集，另外两个到测试集，对吧？ 比如美国和印度在开发集; 中国和其他在测试集。</p>
<p><img src="http://img.blog.csdn.net/20161209022552344?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>​    一旦定义了开发集和测试集，您的团队将专注于提高开发集的性能。 因此，开发集应该反映你最想提高的任务：在所有四个地区都要做得很好，而不只是两个。<br>​    开发集和测试集的不同分布带来的第二个问题：有一个机会，你的团队将构建一些在开发集件上工作得很好，只是发现它在测试集上做得不好。 我曾经在很多失望和白费的努力中看到这个结果。 避免让这些发生在你身上。<br>​    例如，假设您的团队开发的系统在开发集上工作的很好，但在测试集上并不如意。 如果你的开发集和测试集合来自相同的分布，那么你会有一个非常明确的诊断哪里出错了：你在开发集上过拟合(overfit)了。显而易见的方法是去获得更多的开发集数据。</p>
<p>​    但是如果开发集和测试集来自不同的分布，那么你的选择是不清晰的。几方面可能会出错：</p>
<ul>
<li>1、在开发集上过拟合。</li>
<li>2、测试集比开发集更难。所以你的算法可能做的和预期一样好，因此没有进一步的重大改进的可能了。</li>
<li><p>3、测试集不一定更难，但只是和开发集不同。所以在开发集上表现很好但并不能在测试集上表现一样。这种情况下，之前很多提高开发集性能的努力可能都白费了。</p>
<p>​在机器学习应用程序上工作是很艰难的。具有不匹配的开发和测试集引入了关于是否改进开发集分布也提高测试集性能额外的不确定性。具有不匹配的开发和测试集，使得更难找出什么是有效和无效的努力，因此使得更难以确定工作的优先级。<br>​如果你面临的是第三方基准测试 问题，他们的创建者可能会指定开发集和测试集来自不同的分布。相比开发和测试集来自同一分布，此时运气，而不是技术，将对这样的基准的性能有更大的影响。开发一个在一个分布上训练的很好同时能够很好的推广到另一个分布中的学习算法是一个重要的研究问题。但是如果你的目标是在一个特定的机器学习应用中取得进展，而不是研究进展，我建议尝试选择开发集和测试集从相同的分布。这将使您的团队更有效率。</p>
</li>
</ul>
<h2 id="Chapter-7、How-large-do-the-dev-test-sets-need-to-be"><a href="#Chapter-7、How-large-do-the-dev-test-sets-need-to-be" class="headerlink" title="Chapter 7、How large do the dev/test sets need to be?"></a>Chapter 7、How large do the dev/test sets need to be?</h2><p><strong>开发集/测试集需要多大？</strong></p>
<p>​    开发集应该足够大，以检测您尝试的算法之间的差异。例如，如果分类器A具有90.0％的准确度，分类器B具有90.1％的准确度，那么100个样本的开发集将不能检测出这0.1％的差异。与我看到的其他机器学习问题相比，100个样本的开发集太小了。常见的开发集的大小在1,000到10,000个样本之间。有10,000个样本，你将有很好的机会检测到这0.1％的提升。[2]<br>​    对于成熟和重要的应用，例如广告，网络搜索和产品建议 - 我也看到了很多团队，甚至为提升0.01％积极努力，因为它对公司的利润有直接影响。在这种情况下，开发集可以远大于10,000，以便检测出更小的提升。<br>​    测试集的大小应该多大？它应该足够大，使得对系统的整体性能有一个高的信心。一个流行的启发式方法是将30％的数据用于测试集。当你有适量的样本，比如100到10,000的样本，它会工作的很好。但在大数据的时代，我们现在有机器学习问题，有时会超过十亿个样本，分配给开发集/测试集的比例一直在缩小，即使开发集 /测试集中的样本绝对数量一直在增长。除了需要评估算法的性能之外，没有必要提供过大的开发集/测试集。</p>
<p>——————————</p>
<p>[2]. 在理论上，我们可以测试算法的变化是否对开发集产生统计上显着的差异。 在实践中，大多数团队不会为此困扰（除非他们出版学术研究论文），我通常没法发现统计意义的测试对测量临时进展是有用的。</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(3、4)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/03/Machine-Learning-Yearning-3%E3%80%814/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，第三章：预备知识和注释；第四章：规模驱使机器学习前进。<br><a id="more"></a></p>
<p><strong>update 2019:</strong></p>
<p>所有56篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning" target="_blank" rel="noopener">https://github.com/xiaqunfeng/machine-learning-yearning</a></p>
<h2 id="Chapter-3、Prerequisites-and-Notation"><a href="#Chapter-3、Prerequisites-and-Notation" class="headerlink" title="Chapter 3、Prerequisites and Notation"></a>Chapter 3、Prerequisites and Notation</h2><p><strong>预备知识和注释</strong><br>​    如果你有学习过机器学习课程，比如我在Coursera上的的机器学习MOOC，或者如果你有应用监督学习的经验，你也将能够理解这段文字。<br>​    我假设你熟悉监督学习（supervised learning）：使用标记的训练样本（x，y）去学习一个从x映射到y的函数。 监督学习算法包括线性回归（linear regression），逻辑回归（logistic regression）和神经网络（neural networks）。 机器学习的形式有很多，但是现如今大部分机器学习的实用价值来自于监督学习。<br>​    我将经常提到神经网络（也称为“deep learning”）。你只需要遵循本问对它是什么有一个基本的理解就可以了。<br>​    如果您不熟悉这里提到的概念，请观看在Coursera上前三周 机器学习视频课程<a href="http://ml-class.org" target="_blank" rel="noopener">http://ml-class.org</a></p>
<p><img src="http://img.blog.csdn.net/20161208234928384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="Chapter-4、Scale-drives-machine-learning-progress"><a href="#Chapter-4、Scale-drives-machine-learning-progress" class="headerlink" title="Chapter 4、Scale drives machine learning progress"></a>Chapter 4、Scale drives machine learning progress</h2><p><strong>规模驱使机器学习前进</strong></p>
<p>深度学习（神经网络）的许多想法已经存在几十年了。 为什么这些想法现在才火起来？<br>最近得以进步的最大驱动因素有两个：</p>
<ul>
<li>数据可用性。 人们现在在数字设备（笔记本电脑，移动设备）上花费更多的时间。这些活动产生大量的数据，我们可以使用这些数据来训练和反馈我们的学习算法。</li>
<li>计算尺度。 我们几年前才开始能够训练足够大的神经网络，以利用我们现在拥有的巨大的数据集。</li>
</ul>
<p>具体来说，即使你积累了更多的数据，通常传统学习算法（如逻辑回归）的性能表现“平稳”。这意味着它的学习曲线“平坦”，即使你给它更多的数据，算法也不会再有提升效果。</p>
<p><img src="http://img.blog.csdn.net/20161209001935676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这就好像传统的算法不知道如何处理我们现在拥有的所有数据。<br>如果你在同一个监督学习任务上训练一个小的神经网络（NN），你可能会获得略好一点的性能：</p>
<p><img src="http://img.blog.csdn.net/20161209002633511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里，“小的神经网络”是指仅具有少量隐藏单位/层/参数的神经网络。 最后，如果你训练越来越大的神经网络，你可以获得更好的性能：[1]</p>
<p><img src="http://img.blog.csdn.net/20161209003804359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>因此，当你做到下面两点的时候你会获得最佳的性能（i）训练一个非常大的神经网络，使其在上面的绿色曲线上; （ii）有大量的数据。<br>许多其他细节，如神经网络架构也很重要，这里已经有很多创新。 但是现在提高算法性能的更可靠的方法之一仍然是（i）训练更大的网络和（ii）获得更多的数据。<br>如何完成（i）和（ii）的方法是极其复杂的。 这本书将详细讨论细节。 我们将从对传统学习算法和神经网络都有用的一般策略开始，并建立构建深度学习系统所需的最先进策略。</p>
<p>[1]这个图表展示了NN在小数据集下做得更好。这种效果不如NNs在大数据集中表现良好的效果一致。 在小数据系统中，取决于特征是如何手工设计的，传统算法可能做的很好，也可能做得并不好。 例如，如果你有20个训练样本，那么使用逻辑回归还是神经网络可能并不重要; 手工特征的选择将比算法的选择产生更大的影响。 但如果你有100万的样本，我更倾向于神经网络。</p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Machine Learning Yearning(开篇、1、2)]]></title>
      <url>http://xiaqunfeng.cc/2017/03/02/Machine-Learning-Yearning-%E5%BC%80%E7%AF%87%E3%80%811%E3%80%812/</url>
      <content type="html"><![CDATA[<p>NG的机器学习教程，翻译过来，这里是开篇、第一章和第二章的内容。<br><a id="more"></a></p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>网上搜了一下，发现已经有一些翻译后的资料了，我这里就是边学习边翻译记录，主要作为给自己的学习笔记吧，并不冲突。</p>
<p>官网：<a href="http://www.mlyearning.org/" target="_blank" rel="noopener">http://www.mlyearning.org/</a></p>
<p>这里可以留下你的邮箱，当有更新的时候会发到你的邮箱（好像我关注后就没发过）。</p>
<p><strong>update 2019:</strong></p>
<p>所有56篇完整手稿已翻译完毕，详见：<a href="https://github.com/xiaqunfeng/machine-learning-yearning" target="_blank" rel="noopener">https://github.com/xiaqunfeng/machine-learning-yearning</a></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这本书的目的是教你如何做组织一个机器学习项目所需的大量的决定。 你将学习：</p>
<ul>
<li>如何建立你的开发和测试集</li>
<li>基本错误分析</li>
<li>如何使用偏差和方差来决定该做什么</li>
<li>学习曲线</li>
<li>将学习算法与人类水平的表现进行比较</li>
<li>调试推理算法</li>
<li>什么时候应该和不应该使用端到端的深度学习</li>
<li>按部进行错误分析</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>当前更新了14章，下载如下：</p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_01.pdf" target="_blank" rel="noopener">1-12章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_02.pdf" target="_blank" rel="noopener">13章</a></p>
<p><a href="https://gallery.mailchimp.com/dc3a7ef4d750c0abfc19202a3/files/Machine_Learning_Yearning_V0.5_03.pdf" target="_blank" rel="noopener">14章</a></p>
<h3 id="章节名称"><a href="#章节名称" class="headerlink" title="章节名称"></a>章节名称</h3><p>Chapter 1、Why Machine Learning Strategy<br>Chapter 2、How to use this book to help your team<br>Chapter 4、Prerequisites and Notation<br>Chapter 5、Scale drives machine learning progress<br>Chapter 6、Your development and test sets<br>Chapter 7、Your dev and test sets should come from the same distribution<br>Chapter 8、How large do the dev/test sets need to be?<br>Chapter 9、Establish a single-number evaluation metric for your team to optimize<br>Chapter 10、Optimizingandsatisficingmetrics<br>Chapter 11、Having a dev set and metric speeds up iterations<br>Chapter 12、When to change dev/test sets and metrics<br>Chapter 13、Takeaways: Setting up development and test sets<br>Chapter 14、Build your first system quickly, then iterate<br>Chapter 15、Error analysis: Look at dev set examples to evaluate ideas<br>Chapter 16、Evaluate multiple ideas in parallel during error analysis </p>
<p>（待添加）                </p>
<h2 id="Chapter-1、Why-Machine-Learning-Strategy"><a href="#Chapter-1、Why-Machine-Learning-Strategy" class="headerlink" title="Chapter 1、Why Machine Learning Strategy"></a>Chapter 1、Why Machine Learning Strategy</h2><p>为什么是机器学习策略</p>
<p>机器学习是无数重要应用程序的基础，包括网页搜索，电子邮件反垃圾邮件，语音识别，产品推荐等。我假设你或你的团队正在一个机器学习应用程序，并且你想要快速进步。那么这本书将帮助到你。</p>
<p>示例：构建一个cat图片启动</p>
<p>假设你正在建立一个创业公司，将为猫爱好者提供一个无尽的猫图片流。并使用神经网络建立一个计算机视觉系统，以检测图片中的猫。</p>
<p><img src="http://img.blog.csdn.net/20161208213001211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>但悲剧的是，你的学习算法的准确性还不够好。你面临着提高猫检测算法的巨大压力。你该怎么做？</p>
<p>您的团队有很多想法，例如：</p>
<p>•获取更多的数据：收集更多的猫的照片</p>
<p>•收集更多样化的培训集。例如，猫在不寻常的位置的图片;猫不寻常的着色;各种相机设置下拍摄出的猫图; ….</p>
<p>•通过运行更多的梯度下降迭代来增加算法的训练时间</p>
<p>•尝试更大的神经网络，具有更多的层/隐藏单位/参数</p>
<p>•尝试更小的神经网络。</p>
<p>•尝试添加正则化（例如L2正则化）</p>
<p>•改变神经网络架构（激活功能，隐藏单位数等）</p>
<p>•…</p>
<p>在这些可能的方向中，如果选择的好，你将会建立领先的猫图片平台，并带领公司走向成功。如果选择 不好，可能会浪费几个月的时间。你该怎么做？</p>
<p>这本书会告诉你怎么做。大多数机器学习问题留下的线索告诉你什么是有用的的尝试，什么是没用的尝试。学会阅读这些线索会节省你几个月甚至几年的开发时间。</p>
<h2 id="Chapter-2、How-to-use-this-book-to-help-your-team"><a href="#Chapter-2、How-to-use-this-book-to-help-your-team" class="headerlink" title="Chapter 2、How to use this book to help your team"></a>Chapter 2、How to use this book to help your team</h2><p>如何使用这本书来帮助你的团队<br>阅读完本书后，您将对如何设置机器学习项目的技术方向有深入的了解。<br>但是你的队友可能不明白你为什么要推荐一个特定的方向。 也许你希望你的团队定义一个单数评估指标，但他们不相信。 你如何说服他们？<br>这就是为什么我把章节短：所以，你可以打印出来，让你的队友只读你需要他们知道的那一两页。<br>优先级上的一些改变会对您的团队的生产力产生巨大的影响。 通过帮助您的团队进行一些这样的改变，我希望您可以成为您的团队的超级英雄！</p>
<p><img src="http://img.blog.csdn.net/20161208232515575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTk5OTk5OTk5OTk5OWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
      
        <categories>
            
            <category> MachineLearning </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[异步IO]]></title>
      <url>http://xiaqunfeng.cc/2017/03/01/asyc-io/</url>
      <content type="html"><![CDATA[<p>介绍了AIO，以及四种IO模型。<br><a id="more"></a></p>
<p>Linux® 中最常用的输入/输出（I/O）模型是同步 I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是很好的一种解决方案，因为调用应用程序在等待 I/O 请求完成时不需要使用任何中央处理单元（CPU）。但是在某些情况中，I/O 请求可能需要与其他进程产生交叠。可移植操作系统接口（POSIX）异步 I/O（AIO）应用程序接口（API）就提供了这种功能。在本文中，我们将对这个 API 概要进行介绍，并来了解一下如何使用它。</p>
<h2 id="AIO-简介"><a href="#AIO-简介" class="headerlink" title="AIO 简介"></a>AIO 简介</h2><p>Linux 异步 I/O 是 Linux 内核中提供的一个相当新的增强。它是 2.6 版本内核的一个标准特性，但是我们在 2.4 版本内核的补丁中也可以找到它。AIO 背后的基本思想是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。</p>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>在深入介绍 AIO API 之前，让我们先来探索一下 Linux 上可以使用的不同 I/O 模型。这并不是一个详尽的介绍，但是我们将试图介绍最常用的一些模型来解释它们与异步 I/O 之间的区别。图 1 给出了同步和异步模型，以及阻塞和非阻塞的模型。</p>
<p align="center">图 1. 基本 Linux I/O 模型的简单矩阵</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure1.gif" alt="基本 Linux I/O 模型的简单矩阵"></p>
<p>每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。</p>
<h3 id="同步阻塞-I-O"><a href="#同步阻塞-I-O" class="headerlink" title="同步阻塞 I/O"></a>同步阻塞 I/O</h3><h2 id="I-O-密集型与-CPU-密集型进程的比较"><a href="#I-O-密集型与-CPU-密集型进程的比较" class="headerlink" title="I/O 密集型与 CPU 密集型进程的比较"></a>I/O 密集型与 CPU 密集型进程的比较</h2><p>I/O 密集型进程所执行的 I/O 操作比执行的处理操作更多。CPU 密集型的进程所执行的处理操作比 I/O 操作更多。Linux 2.6 的调度器实际上更加偏爱 I/O 密集型的进程，因为它们通常会发起一个 I/O 操作，然后进行阻塞，这就意味着其他工作都可以在两者之间有效地交错进行。</p>
<p>最常用的一个模型是同步阻塞 I/O 模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p>
<p>图 2 给出了传统的阻塞 I/O 模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用 <code>read</code> 系统调用时，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时（从我们正在从中读取的设备中返回），数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞（<code>read</code> 调用返回）。</p>
<p align="center">图 2. 同步阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure2.gif" alt="同步阻塞 I/O 模型的典型流程"></p>
<p>从应用程序的角度来说，<code>read</code> 调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。</p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I/O"></a>同步非阻塞 I/O</h3><p>同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，<code>read</code>操作可能会返回一个错误代码，说明这个命令不能立即满足（<code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>），如图 3 所示。</p>
<p align="center">图 3. 同步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure3.gif" alt="同步非阻塞 I/O 模型的典型流程"></p>
<p>非阻塞的实现是 I/O 命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图 3 所示的一样，这个方法可以引入 I/O 操作的延时，因为数据在内核中变为可用到用户调用 <code>read</code> 返回数据之间存在一定的间隔，这会导致整体数据吞吐量的降低。</p>
<h3 id="异步阻塞-I-O"><a href="#异步阻塞-I-O" class="headerlink" title="异步阻塞 I/O"></a>异步阻塞 I/O</h3><p>另外一个阻塞解决方案是带有阻塞通知的非阻塞 I/O。在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 <code>select</code> 系统调用来确定一个 I/O 描述符何时有操作。使 <code>select</code> 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。</p>
<p align="center">图 4. 异步阻塞 I/O 模型的典型流程 (select)</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure4.gif" alt="异步阻塞 I/O 模型的典型流程"></p>
<p><code>select</code> 调用的主要问题是它的效率不是非常高。尽管这是异步通知使用的一种方便模型，但是对于高性能的 I/O 操作来说不建议使用。</p>
<h3 id="异步非阻塞-I-O（AIO）"><a href="#异步非阻塞-I-O（AIO）" class="headerlink" title="异步非阻塞 I/O（AIO）"></a>异步非阻塞 I/O（AIO）</h3><p>最后，异步非阻塞 I/O 模型是一种处理与 I/O 重叠进行的模型。读请求会立即返回，说明 <code>read</code> 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 <code>read</code> 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p>
<p align="center">图 5. 异步非阻塞 I/O 模型的典型流程</p>

<p><img src="https://www.ibm.com/developerworks/cn/linux/l-async/figure5.gif" alt="异步非阻塞 I/O 模型的典型流程"></p>
<p>在一个进程中为了执行多个 I/O 请求而对计算操作和 I/O 处理进行重叠处理的能力利用了处理速度与 I/O 速度之间的差异。当一个或多个 I/O 请求挂起时，CPU 可以执行其他任务；或者更为常见的是，在发起其他 I/O 的同时对已经完成的 I/O 进行操作。</p>
<h2 id="异步-I-O-的动机"><a href="#异步-I-O-的动机" class="headerlink" title="异步 I/O 的动机"></a>异步 I/O 的动机</h2><p>从前面 I/O 模型的分类中，我们可以看出 AIO 的动机。这种阻塞模型需要在 I/O 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 I/O 操作。同步非阻塞模型允许处理和 I/O 操作重叠进行，但是这需要应用程序根据重现的规则来检查 I/O 操作的状态。这样就剩下异步非阻塞 I/O 了，它允许处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。</p>
<p>除了需要阻塞之外，<code>select</code> 函数所提供的功能（异步阻塞 I/O）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 I/O 调用进行阻塞。</p>
<h2 id="Linux-上的-AIO-简介"><a href="#Linux-上的-AIO-简介" class="headerlink" title="Linux 上的 AIO 简介"></a>Linux 上的 AIO 简介</h2><p>本节将探索 Linux 的异步 I/O 模型，从而帮助我们理解如何在应用程序中使用这种技术。</p>
<p>在传统的 I/O 模型中，有一个使用惟一句柄标识的 I/O 通道。在 UNIX® 中，这些句柄是文件描述符（这对等同于文件、管道、套接字等等）。在阻塞 I/O 中，我们发起了一次传输操作，当传输操作完成或发生错误时，系统调用就会返回。</p>
<h2 id="Linux-上的-AIO"><a href="#Linux-上的-AIO" class="headerlink" title="Linux 上的 AIO"></a>Linux 上的 AIO</h2><p>AIO 在 2.5 版本的内核中首次出现，现在已经是 2.6 版本的产品内核的一个标准特性了。</p>
<p>在异步非阻塞 I/O 中，我们可以同时发起多个传输操作。这需要每个传输操作都有惟一的上下文，这样我们才能在它们完成时区分到底是哪个传输操作完成了。在 AIO 中，这是一个 <code>aiocb</code>（AIO I/O Control Block）结构。这个结构包含了有关传输的所有信息，包括为数据准备的用户缓冲区。在产生 I/O （称为完成）通知时，<code>aiocb</code> 结构就被用来惟一标识所完成的 I/O 操作。这个 API 的展示显示了如何使用它。</p>
<p>本文为转载文章, 原文链接：<a href="https://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="noopener">使用异步 I/O 大大提高应用程序的性能</a></p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bluestore调研]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/ceph-Bluestore/</url>
      <content type="html"><![CDATA[<p>这是之前关注bluestore时写的调研文章，主要介绍了bluestore的架构、存储模型、IO、元数据等，以及优势。现在ceph已经出到K版本了，虽然未在生产中实践，但已经可用。<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    Ceph是一种软件定义存储解决方案，因此Ceph的主要目标是保障存储数据的安全。为了达到数据安全的目的，我们需要原子特性。目前没有一种文件存储系统能够提供写和更新操作的原子特性（Btrfs拥有原子特性的事务, 这是人们为了解决上述问题作出的尝试，但事实上并不成功）。</p>
<p>​    Ceph开发者不得不探索其他的解决方案。这个解决方案就是大家非常熟悉的Ceph日志。ceph后端的存储引擎目前使用的是filestore，写采用的是WAL的方式，但是写前记录日志这种技术有一个主要缺陷就是它把你的硬盘性能降低到原来的二分之一（仅当日志和OSD数据共享同一个硬盘时），因为filestore在写数据前需要先写journal，所以有一倍的写放大。</p>
<p>​    同时filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑。bluestore的初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销。</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="bluestore架构图"></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>RocksDB</td>
<td>存储预写式日志、数据对象元数据、Ceph的omap数据信息、以及分配器的元数据（分配器负责决定真正的数据应在什么地方存储）</td>
</tr>
<tr>
<td>BlueRocksEnv</td>
<td>与RocksDB交互的接口</td>
</tr>
<tr>
<td>BlueFS</td>
<td>小的文件系统，解决元数据、文件空间及磁盘空间的分配和管理，并实现了rocksdb::Env 接口(存储RocksDB日志和sst文件)。因为rocksdb常规来说是运行在文件系统的顶层，下面是BlueFS。 它是数据存储后端层，RocksDB的数据和BlueStore中的真正数据被存储在同一个块物理设备</td>
</tr>
<tr>
<td>HDD</td>
<td>物理块设备，存储实际的数据</td>
</tr>
</tbody>
</table>
<p>​    rocksdb本身是基于文件系统的，不是直接操作裸设备。它将系统相关的处理抽象成Env，用户可用实现相应的接口（<em>rocksdb默认的Env是PosixEnv，直接对接本地文件系统</em>）。</p>
<p>​    BlueRocksEnv是bluestore实现的一个类，继承自rocksdb::EnvWrapper，来为rocksdb提供底层系统的封装。</p>
<p>​    为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口。所有的元数据的修改都记录在BlueFS的日志中，也就是对于BlueFS，元数据的持久化保存在日志中。在系统启动mount这个文件系统时，只需replay日志，就可将所有的元数据都加载到内存中。BluesFS的数据和日志文件都通过块设备保存到裸设备上（<em>BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备</em>）。</p>
<p>​    bluestore不使用本地文件系统，直接接管裸设备，并且只使用一个原始分区，HDD所在的物理块设备实现在用户态下使用linux aio直接对裸设备进行I/O操作。</p>
<blockquote>
<p>读：目前块设备的读操作是同步的；</p>
<p>写：由于操作系统支持的aio操作只支持directIO，所以对BlockDevice的写操作直接写入磁盘，并且需要按照page对齐。其内部有一个aio_thread 线程，用来检查aio是否完成。其完成后，通过回调函数aio_callback 通知调用方。 </p>
</blockquote>
<p>​    Ceph数据对象(真正的‘数据’)直接被写入块物理设备。因为是直接管理裸设备，所以需要分配器（Allocator）来进行裸设备的空间管理。OSD附带的数据对象元数据被存储到键值数据库RocksDB中。</p>
<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2><p> <img src="http://ojet8bprn.bkt.clouddn.com/Bluestore%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B.png" alt="bluestore存储模型"></p>
<p>这里把一个硬盘分了两个分区：</p>
<ol>
<li>第一个迷你小分区使用了XFS或ext4文件系统。它存储了Ceph文件（像初始系统描述符，状态，id，fsid，钥匙串等），和RocksDB文件(RocksDB元数据和预写式日志)。</li>
<li>第二个分区是没有文件系统的原始分区。</li>
</ol>
<p>​        每一个组件都可以存储在一个不同的物理设备上。在这张图中，RocksDB的预写式日志和数据可以被存储在不同的物理设备也可以存储在迷你小分区上。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>​    数据结构onode 保存了BlueStore中一个对象的数据结构，这是一个常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。一个onode里会存在多个lextent（逻辑的数据块），用一个map来记录。lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。blob和pextent是多对多的关系。</p>
<p>​    数据结构Enode定义了一个共享的extent，也就是这段数据被多个对象共享，一个对象的onode里保存一个enode数据结构，记录该对象被共享的extent。</p>
<h2 id="I-O处理"><a href="#I-O处理" class="headerlink" title="I/O处理"></a>I/O处理</h2><p>​    到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在执行写操作时，首先就会根据最小分配单位min_alloc_size进行判断，并按照min_alloc_size进行拆分，从而将I/O分为对齐和非对齐的。落到某一个min_alloc_size区间的写I/O执行非对齐写，min_alloc_size整数倍的写I/O执行对齐写。</p>
<p><strong>整块写（对齐写）</strong></p>
<p>​    也就是对齐到min_alloc_size的写请求，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍。如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。（PS:回收这部分还没看）</p>
<p><strong>部分写（非对齐写）</strong></p>
<p>​    在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p>
<p>1、没有找到可以复用的blob，新生成blob</p>
<p>​    在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操，然后再把对齐后的offset和len作为lextent，进而放到blob里。之所以需要进行补零操作是因为采用Direct I/O的方式写盘要求偏移和缓冲区都对齐的。</p>
<p>2、找到可以复用的blob</p>
<p>​    先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p>
<p><em>a) 直接写在blob未使用的空间上</em></p>
<p>​    这种情况下直接新生成lextent放到blob里。</p>
<p><em>b) 覆盖写的情况</em></p>
<p>​    通过WAL写到rocksdb。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    从BlueStore 的设计和实现上看，可以将其理解为用户态下的一个文件系统，同时使用RocksDB来实现BlueStore所有元数据的管理，简化实现。</p>
<p><strong>优点</strong></p>
<p>​    对于整块数据的写入，数据直接以aio的方式写入磁盘，再更新RocksDB中数据对象的元数据，避免了filestore的先写日志，后apply到实际磁盘的两次写盘。同时避免了日志元数据的冗余存储占用，因为传统文件系统有他们自己内部的日志和元数据管理机制。</p>
<p>​    对于随机IO，直接WAL的形式，写入RocksDB 高性能的KV存储中。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RocksDB相比LevelDB的新特性]]></title>
      <url>http://xiaqunfeng.cc/2017/02/23/RocksDB-LevelDB/</url>
      <content type="html"><![CDATA[<p>如题，具体列举了RocksDB中相比LevelDB的一些新特性。<br><a id="more"></a></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>多线程压缩</li>
<li>多线程memtable插入</li>
<li>减少DB互斥体保持</li>
<li>优化的基于级别的压缩风格和通用压缩风格</li>
<li>前缀bloom过滤器</li>
<li>Memtable布隆过滤器</li>
<li>覆盖整个SST文件的单个布过滤器</li>
<li>写锁优化</li>
<li>改进<code>Iter :: Prev（）</code>性能</li>
<li>在SkipList搜索期间，较少的比较器调用</li>
<li>使用巨大的页面分配memtable内存</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>列簇（column families）</li>
<li>事务和WriteBatchWithIndex</li>
<li>备份和检查点</li>
<li>合并操作</li>
<li>压缩过滤器</li>
<li>RocksDB Java</li>
<li>手动压缩与自动压缩并行运行</li>
<li>持久化缓存</li>
<li>批量加载</li>
<li>前向迭代器/尾部迭代器</li>
<li>单个删除</li>
<li>范围删除文件</li>
<li>引脚迭代器key/value</li>
</ul>
<h2 id="替换的数据结构和格式"><a href="#替换的数据结构和格式" class="headerlink" title="替换的数据结构和格式"></a>替换的数据结构和格式</h2><ul>
<li>仅用于内存使用情况的纯表格式</li>
<li>基于向量和基于哈希的memtable格式</li>
<li>基于时钟的缓存（即将推出）</li>
<li>可插拔信息日志</li>
<li>使用blob注释事务日志写入（用于副本）</li>
</ul>
<h2 id="可调性"><a href="#可调性" class="headerlink" title="可调性"></a>可调性</h2><ul>
<li>速率限制</li>
<li>可调减速和停止阈值</li>
<li>保持所有文件打开的选项</li>
<li>将所有索引和bloom过滤器块保留在块缓存中的选项</li>
<li>多种WAL恢复模式</li>
<li>Fadvise提示用于预读和避免在OS页面缓存中缓存</li>
<li>用于在内存中固定L0文件的索引和bloom过滤器的选项</li>
<li>更多压缩类型：zlib，lz4，zstd</li>
<li>压缩字典</li>
<li>校验类型：xxhash</li>
<li>每级的不同级别尺寸乘法器和压缩类型</li>
</ul>
<h2 id="可管理性"><a href="#可管理性" class="headerlink" title="可管理性"></a>可管理性</h2><ul>
<li>统计</li>
<li>Thread-local分析</li>
<li>命令行工具中的更多命令</li>
<li>用户定义的表属性</li>
<li>事件侦听器</li>
<li>更多数据库属性</li>
<li>动态选项更改</li>
<li>从字符串或映射获取选项</li>
<li>选项文件的持久性选项</li>
</ul>
<p>英文原文链接：<a href="https://github.com/facebook/rocksdb/wiki/Features-Not-in-LevelDB" target="_blank" rel="noopener">Features Not in LevelDB</a></p>
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kernel modules (简体中文)]]></title>
      <url>http://xiaqunfeng.cc/2017/02/20/kenel-modules/</url>
      <content type="html"><![CDATA[<p>介绍了内核模块的相关操作。加载、查看info、卸载、配置等……<br><a id="more"></a></p>
<p>相关文章</p>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Boot_Debugging" target="_blank" rel="noopener">Boot Debugging</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Kernels_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Kernels (简体中文)</a>)</li>
<li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Kernel parameters (简体中文)</a>)</li>
</ul>
<p><strong>翻译状态： </strong>本文是英文页面 <a href="https://wiki.archlinux.org/index.php/Kernel_modules" target="_blank" rel="noopener">Kernel_modules</a> 的<a href="https://wiki.archlinux.org/index.php/ArchWiki_Translation_Team_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">翻译</a>)，最后翻译时间：2013-07-06，点击<a href="https://wiki.archlinux.org/index.php?title=Kernel_modules&amp;diff=0&amp;oldid=264846" target="_blank" rel="noopener">这里</a>可以查看翻译后英文页面的改动。</p>
<p><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module" target="_blank" rel="noopener">内核模块</a>是可以按需加载或卸载的内核代码，可以不重启系统就扩充内核的功能。</p>
<blockquote>
<p>本文为转载文章，原文链接见文末</p>
</blockquote>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>要创建内核模块，请阅读<a href="http://tldp.org/LDP/lkmpg/2.6/html/index.html" target="_blank" rel="noopener">此指南</a>。模块可以设置成内置或者动态加载，要编译成可动态加载，需要在内核配置时将模块配置为 <code>M</code> (模块)。</p>
<p>模块保存在 <code>/lib/modules/*kernel_release*</code> (使用 <code>uname -r</code> 命令显示当前内核版本)。</p>
<p><strong>注意: </strong>模块名通常使用 (<code>_</code>) 或 <code>-</code> 连接，但是这些符号在 <code>modprobe</code> 命令和 <code>/etc/modprobe.d/</code> 配置文件中都是可以相互替换的。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><p>显示当前装入的内核模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod</span><br></pre></td></tr></table></figure>
<p>显示模块信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ modinfo module_name</span><br></pre></td></tr></table></figure>
<p>显示所有模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe -c | less</span><br></pre></td></tr></table></figure>
<p>显示某个模块的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe -c | grep module_name</span><br></pre></td></tr></table></figure>
<p>显示一个装入模块使用的选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systool -v -m module_name</span><br></pre></td></tr></table></figure>
<p>显示模块的依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe --show-depends module_name</span><br></pre></td></tr></table></figure>
<h2 id="手动加载卸载"><a href="#手动加载卸载" class="headerlink" title="手动加载卸载"></a>手动加载卸载</h2><p>控制内核模块载入/移除的命令是<a href="https://www.archlinux.org/packages/?name=kmod" target="_blank" rel="noopener">kmod</a> 软件包提供的, 要手动装入模块的话，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># modprobe module_name</span><br></pre></td></tr></table></figure>
<p>如果要移除一个模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># modprobe -r module_name</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod module_name</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前，所有必要模块的加载均由 <a href="https://wiki.archlinux.org/index.php/Udev" target="_blank" rel="noopener">udev</a> 自动完成。所以，如果不需要使用任何额外的模块，就没有必要在任何配置文件中添加启动时加载的模块。但是，有些情况下可能需要在系统启动时加载某个额外的模块，或者将某个模块列入黑名单以便使系统正常运行。</p>
<h3 id="开机加载"><a href="#开机加载" class="headerlink" title="开机加载"></a>开机加载</h3><p>systemd 读取 <code>/etc/modules-load.d/</code> 中的配置加载额外的内核模块。配置文件名称通常为 <code>/etc/modules-load.d/.conf</code>。格式很简单，一行一个要读取的模块名，而空行以及第一个非空格字符为<code>#</code>或<code>;</code>的行会被忽略，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modules-load.d/virtio-net.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Load virtio-net.ko at boot</span><br><span class="line">virtio-net</span><br></pre></td></tr></table></figure>
<p>另见<code>man 5 modules-load.d</code>。</p>
<h3 id="配置内核模块参数"><a href="#配置内核模块参数" class="headerlink" title="配置内核模块参数"></a>配置内核模块参数</h3><h3 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用 /etc/modprobe.d/中的文件"></a>使用 /etc/modprobe.d/中的文件</h3><p>要通过配置文件传递参数，在 <code>/etc/modprobe.d/</code> 中放入任意名称 <code>.conf</code> 文件，加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/myfilename.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options modname parametername=parametercontents</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/thinkfan.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># On thinkpads, this lets the thinkfan daemon control fan speed</span><br><span class="line">options thinkpad_acpi fan_control=1</span><br></pre></td></tr></table></figure>
<p><strong>注意: </strong>如果要在启动时就修改内核参数(从 init ramdisk 开始)，需要将相应的<code>.conf</code>-文件加入 <a href="https://wiki.archlinux.org/index.php/Mkinitcpio.conf" target="_blank" rel="noopener">mkinitcpio.conf</a> 的 FILES 参数中。</p>
<h3 id="使用内核命令行"><a href="#使用内核命令行" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>如果模块直接编译进内核，也可以通过启动管理器(<a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="noopener">GRUB</a>, <a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="noopener">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="noopener">Syslinux</a>)的内核行加入参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modname.parametername=parametercontents</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thinkpad_acpi.fan_control=1</span><br></pre></td></tr></table></figure>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/myalias.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Lets you use &apos;mymod&apos; in MODULES, instead of &apos;really_long_module_name&apos;</span><br><span class="line">alias mymod really_long_module_name</span><br></pre></td></tr></table></figure>
<p>有些模块具有别名，以方便其它程序自动装入模块。禁用这些别名可以阻止自动装入，但是仍然可以手动装入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/modprobe.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Prevent autoload of bluetooth</span><br><span class="line">alias net-pf-31 off</span><br><span class="line"></span><br><span class="line"># Prevent autoload of ipv6</span><br><span class="line">alias net-pf-10 off</span><br></pre></td></tr></table></figure>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><h3 id="禁用内核模块"><a href="#禁用内核模块" class="headerlink" title="禁用内核模块"></a>禁用内核模块</h3><p>对内核模块来说，黑名单是指禁止某个模块装入的机制。当对应的硬件不存在或者装入某个模块会导致问题时很有用。</p>
<p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs" target="_blank" rel="noopener">initramfs</a> 的一部分装入。</p>
<p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d/modprobe.conf</code> 中将它们加入黑名单。</p>
<p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果要禁用这些模块，记得在配置完成后,将<code>.conf</code>文件加入<code>/etc/mkinitcpio.conf</code> 的 FILES 部分，然后重新生成 initramfs。</p>
<h3 id="使用-etc-modprobe-d-中的文件-1"><a href="#使用-etc-modprobe-d-中的文件-1" class="headerlink" title="使用 /etc/modprobe.d/ 中的文件"></a>使用 /etc/modprobe.d/ 中的文件</h3><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/nobeep.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Do not load the pcspkr module on boot</span><br><span class="line">blacklist pcspkr</span><br></pre></td></tr></table></figure>
<p><strong>注意: </strong><code>blacklist</code> 命令将屏蔽一个模板，所以不会自动装入，但是如果其它非屏蔽模块需要这个模块，系统依然会装入它。</p>
<p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，直接返回导入失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">install MODULE /bin/false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p>
<h3 id="使用内核命令行-1"><a href="#使用内核命令行-1" class="headerlink" title="使用内核命令行"></a>使用内核命令行</h3><p>同样可以通过内核命令行(位于 <a href="https://wiki.archlinux.org/index.php/GRUB" target="_blank" rel="noopener">GRUB</a>、<a href="https://wiki.archlinux.org/index.php/LILO" target="_blank" rel="noopener">LILO</a> 或 <a href="https://wiki.archlinux.org/index.php/Syslinux" target="_blank" rel="noopener">Syslinux</a>)禁用模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe.blacklist=modname1,modname2,modname3</span><br></pre></td></tr></table></figure>
<p>当某个模块导致系统无法启动时，可以使用此方法禁用模块。</p>
<p>参阅<a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="noopener">Kernel parameters</a>.</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="显示所有内核参数的脚本"><a href="#显示所有内核参数的脚本" class="headerlink" title="显示所有内核参数的脚本"></a>显示所有内核参数的脚本</h3><p>下面的 bash 脚本可以显示当前装入模块、模块参数及当前参数的数值。它使用 <code>/proc/modules</code> 获取当前装入模块的列表，然后用 modinfo 获取模块的描述和模块的参数，最后访问 sysfs 文件系统获得当前模块名和参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function aa_mod_parameters () </span><br><span class="line">&#123; </span><br><span class="line">    N=/dev/null;</span><br><span class="line">    C=`tput op` O=$(echo -en &quot;\n`tput setaf 2`&gt;&gt;&gt; `tput op`&quot;);</span><br><span class="line">    for mod in $(cat /proc/modules|cut -d&quot; &quot; -f1);</span><br><span class="line">    do</span><br><span class="line">        md=/sys/module/$mod/parameters;</span><br><span class="line">        [[ ! -d $md ]] &amp;&amp; continue;</span><br><span class="line">        m=$mod;</span><br><span class="line">        d=`modinfo -d $m 2&gt;$N | tr &quot;\n&quot; &quot;\t&quot;`;</span><br><span class="line">        echo -en &quot;$O$m$C&quot;;</span><br><span class="line">        [[ $&#123;#d&#125; -gt 0 ]] &amp;&amp; echo -n &quot; - $d&quot;;</span><br><span class="line">        echo;</span><br><span class="line">        for mc in $(cd $md; echo *);</span><br><span class="line">        do</span><br><span class="line">            de=`modinfo -p $mod 2&gt;$N | grep ^$mc 2&gt;$N|sed &quot;s/^$mc=//&quot; 2&gt;$N`;</span><br><span class="line">            echo -en &quot;\t$mc=`cat $md/$mc 2&gt;$N`&quot;;</span><br><span class="line">            [[ $&#123;#de&#125; -gt 1 ]] &amp;&amp; echo -en &quot; - $de&quot;;</span><br><span class="line">            echo;</span><br><span class="line">        done;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># aa_mod_parameters</span><br><span class="line">&gt;&gt;&gt; ehci_hcd - USB 2.0 &apos;Enhanced&apos; Host Controller (EHCI) Driver</span><br><span class="line">        hird=0 - hird:host initiated resume duration, +1 for each 75us (int)</span><br><span class="line">        ignore_oc=N - ignore_oc:ignore bogus hardware overcurrent indications (bool)</span><br><span class="line">        log2_irq_thresh=0 - log2_irq_thresh:log2 IRQ latency, 1-64 microframes (int)</span><br><span class="line">        park=0 - park:park setting; 1-3 back-to-back async packets (uint)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; processor - ACPI Processor Driver</span><br><span class="line">        ignore_ppc=-1 - ignore_ppc:If the frequency of your machine gets wronglylimited by BIOS, this should help (int)</span><br><span class="line">        ignore_tpc=0 - ignore_tpc:Disable broken BIOS _TPC throttling support (int)</span><br><span class="line">        latency_factor=2 - latency_factor: (uint)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; usb_storage - USB Mass Storage driver for Linux</span><br><span class="line">        delay_use=1 - delay_use:seconds to delay before using a new device (uint)</span><br><span class="line">        option_zero_cd=1 - option_zero_cd:ZeroCD mode (1=Force Modem (default), 2=Allow CD-Rom (uint)</span><br><span class="line">        quirks= - quirks:supplemental list of device IDs and their quirks (string)</span><br><span class="line">        swi_tru_install=1 - swi_tru_install:TRU-Install mode (1=Full Logic (def), 2=Force CD-Rom, 3=Force Modem) (uint)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; video - ACPI Video Driver</span><br><span class="line">        allow_duplicates=N - allow_duplicates: (bool)</span><br><span class="line">        brightness_switch_enabled=Y - brightness_switch_enabled: (bool)</span><br><span class="line">        use_bios_initial_backlight=Y - use_bios_initial_backlight: (bool)</span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://wiki.archlinux.org/index.php/Kernel_modules_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">kernel modules</a>)</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——pgrep和pkill]]></title>
      <url>http://xiaqunfeng.cc/2017/02/17/linux-cmd-pgrep-pkill/</url>
      <content type="html"><![CDATA[<p>通过程序名来查询进程PID的命令pgrep，以及对应的杀进程命令pkill。<br><a id="more"></a></p>
<h2 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h2><p>在linux中查看进程信息，经常要用到<code>pa auxf</code>，具体到某个进程的时候，又需进行grep管道。如：<code>ps auxf|grep java|grep -v grep</code> ，即然这么长，可以不可以简化呢？当然可以，如果还是使用ps命令的话，可以改为<code>ps auxf|grep jav[a]</code>，这样就不用排除自身了。不过感觉命令还是长了点，能不能再简点，可以，使用<code>pgrep java</code>，不过此时得出的只是pid 。</p>
<p>pgrep是linux中常用的通过 <strong>程序名</strong> 来查询进程PID信息的命令。</p>
<p>pgrep命令相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep KeyWord</span><br></pre></td></tr></table></figure>
<p>注：pgrep命令查找的的是程序名，不包括其参数。如果参数里包括查找的keyword，而程序名中不包括，所则使用pgrep命令无法查到该进程。这时可以使用<code>ps -aux|grep keyword</code>命令。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure>
<p>默认只显示PID，可以加选项来显示更多信息</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>通过命令 <code>pgrep --help</code> 获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line"> -d, --delimiter &lt;string&gt;  specify output delimiter</span><br><span class="line"> -l, --list-name           list PID and process name</span><br><span class="line"> -v, --inverse             negates the matching</span><br><span class="line"> -w, --lightweight         list all TID</span><br><span class="line"> -c, --count               count of matching processes</span><br><span class="line"> -f, --full                use full process name to match</span><br><span class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</span><br><span class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</span><br><span class="line"> -n, --newest              select most recently started</span><br><span class="line"> -o, --oldest              select least recently started</span><br><span class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</span><br><span class="line"> -s, --session &lt;sid,...&gt;   match session IDs</span><br><span class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</span><br><span class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</span><br><span class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</span><br><span class="line"> -x, --exact               match exactly with the command name</span><br><span class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</span><br><span class="line"> -L, --logpidfile          fail if PID file is not locked</span><br><span class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</span><br><span class="line">                           namespace as &lt;pid&gt;</span><br><span class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</span><br><span class="line">                           the --ns option.</span><br><span class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br></pre></td></tr></table></figure>
<p>翻译和解释如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>定义输出的多个进程之间的分隔符（默认使用换行符）</td>
</tr>
<tr>
<td>-l</td>
<td>列出pid 和 进程名</td>
</tr>
<tr>
<td>-v</td>
<td>否定匹配，即列出除了查找的进程以外的其他进程</td>
</tr>
<tr>
<td>-w</td>
<td>列出所有的TID</td>
</tr>
<tr>
<td>-c</td>
<td>统计匹配到的所有进程数量</td>
</tr>
<tr>
<td>-f</td>
<td>用进程全名去匹配</td>
</tr>
<tr>
<td>-g</td>
<td>匹配列出的进程组ID</td>
</tr>
<tr>
<td>-G</td>
<td>其后跟着一组group id，该命令在搜索时，仅考虑group列表中的进程。</td>
</tr>
<tr>
<td>-n</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最新的，即最后启动的。</td>
</tr>
<tr>
<td>-o</td>
<td>表示如果该程序有多个进程正在运行，则仅查找最老的，即最先启动的（多个进程时即父进程PID）。</td>
</tr>
<tr>
<td>-P</td>
<td>根据父进程PID，找出所有子进程的pid</td>
</tr>
<tr>
<td>-s</td>
<td>匹配会话ID</td>
</tr>
<tr>
<td>-t</td>
<td>通过控制终端匹配</td>
</tr>
<tr>
<td>-u</td>
<td>其后跟着一组有效用户ID(effetive user id)，该命令在搜索时，仅考虑该effective user列表中的进程。</td>
</tr>
<tr>
<td>-U</td>
<td>其后跟着一组实际用户ID(real user id)，该命令在搜索时，仅考虑该real user列表中的进程。</td>
</tr>
<tr>
<td>-x</td>
<td>表示进程的名字必须完全匹配, 以上的选项均可以部分匹配。</td>
</tr>
<tr>
<td>-F</td>
<td>从文件中读取PID</td>
</tr>
<tr>
<td>-L</td>
<td>如果PID文件未锁定，则失败</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="列出要查找的进程"><a href="#列出要查找的进程" class="headerlink" title="列出要查找的进程"></a>列出要查找的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l ceph</span><br><span class="line">1478 ceph-msgr</span><br><span class="line">4682 ceph-watch-noti</span><br><span class="line">7058 ceph-mon</span><br><span class="line">9371 ceph-osd</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ps -eo pid,cmd | awk &apos;&#123;print $1,$2&#125;&apos;  | grep ceph</span><br><span class="line">1478 [ceph-msgr]</span><br><span class="line">4682 [ceph-watch-noti]</span><br><span class="line">7058 /usr/bin/ceph-mon</span><br><span class="line">9371 /usr/bin/ceph-osd</span><br></pre></td></tr></table></figure>
<h4 id="自定义输出进程间分隔符"><a href="#自定义输出进程间分隔符" class="headerlink" title="自定义输出进程间分隔符"></a>自定义输出进程间分隔符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -d , ceph</span><br><span class="line">1478 ceph-msgr,4682 ceph-watch-noti,7058 ceph-mon,9371 ceph-osd</span><br><span class="line"># pgrep -l -d ... ceph</span><br><span class="line">1478 ceph-msgr...4682 ceph-watch-noti...7058 ceph-mon...9371 ceph-osd</span><br></pre></td></tr></table></figure>
<h4 id="否定匹配"><a href="#否定匹配" class="headerlink" title="否定匹配"></a>否定匹配</h4><p>列出所有进程名中不包含 ceph 的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -v ceph</span><br><span class="line">...</span><br><span class="line">4046 scst_mgmtd</span><br><span class="line">5408 kworker/2:1H</span><br><span class="line">6402 bioset</span><br><span class="line">6403 rbd00_0</span><br><span class="line">8734 rbd01_0</span><br><span class="line">8739 xfsalloc</span><br><span class="line">8741 xfs_mru_cache</span><br><span class="line">9153 xfs-buf/vdb1</span><br><span class="line">9154 xfs-data/vdb1</span><br><span class="line">9155 xfs-conv/vdb1</span><br><span class="line">9156 xfs-cil/vdb1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="列出所有TID"><a href="#列出所有TID" class="headerlink" title="列出所有TID"></a>列出所有TID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -w ceph</span><br><span class="line">1478 ceph-msgr</span><br><span class="line">4682 ceph-watch-noti</span><br><span class="line">7058 ceph-mon</span><br><span class="line">7062 ceph-mon</span><br><span class="line">7063 ceph-mon</span><br><span class="line">...</span><br><span class="line">6661 ceph-mon</span><br><span class="line">9371 ceph-osd</span><br><span class="line">9373 ceph-osd</span><br><span class="line">9374 ceph-osd</span><br><span class="line">...</span><br><span class="line">9702 ceph-osd</span><br><span class="line">27446 ceph-osd</span><br></pre></td></tr></table></figure>
<h4 id="统计匹配到的进程数"><a href="#统计匹配到的进程数" class="headerlink" title="统计匹配到的进程数"></a>统计匹配到的进程数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -c ceph</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="匹配全名"><a href="#匹配全名" class="headerlink" title="匹配全名"></a>匹配全名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -f ceph</span><br><span class="line">1478 ceph-msgr</span><br><span class="line">4682 ceph-watch-noti</span><br><span class="line">7058 ceph-mon</span><br><span class="line">9371 ceph-osd</span><br></pre></td></tr></table></figure>
<p>感觉并没有什么卵用</p>
<h4 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h4><p>//TODO</p>
<h4 id="查找最新和最旧进程"><a href="#查找最新和最旧进程" class="headerlink" title="查找最新和最旧进程"></a>查找最新和最旧进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l ceph</span><br><span class="line">1478 ceph-msgr</span><br><span class="line">4682 ceph-watch-noti</span><br><span class="line">7058 ceph-mon</span><br><span class="line">9371 ceph-osd</span><br></pre></td></tr></table></figure>
<p>查找最新(newest)、最后启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -n ceph</span><br><span class="line">4682 ceph-watch-noti</span><br></pre></td></tr></table></figure>
<p>查找最旧(oldest)、最早启动的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -o ceph</span><br><span class="line">7058 ceph-mon</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：进程号越大，并不一定意味着进程的启动时间越晚、进程越新</p>
</blockquote>
<h4 id="显示所有父进程的子进程"><a href="#显示所有父进程的子进程" class="headerlink" title="显示所有父进程的子进程"></a>显示所有父进程的子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -P 2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br></pre></td></tr></table></figure>
<h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l ceph</span><br><span class="line">1478 ceph-msgr</span><br><span class="line">4682 ceph-watch-noti</span><br><span class="line">7058 ceph-mon</span><br><span class="line">9371 ceph-osd</span><br><span class="line"># pgrep -x ceph</span><br><span class="line"># pgrep -x ceph-osd</span><br><span class="line">9371</span><br></pre></td></tr></table></figure>
<h4 id="从文件中读取PID"><a href="#从文件中读取PID" class="headerlink" title="从文件中读取PID"></a>从文件中读取PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat pid-file.txt </span><br><span class="line">1478</span><br><span class="line">7051</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -l -F pid-file.txt </span><br><span class="line">1478 ceph-msgr</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>PID和TID的区别</p>
<p>pid是进程标识符，tid是线程标识符。</p>
<p>内核不会在它们之间做出真正的区分：线程就像进程一样，但它们与同一组的其他实例共享一些东西（内存，fds …）。</p>
<p>因此，tid实际上是内核（线程）中可调度对象的标识符，而pid是共享内存和fds（进程）的可调度对象组的标识符。当一个进程只有一个线程，pid和tid总是相同的。 所以任何使用tid的函数都会自动使用pid。</p>
<p>值得注意的是，许多函数/系统调用/命令行实用程序记录使用pid实际上使用tids。 但如果效果是过程范围的，你就不会注意到差异。</p>
<h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>与 <code>pgrep</code> 使用方法基本类似，不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># pkill --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> pkill [options] &lt;pattern&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -&lt;sig&gt;, --signal &lt;sig&gt;    signal to send (either number or name)</span><br><span class="line"> -e, --echo                display what is killed</span><br><span class="line"> -c, --count               count of matching processes</span><br><span class="line"> -f, --full                use full process name to match</span><br><span class="line"> -g, --pgroup &lt;id,...&gt;     match listed process group IDs</span><br><span class="line"> -G, --group &lt;gid,...&gt;     match real group IDs</span><br><span class="line"> -n, --newest              select most recently started</span><br><span class="line"> -o, --oldest              select least recently started</span><br><span class="line"> -P, --parent &lt;ppid,...&gt;   match only child processes of the given parent</span><br><span class="line"> -s, --session &lt;sid,...&gt;   match session IDs</span><br><span class="line"> -t, --terminal &lt;tty,...&gt;  match by controlling terminal</span><br><span class="line"> -u, --euid &lt;id,...&gt;       match by effective IDs</span><br><span class="line"> -U, --uid &lt;id,...&gt;        match by real IDs</span><br><span class="line"> -x, --exact               match exactly with the command name</span><br><span class="line"> -F, --pidfile &lt;file&gt;      read PIDs from file</span><br><span class="line"> -L, --logpidfile          fail if PID file is not locked</span><br><span class="line"> --ns &lt;pid&gt;                match the processes that belong to the same</span><br><span class="line">                           namespace as &lt;pid&gt;</span><br><span class="line"> --nslist &lt;ns,...&gt;         list which namespaces will be considered for</span><br><span class="line">                           the --ns option.</span><br><span class="line">                           Available namespaces: ipc, mnt, net, pid, user, uts</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see pgrep(1).</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——strace]]></title>
      <url>http://xiaqunfeng.cc/2017/02/16/linux-cmd-strace/</url>
      <content type="html"><![CDATA[<p>strace命令，用来查看运行程序的系统调用，统计每个系统调用的时间。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<p>我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。 </p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usage: strace [-CdffhiqrtttTvVxxy] [-I n] [-e expr]...</span><br><span class="line">              [-a column] [-o file] [-s strsize] [-P path]...</span><br><span class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</span><br><span class="line">   or: strace -c[df] [-I n] [-e expr]... [-O overhead] [-S sortby]</span><br><span class="line">              -p pid... / [-D] [-E var=val]... [-u username] PROG [ARGS]</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class="line">-d 输出strace关于标准错误的调试信息.</span><br><span class="line">-f 跟踪由fork调用所产生的子进程.</span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class="line">-h 输出简要的帮助信息.</span><br><span class="line">-i 输出系统调用的入口指针.</span><br><span class="line">-q 禁止输出关于脱离的消息.</span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class="line">-t 在输出中的每一行前加上时间信息.</span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class="line">-ttt 微秒级输出,以秒了表示时间.</span><br><span class="line">-T 显示每一调用所耗的时间.</span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class="line">-V 输出strace的版本信息.</span><br><span class="line">-x 以十六进制形式输出非标准字符串</span><br><span class="line">-xx 所有字符串以十六进制形式输出.</span><br><span class="line">-a column</span><br><span class="line">设置返回值的输出位置.默认 为40.</span><br><span class="line">-e expr</span><br><span class="line">指定一个表达式,用来控制如何跟踪.格式如下:</span><br><span class="line">[qualifier=][!]value1[,value2]...</span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</span><br><span class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</span><br><span class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</span><br><span class="line">-e trace=set</span><br><span class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class="line">-e trace=file</span><br><span class="line">只跟踪有关文件操作的系统调用.</span><br><span class="line">-e trace=process</span><br><span class="line">只跟踪有关进程控制的系统调用.</span><br><span class="line">-e trace=network</span><br><span class="line">跟踪与网络有关的所有系统调用.</span><br><span class="line">-e strace=signal</span><br><span class="line">跟踪所有与系统信号有关的 系统调用</span><br><span class="line">-e trace=ipc</span><br><span class="line">跟踪所有与进程通讯有关的系统调用</span><br><span class="line">-e abbrev=set</span><br><span class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</span><br><span class="line">-e raw=set</span><br><span class="line">将指 定的系统调用的参数以十六进制显示.</span><br><span class="line">-e signal=set</span><br><span class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class="line">-e read=set</span><br><span class="line">输出从指定文件中读出 的数据.例如:</span><br><span class="line">-e read=3,5</span><br><span class="line">-e write=set</span><br><span class="line">输出写入到指定文件中的数据.</span><br><span class="line">-o filename</span><br><span class="line">将strace的输出写入文件filename</span><br><span class="line">-p pid</span><br><span class="line">跟踪指定的进程pid.</span><br><span class="line">-s strsize</span><br><span class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span><br><span class="line">-u username</span><br><span class="line">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><p>先用一个程序当例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#cat test.c </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">	int a; </span><br><span class="line">	scanf(&quot;%d&quot;, &amp;a); </span><br><span class="line">	printf(&quot;%09d\n&quot;, a); </span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc -o test test.c</code> 得到可执行文件 test</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># strace ./test </span><br><span class="line">execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 20 vars */]) = 0</span><br><span class="line">brk(0)                                  = 0x9fa000</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a68a000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=30643, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 30643, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb60a682000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1840928, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb60a0a5000</span><br><span class="line">mprotect(0x7fb60a25f000, 2097152, PROT_NONE) = 0</span><br><span class="line">mmap(0x7fb60a45f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fb60a45f000</span><br><span class="line">mmap(0x7fb60a465000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb60a465000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a681000</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a67f000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7fb60a67f740) = 0</span><br><span class="line">mprotect(0x7fb60a45f000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</span><br><span class="line">mprotect(0x7fb60a68c000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7fb60a682000, 30643)           = 0</span><br><span class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a689000</span><br><span class="line">read(0, 100</span><br><span class="line">&quot;100\n&quot;, 1024)                  = 4</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb60a688000</span><br><span class="line">write(1, &quot;000000100\n&quot;, 10000000100</span><br><span class="line">)             = 10</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<ul>
<li>从trace结构可以看到，系统首先调用execve开始一个新的进行</li>
<li>接着进行些环境的初始化操作</li>
<li>最后停顿在”read(0,”上面，这也就是执行到了我们的scanf函数，等待我们输入数字</li>
<li>输入完100之后，再调用write函数将格式化后的数值”0000000100″输出到屏幕</li>
<li>最后调用exit_group退出进行，完成整个程序的执行过程</li>
</ul>
<p>如果在执行的过程中，进程 <code>test</code> 被kill掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd8d880a000</span><br><span class="line">read(0, 0x7fd8d880a000, 1024)           = ? ERESTARTSYS (To be restarted if SA_RESTART is set)</span><br><span class="line">--- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=1161, si_uid=0&#125; ---</span><br><span class="line">+++ killed by SIGTERM +++</span><br></pre></td></tr></table></figure>
<p>告诉你test进程”+++ killed by SIGTERM +++”</p>
<h3 id="系统调用统计"><a href="#系统调用统计" class="headerlink" title="系统调用统计"></a>系统调用统计</h3><p>使用参数 <code>-c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># strace -c ./test </span><br><span class="line">99</span><br><span class="line">000000099</span><br><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">  0.00    0.000000           0         2           read</span><br><span class="line">  0.00    0.000000           0         1           write</span><br><span class="line">  0.00    0.000000           0         2           open</span><br><span class="line">  0.00    0.000000           0         2           close</span><br><span class="line">  0.00    0.000000           0         4           fstat</span><br><span class="line">  0.00    0.000000           0         9           mmap</span><br><span class="line">  0.00    0.000000           0         4           mprotect</span><br><span class="line">  0.00    0.000000           0         1           munmap</span><br><span class="line">  0.00    0.000000           0         1           brk</span><br><span class="line">  0.00    0.000000           0         3         3 access</span><br><span class="line">  0.00    0.000000           0         1           execve</span><br><span class="line">  0.00    0.000000           0         1           arch_prctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.000000                    31         3 total</span><br></pre></td></tr></table></figure>
<p>很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。这里太快了，都是0。</p>
<h3 id="追踪现有进程"><a href="#追踪现有进程" class="headerlink" title="追踪现有进程"></a>追踪现有进程</h3><p>参数<code>-p</code> ，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>使用参数<code>-o</code> 将strace的结果输出到文件中，如果不指定-o参数的话，默认的输出设备是STDERR，也就是说使用”-o filename”和” 2&gt;filename”的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这两个命令都是将strace结果输出到文件test.txt中 </span><br><span class="line">strace -c -o test.txt ./test </span><br><span class="line">strace -c ./test 2&gt;test.txt</span><br></pre></td></tr></table></figure>
<h3 id="系统调用计时"><a href="#系统调用计时" class="headerlink" title="系统调用计时"></a>系统调用计时</h3><p>使用参数 <code>-T</code> 将每个系统调用所花费的时间打印出来，每个调用的时间花销现在在调用行最右边的尖括号里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000013&gt;</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31135000 &lt;0.000015&gt;</span><br><span class="line">read(0, 54</span><br><span class="line">&quot;54\n&quot;, 1024)                   = 3 &lt;9.354830&gt;</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 4), ...&#125;) = 0 &lt;0.000012&gt;</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdd31134000 &lt;0.000013&gt;</span><br><span class="line">write(1, &quot;000000054\n&quot;, 10000000054</span><br><span class="line">)             = 10 &lt;0.000010&gt;</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>-t</code> 输出结果精确到秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:21:20 read(0, 100</span><br><span class="line">&quot;100\n&quot;, 1024)         = 4</span><br><span class="line">20:21:24 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">20:21:24 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa926d0b000</span><br><span class="line">20:21:24 write(1, &quot;000000100\n&quot;, 10000000100</span><br><span class="line">)    = 10</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>-tt</code> 输出结果精确到微秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:24:52.063615 read(0, 100</span><br><span class="line">&quot;100\n&quot;, 1024)  = 4</span><br><span class="line">20:24:54.031118 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">20:24:54.031167 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2dc4bd3000</span><br><span class="line">20:24:54.031210 write(1, &quot;000000100\n&quot;, 10000000100</span><br><span class="line">) = 10</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>-ttt</code> 输出结果精确到微秒，而且时间表示为unix时间戳</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1487247731.103542 read(0, 100</span><br><span class="line">&quot;100\n&quot;, 1024) = 4</span><br><span class="line">1487247887.084673 fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">1487247887.084717 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22beb1f000</span><br><span class="line">1487247887.084812 write(1, &quot;000000100\n&quot;, 10000000100</span><br><span class="line">) = 10</span><br></pre></td></tr></table></figure>
<h3 id="截断输出"><a href="#截断输出" class="headerlink" title="截断输出"></a>截断输出</h3><p><code>-s</code> 参数用于指定trace结果的每一行输出的字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># strace -s 3 ./test </span><br><span class="line">...</span><br><span class="line">read(0, 1024</span><br><span class="line">&quot;102&quot;..., 1024)                 = 5</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 6), ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdeeb74a000</span><br><span class="line">write(1, &quot;000&quot;..., 10000001024</span><br><span class="line">)                  = 10</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<h3 id="跟踪服务程序"><a href="#跟踪服务程序" class="headerlink" title="跟踪服务程序"></a>跟踪服务程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt -T -tt -e trace=all -p 28979</span><br></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h3 id="跟踪可执行程序"><a href="#跟踪可执行程序" class="headerlink" title="跟踪可执行程序"></a>跟踪可执行程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f -F -o ~/straceout.txt myserver</span><br></pre></td></tr></table></figure>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>参考资料：</p>
<p><a href="http://man.linuxde.net/strace" target="_blank" rel="noopener">strace命令</a></p>
<p><a href="http://huoding.com/2013/10/06/288" target="_blank" rel="noopener">通过Strace定位故障原因</a></p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取每个osd的PG数]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/ceph-osd-pg-num/</url>
      <content type="html"><![CDATA[<p>一个shell脚本，用于获取ceph集群中每个osd的PG数，同时分别统计每个pool上的PG数信息。<br><a id="more"></a></p>
<h2 id="Ceph集群信息"><a href="#Ceph集群信息" class="headerlink" title="Ceph集群信息"></a>Ceph集群信息</h2><p><strong>pool信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd lspools</span><br><span class="line">0 rbd,1 testpool,</span><br></pre></td></tr></table></figure>
<p><strong>osd信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">ID WEIGHT  TYPE NAME       UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-1 0.54538 root default                                      </span><br><span class="line">-2 0.18179     host jewel0                                   </span><br><span class="line"> 0 0.18179         osd.0        up  1.00000          1.00000 </span><br><span class="line">-3 0.18179     host jewel1                                   </span><br><span class="line"> 1 0.18179         osd.1        up  1.00000          1.00000 </span><br><span class="line">-4 0.18179     host jewel2                                   </span><br><span class="line"> 2 0.18179         osd.2        up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h2 id="脚本执行结果展示"><a href="#脚本执行结果展示" class="headerlink" title="脚本执行结果展示"></a>脚本执行结果展示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># sh pg-per-osd.sh </span><br><span class="line">dumped all in format plain</span><br><span class="line"></span><br><span class="line">pool :	0	1	| SUM </span><br><span class="line">--------------------------------</span><br><span class="line">osd.0	64	128	| 192</span><br><span class="line">osd.1	64	128	| 192</span><br><span class="line">osd.2	64	128	| 192</span><br><span class="line">--------------------------------</span><br><span class="line">SUM :	192	384</span><br></pre></td></tr></table></figure>
<p>每行显示单个OSD在每个pool中的PG数详情</p>
<p>每列显示单个pool中每个OSD的PG数详情</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat pg-per-osd.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">ceph pg dump | awk &apos;</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!=&quot;up&quot;) &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"> printf(&quot;pool :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,i); printf(&quot;| SUM \n&quot;);</span><br><span class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</span><br><span class="line"> for (i in osdlist) &#123; printf(&quot;osd.%i\t&quot;, i); sum=0;</span><br><span class="line">   for (j in poollist) &#123; printf(&quot;%i\t&quot;, array[i,j]); sum+=array[i,j]; sumpool[j]+=array[i,j] &#125;; printf(&quot;| %i\n&quot;,sum) &#125;</span><br><span class="line"> for (i in poollist) printf(&quot;--------&quot;); printf(&quot;----------------\n&quot;);</span><br><span class="line"> printf(&quot;SUM :\t&quot;); for (i in poollist) printf(&quot;%s\t&quot;,sumpool[i]); printf(&quot;|\n&quot;);</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RBD 相关操作]]></title>
      <url>http://xiaqunfeng.cc/2017/02/10/ceph-RBD-operator/</url>
      <content type="html"><![CDATA[<p>本文主要有两点：一、创建RBD设备用于测试；二、RBD相关其他操作。<br><a id="more"></a></p>
<p>查看系统和内核版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 14.04.4 LTS</span><br><span class="line">Release:	14.04</span><br><span class="line">Codename:	trusty</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -r</span><br><span class="line">4.2.0-27-generic</span><br></pre></td></tr></table></figure>
<h2 id="创建RBD设备"><a href="#创建RBD设备" class="headerlink" title="创建RBD设备"></a>创建RBD设备</h2><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>1、<code>--image-format format-id</code></p>
<p>选择用哪个对象布局，默认为 2 。</p>
<ul>
<li>format 1 - 新建 rbd 映像时使用最初的格式。此格式兼容所有版本的 librbd 和内核模块，但是不支持较新的功能，像克隆。</li>
<li>format 2 - 使用第二版 rbd 格式， librbd 和 3.11 版以上内核模块才支持（除非是分拆的模块）。此格式增加了克隆支持，使得扩展更容易，还允许以后增加新功能。</li>
</ul>
<p>注意： <code>--image-format 1</code> 已不被支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># rbd create rbd-f1 --size 10G --image-format 1 --image-feature layering </span><br><span class="line">rbd: image format 1 is deprecated</span><br><span class="line">rbd: features not allowed with format 1; use --image-format 2</span><br></pre></td></tr></table></figure>
<p>2、<code>--image-feature   feature</code></p>
<p>选项指定使用特性，不用全部开启。如果仅需要使用快照等特性，开启layering即可。</p>
<ul>
<li>layering: 支持分层</li>
<li>striping: 支持条带化 v2</li>
<li>exclusive-lock: 支持独占锁</li>
<li>object-map: 支持对象映射（依赖 exclusive-lock ）</li>
<li>fast-diff: 快速计算差异（依赖 object-map ）</li>
<li>deep-flatten: 支持快照扁平化操作</li>
<li>journaling: 支持记录 IO 操作（依赖独占锁）</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>这里 <code>--image-format 2</code> 可以省略掉（命令如下），因为默认值就是 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rbd create rbd-blue --size 20G --image-feature layering</span><br></pre></td></tr></table></figure>
<p>查看创建的RBD信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># rbd info rbd-blue</span><br><span class="line">rbd image &apos;rbd-blue&apos;:</span><br><span class="line">	size 20480 MB in 5120 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.105774b0dc51</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<h2 id="映射块设备"><a href="#映射块设备" class="headerlink" title="映射块设备"></a>映射块设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd map rbd/rbd-blue</span><br><span class="line">/dev/rbd0</span><br></pre></td></tr></table></figure>
<p>查看映射后信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rbd showmapped </span><br><span class="line">id pool image    snap device    </span><br><span class="line">0  rbd  rbd-blue -    /dev/rbd0 </span><br><span class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </span><br><span class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l /dev/rbd0</span><br><span class="line"># mkfs.xfs /dev/rbd0</span><br></pre></td></tr></table></figure>
<h3 id="创建文件夹并挂载"><a href="#创建文件夹并挂载" class="headerlink" title="创建文件夹并挂载"></a>创建文件夹并挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /mnt/ceph-disk1</span><br><span class="line"># mount /dev/rbd0 /mnt/ceph-disk1</span><br><span class="line"></span><br><span class="line"># df -h /mnt/ceph-disk1/</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/rbd0        20G   33M   20G   1% /mnt/ceph-disk1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，RBD设备已准备就绪，可以对RBD块设备进行测试了。</p>
</blockquote>
<h2 id="块设备其他操作"><a href="#块设备其他操作" class="headerlink" title="块设备其他操作"></a>块设备其他操作</h2><h3 id="罗列块设备映像"><a href="#罗列块设备映像" class="headerlink" title="罗列块设备映像"></a>罗列块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd ls &#123;poolname&#125;	# poolname默认是rbd，可省略</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># rbd ls</span><br><span class="line">rbd-blue</span><br><span class="line">rbd-tmp</span><br><span class="line">rbd-tmp1</span><br></pre></td></tr></table></figure>
<h3 id="检索镜像信息"><a href="#检索镜像信息" class="headerlink" title="检索镜像信息"></a>检索镜像信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd info &#123;pool-name&#125;/&#123;image-name&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有创建其他rbd的话，可以将命令简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd info &#123;image-name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整块设备映像大小"><a href="#调整块设备映像大小" class="headerlink" title="调整块设备映像大小"></a>调整块设备映像大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rbd resize --size 2048 rbd-blue (to increase)</span><br><span class="line">rbd resize --size 2048 rbd-blue --allow-shrink (to decrease)</span><br></pre></td></tr></table></figure>
<h3 id="删除块设备映像"><a href="#删除块设备映像" class="headerlink" title="删除块设备映像"></a>删除块设备映像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbd rm &#123;pool-name&#125;/&#123;image-name&#125;	# 默认pool是rbd，可省略&#123;pool-name&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在删除前需要umap映像</p>
</blockquote>
<h4 id="正确删除过程"><a href="#正确删除过程" class="headerlink" title="正确删除过程"></a><strong>正确删除过程</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rbd showmapped</span><br><span class="line">id pool image    snap device    </span><br><span class="line">0  rbd  rbd-blue -    /dev/rbd0 </span><br><span class="line">1  rbd  rbd-tmp  -    /dev/rbd1 </span><br><span class="line">2  rbd  rbd-tmp1 -    /dev/rbd2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rbd unmap /dev/rbd2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd rm rbd-tmp1</span><br><span class="line">Removing image: 100% complete...done.</span><br></pre></td></tr></table></figure>
<p>注意：命令 <code>service rbdmap stop</code> 并不管用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># service rbdmap stop</span><br><span class="line">stop: Job failed while stopping</span><br></pre></td></tr></table></figure>
<h4 id="不unmap的删除"><a href="#不unmap的删除" class="headerlink" title="不unmap的删除"></a><strong>不unmap的删除</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rbd rm rbd-tmp1</span><br><span class="line">2017-02-08 11:17:47.700190 7f4ba6977000 -1 librbd: image has watchers - not removing</span><br><span class="line">Removing image: 0% complete...failed.</span><br><span class="line">rbd: error: image still has watchers</span><br><span class="line">This means the image is still open or the client using it crashed. Try again after closing/unmapping it or waiting 30s for the crashed client to timeout.</span><br></pre></td></tr></table></figure>
<p>提示image正在被使用。如果想查看谁正在使用的话，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># rbd info rbd-tmp1</span><br><span class="line">rbd image &apos;rbd-tmp1&apos;:</span><br><span class="line">	size 10240 MB in 2560 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.104c2ae8944a</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"># rados -p rbd listwatchers rbd_header.104c2ae8944a</span><br><span class="line">watcher=172.20.1.151:0/1839598827 client.4186 cookie=3</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面这种方式创建RBD在map的时候会失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rbd create --size 10240 rbd-test</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rbd map rbd/rbd-test</span><br><span class="line">rbd: sysfs write failed</span><br><span class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</span><br><span class="line">rbd: map failed: (6) No such device or address</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Kraken release版本上测试Ceph BlueStore]]></title>
      <url>http://xiaqunfeng.cc/2017/02/07/ceph-Kraken-test-BlueStore/</url>
      <content type="html"><![CDATA[<p>前面写了一篇文章《ceph升级到kraken版本》，在升级后的集群上重新部署OSD遇到一些问题。这里在干净的kraken环境下部署bluestore，用来测试一下性能。本文记录部署过程及遇到的问题和解决方法。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ceph版本Kraken（11.2.0）已经发布，发行说明告诉我们，用于OSD的新的BlueStore后端现在可用。</p>
<h2 id="bluestore"><a href="#bluestore" class="headerlink" title="bluestore"></a>bluestore</h2><p>OSD的当前后端是FileStore，它主要使用XFS文件系统来存储它的数据。 为了克服XFS和POSIX的一些限制，所以开发了BlueStore后端。</p>
<p>由于校验和压缩它将提供更多的性能（主要是写）和数据安全。</p>
<p>鼓励用户从Kraken发行版本开始，使用非生产和非关键数据集来测试BlueStore，并向社区报告。</p>
<h2 id="部署BlueStore"><a href="#部署BlueStore" class="headerlink" title="部署BlueStore"></a>部署BlueStore</h2><p>要使用BlueStore部署OSD，您可以使用<code>-bluestore</code>标志来使用ceph-deploy。</p>
<p>我创建了一个简单的测试集群，有三个机器：alpha，bravo和charlie。</p>
<p>每个机器将运行一个ceph-mon和ceph-osd进程。</p>
<p>这是我用来部署集群的ceph-deploy命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy new alpha bravo charlie</span><br><span class="line">ceph-deploy mon create alpha bravo charlie</span><br></pre></td></tr></table></figure>
<p>现在，编辑当前目录中的ceph.conf文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[osd]</span><br><span class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</span><br></pre></td></tr></table></figure>
<p>有了这个设置我们允许使用BlueStore，我们现在可以部署我们的OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf osd create --bluestore alpha:sdb bravo:sdb charlie:sdb</span><br></pre></td></tr></table></figure>
<h2 id="运行Bluestore"><a href="#运行Bluestore" class="headerlink" title="运行Bluestore"></a>运行Bluestore</h2><p>这个微小的集群如何使用BlueStore运行三个OSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@alpha:~# ceph -s</span><br><span class="line">    cluster c824e460-2f09-4994-8b2f-108aedc52d19</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e2: 3 mons at &#123;alpha=[2001:db8::100]:6789/0,bravo=[2001:db8::101]:6789/0,charlie=[2001:db8::102]:6789/0&#125;</span><br><span class="line">            election epoch 14, quorum 0,1,2 alpha,bravo,charlie</span><br><span class="line">        mgr active: charlie standbys: alpha, bravo</span><br><span class="line">     osdmap e14: 3 osds: 3 up, 3 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v24: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            43356 kB used, 30374 MB / 30416 MB avail</span><br><span class="line">                  64 active+clean</span><br><span class="line">root@alpha:~#</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@alpha:~# ceph osd tree</span><br><span class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-1 0.02907 root default                                       </span><br><span class="line">-2 0.00969     host alpha                                     </span><br><span class="line"> 0 0.00969         osd.0         up  1.00000          1.00000 </span><br><span class="line">-3 0.00969     host bravo                                     </span><br><span class="line"> 1 0.00969         osd.1         up  1.00000          1.00000 </span><br><span class="line">-4 0.00969     host charlie                                   </span><br><span class="line"> 2 0.00969         osd.2         up  1.00000          1.00000 </span><br><span class="line">root@alpha:~#</span><br></pre></td></tr></table></figure>
<p>在alpha我看到osd.0只有一个小分区的一点配置，其余的由BlueStore使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@alpha:~# df -h /var/lib/ceph/osd/ceph-0</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sdb1        97M  5.4M   92M   6% /var/lib/ceph/osd/ceph-0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@alpha:~# lsblk </span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0    8G  0 disk </span><br><span class="line">├─sda1   8:1    0  7.5G  0 part /</span><br><span class="line">├─sda2   8:2    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0  510M  0 part [SWAP]</span><br><span class="line">sdb      8:16   0   10G  0 disk </span><br><span class="line">├─sdb1   8:17   0  100M  0 part /var/lib/ceph/osd/ceph-0</span><br><span class="line">└─sdb2   8:18   0  9.9G  0 part </span><br><span class="line">sdc      8:32   0   10G  0 disk</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@alpha:~# cat /var/lib/ceph/osd/ceph-0/type</span><br><span class="line">bluestore</span><br></pre></td></tr></table></figure>
<p>OSD应该像运行FileStore的OSD一样工作，但它们应该运行得更好。</p>
<blockquote>
<p>以上内容翻译自：<a href="https://blog.widodh.nl/2017/01/testing-ceph-bluestore-with-the-kraken-release/" target="_blank" rel="noopener">Testing Ceph BlueStore with the Kraken release</a>。亲测可以成功，觉得很好就不放自己的配置，直接翻译过来了。</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>问题1</strong>、<code>ceph -s</code>的时候出现告警：<code>WARNING: the following dangerous and experimental features are enabled: bluestore</code></p>
<p>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">2017-02-07 10:10:34.266900 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</span><br><span class="line">2017-02-07 10:10:34.271112 7f06a82e0700 -1 WARNING: the following dangerous and experimental features are enabled: bluestore</span><br><span class="line">    cluster 7e9423ea-95f8-42d1-ae2d-7a384d68dea7</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e2: 3 mons at &#123;blue0=172.20.1.151:6789/0,blue1=172.20.1.152:6789/0,blue2=172.20.1.153:6789/0&#125;</span><br><span class="line">            election epoch 6, quorum 0,1,2 blue0,blue1,blue2</span><br><span class="line">        mgr no daemons active </span><br><span class="line">     osdmap e15: 3 osds: 3 up, 3 in</span><br><span class="line">            flags sortbitwise,require_jewel_osds,require_kraken_osds</span><br><span class="line">      pgmap v34: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            49092 kB used, 599 GB / 599 GB avail</span><br><span class="line">                  64 active+clean</span><br></pre></td></tr></table></figure>
<p>查了资料，无果，有些认为是<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2016-April/009059.html" target="_blank" rel="noopener">内核版本的问题</a>，然而并不对。</p>
<p>真正原因是在添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable_experimental_unrecoverable_data_corrupting_features = bluestore</span><br></pre></td></tr></table></figure>
<p>的时候忘记在前面加上：<code>[osd]</code></p>
<p><strong>问题2</strong>、从jewel版本上升级到kraken版本，然后再通过上述方法创建OSD并不成功</p>
<p><strong>问题3</strong>、创建mon的时候出现error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ceph_deploy.mon][ERROR ] RuntimeError: config file /etc/ceph/ceph.conf exists with different content; use --overwrite-conf to overwrite</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy --overwrite-conf mon create-initial</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph升级到kraken版本]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/ceph-upgrage-kraken/</url>
      <content type="html"><![CDATA[<p>记录从jewel版本升级到kraken版本的过程，其中重启mon和osd部分官网上的命令并不凑效，这里纠正并记录之。<br><a id="more"></a></p>
<h2 id="1、在Jewel集群上设置sortbitwise标志"><a href="#1、在Jewel集群上设置sortbitwise标志" class="headerlink" title="1、在Jewel集群上设置sortbitwise标志"></a>1、在Jewel集群上设置sortbitwise标志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph osd set sortbitwise</span><br></pre></td></tr></table></figure>
<h2 id="2、添加安装源"><a href="#2、添加安装源" class="headerlink" title="2、添加安装源"></a>2、添加安装源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo deb https://download.ceph.com/debian-kraken/ $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/ceph.list</span><br></pre></td></tr></table></figure>
<p><strong>设置环境变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CEPH_DEPLOY_REPO_URL=http://mirrors.163.com/ceph/debian-kraken</span><br></pre></td></tr></table></figure>
<h2 id="3、升级软件包"><a href="#3、升级软件包" class="headerlink" title="3、升级软件包"></a>3、升级软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph-deploy install --release kraken ceph-0 ceph-1 ceph-2</span><br></pre></td></tr></table></figure>
<p>此时，ceph已升级到 11.2.0 版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph --version</span><br><span class="line">ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</span><br></pre></td></tr></table></figure>
<p>但是，osd和mon的版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ceph tell mon.* version</span><br><span class="line">mon.ceph-0: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</span><br><span class="line">mon.ceph-1: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</span><br><span class="line">mon.ceph-2: ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)</span><br><span class="line"></span><br><span class="line"># ceph tell osd.* version</span><br><span class="line">osd.0: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;ceph version 10.2.5 (c461ee19ecbc0c5c330aca20f7392c9a00730367)&quot;</span><br><span class="line">&#125;</span><br><span class="line">...省略</span><br></pre></td></tr></table></figure>
<h2 id="4、在各节点上重启相关ceph守护进程"><a href="#4、在各节点上重启相关ceph守护进程" class="headerlink" title="4、在各节点上重启相关ceph守护进程"></a>4、在各节点上重启相关ceph守护进程</h2><p>安装官网上的命令操作是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ceph -a restart</span><br><span class="line">ssh ceph-1 sudo /etc/init.d/ceph -a restart</span><br><span class="line">ssh ceph-2 sudo /etc/init.d/ceph -a restart</span><br></pre></td></tr></table></figure>
<p>然而，查看 mon 的进程号发现并没有重启，所以版本还是 10.2.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ps aux | grep ceph-osd</span><br><span class="line"># ps aux | grep ceph-mon</span><br></pre></td></tr></table></figure>
<p><strong>正确的重启命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 重启mon</span><br><span class="line">restart ceph-mon-all</span><br><span class="line">ssh ceph-1 restart ceph-mon-all</span><br><span class="line">ssh ceph-2 restart ceph-mon-all</span><br><span class="line"></span><br><span class="line"># 重启osd</span><br><span class="line">restart ceph-osd-all</span><br><span class="line">ssh ceph-1 restart ceph-osd-all</span><br><span class="line">ssh ceph-2 restart ceph-osd-all</span><br></pre></td></tr></table></figure>
<p>也可以单独重启某一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># restart ceph-mon id=ceph-0</span><br><span class="line">ceph-mon (ceph/ceph-0) start/running, process 23629</span><br><span class="line"></span><br><span class="line"># restart ceph-osd id=0</span><br><span class="line">ceph-osd (ceph/0) start/running, process 23700</span><br></pre></td></tr></table></figure>
<p>查看最新mon和osd版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ceph tell mon.* version</span><br><span class="line">mon.ceph-0: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</span><br><span class="line">mon.ceph-1: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</span><br><span class="line">mon.ceph-2: ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)</span><br><span class="line"></span><br><span class="line"># ceph tell osd.* version</span><br><span class="line">osd.0: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;ceph version 11.2.0 (f223e27eeb35991352ebc1f67423d4ebc252adb7)&quot;</span><br><span class="line">&#125;</span><br><span class="line">...省略</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行 <code>ceph -s</code> 的时候，出现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ceph -s</span><br><span class="line">    cluster 7251c881-bb25-4c36-9be1-653f66c69e1c</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            all OSDs are running kraken or later but the &apos;require_kraken_osds&apos; osdmap flag is not set</span><br><span class="line">...省略</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong></p>
<p>执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd set require_kraken_osds</span><br><span class="line">require_kraken_osds is set</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用户态和内核态]]></title>
      <url>http://xiaqunfeng.cc/2017/02/04/user-kernel-mode/</url>
      <content type="html"><![CDATA[<p>以前整理的小知识点，关于用户态和内核态的解释。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内核态与用户态是操作系统的两种运行级别，intel cpu提供Ring0-Ring3三种级别的运行模式。Ring0级别最高，Ring3最低。</p>
<p>所以当CPU处于内核态，可以随意进入用户态。当CPU处于用户态，只能通过中断的方式进入内核态。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。</p>
<h2 id="cpu的四种状态"><a href="#cpu的四种状态" class="headerlink" title="cpu的四种状态"></a>cpu的四种状态</h2><p>在一台运行 Linux 的计算机中，CPU 在任何时候只会有如下四种状态：</p>
<ol>
<li>在处理一个硬中断。</li>
<li>在处理一个软中断，如 softirq、tasklet 和 bh。</li>
<li>运行于内核态，但有进程上下文，即与一个进程相关。</li>
<li>运行一个用户态进程。</li>
</ol>
<p>其中，【1】、【2】和【3】是运行于内核空间的，而【4】是在用户空间。其中除了【4】，其他状态只可以被在其之上的状态抢占。比如，软中断只可以被硬中断抢占。</p>
<h2 id="linux下详解"><a href="#linux下详解" class="headerlink" title="linux下详解"></a>linux下详解</h2><p>Linux使用了Ring3级别运行用户态，Ring0作为内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。</p>
<p>Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。</p>
<p>用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。</p>
<p>这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> ]]></content>
      
        
        <tags>
            
            <tag> os </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dm-cache vs Bcache]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Dm-cache-vs-Bcache/</url>
      <content type="html"><![CDATA[<p>前面一篇文章介绍了flashcache和cache tier，并进行了对比，其实flashcache的原理和dm-cache是类似的。这里就介绍下dm-cache和bcache，这两种策略均已在linux内核中。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代硬盘驱动器（HDD）已经走了很长的路。他们旋转得越来越快;与过去的HDD相比具有更高的存储密度和更低的错误率，但是它们和其前身一样，仍然被视为性能瓶颈。随着时间的推移，我们已经看到了许多缓存方案来提高性能;有一些块缓存解决方案在磁盘驱动器（磁盘或存储控制器）或使用主机系统内存的文件系统级缓存解决方案附近使用某种类型的缓存。随着企业级的可接受性，大而经济的闪存存储技术的可用性，使用固态驱动器（SSD）的块缓存解决方案作为性能增强解决方案。使用基于SSD的块缓存，我们可以寻找SSD速度和HDD容量 - 快速，大而且实惠。</p>
<p>在块缓存解决方案中，概念上，将逻辑设备呈现给文件系统（或多个应用），而不是实际目的地HDD（或其它目的地块设备，例如iSCSI LUN），其中数据意在被存储。因此呈现的逻辑设备与原始设备具有相同的大小物理设备，而用于高速缓存的SSD可以跨越逻辑设备映射。</p>
<p>Linux开源社区有多个通用的块级缓存解决方案，其中包括bcache，dm-cache和flashcache。 Linux内核社区将内核3.9中的dm-cache上游和内核3.10中的bcache合并。虽然flashcache未在上游合并，但在某些生产环境中已经使用了一段时间。</p>
<h2 id="dm-cache"><a href="#dm-cache" class="headerlink" title="dm-cache"></a>dm-cache</h2><p>又叫 Device Mapper Cache。dm-cache是设备映射器目标，首先提交到kernel-3.9。它使用针对基于闪存的SSD进行优化的I / O调度和缓存管理技术。设备映射程序目标（dmcache）重新使用精简资源调配库中使用的元数据库。write-back和writethrough都由dm-cache支持，write-back是默认模式。</p>
<p>由dm-cache创建的虚拟缓存设备使用源设备（Origin device）、缓存设备（Cache device）和元数据设备（Metadata dev）这三个物理设备来构建。结构如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/dm-cache.png" alt="dm-cache"></p>
<p>源设备是实际（较慢）目的存储设备。</p>
<p>高速缓存设备是用于临时存储用户数据的较快设备。</p>
<p>元数据设备记录块布局，它们的dirty flags和其他内部数据所需的策略。</p>
<h2 id="bcache"><a href="#bcache" class="headerlink" title="bcache"></a>bcache</h2><p>bcache首先提交到kernel-3.10。它围绕基于闪存的SSD的独特特性设计，并使用混合btree/log结构来跟踪缓存的区域。它旨在不惜一切代价（at all cost）避免随机写。 bcache顺序填充一个擦除块，然后在重新使用之前发出一个丢弃（缓存数据可以是桶上的任意一个扇区。bcache最大程度上减少了随机写的代价，它按顺序填充一个桶，重新使用时只需将桶设置为无效）。支持write-through和write-back高速缓存。write-back默认关闭，但可以在运行时任意打开和关闭。</p>
<p>通过后端设备（backing device）和缓存设备（caching device）来创建虚拟的bcache 设备，如下图所示：</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/bcache.png" alt="bcache"></p>
<p>后端设备是实际（较慢）目的存储设备，而高速缓存设备是更快的设备。后备设备必须格式化为bcache 块设备；现有的格式化分区不能与bcache一起使用。（可以尝试 blocks to-bcache进行就地转换）。</p>
<p>默认状态下bcache不缓存顺序IO，只缓存随机读写。为避免随机写，bcache将随机写转换为顺序写，首先写到SSD，然后回写缓存使用SSD缓存大量的写，最后将写有序写到磁盘或者阵列上。</p>
<p>SSD的特点就是随机IO速度很快，而对于大块顺序IO的提升却并不大。bcache会检测顺序IO并忽略；还会对每一个任务记录动态的平均IO大小，当平均IO大小超过截止值时该任务后面的IO将会被忽略，这样就可以透传备份或者大文件拷贝。</p>
<h2 id="Dm-cache-vs-Bcache"><a href="#Dm-cache-vs-Bcache" class="headerlink" title="Dm-cache vs Bcache"></a>Dm-cache vs Bcache</h2><p>与 dm-cache 实现的的分级存储不同，bcache 更像一个传统的缓存。它可以用来存储任何 extents，甚至是是一个扇区，而 dm-cache 只能对整块数据进行缓存。</p>
<p>dm-cache方案假设缓存设备总是存在，bcache 并不要求 cache 设备一直都在。 </p>
<p>bcache 已经在实际产品中使用了，所以它有机会去碰到这些疑难场景，并可以处理这些缓存设备无法工作的情形。</p>
<p>dm-cache 确实还有很多事情要做。起初，它是进行 cache 和原始设备的并行 IO，但最终不得不回到顺序 IO。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flashcache vs Cache tier]]></title>
      <url>http://xiaqunfeng.cc/2017/02/03/Flashcache-vs-Cache-tier/</url>
      <content type="html"><![CDATA[<p>使用SSD作为缓存来提高性能有多种方法，文章前言里会介绍，主要有bcache、dm-cache、flashcache、cache tier等，本文比较两种在ceph中的常用方案：flashcache 和 cache tier。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>传统的HDD具备大容量的优势，但是性能相对偏低，尤其是随机IO性能，经常成为系统的性能瓶颈，在虚拟机化环境下表现的更明显，因为虚拟化场景会加剧IO随机化。相比HDD，SSD具有高性能的优势，尤其在随机IO这方面，优势非常明显，但是SSD的硬件成本比较高。</p>
<p>目前业界在结合HDD的大容量和SSD的高性能方面做了一些优化，基本思路是使用SSD作为HDD的cache。计算机领域，cache的思想无处不在，比如CPU的L1、L2 cache，raid card上的cache，TLB cache等。关于SSD作为HDD的cache的优化方案，主要有Linux bcache，Linux dm-cache，Facebook flashcache，btier，IBM flashcache等。</p>
<h2 id="flashcache"><a href="#flashcache" class="headerlink" title="flashcache"></a>flashcache</h2><p>flashcache 是 facebook 开源的 ssd 存储产品，它基于内核的 devicemapper 机制，允许将 ssd 设备映射为机械存储设备的缓存，堆叠成为一个虚拟设备供用户读写，从而在一定程度上兼顾 ssd 的高速与机械存储设备的高容量，更加经济高效地支撑线上业务。</p>
<p> <img src="http://ojet8bprn.bkt.clouddn.com/flashcache.png" alt="flashcache"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Device Mapper层，对外服务体现方式是块设备，无需修改应用。</p>
<p>确保内核已启用 DeviceMapper，编译内核模块并安装之后：</p>
<ul>
<li>创建缓存设备: flashcache_wt_create /dev/cachedev /dev/sda1 /dev/hda1</li>
<li>删除缓存设备: dmsetup remove cachedev </li>
</ul>
<p>使用者需要注意建立缓存设备之后，就不应该再对 /dev/sda1 和 /dev/hda1 两个设备直接读写了。</p>
<p>用户操作接口是映射之后的虚拟设备，即/dev/mapper/*下面的设备，如cachedev，而不是基设备</p>
<h3 id="缓存的组织"><a href="#缓存的组织" class="headerlink" title="缓存的组织"></a>缓存的组织</h3><p>flashcache是建立在Linux devicemapper之上的，由devicemapper在SSD和backing HDD之上创建了一个逻辑的mapped device，用户使用的就是这个mapped device。</p>
<p>flashcache把cache（SSD）按照哈希的方式进行结构化管理，flashcache 中缓存的盘块的默认大小为 4kb，按照多路组相连的形式组织缓存块，每组含有 512 个缓存块，简单按照取模分组。缓存的查找，就是对后端设备块号取模得到组号，然后凭偏移遍历组中的缓存块。具体管理方式可以参考小结末参考资料。</p>
<p>虽然数据会被写入 ssd 设备，但缓存的组织信息一律保存在内存中，即 cache_c 对象。它里面保存了基本的配置选项、统计信息、对两个设备的引用、每个缓存块的相关信息(cache, cache_state)、 以及缓存组中 FIFO 数组(虽然名字叫做 LRU)的下标。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>flashcache 支持三种缓存策略：</p>
<ul>
<li>writethrough：disk write会在cache中保留一份，但同时也会把数据write到backing disk中，直到write backing disk完成才会返回。</li>
<li>writearound：disk write会bypass cache，直接写到backing disk中，disk read会把从backing disk中读取的数据在cache中缓存。</li>
<li>writeback：write首先会写到cache中，然后更新metadata中得dirty bit，数据并不会立即同步到backing disk中。</li>
</ul>
<p>针对writethrough和writearound，disk read首先根据目的sector找到对应的cache set，然后查找有没有相应的block，如果找到了，也就是cache hit，则直接从cache中读取，如果没有找到，就从backing disk中读取数据，同时也在cache中进行缓存。</p>
<h3 id="数据调度"><a href="#数据调度" class="headerlink" title="数据调度"></a>数据调度</h3><p>DM层request送往flashcache，并将读写请求按照目标设备的blocksize进行划分，切割成blocksize大小的bio。</p>
<p><strong>读</strong></p>
<p>接收到bio，首先，根据bio-&gt;bi_sector，即硬盘的扇区号，得到SSD上的set；</p>
<p>其次，在set内查找是否命中，如果命中，则将硬盘的扇区号转换为SSD的扇区号，然后将此bio向SSD提交，进行读取；</p>
<p>如果未命中，则首先向硬盘驱动提交bio，从硬盘读数据，读取完成后，由回调函数启动回写SSD操作，将bio的扇区号转换为SSD的=扇区号，然后向SSD驱动程序提交，将硬盘读取的数据写入SSD。</p>
<p><strong>写</strong></p>
<p>同文件系统页缓冲，并不直接写入硬盘，而是写入SSD，同时，保持一个阀值，一般为20%，在脏块数目达到此数值时，写回磁盘。</p>
<p>另外：如果<strong>IO size小于blocksize</strong>，flashcache则不会缓存该IO，而是先查找cache中有没有overlap的脏数据：</p>
<p>如果有的话，就先刷脏数据，然后再把刚才从devicemapper传来的IO写到backing disk上</p>
<p>如果没有脏数据，则直接写到backing disk上，这也就是为什么当使用fio测试小于4KB的随机IO时，flashcache几乎没有效果。</p>
<p>部分参考资料：</p>
<p><a href="http://mogu.io/Facebook_flashcache-81" target="_blank" rel="noopener">Facebook flashcache介绍与使用</a></p>
<p><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/flashcache-introduction?lang=en" target="_blank" rel="noopener">flashcache 简介</a></p>
<p><a href="http://blog.csdn.net/kidd_3/article/category/905673" target="_blank" rel="noopener">其他flashcache资料</a></p>
<h2 id="cache-tier"><a href="#cache-tier" class="headerlink" title="cache tier"></a>cache tier</h2><p>缓存分层通过将一部分数据存到缓存层，给ceph客户端提供更好的IO性能。通常是在更快的磁盘上创建存储池，如SSD/NVMe。数据最终被透明的写入常规的存储池中，它们由副本或纠删码类型的存储池所构建。</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/cache%20tier.png" alt="cache tier"></p>
<p>缓存层代理自动处理缓存层和后端存储之间的数据迁移，对客户端透明，管理员可以配置迁移进行的方式。</p>
<h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>缓存分层主要有两种模式：writeback 和 read-only。如果是write-back模式，那么该cache pool 既是read tier ，又是 write tier； 如果只是read only 模式，那么实际上，cache pool 只是 read tier，没有write tier。</p>
<h3 id="writeback模式"><a href="#writeback模式" class="headerlink" title="writeback模式"></a>writeback模式</h3><p>客户端写数据到缓存层后立刻收到确认回复。基于配置的flush/evict策略，数据从缓存层迁移到存储层，最后缓存分层代理从缓存层中将数据删除。</p>
<p>当读操作在缓存中miss的时候</p>
<p>1、返回client结果为cache miss，重新向存储层发起读请求。</p>
<p>2、cache层向存储层发起读请求，返回client的同时缓存一份在cache层</p>
<p>写操作在缓存中miss的时候</p>
<p>直接向存储层写，然后逐级返回，并不将数据缓存在cache层</p>
<p>这种模式适合大量修改数据的场景。</p>
<h3 id="read-only模式"><a href="#read-only模式" class="headerlink" title="read-only模式"></a>read-only模式</h3><p>缓存层只服务于客户端的读操作。当读请求在缓存层中miss的时候，从存储层中读上来，并设置一个expire时间，过期自动被删除。cache层可以设置为单副本，极大减少缓存空间占用率。写操作直接写到后端的存储层。</p>
<p>这种模式适合一次写入多次读取的场景。</p>
<h2 id="Flashcache-vs-Cache-tier"><a href="#Flashcache-vs-Cache-tier" class="headerlink" title="Flashcache vs Cache tier"></a>Flashcache vs Cache tier</h2><p>flashcache将缓存在块层的东西，而缓存池将缓存对象层的东西。 在每种情况下都有潜在的优点和缺点。 一些初始猜测：</p>
<p><strong>flashcache</strong></p>
<ul>
<li>[x] 所有缓存对一个节点是本地的，更少的开销（包括网络）。</li>
<li>[x] 在许多对象访问和大量热的inodes / dentries的情况下可以做得更好</li>
<li>无法仅为高速缓存定义不同的 副本/ EC 策略。</li>
<li>缓存写入是非原子的</li>
</ul>
<p><strong>Ceph cache tier</strong></p>
<ul>
<li>[x] 潜在可以做的事情，如副本缓存和EC存冷数据。</li>
<li>[x] 更安全</li>
<li>更多的网络开销，可能会有更多的CPU开销。</li>
<li>需要更长的时间才能将内容缓存</li>
</ul>
<p>参考资料：<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2014-March/037861.html" target="_blank" rel="noopener"> OSD + FlashCache vs. Cache Pool for RBD</a></p>
<p><strong>关于成本</strong></p>
<p>高速缓存中的数据总是硬盘驱动器上的数据的第二个副本。 缓存的故障很少产生数据丢失，只是性能损失，因为一切都需要从机械驱动器提供，直到缓存可以被替换。</p>
<p> SSD层可能是自动分层系统中唯一的数据副本，不能容忍SSD层的故障，因此这些系统必须通过使用类似RAID的数据保护方案在冗余配置中设置SSD层。 不得不购买额外的SSD来支持类似RAID的功能，使已经高价的技术更加昂贵。</p>
<p><strong>关于读</strong></p>
<p>在大多数情况下，两个选项之间的read 性能应该大致相同。 大多数情况下，read 性能的效率将取决于缓存设备提升数据的效率和可定制性。 目标应该是确保正确的数据在正确的时间存在缓存中。缓存和自动分层需要在关于他们缓存什么和什么时候缓存需要变得更加聪明。</p>
<p><strong>终上所述</strong></p>
<p>从用户的角度来看，如果适当的冗余存在，缓存或分层没有显着的优势，因此不应该单独选择基于闪存的存储系统。 IT规划人员可能想要调查其他因素，例如将某些数据集固定到闪存层或缓存区，以及与环境或应用程序集成的能力。</p>
<p>参考资料：（这两篇文章是同一个作者）</p>
<p><a href="http://www.networkcomputing.com/storage/ssd-options-tier-vs-cache/1267262167" target="_blank" rel="noopener">SSD Options: Tier Vs. Cache</a></p>
<p><a href="http://searchsolidstatestorage.techtarget.com/tip/Tiering-vs-caching-in-flash-based-storage-systems" target="_blank" rel="noopener">Tiering vs. caching in flash-based storage systems</a></p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 

]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——parted]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/linux-cmd-parted/</url>
      <content type="html"><![CDATA[<p>一直用parted命令来进行磁盘分区，这里学习一下总结一下。顺带对比一下MBR和GPT两种分区表，以及parted命令和fdisk命令的区别。<br><a id="more"></a></p>
<h2 id="MBR和GPT"><a href="#MBR和GPT" class="headerlink" title="MBR和GPT"></a>MBR和GPT</h2><p>MBR：MBR分区表(即主引导记录)大家都很熟悉。所支持的最大卷：2T，而且对分区有限制：最多4个主分区或3个主分区加一个扩展分区（包含随意数目的逻辑分区）。</p>
<p>GPT：GPT（即GUID分区表）。是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。GPT的分区信息是在分区中，而MBR在主引导扇区。</p>
<p>与MBR分区方式相比，具有如下优点：</p>
<ul>
<li>突破MBR 4个主分区限制，每个磁盘最多支持128个主分区。</li>
<li>支持大于2T的分区，最大卷可达18EB。</li>
</ul>
<h2 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h2><ul>
<li><strong>主分区</strong>又叫主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘。一个硬盘的主分区也就是包含操作系统启动所必需的文件和数据的硬盘分区，要在硬盘上安装操作系统，则该硬盘必须得有一个主分区。</li>
<li><strong>扩展分区</strong>不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。</li>
<li><strong>逻辑分区</strong>也相当于一个逻辑磁盘，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中。</li>
</ul>
<p>MBR模式分区只能划分四个分区，现在GPT分区至少可以划分128个主分区，未来很有可能将不存在扩展分区和逻辑分区的概念。</p>
<h2 id="parted和fdisk"><a href="#parted和fdisk" class="headerlink" title="parted和fdisk"></a>parted和fdisk</h2><p>parted命令可以划分单个分区大于2T的GPT格式的分区，也可以划分普通的MBR分区，并且允许调整分区的大小。</p>
<p>fdisk命令对于大于2T的分区无法划分，所以用fdisk无法看到parted划分的GPT格式的分区。</p>
<p>parted是一个可以分区并进行分区调整的工具，他可以创建，破坏，移动，复制，调整ext2 linux-swap fat fat32 reiserfs类型的分区，可以创建，调整，移动Macintosh的HFS分区，检测jfs，ntfs，ufs，xfs分区。</p>
<h2 id="parted命令"><a href="#parted命令" class="headerlink" title="parted命令"></a>parted命令</h2><p>Parted 命令分为两种模式：命令行模式和交互模式</p>
<p> 1、命令行模式：<code>parted [option] device [command]</code> ，该模式可以直接在命令行下对磁盘进行分区操作，比较适合编程应用，比如利用脚本批量执行命令。</p>
<p> 2、交互模式：<code>parted [option] device</code>类似于使用<code>fdisk /dev/xxx</code>，这种适合当个操作。</p>
<h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><h4 id="1、初始状态"><a href="#1、初始状态" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk</span><br></pre></td></tr></table></figure>
<p>parted有个不提示用户参数选项，就是通过这个选项来实现非交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s, --script</span><br><span class="line">              never prompts for user intervention</span><br></pre></td></tr></table></figure>
<h4 id="2、添加分区"><a href="#2、添加分区" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># parted -s /dev/vdb mklabel gpt			# 定义分区表格式</span><br><span class="line"># parted -s /dev/vdb mkpart primary ext4 1 10G		# 划分主分区</span><br><span class="line"># parted -s /dev/vdb mkpart logic 10G 20G		# 划分逻辑分区</span><br><span class="line"># parted -s /dev/vdb mkpart logic ext3 20G 40G</span><br><span class="line"># parted -s /dev/vdb mkpart entended 40G 100%		# 划分扩展分区，100%表示使用剩余所有空间</span><br><span class="line"></span><br><span class="line"># parted -s /dev/vdb p					# 查看分区详情</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</span><br><span class="line"> 2      10.0GB  20.0GB  9999MB  xfs          logic</span><br><span class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</span><br><span class="line"> 4      40.0GB  107GB   67.4GB               entended</span><br></pre></td></tr></table></figure>
<p>查看分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk </span><br><span class="line">├─vdb1 253:17   0   9.3G  0 part </span><br><span class="line">├─vdb2 253:18   0   9.3G  0 part </span><br><span class="line">├─vdb3 253:19   0  18.6G  0 part </span><br><span class="line">└─vdb4 253:18   0  62.8G  0 part</span><br></pre></td></tr></table></figure>
<h4 id="3、删除分区"><a href="#3、删除分区" class="headerlink" title="3、删除分区"></a>3、删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># parted -s /dev/vdb rm 2</span><br><span class="line"></span><br><span class="line"># parted -s /dev/vdb p</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB  ext4         primary</span><br><span class="line"> 3      20.0GB  40.0GB  20.0GB  ext3         logic</span><br></pre></td></tr></table></figure>
<h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h4 id="1、初始状态-1"><a href="#1、初始状态-1" class="headerlink" title="1、初始状态"></a>1、初始状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk</span><br></pre></td></tr></table></figure>
<h4 id="2、添加分区-1"><a href="#2、添加分区-1" class="headerlink" title="2、添加分区"></a>2、添加分区</h4><p>针对盘 vdb 开始分区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># parted /dev/vdb</span><br><span class="line">GNU Parted 2.3</span><br><span class="line">Using /dev/vdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br><span class="line">(parted)mklabel gpt 				# 定义分区表格式</span><br><span class="line">...</span><br><span class="line">(parted) mkpart p1      			# 创建第一个分区，名称为p1                                                  </span><br><span class="line">File system type?  [ext2]? ext4     		# 定义分区格式                                      </span><br><span class="line">Start? 1 					# 定义分区的起始位置（单位支持K,M,G,T）                                                              </span><br><span class="line">End? 10G      					# 定义分区的结束为止(单位支持K,M,G,T)                                                            </span><br><span class="line">(parted) print     				# 查看当前分区情况                                                       </span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB               p1</span><br><span class="line"></span><br><span class="line">(parted) mkpart part2                                                    </span><br><span class="line">File system type?  [ext2]? ext3                                           </span><br><span class="line">Start? 10G                                                                </span><br><span class="line">End? 20G                                                                  </span><br><span class="line">(parted) p					# print可以简写成“p“                                                            </span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name   Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB               p1</span><br><span class="line"> 2      10.0GB  20.0GB  9999MB               part2</span><br><span class="line"></span><br><span class="line">(parted) quit					# 退出。quit可以简写为”q“ </span><br><span class="line">Information: You may need to update /etc/fstab.</span><br></pre></td></tr></table></figure>
<h4 id="3、设置文件系统"><a href="#3、设置文件系统" class="headerlink" title="3、设置文件系统"></a>3、设置文件系统</h4><p>不知道为啥，print的时候不现实文件系统格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.ext4 /dev/vdb1</span><br><span class="line"># mkfs.xfs /dev/vdb2</span><br></pre></td></tr></table></figure>
<p>再查看文件系统信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) print                                                            </span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name   Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</span><br><span class="line"> 2      10.0GB  20.0GB  9999MB  xfs          part2</span><br></pre></td></tr></table></figure>
<p>发现分区的 File system 变成了 ext4 和 xfs。所以，还是通过命令的方式来定义文件系统格式。</p>
<p>查看一下分区后情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1   436K  0 rom  </span><br><span class="line">vda    253:0    0    20G  0 disk </span><br><span class="line">├─vda1 253:1    0     2M  0 part </span><br><span class="line">├─vda2 253:2    0   476M  0 part /boot</span><br><span class="line">└─vda3 253:3    0  19.5G  0 part /</span><br><span class="line">vdb    253:16   0   100G  0 disk </span><br><span class="line">├─vdb1 253:17   0   9.3G  0 part </span><br><span class="line">└─vdb2 253:18   0   9.3G  0 part</span><br></pre></td></tr></table></figure>
<h4 id="4、删除分区"><a href="#4、删除分区" class="headerlink" title="4、删除分区"></a>4、删除分区</h4><p>删除分区 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(parted) rm                                                             </span><br><span class="line">Partition number? 2  </span><br><span class="line"></span><br><span class="line"># 或者直接</span><br><span class="line">(parted) rm 2    </span><br><span class="line"></span><br><span class="line">(parted) print</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 107GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  10.0GB  9999MB  ext4         p1</span><br></pre></td></tr></table></figure>
<h4 id="5、修改分区大小"><a href="#5、修改分区大小" class="headerlink" title="5、修改分区大小"></a>5、修改分区大小</h4><p>暂时不支持改变分区的大小（resize操作），针对有无文件系统报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># none</span><br><span class="line">Error: Could not detect file system.  </span><br><span class="line"></span><br><span class="line"># ext4，ext3</span><br><span class="line">Error: File system has an incompatible feature enabled.  Compatible       </span><br><span class="line">features are has_journal, dir_index, filetype, sparse_super and large_file.</span><br><span class="line">Use tune2fs or debugfs to remove features.</span><br><span class="line"></span><br><span class="line"># xfs</span><br><span class="line">No Implementation: Support for opening xfs file systems is not implemented</span><br><span class="line">yet.</span><br></pre></td></tr></table></figure>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[认识SSD]]></title>
      <url>http://xiaqunfeng.cc/2017/01/25/ssd/</url>
      <content type="html"><![CDATA[<p>SSD越来越火，性能提升比较快，成本也有所下降，是未来的方向和主流，这里认识和学习一下SSD相关知识，以便更好的理解和应用SSD的特性。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>固态硬盘（Solid State Disk）用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。<br>一块SSD，<strong>核心部件</strong>是一颗控制器和多颗Flash颗粒，一般还会有一些内存和超级电容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--&gt;控制器主要作用是提供高效的手段来访问这些Flash颗粒。</span><br><span class="line">--&gt;内存的作用主要是表项管理和读写CACHE。</span><br><span class="line">--&gt;超级电容的作用是在异常下电时保证关键数据不丢失。</span><br></pre></td></tr></table></figure>
<p>而<strong>Flash颗粒</strong>是SSD最重要的器件，其相关特性决定了SSD的实现方式。</p>
<h2 id="FLASH颗粒"><a href="#FLASH颗粒" class="headerlink" title="FLASH颗粒"></a>FLASH颗粒</h2><h3 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h3><blockquote>
<p>闪存是一种不挥发性（ Non-Volatile ）内存，在没有电流供应的条件下也能够长久地保持数据，其存储特性相当于硬盘，这项特性正是闪存得以成为各类便携型数字设备的存储介质的基础。</p>
</blockquote>
<p>Flash颗粒是SSD最重要的器件，其相关特性决定了SSD的实现方式。目前业界主要有两种类型的Flash技术：NOR（Intel开发）和NAND（东芝开发）。由于这两种技术在如下方面的一些差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt;NOR的读取速度略快于NAND；</span><br><span class="line">--&gt;NOR的写入速度远低于NAND；</span><br><span class="line">--&gt;NOR的擦除速度远低于NAND；</span><br><span class="line">--&gt;的擦写次数约为NAND的1/10；</span><br><span class="line">--&gt;的单元尺寸约为NAND的2倍；</span><br></pre></td></tr></table></figure>
<p>导致1~16M的闪存市场主要采用NOR颗粒（主要用于保存嵌入式设备的程序），而<strong>更大容量的数据存储（例如SSD）则主要选择NAND颗粒</strong>。</p>
<h3 id="SLC和MLC"><a href="#SLC和MLC" class="headerlink" title="SLC和MLC"></a>SLC和MLC</h3><p>NAND FLASH芯片，flash颗粒有两种类型：SLC和MLC</p>
<p>SLC：Single Level Cell，每个存储单元均只能存储1个bit的数据。只包含0和1两个电压符。<br>MLC：Multi Level Cell，每个存储单元能够存储2个bit或者更多bit的数据。包含四个电压符（00,01,10,11）。</p>
<p><strong>SLC和MLC的比较：</strong><br>MLC容量比SLC大，且价格便宜。<br>但在性能、使用寿命和稳定性上：<br>1、SLC更简单可靠；<br>2、SLC读取和写入的速度都比MLC更快；<br>3、SLC比MLC更耐用，MLC每单元可擦除1w次，而SLC可擦除10w次。</p>
<p>一般而言，<strong>SLC主要用于企业级市场</strong>，MLC主要用于消费级市场。下表显示了SLC和MLC两种Flash颗粒的一些性能指标：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>SLC</th>
<th>MLC</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机读</td>
<td>25us</td>
<td>50us</td>
</tr>
<tr>
<td>擦除</td>
<td>2ms</td>
<td>2ms</td>
</tr>
<tr>
<td>编程</td>
<td>250us</td>
<td>900us</td>
</tr>
<tr>
<td>擦除次数</td>
<td>100k</td>
<td>10k</td>
</tr>
</tbody>
</table>
<h2 id="SSD的内部逻辑划分"><a href="#SSD的内部逻辑划分" class="headerlink" title="SSD的内部逻辑划分"></a>SSD的内部逻辑划分</h2><p>一颗NAND Flash颗粒，其内部被划分为若干block，每个block又包含若干page。page的大小一般为2k/4k/8k（同一颗Flash颗粒内的page大小是固定且相同的）。</p>
<p>Flash的一个特点是：不能对任意bit位进行0/1互转，只能按照一定的颗粒度进行擦除和编程操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--&gt;擦除 —— 颗粒度为block，是将指定block中所有的bit位全部设置为1；</span><br><span class="line">--&gt;编程 —— 颗粒度为page，是将指定page中指定的bit位设置为0；</span><br></pre></td></tr></table></figure>
<p>因此，对SSD进行写的操作实际上对需要写的Page所在的Block全部完成“擦除”(全部bit位置1)后，才能对指定的Page进行“编程”(部分bit位置0)。PS：实际上SSD硬盘在出厂时，厂商都会把所有Block完成擦除操作。</p>
<h2 id="SSD的表项管理"><a href="#SSD的表项管理" class="headerlink" title="SSD的表项管理"></a>SSD的表项管理</h2><p>  每一个IO读写都是下发给一个地址，这个地址称为LBA(Logic Block Address)，其真正对应在磁盘上的地址称为PBA(Physical Block Address)，和传统机械硬盘中LBA到PBA的映射通过磁轨、磁道、扇区来进行唯一对应不同的是，<strong>SSD的LBA到PBA</strong>的映射通过一张<strong>映射表</strong>来记录。<br>&emsp;&emsp;LBA的粒度是扇区，而Flash颗粒的擦粒度是block，写粒度是page，均为扇区的若干倍，在这种条件下，如果仍以扇区为粒度进行映射，虽然理论上可行，但是显然是增加实现难度和性能的.<br>&emsp;&emsp;同时，如果强制以扇区为粒度进行映射，会导致所需要的映射表空间超过物理内存的限制，这就直接决定了不可能以扇区为粒度进行映射。<br>&emsp;&emsp;即使以page为粒度进行映射，也可能存在物理内存不够用的情况（现在正在使用的SSD盘即属于这种情况），所以需要以更大一些的粒度进行管理。<br>&emsp;&emsp;这个粒度成为”<strong>小块(Sub Block)</strong>“,是SSD进行擦除和编程的最小单位。每个block中，均包含多个sub block；每个sub block，由多个page组成；每个sub block，可能的状态包括：有效、垃圾、空白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--&gt;有效：该小块中的数据正在被引用；</span><br><span class="line">--&gt;垃圾：该小块中的数据没有被引用；</span><br><span class="line">--&gt;空白：该小块可用于写入新的数据；</span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>&emsp;&emsp;SSD的写要先进行整个Block的擦除，然后才能对指定的Sub Block进行编程。实际上，如果某一个写操作需要修改一个Sub Block的内容，是无法直接进行修改的，而是写到一个新的Sub Block中，把该LBA的映射指向新的这个Sub Block，同时把原来数据所在的Sub Block标记为“垃圾”。<br>  这样，随着SSD使用时间的越来越长，新的未被编程过的Sub Block越来越少，后面新的写请求则只能重新擦除所有Sub Block均为垃圾的Block才能再次写入，这样必然会造成写操作的性能降低，因此，在SSD内部引入了一个重要的机制——垃圾回收（Garbage Collection），用以提升SSD长期写入操作的性能。</p>
<p><strong>垃圾回收的工作：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--&gt;找出合适的block</span><br><span class="line">--&gt;将该block中的有效小块迁移到别的地方，同时更改映射表</span><br><span class="line">--&gt;将该block擦除，并放入空白块表</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所谓“最合适进行回收的block”，是指这个block的垃圾小块足够多、有效/空白小块足够少。<br>&emsp;&emsp;垃圾回收算法是否高效，与该SSD的性能有很强的联系。</p>
<h2 id="SSD的磨损均衡"><a href="#SSD的磨损均衡" class="headerlink" title="SSD的磨损均衡"></a>SSD的磨损均衡</h2><p>  上面说过，每个Flash颗粒中Block的可擦除次数是有限制的，如果颗粒中的某些Block很快达到了擦除次数上限，而其他大部分都几乎没有被擦除过，则会很快的造成整个SSD失效。而磨损均衡（Wear Leveling）则是通过各种手段，保证整个SSD所有的block的擦除次数是相近的从而延长SSD的使用寿命。</p>
<p>磨损均衡分为  <strong>动态磨损均衡</strong>  和  <strong>静态磨损均衡</strong>：</p>
<blockquote>
<p>动态磨损均衡，是指在外部力量的驱动下，自然完成磨损均衡。这里外部力量，包括写IO和垃圾回收。<br>静态磨损均衡，是指磨损均衡功能模块主动地查找那些长时间没有变化的数据，将这些数据搬移到其他位置，以便释放出擦除次数较少的block，使其投入到擦除/编程的循环之中。</p>
</blockquote>
<h2 id="SSD使用寿命计算举例"><a href="#SSD使用寿命计算举例" class="headerlink" title="SSD使用寿命计算举例"></a>SSD使用寿命计算举例</h2><p>&emsp;&emsp;虽然一个block擦写次数只有100k（SLC），但是因为动态映射、磨损均衡等机制的存在，使得SSD的寿命远不止写入100k个IO。<br>计算SSD寿命的方式，一般是先确认一个block在其生命周期内能够写入多少数据量，再乘以该SSD具有的block数量，再除以一个估计的写入带宽，最后得到寿命值。<br>&emsp;&emsp;以我司（<strong>你们猜o(^▽^)o</strong>）自研的100G SLC SSD为例，16片Flash颗粒，每片颗粒拥有32k个block，每个block拥有64个4k的page，每个block可以被擦除100k次： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16 x (32 x 1024) x 64 x (4 x 1024) x 100000 = 12500 TB</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;12500 TB，这是当所有block同时达到擦除次数上限时，可以写入的数据总量。<br>按照用户平均每秒钟写入10MB的数据进行计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(12500 x 1024 x 1024) / (10 x 60 x 60 x 24 x 365.25) = 41.5 年</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;41.5年，这是在10MB/s的压力下、持续不断地向SSD写入数据的使用寿命。<br>&emsp;&emsp;考虑到其他一些因素的影响，一块SLC SSD的使用寿命，10年是可以保证的。</p>
<h2 id="SSD和传统磁盘的对比"><a href="#SSD和传统磁盘的对比" class="headerlink" title="SSD和传统磁盘的对比"></a>SSD和传统磁盘的对比</h2><p>&emsp;&emsp;SSD与传统磁盘相比:<br>&emsp;&emsp;第一是没有机械装置;<br>&emsp;&emsp;第二是由磁介质改为了电介质。<br>&emsp;&emsp;在SSD内部有一个FTL(Flash Transalation Layer)，它相当于磁盘中的控制器，主要功能就是作地址映射，将flash memory的物理地址映射为磁盘的LBA逻辑地址，并提供给OS作透明访问。</p>
<h3 id="读方面"><a href="#读方面" class="headerlink" title="读方面"></a>读方面</h3><p><strong>随机读</strong><br>  SSD没有传统磁盘的寻道时间和延迟时间，所以SSD可以提供非常高的随机读取能力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<p><strong>连续读</strong><br>  SSD连续读的能力相比普通磁盘优势并不明显。传统磁盘连续读，并不需要寻道时间：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLC类型的SSD</td>
<td>超过35000的IOPS</td>
</tr>
<tr>
<td>传统15k的SAS磁盘</td>
<td>最高160个IOPS。</td>
</tr>
</tbody>
</table>
<h3 id="写方面"><a href="#写方面" class="headerlink" title="写方面"></a>写方面</h3><p>  Page为最小的读写单位，Block为最小的擦除/编程单位，其中1个Page为4KB，1个Block由256个Page组成，1个Plane由2048个Block组成，2个Plane组成1个Die，也就是最小的芯片(4GB)</p>
<p>&emsp;&emsp;向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元（page）的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入。SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。因为这个特性，引入<strong>“写放大”</strong>的概念。</p>
<p>&emsp;&emsp;比如你想改写4K的数据，必须首先将整个擦除块（1024KB）中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了1024KB的数据，写入放大系数是256。写入放大最好的情况是1，就是不存在放大的情况。s</p>
<p>&emsp;&emsp;在<strong>长时间写入</strong>后，MLC随机写IO下降得非常厉害，而<strong>SLC表现则比较稳定</strong>，可以稳定在3000 IOPS，而MLC随机写IOPS甚至降低到300。</p>
<p>&emsp;&emsp;当某个单元长时间被反复擦写时（比如Oracle redo），不仅会造成写入的性能问题，而且会大大缩短SSD的使用寿命。所以，引入磨损均衡算法（wear leveling）。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力<br>！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> ]]></content>
      
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Crushmap学习]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/ceph-crushmap/</url>
      <content type="html"><![CDATA[<p>介绍了ceph中crush的优点、原理及作用，同时dump出自己的crushmap内容，进行详细的分解学习。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着大规模分布式存储系统的出现。这些系统必须平衡的分布数据和负载，最大化系统的性能，并要处理系统的扩展和硬件失效。但是简单HASH分布不能有效处理设备数量的变化，导致大量数据迁移。ceph设计了CRUSH，用在分布式对象存储系统上，可以有效映射数据对象到存储设备上(不需要中心设备)。因为大型系统的结构式动态变化的，CRUSH能够处理存储设备的添加和移除，并最小化由于存储设备的的添加和移动而导致的数据迁移。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CRUSH算法，全称 Controlled Replication Under Scalable Hashing。它是一种伪随机的算法，在相同的环境下，它能够在层级结构的存储集群中有效的分布对象的副本。</p>
<p>CRUSH实现了一种伪随机(确定性)的函数，它的参数是object id或object group id，并返回一组存储设备(用于保存object副本)。相似的输入得到的结果之间没有相关性，相同的输入得到的结果是确定的。</p>
<p>CRUSH需要cluster map(描述存储集群的层级结构)、和副本分布策略(rule)就可以根据一个整型的输入得到存放数据的一个设备列表。</p>
<p>CRUSH有两个关键优点：</p>
<ul>
<li>任何组件都可以独立计算出每个object所在的位置(去中心化)。</li>
<li>只需要很少的元数据(cluster map)，只要当删除添加设备时，这些元数据才需要改变。</li>
</ul>
<h2 id="crush的作用"><a href="#crush的作用" class="headerlink" title="crush的作用"></a>crush的作用</h2><p>传统存储的架构体系需要一个MDC（meta data controll），ceph不使用这种架构，而是通过引入CRUSH算法，将数据分布的查询操作变成了计算操作，并且是在client端完成。同时，Crush算法还有效缓解了普通hash算法在处理存储设备增删时带来的数据迁移问题。</p>
<p>ceph允许客户端直接访问OSD守护进程，从而消除集中式查询元数据中心的需求。ceph使用一个monitor集群来保证系统的高可用性。同时采用crush算法来实现去中心化，使用crush算法后，客户端根据需要来计算数据被写到哪里，以及从哪读数据。</p>
<p><strong>ceph集群的一个写操作流程</strong></p>
<p>1、client首先访问ceph monitor获取cluster map的一份副本，共五个map（monitor map，OSD map，MDS map，CRUSH map，PG map），知晓集群的状态和配置；</p>
<p>2、数据被转化为一个或多个对象，每个对象都具有对象名称和存储池名称；</p>
<p>3、以PG数为基数做hash，将对象映射到一个PG钟；</p>
<p>4、根据计算出的PG，再通过CRUSH算法得到存放数据的一组OSD位置（副本个数），第一个是主，后面是从；</p>
<p>5、客户端获得OSD ID，直接和这些OSD通信并存放数据。</p>
<p><strong>注</strong>：所有的这些操作都是在<strong>客户端</strong>完成的，不会影响ceph集群服务器端的性能。</p>
<p><strong>一句话描述</strong></p>
<p>说了半天，一句话说明CRUSH的作用，就是——<strong>根据PG ID得到一个OSD列表</strong>。</p>
<h2 id="crush的工作形式"><a href="#crush的工作形式" class="headerlink" title="crush的工作形式"></a>crush的工作形式</h2><p>CRUSH是基于一张描述当前集群资源状态的map（Crush map）按照一定的规则（rules）得到这个OSD列表的。Ceph将系统的所有硬件资源描述成一个树状结构，然后再基于这个结构按照一定的容错规则生成一个逻辑上的树形结构作为Crush map。数的叶子节点是OSD。</p>
<h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="集群详情"><a href="#集群详情" class="headerlink" title="集群详情"></a>集群详情</h3><p>三个节点（ceph1，ceph2，ceph3），每个节点三个OSD，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd tree</span><br><span class="line">ID WEIGHT  TYPE NAME      UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-1 1.36345 root default                                     </span><br><span class="line">-2 0.45448     host ceph1                                   </span><br><span class="line"> 0 0.09090         osd.0       up  1.00000          1.00000 </span><br><span class="line"> 1 0.18179         osd.1       up  1.00000          1.00000 </span><br><span class="line"> 2 0.18179         osd.2       up  1.00000          1.00000 </span><br><span class="line">-3 0.45448     host ceph2                                   </span><br><span class="line"> 3 0.09090         osd.3       up  1.00000          1.00000 </span><br><span class="line"> 4 0.18179         osd.4       up  1.00000          1.00000 </span><br><span class="line"> 5 0.18179         osd.5       up  1.00000          1.00000 </span><br><span class="line">-4 0.45448     host ceph3                                   </span><br><span class="line"> 6 0.09090         osd.6       up  1.00000          1.00000 </span><br><span class="line"> 7 0.18179         osd.7       up  1.00000          1.00000 </span><br><span class="line"> 8 0.18179         osd.8       up  1.00000          1.00000</span><br></pre></td></tr></table></figure>
<h3 id="crushmap内容"><a href="#crushmap内容" class="headerlink" title="crushmap内容"></a>crushmap内容</h3><p>来看一下crushmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># begin crush map</span><br><span class="line">tunable choose_local_tries 0</span><br><span class="line">tunable choose_local_fallback_tries 0</span><br><span class="line">tunable choose_total_tries 50</span><br><span class="line">tunable chooseleaf_descend_once 1</span><br><span class="line">tunable chooseleaf_vary_r 1</span><br><span class="line">tunable straw_calc_version 1</span><br><span class="line"></span><br><span class="line"># devices</span><br><span class="line">device 0 osd.0</span><br><span class="line">device 1 osd.1</span><br><span class="line">device 2 osd.2</span><br><span class="line">device 3 osd.3</span><br><span class="line">device 4 osd.4</span><br><span class="line">device 5 osd.5</span><br><span class="line">device 6 osd.6</span><br><span class="line">device 7 osd.7</span><br><span class="line">device 8 osd.8</span><br><span class="line"></span><br><span class="line"># types</span><br><span class="line">type 0 osd</span><br><span class="line">type 1 host</span><br><span class="line">type 2 chassis</span><br><span class="line">type 3 rack</span><br><span class="line">type 4 row</span><br><span class="line">type 5 pdu</span><br><span class="line">type 6 pod</span><br><span class="line">type 7 room</span><br><span class="line">type 8 datacenter</span><br><span class="line">type 9 region</span><br><span class="line">type 10 root</span><br><span class="line"></span><br><span class="line"># buckets</span><br><span class="line">host ceph1 &#123;</span><br><span class="line">	id -2		# do not change unnecessarily</span><br><span class="line">	# weight 0.454</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0	# rjenkins1</span><br><span class="line">	item osd.0 weight 0.091</span><br><span class="line">	item osd.1 weight 0.182</span><br><span class="line">	item osd.2 weight 0.182</span><br><span class="line">&#125;</span><br><span class="line">host ceph2 &#123;</span><br><span class="line">	id -3		# do not change unnecessarily</span><br><span class="line">	# weight 0.454</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0	# rjenkins1</span><br><span class="line">	item osd.3 weight 0.091</span><br><span class="line">	item osd.4 weight 0.182</span><br><span class="line">	item osd.5 weight 0.182</span><br><span class="line">&#125;</span><br><span class="line">host ceph3 &#123;</span><br><span class="line">	id -4		# do not change unnecessarily</span><br><span class="line">	# weight 0.454</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0	# rjenkins1</span><br><span class="line">	item osd.6 weight 0.091</span><br><span class="line">	item osd.7 weight 0.182</span><br><span class="line">	item osd.8 weight 0.182</span><br><span class="line">&#125;</span><br><span class="line">root default &#123;</span><br><span class="line">	id -1		# do not change unnecessarily</span><br><span class="line">	# weight 1.363</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0	# rjenkins1</span><br><span class="line">	item ceph1 weight 0.454</span><br><span class="line">	item ceph2 weight 0.454</span><br><span class="line">	item ceph3 weight 0.454</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># rules</span><br><span class="line">rule replicated_ruleset &#123;</span><br><span class="line">	ruleset 0</span><br><span class="line">	type replicated</span><br><span class="line">	min_size 1</span><br><span class="line">	max_size 10</span><br><span class="line">	step take default</span><br><span class="line">	step chooseleaf firstn 0 type host</span><br><span class="line">	step emit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># end crush map</span><br></pre></td></tr></table></figure>
<h3 id="begin-crush-map"><a href="#begin-crush-map" class="headerlink" title="begin crush map"></a>begin crush map</h3><p>配置参数</p>
<h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>列出集群的OSD设备</p>
<h3 id="types"><a href="#types" class="headerlink" title="types"></a>types</h3><p>表示buckets的类型 <img src="http://ojet8bprn.bkt.clouddn.com/osdmap.png" alt="osdmap"></p>
<h3 id="Buckets"><a href="#Buckets" class="headerlink" title="Buckets"></a>Buckets</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">host ceph1 &#123;</span><br><span class="line">	id -2		# do not change unnecessarily</span><br><span class="line">	# weight 0.454</span><br><span class="line">	alg straw</span><br><span class="line">	hash 0	# rjenkins1</span><br><span class="line">	item osd.0 weight 0.091</span><br><span class="line">	item osd.1 weight 0.182</span><br><span class="line">	item osd.2 weight 0.182</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的定义是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[bucket-type] [bucket-name] &#123;</span><br><span class="line">  	id 		[a unique negative numeric ID]</span><br><span class="line">  	weight	[the relative capacity the item]</span><br><span class="line">  	alg		[the bucket type: uniform | list | tree | straw | straw2]</span><br><span class="line">  	hash	[the hash type: 0 by default]</span><br><span class="line">  	item	[item-name]		weight		[weight]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bucket-type: bucket的类型，用来指定OSD在CRUSH分层结构中的位置</p>
<p>bucket-name：唯一的bucket名称</p>
<p>id：唯一的ID，用一个负整数表示</p>
<p>weight：OSD的权重，权重越高，说明它的物理存储容量越大。建议1TB存储设备的权重为1.00，500G的权重为0.50。当然这是一个相对值。</p>
<p>alg：bucket类型的算法选择</p>
<blockquote>
<p>见最后bucket的类型</p>
</blockquote>
<p>hash：每个bucket都具有hash算法。目前ceph支持jrenkins1算法，默认hash设置为0使用该算法。</p>
<p>item：bucket里包含的元素，即叶子bucket，及其权重。这里bucket为host，叶子为OSD。</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules</span><br><span class="line">rule replicated_ruleset &#123;</span><br><span class="line">	ruleset 0</span><br><span class="line">	type replicated</span><br><span class="line">	min_size 1</span><br><span class="line">	max_size 10</span><br><span class="line">	step take default</span><br><span class="line">	step chooseleaf firstn 0 type host</span><br><span class="line">	step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule [rulename] &#123;</span><br><span class="line">  	ruleset		[ruleset]</span><br><span class="line">  	type		[replicated | erasure]</span><br><span class="line">  	min_size	[min-size]</span><br><span class="line">  	max_size	[max-size]</span><br><span class="line">  	step take	[bucket-type]</span><br><span class="line">  	step		[choose | chooseleaf]	firstn	[num]	type	[bucket-type]</span><br><span class="line">  	step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rulename：定义的规则名称</p>
<p>ruleset：一个整数值，指定这条规则所属的规则集</p>
<p>min_size和max_size用来限定这个rule的使用范围，即当一个pool的副本数小于min_size或者大于max_size的时候不使用这个rule。</p>
<p>step take：选择一个bucket，然后从这个bucket开始往下遍历，找出OSD</p>
<p>choose是从bucket中找出若干个type类型的项</p>
<p>chooseleaf操作是bucket中选出若干个type类型的leaf节点</p>
<blockquote>
<p>如果在一台机器上部署3各OSD，这里就要将type后面的“host”改为“OSD”，否则一直是HEALTH_ERR，因为选择规则是在bucket（host）中选择3个host类型的leaf节点，显然你这里没有，改为OSD的话就刚好。</p>
</blockquote>
<p>firstn后面的数字，表示按照前面规则选出节点的个数。如果是0，就按照副本数选择，如果是正数，就按个数来，如果是负数，就按副本数＋负数得到的值来选。</p>
<p>step emit：它首先弹出当前值，并清空栈。它会被典型的应用于rule结尾，也可以用于组织同一条rule的不同树。</p>
<h2 id="Bucket的类型"><a href="#Bucket的类型" class="headerlink" title="Bucket的类型"></a>Bucket的类型</h2><p>Cluster map由device和bucket组成，它们都有id和权重值。Bucket可以包含任意数量item。item可以都是的devices或者都是buckets。管理员控制存储设备的权重。权重和存储设备的容量有关。Bucket的权重被定义为它所包含所有item的权重之和。CRUSH基于4种不同的bucket type，每种有不同的选择算法。</p>
<p>CRUSH映射算法解决了效率和扩展性这两个矛盾的目标。而且当存储集群发生变化时，可以最小化数据迁移，并重新恢复平衡分布。CRUSH定义了四种具有不同算法的的buckets。每种bucket基于不同的数据结构，并有不同的c(r,x)伪随机选择函数。</p>
<p>不同的bucket有不同的性能和特性：</p>
<ul>
<li>Uniform：适用于具有相同权重的item，而且bucket很少添加删除item。它的查找速度是最快的。</li>
<li>List：它的结构是链表结构，所包含的item可以具有任意的权重。CRUSH从表头开始查找副本的位置，它先得到表头item的权重Wh、剩余链表中所有item的权重之和Ws，然后根据hash(x, r, item)得到一个[0~1]的值v，假如这个值v在[0~Wh/Ws)之中，则副本在表头item中，并返回表头item的id。否者继续遍历剩余的链表。</li>
<li>Tree：链表的查找复杂度是O(n)，决策树的查找复杂度是O(log n)。item是决策树的叶子节点，决策树中的其他节点知道它左右子树的权重，节点的权重等于左右子树的权重之和。CRUSH从root节点开始查找副本的位置，它先得到节点的左子树的权重Wl，得到节点的权重Wn，然后根据hash(x, r, node_id)得到一个[0~1]的值v，假如这个值v在[0~Wl/Wn)中，则副本在左子树中，否者在右子树中。继续遍历节点，直到到达叶子节点。Tree Bucket的关键是当添加删除叶子节点时，决策树中的其他节点的node_id不变。决策树中节点的node_id的标识是根据对二叉树的中序遍历来决定的(node_id不等于item的id，也不等于节点的权重)。</li>
<li>Straw：这种类型让bucket所包含的所有item<strong>公平竞争</strong>(不像list和tree一样需要遍历)。这种算法就像抽签一样，所有的item都有机会被抽中(只有最长的签才能被抽中)。每个签的长度是由length = f(Wi)<em>hash(x, r, i) 决定的，f(Wi)和item的权重有关，i是item的id号。c(r, x) = MAXi(f(Wi) </em> hash(x, r, i))。</li>
<li><strong>Straw2</strong>：它是改进的straw bucket。它会在项目A和B的<strong>权重都没有改变时避免任何数据移动</strong>。例如，增加或删除一个项目C，改变它的权重，数据只会移动到它上面或者从它上面移动到其他地方，而不会在bucket内的其他项目之间出现数据移动。因此，该算法减少了集群发生改变后的数据移动量。这是目前使用最广的bucket类型。（《ceph cookbook》）</li>
</ul>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> 

]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph — V11.2.0 KRAKEN(译)]]></title>
      <url>http://xiaqunfeng.cc/2017/01/24/ceph-kraken/</url>
      <content type="html"><![CDATA[<p>ceph的版本出到K了，针对bluestore又有了新的优化，并进行了一定的压力和故障测试，当然还有其他的特性，针对Jewel版本有较多改动。当前还没有什么中文资料，<a href="http://docs.ceph.org.cn/" target="_blank" rel="noopener">ceph中文社区</a>中关于V11.2.0还没有更新进去，所以闲暇之余翻译了一下，也给大家节省时间。<br><a id="more"></a></p>
<p>英文原文链接：<a href="http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken" target="_blank" rel="noopener">http://docs.ceph.com/docs/master/release-notes/#v11.2.0-kraken</a></p>
<h2 id="V11-2-0-KRAKEN"><a href="#V11-2-0-KRAKEN" class="headerlink" title="V11.2.0 KRAKEN"></a>V11.2.0 KRAKEN</h2><p>这是Kraken系列的第一个release版本。它适用于生产部署，并将维护到下一个稳定的版本Luminous，将在2017年春季完成。</p>
<h2 id="对比JEWEL版本的主要变化"><a href="#对比JEWEL版本的主要变化" class="headerlink" title="对比JEWEL版本的主要变化"></a>对比JEWEL版本的主要变化</h2><h3 id="RADOS"><a href="#RADOS" class="headerlink" title="RADOS"></a>RADOS</h3><ul>
<li>新的BlueStore 后端现在有一个稳定的磁盘格式，并通过了我们的故障和压力测试。尽管该后端仍被标记为实验性的，但我们鼓励用户使用非生产集群和非关键数据集进行尝试。</li>
<li>RADOS现在已经对EC-pool上的覆盖写（overwrites）进行了实验性支持。因为磁盘格式和实现尚未完成，所以必须启用特殊pool选项才能测试新功能。在群集上启用此选项将永久禁止该群集升级到将来的版本。</li>
<li>我们现在默认使用AsyncMessenger（ms type = async）而不是传统的SimpleMessenger。最明显的区别是，我们现在使用固定大小的线程池用于网络连接（而不是使用SimpleMessenger的每个套接字两个线程）。</li>
<li>现在一些OSD的故障几乎可以立即检测到，而先前心跳超时（默认为20秒）必须到期。这可以防止IO在主机保持启动但ceph-osd进程不再运行的故障情况下长时间阻塞。</li>
<li>有一个新的ceph-mgr守护进程。它目前与默认监视器并置，并且尚未使用太多，但基本的基础设施现在已到位。</li>
<li>减少了编码OSDMaps的大小。</li>
<li>当恢复（recovery）或重新平衡（rebalanceing）正在进行时，OSD现在停止擦除（scrubbing）。</li>
</ul>
<h3 id="RGW"><a href="#RGW" class="headerlink" title="RGW"></a>RGW</h3><ul>
<li>RGW现在支持一种新的区域类型，可用于通过ElasticSearch进行元数据索引。</li>
<li>RGW现在支持S3复合对象复制部分API。</li>
<li>现在可以重新分割现有的桶。注意，桶重新分片目前需要停止对特定桶的所有IO（特别是写）。</li>
<li>RGW现在支持对象的数据压缩。</li>
<li>Civetweb版本已经升级到1.8。</li>
<li>现在支持Swift静态网站API（以前已经添加了S3支持）。</li>
<li>S3桶生命周期API已添加。注意，目前它只支持对象到期。</li>
<li>支持自定义搜索过滤器已添加到LDAP身份验证实现中。</li>
<li>支持NFS版本3已添加到RGW NFS网关。</li>
<li>为librgw创建了一个Python绑定。</li>
</ul>
<h3 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h3><ul>
<li>RBD现在支持使用新的(实验)覆盖写(overwrite)支持在 EC RADOS pool 中存储images。必须使用新的rbd CLI <code>“-data-pool &lt;ec pool&gt;”</code> 选项来创建images，用以指定EC池存储后端数据对象。尝试在EC池上直接创建image不会成功，因为image的后端元数据仅在副本池上被支持。</li>
<li>rbd-mirror守护进程现在支持从主image复制动态image特征更新和image元数据key/value对到非主image。</li>
<li>image快照的数量可以选择性地限制为可配置的最大值。</li>
<li>rbd Python API现在支持异步IO操作。</li>
</ul>
<h3 id="CephFS"><a href="#CephFS" class="headerlink" title="CephFS"></a>CephFS</h3><ul>
<li>libcephfs函数的定义已更改为启用适当的uid / gid控制。库版本已增加以反映接口更改。</li>
<li>备用的回放(replay)MDS守护程序现在在执行删除操作的工作负载上消耗更少的内存。</li>
<li>Scrub现在修复backtrace，并用已发现的错误填充损坏ls。</li>
<li>cephfs-data-scan的新的pg_files子命令可以识别受损坏或丢失的RADOS PG影响的文件。</li>
<li>假阳性“未能响应缓存压力”警告已修复。</li>
</ul>
<h2 id="UPGRADING-FROM-JEWEL"><a href="#UPGRADING-FROM-JEWEL" class="headerlink" title="UPGRADING FROM JEWEL"></a>UPGRADING FROM JEWEL</h2><ul>
<li>所有集群必须首先升级到 Jewel 10.2.z，然后升级到 Kraken 11.2.z（或者，最终，Luminous 12.2.z）。</li>
<li>升级到Kraken之前，必须在Jewel集群上设置sortbitwise标志。如果未设置标志，则最新的Jewel（10.2.4+）版本会发出健康警告，因此可能已设置。如果不是，Kraken OSDs将拒绝启动，并将在其日志中打印和错误消息。</li>
<li>您可以按任意顺序升级OSD，监视器和MDS。 RGW守护进程应该最后升级。</li>
<li>升级时，新的ceph-mgr守护进程实例将自动被创建，与任何监视器一起。在Jewel到Kraken和Jewel到Luminous的升级中这将是事实，但在未来高于Luminous版本的升级中可能不是这样。如果你不与他们共置ceph-mon守护进程的话，你当然可以自由创建新的ceph-mgr守护进程实例，并销毁自动创建的实例。</li>
</ul>
<h2 id="BLUESTORE"><a href="#BLUESTORE" class="headerlink" title="BLUESTORE"></a>BLUESTORE</h2><p>BlueStore是一个新的后端，用于管理直接硬盘或SSD上每个OSD存储的数据。与现有的FileStore实现（它利用XFS文件系统将对象存储为文件）不同，BlueStore直接管理底层块设备。实现它自己的文件系统类磁盘结构，专为Ceph OSD工作负载而设计。 BlueStore的主要特点包括：</p>
<ul>
<li>默认情况下启用写入磁盘的所有数据的校验和，所有读取的校验和验证。</li>
<li>内联压缩支持，可以分别通过池属性或客户端提示在每个池或每个对象的基础上启用。</li>
<li>高效日记。与将所有数据写入其日志设备的FileStore不同，BlueStore仅记录元数据和（在某些情况下）小型写入，从而减少其日志的大小和吞吐量要求。与文件存储一样，日志可以与其他数据共存在同一设备上，或者分配在较小的高性能设备（例如，SSD或NVMe设备）上。 BlueStore日志默认只有512 MB。</li>
</ul>
<p>BlueStore磁盘格式预计将继续发展。但是，我们将在OSD中提供支持，以便在升级时迁移到新格式。</p>
<p>为了启用BlueStore，将以下内容添加到ceph.conf：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable experimental unrecoverable data corrupting features = bluestore</span><br></pre></td></tr></table></figure>
<p>要创建一个BlueStore OSD，在OSD创建期间将-bluestore选项传递给ceph-disk或ceph-deploy。</p>
<h2 id="打赏通道"><a href="#打赏通道" class="headerlink" title="打赏通道"></a>打赏通道</h2><p align="center">如果本文对你有所帮助，欢迎小额赞助。您的打赏也是我坚持随笔总结的动力！</p><br><div style="text-align: center"><img src="http://ojet8bprn.bkt.clouddn.com/%E6%89%93%E8%B5%8F1.jpg"></div><br><p align="center">谢谢O(∩_∩)O~</p> ]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ceph-data-inconsistency-bug]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/ceph-data-inconsistency-bug/</url>
      <content type="html"><![CDATA[<p>目前，块存储服务是Ceph存储中被使用的最普遍的服务之一，通过块存储服务，可以向客户端以使用块设备一样访问Ceph集群。然而，目前在使用块存储服务时，尤其是OpenStack与Ceph对接时，如果没有严格的控制Ceph端的对象大小（使用 &gt;= 8MB对象时），将有可能导致严重的数据不一致情况，该异常由于XFS文件系统本身对Fiemap的支持特性导致的。<br><a id="more"></a></p>
<h2 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h2><p>XFS使用fiemap时，当extents数量大于1364时，通过ioctl的FS_IOC_FIEMAP接口，获取的extents数量上限为1364，导致超出部分extents数据获取不到。这将导致，在开启fiemap时，Ceph集群进行recovery与backfill之后，产生大量数据不一致的情况，也是迄今为止Ceph中影响最大的，最严重的数据不一致BUG。</p>
<p>由于fiemap BUG，碎片化对象在recovery与backfill之后（fiemap 获取不正确的数据），从而使的恢复的对象数据与原对象数据不一致。而恢复后的副本若成为主副本，则可能发生静默读错误，并且如果使用Ceph策略自动修复对象（repair object之后），可能将错误数据覆盖至正确数据，数据将永远损毁。在某些情况下，还会触发对象永远处于inconsistent状态。</p>
<h2 id="复现方式"><a href="#复现方式" class="headerlink" title="复现方式"></a>复现方式</h2><p>初始化大量extents碎片文件test，使其成为一个拥有3999个extents的碎片文件。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/1.png" alt="1"></p>
<p>通过fiemap系统调用，获取这些extents<br><a href="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" target="_blank" rel="noopener"><img src="https://www.ustack.com/wp-content/uploads/2016/11/2-1.jpg" alt="2"></a><br>编译g++ do_fiemap.cc -o do_fiemap</p>
<p>通过该程序可以打印出可以获取的到fiemap extents, do_fiemap test，通过xfs_bmap test 打印出真正的extents数量后，进行比较。<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/3.jpg" alt="3"></p>
<p>可以看到，我们最先写了2000个extents，并通过xfs_bmap获取到了 2000个有内容的extents，但是通过fiemap系统调用，只获取到了1364个有数据的extents，所以在ceph中使用fiemap系统调用在某些情况下导致数据一致性BUG。</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>1）目前，在使用块存储使用场景时，通常情况下，默认使用4MB对象。在无特殊情况下，不用使用大于4MB 对象的RBD 镜像。</p>
<p>2）在I版以后，通过新的系统调用，seek_data, seek_hole，可以避免触发该BUG，防止extents过多时使用fiemap调用产生的问题<br><img src="https://www.ustack.com/wp-content/uploads/2016/11/4.png" alt="4"></p>
<p>这组系统调用，可以让使用者通过while循环，反复的发现文件中的data 与 hole，从而组织出一个文件中真正存在的数据，能够避免产生与fiemap系统调用类似的BUG，又保证了recovery或者clone时候只复制有用数据，而反复的系统调，应该会带来一定性能上的影响，请读者们自行测试。</p>
<p>目前，在I版本以后的ceph中，提供参数filestore_seek_data_hole，来启用该功能。当filestore_seek_data_hole 与 filestore_fiemap同时设置时，只用文件系统支持seek_data_hole，那么就会先通过seek_data_hole方式来获取文件的extents，所以在I版本以后的ceph中，应启用filestore_seek_data_hole功能来替代filestore_fiemap 功能。</p>
<p>3）对于已经使用8MB，16MB 甚至更大对象大小的RBD镜像，请暂时设置禁用Fiemap功能，并等待后续版本修复。</p>
<p>原文链接：[有云存储团队公布Ceph中最严重数据不一致BUG!](</p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[块存储的世界]]></title>
      <url>http://xiaqunfeng.cc/2017/01/20/block-storage-world/</url>
      <content type="html"><![CDATA[<p>在OpenStack中，存储是非常重要的一块，但是因为其提供方式的不同，即使是专业的工程师也会感到十分困惑。OpenStack的存储主要分为三大类，一是对象    存储服务，Swift解决的问题，二是块设备存储服务，在OpenStack里主要是提供给虚拟机的作为“硬盘”的存储，这里又分为本地块存储和分布式块存储，Cinder项目正    在解决相关的问题；第三类，数据库存储服务，Databases as a Service(DBaaS), 对应AWS里面的RDC，目前是一个正在孵化的项目，Trove，前身是Rackspace开源出&gt;    来的RedDwarf。本文重点介绍块存储服务。<br><a id="more"></a></p>
<blockquote>
<p>转载的文章，原文排版看的心累，链接见文末。</p>
</blockquote>
<p>​    UnitedStack OS的块存储是在OpenStack Cinder框架下开发的，开发过程中，我们对目前主流的块存储服务提供商和开源的块存储软件做了一个简要分析，希望能给从事块存储开发的工程师对于块存储一个全局的认识。        </p>
<p>​    块存储，简单来说就是提供了块设备存储的接口。用户需要把块存储卷附加到虚拟机(或者裸机)上后才可以与其交互。这些卷都是持久的: 它们可以被从运行实例上解除或者重新附加而数据保持完整不变。下面会先介绍常见的单机块设备工具来建立对块存储的初步印象。</p>
<h2 id="单机块存储"><a href="#单机块存储" class="headerlink" title="单机块存储"></a>单机块存储</h2><p>​    首先一个硬盘是一个块设备，内核检测到硬盘然后在/dev/下会看到/dev/sda/。因为我们需要利用一个硬盘来得到不同的分区来做不同的事，通过fdisk工具得到/dev/sda1, /dev/sda2等，这种通过直接写入分区表来规定和切分硬盘,是最死板的分区方式。</p>
<h3 id="LVM-amp-Device-mapper"><a href="#LVM-amp-Device-mapper" class="headerlink" title="LVM &amp; Device-mapper"></a>LVM &amp; Device-mapper</h3><p>​    LVM是一种逻辑卷管理器，通过LVM来对硬盘创建逻辑卷组和得到逻辑卷来完成目的比fdisk方式更加弹性。LVM对于不太熟悉其机制的人看来可能会造成不小的开销，但是相对于LVM对来的易用性其映射机制的负载小的足以忽略(在snapshot的情况会有不小的负载)。</p>
<p>​    LVM在大多数Linux使用者看来非常普通的工具，它同时也是OpenStack块存储项目的一种backend并且是默认的。通过LVM在每个主机创建Volume Group，通过Cinder(OpenStack块存储项目)的调度器可以在任何一个合适的主机(满足容量和其他要求)使用lvcreate创建一个块设备供Nova(OpenStack Computing项目)使用。</p>
<p>​    Device-mapper是一种支持逻辑卷管理的通用设备映射机制，为存储资源管理的块设备驱动提供了一个高度模块化的内核架构。LVM是基于Device-mapper的用户程序实现。</p>
<p>​    Device-mapper在内核中它通过一个模块化的Target Driver插件实现对IO请求的过滤或者重定向工作，当前已经实现的Target Driver插件包括软Raid、软加密、逻辑卷条带、多路径、镜像、快照等。整个 device mapper 机制由两部分组成–内核空间的 device mapper 驱动、用户空间的device mapper 库以及它提供的 dmsetup 工具。内核中主要提供完成这些策略所需要的机制。Device-mapper 用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等等，而具体过滤和重定向 IO 请求的工作由内核中相关代码完成。</p>
<h3 id="SAN-amp-iSCSI"><a href="#SAN-amp-iSCSI" class="headerlink" title="SAN &amp; iSCSI"></a>SAN &amp; iSCSI</h3><p>​    在接触了单机下的逻辑卷管理后，你需要了解<a href="http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">SAN</a>，目前主流的企业级存储方式。</p>
<p>​    大部分SAN使用<a href="http://en.wikipedia.org/wiki/SCSI" target="_blank" rel="noopener">SCSI</a>协议在服务器和存储设备之间传输和沟通，通过在SCSI之上建立不同镜像层，可以实现存储网络的连接。常见的有<a href="http://zh.wikipedia.org/wiki/ISCSI" target="_blank" rel="noopener">iSCSI</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_Protocol" target="_blank" rel="noopener">FCP</a>，<a href="http://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet" target="_blank" rel="noopener">Fibre Channel over Ethernet</a>等。</p>
<p>​    SAN通常需要在专用存储设备中建立，而iSCSI是基于TCP/IP的SCSI映射，通过iSCSI协议和<a href="http://linux-iscsi.sourceforge.net/" target="_blank" rel="noopener">Linux iSCSI</a>项目我们可以在常见的PC机上建立SAN存储。。</p>
<p>​    如何建立在PC机上的SAN可以参考<a href="http://linux.vbird.org/linux_server/0460iscsi.php" target="_blank" rel="noopener">iSCSI建立</a>，这篇文章的iSCSI target管理方式不太方便，通常利用<a href="http://linux-iscsi.org/wiki/Targetcli" target="_blank" rel="noopener">targetcli</a>管理target是及其方便的。targetcli可以直接建立和管理不同backstone类型的逻辑卷和不同的export方式，如建立ramdisk并且通过iSCSI export非常方便，操作方式见<a href="http://www.youtube.com/watch?v=mKjBsgOlYmE" target="_blank" rel="noopener">targetcli screencast Part 2 of 3: ISCSI – YouTube</a>。</p>
<h2 id="分布式块存储服务"><a href="#分布式块存储服务" class="headerlink" title="分布式块存储服务"></a>分布式块存储服务</h2><p>​    以上都是我们经常解除的单机下块存储环境，接下来开始本文的正式分享内容，包括公共云技术服务提供的块存储服务，开源的块存储框架和OpenStack目前对块存储的定义和支持情况。</p>
<h3 id="分布式块存储"><a href="#分布式块存储" class="headerlink" title="分布式块存储"></a>分布式块存储</h3><p>​    在面对极具弹性的存储需求和性能要求下，单机或者独立的SAN越来越不能满足企业的需要。如同数据库系统一样，块存储在scale up的瓶颈下也面临着scale out的需要。我们可以用以下几个特点来描述分布式块存储系统的概念:</p>
<ul>
<li>分布式块存储可以为任何物理机或者虚拟机提供持久化的块存储设备</li>
<li>分布式块存储系统管理块设备的创建、删除和attach/deattach。</li>
<li>分布式块存储支持强大的快照功能，快照可以用来恢复或者创建新的块设备</li>
<li>分布式存储系统能够提供不同IO性能要求的块设备</li>
</ul>
<h3 id="Amazon-EBS-amp-阿里云磁盘"><a href="#Amazon-EBS-amp-阿里云磁盘" class="headerlink" title="Amazon EBS &amp; 阿里云磁盘"></a>Amazon EBS &amp; 阿里云磁盘</h3><p>​    Amazon作为领先的IAAS服务商，其API目前是IAAS的事实标准。Amazon EC2目前仍然一骑绝尘，在大多数方面远超其他IAAS服务商。通过Amazon EC2的<a href="http://aws.amazon.com/cn/ec2/" target="_blank" rel="noopener">产品介绍</a>是快速了解Amazon EC2的捷径。</p>
<p>​    而<a href="http://aws.amazon.com/cn/ebs/" target="_blank" rel="noopener">EBS</a>是Amazon提供的块存储服务，通过EBS，用户可以随时增删迁移volume和快照操作。</p>
<p>​    Amazon EC2实例可以将根设备数据存储在Amazon EBS或者本地实例存储上。使用 Amazon EBS时，根设备中的数据将独立于实例的生命周期保留下来，使得在停止实例后仍可以重新启动使用，与笔记本电脑关机并在再次需要时重新启动相似。另一方面，本地实例存储仅在实例的生命周期内保留。这是启动实例的一种经济方式，因为数据没有存储到根设备中。</p>
<p>​    Amazon EBS提供两种类型的卷，即标准卷和预配置IOPS卷。它们的性能特点和价格不同，可以根据应用程序的要求和预算定制所需的存储性能。</p>
<p>​    标准卷可为要求有适度或突发式I/O的应用程序提供存储。这些卷平均可以提供大约 100 IOPS，最多可突增至数百 IOPS。标准卷也非常适合用作引导卷，其突发能力可提供快速的实例启动时间(通常十几秒)。</p>
<p>​    预配置 IOPS 卷旨在为数据库等 I/O 密集型随机读写工作负载提供可预计的高性能。创建一个卷时，利用预置 IOPS 为卷确定 IOPS 速率，随之 Amazon EBS 在该卷的生命周期内提供该速率。Amazon EBS 目前支持每预配置 IOPS 卷最多 4000 个IOPS。您可以将多个条带式卷组合在一起，为您的应程程序提供每个Amazon EC2数千IOPS的能力。</p>
<p>​    EBS可以在卷连接和使用期间实时拍摄快照。不过，快照只能捕获已写入Amazon EBS 卷的数据，不包含应用程序或操作系统已在本地缓存的数据。如果需要确保能为实例连接的卷获得一致的快照，需要先彻底地断开卷连接，再发出快照命令，然后重新连接卷。</p>
<p>​    EBS快照目前可以跨regions增量备份，意味着EBS快照时间会大大缩短，从另一面增加了EBS使用的安全性。</p>
<p>​    总的来说，Amazon EBS是目前IAAS服务商最引入注目的服务之一，目前的OpenStack、CloudStack等等其他开源框架都无法提供Amazon EBS对于的如此弹性和强大的服务。了解和使用Amazon EBS是学习IAAS块存储的最好手段。</p>
<h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>​    阿里云是国内的公共云计算服务商，不过这里阿里云目前的块存储服务较于Amazon EBS差的太远，阿里云磁盘目前仅支持在创建云主机的时候绑定云磁盘或者在升级云主机的进行云磁盘扩容，这从根本上就是传统的虚拟主机的特点而不是所谓的“云磁盘”。</p>
<p>从目前的阿里云磁盘的限制:</p>
<ul>
<li>无法快速创建或删除volume，在进行扩容时需要升级云主机才能达到，而升级云主机只有在下月云主机套餐到期时才能生效(想起了中国移动套餐)</li>
<li>一个云主机最多只能绑定3个云磁盘</li>
</ul>
<p>从阿里云磁盘目前的使用分析，阿里云磁盘系统目前还很不成熟，以下是我对阿里云磁盘实现的推测</p>
<ul>
<li>阿里云主机是跟磁盘绑定的，这意味着阿里云的云磁盘是local volume(因此性能还是挺可观的)。如果用户需要扩容、减少都是需要下个月更说明了这点，整个主机在扩容时去调度合适的有足够存储空间的host，然后进行扩容。</li>
<li>阿里云磁盘是分布式块存储系统，但是由于其QoS无法保证和其他资源调度原因无法提供足够的块存储支持。</li>
</ul>
<p>从<a href="http://www.infoq.com/cn/news/2013/06/aliyun-nihao-storage" target="_blank" rel="noopener">演讲回顾：阿里云存储技术的演进，以及云服务用例最佳实践</a>中了解到阿里云是基于自家的“盘古”系统，那么从实际使用来说，远没达到一般的分布式块存储系统的要求。</p>
<h3 id="Ceph-amp-Sheepdog"><a href="#Ceph-amp-Sheepdog" class="headerlink" title="Ceph &amp; Sheepdog"></a>Ceph &amp; Sheepdog</h3><p><a href="http://ceph.com/" target="_blank" rel="noopener">Ceph</a>是开源实现的PB级分布式文件系统，通过其分布式对象存储机制为上层提供了文件接口、块存储接口和对象存储接口。<a href="http://www.inktank.com/" target="_blank" rel="noopener">Inktank</a>是Ceph的主要支持商，也是目前Ceph开源社区的主要力量。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/11.png" alt="1"></p>
<p>​    Ceph目前是OpenStack支持的Backend中一个不错的开源块存储实现系统(即Cinder项目backend driver之一)，其实现分为三个部分: OSD, Monitor, MDS。OSD是底层对象存储系统，Monitor是集群管理系统，MDS是用来支持POSIX文件接口的Metadata Server。从Ceph的原始论文(<a href="http://ceph.newdream.net/papers/weil-thesis.pdf" target="_blank" rel="noopener">Ceph: Reliable, Scalable, and High-Performance Distributed Storage</a>)来看，Ceph专注于扩展性，高可用性和容错性。Ceph放弃了传统的Metadata查表方式(HDFS)而改用算法(CRUSH)去定位具体的block。</p>
<p>​    利用Ceph提供的RULES可以弹性地制订存储策略和Pool选择，Monitor作为集群管理系统掌握了全部的Cluster Map，Client在没有Map的情况下需要先向Monitor请求得到，然后通过Object id计算相应的OSD Server。</p>
<p>​    Ceph支持传统的POSIX文件接口，因此需要额外的MDS(Meatadata Server)支持文件元信息(Ceph的块存储和对象存储支持不需要MDS服务)。Ceph将Data和Metadata分离到两个服务上，跟传统的分布式系统如Lustre相比可以大大增强扩展性。在小文件读写上，Ceph读写文件会有[RTT*2]，在每次open时，会先去Metadata Server查询一次，然后再去Object Server。除了Open操作外，Ceph在Delete上也有问题，它需要到Metadata Server擦除对应的Metadata，是n(2)复杂度。Ceph在Metadata上并非只有坏处，通过Metadata Server，像目录列表等目录操作为非常快速，远超GlusterFS等其他分布式文件系统的目录或文件元操作。</p>
<p>利用Ceph可以作两种不同类型的“共享存储”支持:</p>
<ol>
<li>利用CephFS作分布式系统，所有虚拟机的块设备直接使用CephFS的命名空间</li>
<li>使用Ceph RBD块设备接口，从Ceph Cluster中导出Volume作为块设备Attach到虚拟机。</li>
</ol>
<p>关于Ceph作为块存储项目的几个问题需要考虑:</p>
<ul>
<li>Ceph在读写上不太稳定（有Btrfs的原因），目前Ceph官方推荐XFS作为底层文件系统</li>
<li>Ceph的扩展性和架构较复杂，如果需要介入Ceph，需要较长时间深入了解</li>
<li>Ceph的部署不够简易，目前Ceph的官方部署工具不太成熟，而对于的Pupet模块或者其他都没有公认的较好实现。</li>
<li>Ceph的稳定性依赖高版本Linux的一些特性，并且Ceph的rbd.ko在高版本中更具稳定性。</li>
</ul>
<h3 id="Sheepdog"><a href="#Sheepdog" class="headerlink" title="Sheepdog"></a>Sheepdog</h3><p>​    <a href="http://www.osrg.net/sheepdog/" target="_blank" rel="noopener">Sheepdog</a>是另一个分布式块存储系统实现，它与Ceph相比，最大优势就是代码短小好维护和hack的成本很小。Sheepdog也有很多Ceph不支持的特性，比如说Multi-Disk, Cluster-wide Snapshot等。</p>
<p>​    Sheepdog主要有两部分，一个是集群管理，另一个是存储服务。集群管理目前使用Corosync或者Zookper来完成，其存储服务的特点是在Client和存储Host有Cache的实现可以大大减小数据流量。</p>
<p>​    目前Sheepdog只在QEMU端提供Drive，而缺少library支持，这是Sheepdog目前最主要的问题。但是社区已经有相关的Blueprint在讨论这个问题。</p>
<p>了解Sheepdog通过以下链接:</p>
<ul>
<li><a href="http://www.slideshare.net/multics/overview-of-sheepdog" target="_blank" rel="noopener">Sheepdog Overview</a></li>
<li><a href="http://rdc.taobao.com/blog/cs/?tag=sheepdog" target="_blank" rel="noopener">Sheepdog 淘宝核心系统团队</a></li>
<li><a href="https://github.com/collie/sheepdog/wiki" target="_blank" rel="noopener">Sheepdog wiki</a>: Sheepdog的一系列Wiki如同它的代码一样简短出色</li>
</ul>
<p>目前Taobao是Sheepdog主要用户和社区贡献者，国内也有Startup参与Sheepdog的社区开发。</p>
<h3 id="Cinder"><a href="#Cinder" class="headerlink" title="Cinder"></a>Cinder</h3><p>​    <a href="https://wiki.openstack.org/wiki/Main_Page" target="_blank" rel="noopener">OpenStack</a>是目前流行的IAAS框架，提供了AWS类似的服务并且兼容其API。OpenStack Nova是计算服务，Swift是对象存储服务，Quantum是网络服务，Glance是镜像服务，Cinder是块存储服务，Keystone是身份认证服务，Horizon是Dashboard，另外还有Heat、Oslo、Ceilometer、Ironic等等项目。</p>
<p>​    <a href="https://wiki.openstack.org/wiki/Cinder" target="_blank" rel="noopener">Cinder</a>是OpenStack中提供类似于EBS块存储服务的API框架，它并没有实现对块设备的管理和实际服务提供，用来为后端不同的存储结构提供统一的接口与OpenStack进行整合，不同的块设备服务厂商在Cinder中实现其驱动支持。后端的存储可以是DAS，NAS，SAN，对象存储或者分布式文件系统。也就是说，Cinder的块存储数据完整性，可用性保障是由后端存储提供的。在<a href="https://wiki.openstack.org/wiki/CinderSupportMatrix" target="_blank" rel="noopener">CinderSupportMatrix</a>中可以看到众多存储厂商如NetAPP、IBM、SolidFire、EMC和众多开源块存储系统对Cinder的支持，在这里我们也可以看到OpenStack是非常受欢迎的。</p>
<p><img src="https://www.ustack.com/wp-content/themes/officalsite/uploads/2013/07/2.png" alt="2"></p>
<p>​    从上图我们也可以看到，Cinder只是提供了一层抽象，然后通过其后段支持的driver实现来发出命令来得到回应。关于块存储的分配信息以及选项配置等会被保存到OpenStack统一的DB中。</p>
<p>​    目前Cinder项目支持的操作包括创建/删除Volume，创建/删除Snapshot，Clone Volume，将Volume制作成Image或者将Image导出到Volume，备份/恢复Volume和扩展Volume大小，不同的Backend会实现不同程度的操作，但基本的创建Volume和快照操作都是支持的。目前令人振奋的Amazon EBS的QoS机制已经在Cinder社区中得到广泛讨论，在经历近两个月的Patch Review之后，整个QoS机制即将正式进入Cinder项目。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    目前分布式块存储的实现仍然是由Amazon EBS领衔，其卓越稳定的读写性能、强大的增量快照和跨区域块设备迁移，以及令人惊叹的QoS控制都是目前开源或者其他商业实现无法比拟的。</p>
<p>​    不过Amazon EBS始终不是公司私有存储的一部分，作为企业IT成本的重要部分，块存储正在发生改变。EMC在一个月前发布了其ViPR平台，并开放了其接口试图接纳其他厂商和开源实现。Nexenta在颠覆传统的的存储专有硬件，在其上软件实现原来只有专有SDN的能力，让企业客户完全摆脱存储与厂商的绑定。Inktank极力融合OpenStack并推动Ceph在OpenStack社区的影响力都说明了无论是目前的存储厂商还是开源社区都在极力推动整个分布式块存储的发展，存储专有设备的局限性正在进一步弱化了原有企业的存储架构。</p>
<p>​    在分布式块存储和OpenStack之间我们可以打造更巩固的纽带，UnitedStack存储团队在开源存储的基础上，结合本地块存储和分布式块存储的优势，为UnitedStack OS提供一个通用的存储解决方案。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-1/" target="_blank" rel="noopener">通用线程: 学习 Linux LVM，第 1 部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/filesystem/lvm/lvm-2/" target="_blank" rel="noopener">通用线程：学习 Linux LVM，第 2部分</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="noopener">Ceph：一个 Linux PB 级分布式文件系统</a></li>
<li><a href="http://www.alidata.org/archives/1589" target="_blank" rel="noopener">分布式文件系统Ceph调研1 – RADOS</a></li>
<li><a href="http://ceph.com/docs/next/architecture/" target="_blank" rel="noopener">Ceph Architecture</a></li>
<li><a href="http://way4ever.com/?p=375" target="_blank" rel="noopener">Ceph的现状</a></li>
<li><a href="http://way4ever.com/?p=122" target="_blank" rel="noopener">ceph的CRUSH数据分布算法介绍</a></li>
<li><a href="http://ceph.com/docs/next/dev/" target="_blank" rel="noopener">Ceph INTERNAL DEVELOPER DOCUMENTATION</a></li>
<li>原文链接：<a href="https://www.ustack.com/blog/block-storage-overview/" target="_blank" rel="noopener">块存储的世界</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Distribute </category>
            
        </categories>
        
        
        <tags>
            
            <tag> storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——uptime]]></title>
      <url>http://xiaqunfeng.cc/2017/01/17/Linux-cmd-uptime/</url>
      <content type="html"><![CDATA[<p>打印系统总共运行了多长时间和系统的平均负载。<br><a id="more"></a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> uptime [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -p, --pretty   show uptime in pretty format</span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -s, --since    system up since</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see uptime(1).</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uptime</span><br><span class="line"> 17:40:45 up 1 day,  6:37,  3 users,  load average: 0.27, 0.21, 0.31</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>显示内容</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>17:40:45</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day,  6:37</td>
<td>主机已运行时间，时间越大，说明机器越稳定</td>
</tr>
<tr>
<td>3 users</td>
<td>用户连接数，是总连接数而不是用户数</td>
</tr>
<tr>
<td>load average: 0.27, 0.21, 0.31</td>
<td>最近1，5，15分钟的系统平均负载</td>
</tr>
</tbody>
</table>
<p><strong>系统平均负载</strong>：在特定时间间隔内运行队列中的平均进程数。</p>
<p><strong>查看CPU内核数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/cpuinfo |grep &quot;processor&quot;|wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
<h3 id="运行时间格式输出"><a href="#运行时间格式输出" class="headerlink" title="运行时间格式输出"></a>运行时间格式输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uptime -p</span><br><span class="line">up 1 day, 6 hours, 56 minutes</span><br></pre></td></tr></table></figure>
<h3 id="系统启动的时间"><a href="#系统启动的时间" class="headerlink" title="系统启动的时间"></a>系统启动的时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uptime -s</span><br><span class="line">2017-01-16 11:03:35</span><br></pre></td></tr></table></figure>
<h3 id="uptime版本"><a href="#uptime版本" class="headerlink" title="uptime版本"></a>uptime版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uptime -V</span><br><span class="line">uptime from procps-ng 3.3.9</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决calamari无法获取集群hosts信息的BUG]]></title>
      <url>http://xiaqunfeng.cc/2017/01/12/ceph-calamari/</url>
      <content type="html"><![CDATA[<p>如题，环境是ubuntu 14.04，解决过程和方法详见正文。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在磨磨的文章中看到这个问题，他是在CentOS上，通过修改 <code>/usr/lib/python2.7/site-packages/salt/master.py</code> 文件，然后重启salt-master和salt-minion服务来解决的，链接在文末。原理类似，可ubuntu上并不能完全照搬。</p>
<h2 id="折腾过程"><a href="#折腾过程" class="headerlink" title="折腾过程"></a>折腾过程</h2><blockquote>
<p>这部分的内容为折腾求证的过程，想看解决方法的可以直接跳过！</p>
</blockquote>
<p>在ubuntu上并没有这个文件和路径，通过tab可以看到site开头的只有这几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@calamari:~# vim /usr/lib/python2.7/site</span><br><span class="line">sitecustomize.py   sitecustomize.pyc  site.py            site.pyc</span><br></pre></td></tr></table></figure>
<p>我以为可能是系统下包安装的位置不对而已，好，那我就查看一下ubuntu下salt-master的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">root@calamari:~# dpkg -L salt-master</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/man</span><br><span class="line">/usr/share/man/man1</span><br><span class="line">/usr/share/man/man1/salt.1.gz</span><br><span class="line">/usr/share/man/man1/salt-run.1.gz</span><br><span class="line">/usr/share/man/man1/salt-master.1.gz</span><br><span class="line">/usr/share/man/man1/salt-key.1.gz</span><br><span class="line">/usr/share/man/man1/salt-cp.1.gz</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/salt-master</span><br><span class="line">/usr/share/doc/salt-master/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/salt-master/NEWS.Debian.gz</span><br><span class="line">/usr/share/doc/salt-master/copyright</span><br><span class="line">/usr/bin</span><br><span class="line">/usr/bin/salt-run</span><br><span class="line">/usr/bin/salt-master</span><br><span class="line">/usr/bin/salt-key</span><br><span class="line">/usr/bin/salt-cp</span><br><span class="line">/usr/bin/salt</span><br><span class="line">/lib</span><br><span class="line">/lib/systemd</span><br><span class="line">/lib/systemd/system</span><br><span class="line">/lib/systemd/system/salt-master.service</span><br><span class="line">/etc</span><br><span class="line">/etc/init.d</span><br><span class="line">/etc/init.d/salt-master</span><br><span class="line">/etc/init</span><br><span class="line">/etc/init/salt-master.conf</span><br><span class="line">/etc/salt</span><br><span class="line">/etc/salt/master</span><br><span class="line">/etc/salt/master.d</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>find</code> 命令去 <code>/etc, /usr, /lib</code> 这几个目录下找 <code>master.py</code> ，结果真没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find: `master.py&apos;: No such file or directory</span><br></pre></td></tr></table></figure>
<p>好吧，下面来看问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在calamari的web界面下，查看 MANAGE -&gt; Cluster -&gt;HOSTS 信息，发现啥也没有，如下图所示：<img src="http://ojet8bprn.bkt.clouddn.com/calamari-1.png" alt="calamari-1"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>calamari的salt-master节点在读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/cache/salt/master/minions/&#123;minion-hostname&#125;/data.p</span><br></pre></td></tr></table></figure>
<p>该文件的时候有权限问题，当前权限为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw------- 1 root root 3019 Jan 10 11:06 data.p</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改权限为 644 即可，写了个脚本，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for x in 0 1 2</span><br><span class="line">do</span><br><span class="line">    chmod 644 /var/cache/salt/master/minions/ceph$x/data.p</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>修改完后，再次查看，可以看到hosts的详细信息了<img src="http://ojet8bprn.bkt.clouddn.com/calamari-2.png" alt="calamari-2"></p>
<blockquote>
<p>当然，重启 salt-minion 后又需要在 salt-master 机器上重新执行一遍，<del>~~(&gt;_&lt;)</del>~~，忧伤~</p>
</blockquote>
<p>磨磨的方法：<a href="http://www.zphj1987.com/2017/01/09/calamari-node-info/" target="_blank" rel="noopener">centos下该问题的解决方法</a></p>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ceph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——history及其优化]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/linux-cmd-history/</url>
      <content type="html"><![CDATA[<p>没啥好说的，就是查看历史输入的命令。这里引入两个优化点，一是历史记录带时间，二是可以统计汇总不同终端下的命令。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history [n]</span><br><span class="line">history [-c]</span><br><span class="line">history [-raw] histfiles</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>数字，列出最近的 n 条命令列表</td>
</tr>
<tr>
<td>-c</td>
<td>将目前的shell中的所有 history 内容全部清除</td>
</tr>
<tr>
<td>-a</td>
<td>将目前新增的history指令新增入 histfiles中，若没有➕histfiles，则预设写入 ~/.bash_history</td>
</tr>
<tr>
<td>-r</td>
<td>将histfiles的内容读到目前这个shell的history记忆中</td>
</tr>
<tr>
<td>-w</td>
<td>将目前的history记忆内容写入histfiles</td>
</tr>
</tbody>
</table>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more, less, tail, head</code> 来使用，其他复杂用法这里不作介绍。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history | more</span><br><span class="line">history | tail -4</span><br></pre></td></tr></table></figure>
<h2 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h2><p><strong>出发点</strong>：在项目中，在不同终端下执行了一系列的命令后，翻不到历史记录，也没有汇总，也不知道每条命令的执行时间，所以需要对该命令进行优化。</p>
<p><strong>优化点</strong></p>
<ul>
<li>历史记录里面每条命令带有时间</li>
<li>所有终端命令都记录到history当中去</li>
</ul>
<blockquote>
<p>命令的汇总限同一个机器下的同一个用户</p>
</blockquote>
<p>注：以下设置方法适用ubuntu，其他系统类似。ubuntu上修改的文件是 <code>/etc/bash.bashrc</code>，mac上修改的文件是 <code>/etc/bashrc</code> 。</p>
<h3 id="添加日期"><a href="#添加日期" class="headerlink" title="添加日期"></a>添加日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">export HISTTIMEFORMAT</span><br></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候，history命令的显示就带有日期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">448  2017-01-11 11:42:01 vim /etc/bash.bashrc </span><br><span class="line">449  2017-01-11 11:42:45 source /etc/bash.bashrc </span><br><span class="line">450  2017-01-11 11:40:18 history</span><br><span class="line">451  2017-01-11 11:41:11 ls</span><br><span class="line">452  2017-01-11 11:41:12 pwd</span><br><span class="line">453  2017-01-11 11:41:35 history</span><br></pre></td></tr></table></figure>
<h3 id="不同终端命令汇总"><a href="#不同终端命令汇总" class="headerlink" title="不同终端命令汇总"></a>不同终端命令汇总</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Avoid duplicates</span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br><span class="line"># When the shell exits, append to the history file instead of overwriting it</span><br><span class="line">shopt -s histappend</span><br><span class="line"></span><br><span class="line"># After each command, append to the history file and reread it</span><br><span class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&apos;\n&apos;&#125;history -a; history -c; history -r&quot;</span><br></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p><strong>新开终端</strong>的时候就可以看到之前在该机器该用户下的所有命令操作。</p>
<h3 id="调整记录命令长度"><a href="#调整记录命令长度" class="headerlink" title="调整记录命令长度"></a>调整记录命令长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p>在末尾添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HISTSIZE=1000	# 该数字自己定</span><br></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="剔除连续重复的条目"><a href="#剔除连续重复的条目" class="headerlink" title="剔除连续重复的条目"></a>剔除连续重复的条目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
<p>将 HISTCONTROL 设置为 ignoredups</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Avoid duplicates</span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br></pre></td></tr></table></figure>
<p>执行使生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/bash.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令——crontab]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/linux-cmd-crontab/</url>
      <content type="html"><![CDATA[<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br><a id="more"></a></p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>crontab使用格式说明</p>
<p><img src="http://ojet8bprn.bkt.clouddn.com/crontab%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.png" alt="crontab格式说明"></p>
<p>如图所示：</p>
<ul>
<li>第1列分钟0～59</li>
<li>第2列小时0～23（0表示子夜）</li>
<li>第3列日1～31</li>
<li>第4列月1～12</li>
<li>第5列星期0～7（0和7表示星期天）</li>
<li>第6列要运行的命令</li>
</ul>
<p><strong>TIPS</strong></p>
<p>每一列之间用空格隔开。</p>
<p>破折号 <code>-</code> 表示一个整数范围。例如：“2-4”表示“2,3,4”。</p>
<p>逗号 <code>,</code> 表示枚举的意思，一个指定的集合。例如：“1,5,8”。</p>
<p>正向斜杠 <code>/</code> 表示间隔频率。例如：“8-20/2”表示从8点到20点每2小时执行一次。</p>
<p><code>/</code> 可以和 <code>*</code> 一起使用。例如<code>*/5</code>，如果用在minute字段，表示每五分钟执行一次。<code>* */1 * * *</code>  表示每一小时执行一次。</p>
<p><strong>命令格式</strong></p>
<p><code>crontab [-u user] file crontab [-u user][ -e | -l | -r ]</code></p>
<h2 id="选项详解"><a href="#选项详解" class="headerlink" title="选项详解"></a>选项详解</h2><ul>
<li>-u user：用来设定某个用户的crontab服务；</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><p>1、创建crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab yourcron</span><br></pre></td></tr></table></figure>
<p>2、列出crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>3、编辑crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure>
<p>4、删除crontab文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$crontab -r</span><br></pre></td></tr></table></figure>
<p>5、ubuntu下启动、停止与重启cron</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo /etc/init.d/cron start</span><br><span class="line">$sudo /etc/init.d/cron stop</span><br><span class="line">$sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>
<p>6、清理用户的邮件日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p><code>&gt; /dev/null 2&gt;&amp;1</code> 表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<blockquote>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要</p>
</blockquote>
<h3 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h3><p><strong>一种是新建crontab任务，然后重启cron服务</strong></p>
<p>第一步、创建一个crontab文件</p>
<p>设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。使用vi的话，在$HOME目录下的. profile文件中加入一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=vi; export EDITOR</span><br></pre></td></tr></table></figure>
<p>创建一个比如名为 testcron 的文件，在其中加入自己想要执行的命令，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */3 * * * command &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>把这个新创建的文件作为cron命令的参数，用来创建crontab任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab testcron</span><br></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>
<p><strong>失败！</strong></p>
<blockquote>
<p>试过多次，不知道为啥这种通过自己创建crontab文件的方式不行，查资料也未果。后续有机会再试试，就暂时先用后一种可用的方法吧。有知道的忘不吝指教。</p>
</blockquote>
<p><strong>另一种是把要执行的命令直接写入 <code>/etc/crontab</code> 中，然后重启cron服务</strong></p>
<p>第一步、直接编辑 /etc/crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/crontab</span><br><span class="line">添加自己的任务</span><br><span class="line">* * * * * root sh myjob.sh &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>第二步、重启cron服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo /etc/init.d/cron restart</span><br></pre></td></tr></table></figure>
<p><strong>成功！</strong></p>
<p>如果需要停止该任务的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo /etc/init.d/cron stop</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实例1：每1分钟执行一次myCommand</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure>
<p>实例2：每小时的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure>
<p>实例3：在上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br></pre></td></tr></table></figure>
<p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br></pre></td></tr></table></figure>
<p>实例5：每周一上午8点到11点的第3和第15分钟执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br></pre></td></tr></table></figure>
<p>实例6：每晚的21:30重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例7：每月1、10、22日的4 : 45重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例8：每周六、周日的1 : 10重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例10：每星期六的晚上11 : 00 pm重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例11：每一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<p>实例12：晚上11点到早上7点之间，每隔一小时重启smb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23-7 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件中。</p>
<p>2、新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>3、<code>crontab -r</code> 将从Crontab目录（/var/spool/cron）中删除用户的Crontab文件，该用户的所有crontab都将被删除。</p>
<p>4、在crontab中 <code>%</code> 表示换行的意思。使用的时候必须进行转义%。比如经常使用的 <code>date ‘+%Y%m%d’</code> 在crontab里是不会执行的，应该换成 <code>date ‘+\%Y\%m\%d’’</code>。</p>
<p><strong>参考资料</strong>：<a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">crontab 定时任务</a></p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下利用screen进行屏幕协作]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/linux-screen/</url>
      <content type="html"><![CDATA[<p>Linux本身是支持多终端并行处理的，但是某些时候我们可能需要两个人同时处理同一个终端，比如远程协助定位问题等。screen正好能满足这个需求。<br><a id="more"></a></p>
<h2 id="screen的安装"><a href="#screen的安装" class="headerlink" title="screen的安装"></a>screen的安装</h2><p>debian和ubuntu下安装方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install screen</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>假设现在有a和b需要进行屏幕协作。</p>
<blockquote>
<p>他们需要登录同一台服务器/机器</p>
<p>必须使用相同的账户，不同账户之前不能屏幕协作</p>
</blockquote>
<p>第一步：a 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S zp</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>S</code> 是大写</p>
<p>第二步：b 在终端上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -x zp</span><br></pre></td></tr></table></figure>
<p>这时两边的操作是实时而且同步的。</p>
<h2 id="退出协作"><a href="#退出协作" class="headerlink" title="退出协作"></a>退出协作</h2><p>在任意一个终端上输入命令：<code>exit</code> ，输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[screen is terminating]</span><br></pre></td></tr></table></figure>
<p>表示退出成功。</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下配置邮件发送]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu-email-send/</url>
      <content type="html"><![CDATA[<p>Linux下发送email有很多种方式，包括sendmail、mailx、mutt、uuencode等等。这里介绍ubuntu下使用mutt和msmtp发送邮件的配置方法。<br><a id="more"></a></p>
<h2 id="软件包的安装"><a href="#软件包的安装" class="headerlink" title="软件包的安装"></a>软件包的安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mutt</span><br><span class="line">sudo apt-get install msmtp</span><br></pre></td></tr></table></figure>
<h2 id="文件的配置"><a href="#文件的配置" class="headerlink" title="文件的配置"></a>文件的配置</h2><h3 id="配置-mutt"><a href="#配置-mutt" class="headerlink" title="配置 mutt"></a>配置 mutt</h3><p>,系统全局设置配置文件在 /etc/Muttrc,如果使用某个系统用户，可以在~/.muttc中设置，没有该文件，就自己创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi .muttrc</span><br><span class="line"></span><br><span class="line">set sendmail=&quot;/usr/bin/msmtp&quot;</span><br><span class="line">set use_from=yes</span><br><span class="line">set realname=&quot;xia&quot;</span><br><span class="line">set from=abcdefg@126.com</span><br><span class="line">set envelope_from=yes</span><br></pre></td></tr></table></figure>
<h3 id="配置msmtp"><a href="#配置msmtp" class="headerlink" title="配置msmtp"></a>配置msmtp</h3><p>创建 ~/.msmtprc 和 ~/.msmtp.log，分别为配置文件和日志文件。</p>
<p><strong>1、创建配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi .msmtprc</span><br></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">account default</span><br><span class="line">host smtp.126.com</span><br><span class="line">from youremailname@126.com</span><br><span class="line">auth plain</span><br><span class="line">user youremailname@126.com</span><br><span class="line">password xxxxxxx</span><br><span class="line">logfile ~/.msmtp.log</span><br></pre></td></tr></table></figure>
<p>由于password是明文，所以需要修改此文件的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 .msmtprc</span><br></pre></td></tr></table></figure>
<p><strong>特别注意</strong>：</p>
<blockquote>
<p>这里的密码填的是你的授权密码，不是登录密码!</p>
</blockquote>
<p><strong>2、创建日志文件 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.msmtp.log</span><br></pre></td></tr></table></figure>
<h2 id="邮件发送测试"><a href="#邮件发送测试" class="headerlink" title="邮件发送测试"></a>邮件发送测试</h2><p>查看SMTP服务器是否支持认证的TLS加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># msmtp --host=smtp.126.com --serverinfo</span><br><span class="line">SMTP server at smtp.126.com (m15-111.126.com [220.181.15.111]), port 25:</span><br><span class="line">    126.com Anti-spam GT for Coremail System (126com[20140526])</span><br><span class="line">Capabilities:</span><br><span class="line">    PIPELINING:</span><br><span class="line">        Support for command grouping for faster transmission</span><br><span class="line">    STARTTLS:</span><br><span class="line">        Support for TLS encryption via the STARTTLS command</span><br><span class="line">    AUTH:</span><br><span class="line">        Supported authentication methods:</span><br><span class="line">        PLAIN LOGIN </span><br><span class="line">This server might advertise more or other capabilities when TLS is active.</span><br></pre></td></tr></table></figure>
<p>发送一个简单的邮件测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot; | mutt -s &quot;title&quot; 12456789@qq.com</span><br></pre></td></tr></table></figure>
<p>登录QQ邮箱，可以正常收到邮件，成功！</p>
<h2 id="四种发送方式"><a href="#四种发送方式" class="headerlink" title="四种发送方式"></a>四种发送方式</h2><p>1、<strong>带有主题，从文件中读取邮件的正文，并发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mutt -s &quot;hello mutt&quot; user@example.com &lt; message.txt</span><br></pre></td></tr></table></figure>
<p>2、<strong>通过管道获取 <code>echo</code>命令输出作为邮件内容发送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com</span><br></pre></td></tr></table></figure>
<p>3、<strong>发送带附件的邮件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;hello mutt&quot; | mutt -s &quot;Testing mutt&quot; user@example.com -a test.tar.gz</span><br></pre></td></tr></table></figure>
<p>多个附件的话在每个附件前加上 <code>-a</code> 即可。</p>
<p>4、<strong>发送给多个收件人</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello mutt&quot; | mutt -s &quot;Testing muttt&quot; 111111@qq.com,222222@163.com -c 3333333@qq.com -b 44444444@126.com</span><br></pre></td></tr></table></figure>
<p>多个收件人之间用逗号隔开</p>
<p><strong>抄送</strong>，前面加参数 <code>-c</code> </p>
<p><strong>密送</strong>，前面加参数 <code>-b</code></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1、出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msmtp: authentication failed (method PLAIN)</span><br><span class="line">msmtp: server message: 530 Error: A secure connection is requiered(such as ssl). More information at http://service.mail.qq.com/cgi-bin/help?id=28</span><br><span class="line">msmtp: could not send mail (account default from /root/.msmtprc)</span><br><span class="line">Error sending message, child exited 77 (Insufficient permission.).</span><br><span class="line">Could not send the message.</span><br></pre></td></tr></table></figure>
<p>原因，没有权限进行操作</p>
<p>解决方法：</p>
<blockquote>
<p>登录网页邮箱，设置开启POP3/SMTP服务、IMAP/SMTP服务</p>
</blockquote>
<p><strong>参考资料</strong></p>
<p><a href="http://www.cnblogs.com/xiazh/archive/2011/04/15/2016966.html" target="_blank" rel="noopener">ubuntu下使用mutt和msmtp发送邮件的简单配置</a></p>
<p><a href="https://linux.cn/article-5502-1.html" target="_blank" rel="noopener">4个可以发送电子邮件的命令行工具</a></p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下系统打包]]></title>
      <url>http://xiaqunfeng.cc/2017/01/11/ubuntu-package-system/</url>
      <content type="html"><![CDATA[<p>介绍在ubuntu下利用remastersys工具给系统打包成 iso 镜像的方法，在其他系统（centos、windows等）下方法类似，不在赘述。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在初始环境下，经过多次反复安装和配置才组建完成的自己需要的环境，其中各种版本问题和依赖较多，安装过程繁杂，为了避免痛苦的安装过程轮回发生，需要给系统打个包，后续使用直接安装即可。</p>
<p>使用工具：Remastersys</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、依赖项的安装"><a href="#1、依赖项的安装" class="headerlink" title="1、依赖项的安装"></a>1、依赖项的安装</h3><p>依赖：<a href="ftp://ftp.gwdg.de/pub/linux/easyvdr/mirror/remastersys/ubuntu/remastersys/remastersys_3.0.4-2_all.deb" target="_blank" rel="noopener">remastersys_3.0.4-2_all.deb</a>，点击即可下载，也可以自己去去<a href="http://www.filewatcher.com/" target="_blank" rel="noopener">filewatcher</a>搜索下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install plymouth-x11 </span><br><span class="line">sudo dpkg -i remastersys_3.0.4-2_all.deb</span><br></pre></td></tr></table></figure>
<h3 id="2、Remastersys安装"><a href="#2、Remastersys安装" class="headerlink" title="2、Remastersys安装"></a>2、Remastersys安装</h3><p>2.1、添加安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb http://www.remastersys.com/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>2.2、更新安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo install remastersys</span><br><span class="line">sudo remastersys</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo remastersys  backup|clean|dist  [cdfs|iso]  [filename.iso]</span><br></pre></td></tr></table></figure>
<p>两种打包方式：backup和dist</p>
<p>backup 是对整个系统完全打包，包含个人文件</p>
<p>dist 方式用做发行，不包含个人文件</p>
<blockquote>
<p>更多使用方法可以参考<a href="http://forum.ubuntu.org.cn/viewtopic.php?t=174719" target="_blank" rel="noopener">ubuntu论坛</a></p>
</blockquote>
<h3 id="系统打包"><a href="#系统打包" class="headerlink" title="系统打包"></a>系统打包</h3><p>3.1、产生一个只有档案系统的可发布的 livecd/dvd </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo remastersys dist cdfs</span><br></pre></td></tr></table></figure>
<p>3.2、产生一个可发布其名叫 filename.iso的ISO文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo remastersys dist iso filename.iso</span><br></pre></td></tr></table></figure>
<p>3.3、将产生的iso文件移动到安全的位置(如果不移动会被清除掉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /home/remastersys/remastersys/filename.iso /root/</span><br></pre></td></tr></table></figure>
<p>3.4、清除由 remastersys产生的临时文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo remastersys clean</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac上hexo博客的搭建]]></title>
      <url>http://xiaqunfeng.cc/2017/01/06/hexo-deploy/</url>
      <content type="html"><![CDATA[<p>​    第一篇hexo博客，介绍了在mac上搭建hexo博客的全过程。包括：准备工作、本地站点的建立、启动和部署站点、创建新文章、发布到github、更换主题 和 绑定域名。<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><strong>github</strong></li>
<li><strong>homebrew</strong></li>
<li><strong>node.js 和 npm</strong></li>
<li><strong>hexo</strong></li>
</ol>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>1、github账号</p>
<p>​    这部分略过，没有的话自己注册一个。然后将mac上的公钥添加到github上去。</p>
<p>2、建立仓库</p>
<p>​    严格按照 <code>git用户名</code>.<code>github</code>.<code>io</code> 来命名。我这里就叫：<code>xiaqunfeng.github.io</code> 。</p>
<h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><p>homebrew 是MAC OSX 上面用来安装 或者 卸载软件用的非常方面的一个软件。在终端上执行如下命令即可安装，参考<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">官网</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>不推荐使用 brew 安装node， 直接从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载，然后双击安装。我这里选择的版本是：v6.9.3 LTS。node.js 集成带有npm。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v6.9.3</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line">3.10.10</span><br></pre></td></tr></table></figure>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>安装完后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo: 3.2.2</span><br><span class="line">hexo-cli: 1.0.2</span><br><span class="line">os: Darwin 16.1.0 darwin x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 6.9.3</span><br><span class="line">v8: 5.1.281.89</span><br><span class="line">uv: 1.9.1</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">icu: 57.1</span><br><span class="line">modules: 48</span><br><span class="line">openssl: 1.0.2j</span><br></pre></td></tr></table></figure>
<h2 id="hexo命令行使用"><a href="#hexo命令行使用" class="headerlink" title="hexo命令行使用"></a>hexo命令行使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">常用命令：</span><br><span class="line">hexo help			#查看帮助</span><br><span class="line">hexo init 			#初始化一个目录</span><br><span class="line">hexo new &quot;postName&quot; 		#新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; 	#新建页面</span><br><span class="line">hexo generate 			#生成网页，可以在 public 目录查看整个网站的文件</span><br><span class="line">hexo server 			#本地预览，&apos;Ctrl+C&apos;关闭</span><br><span class="line">hexo deploy 			#部署.deploy目录</span><br><span class="line">hexo clean 			#清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<h2 id="建立本地站点"><a href="#建立本地站点" class="headerlink" title="建立本地站点"></a>建立本地站点</h2><p>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。（文件夹不需要提前建好，会自行创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建文件夹目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy 		#需要部署的文件</span><br><span class="line">├── node_modules 	#Hexo插件</span><br><span class="line">├── public 		#生成的静态网页文件</span><br><span class="line">├── scaffolds 		#模板</span><br><span class="line">├── source 		#博客正文和其他源文件</span><br><span class="line">| ├── _drafts 		#草稿(刚开始没有)</span><br><span class="line">| └── _posts 		#文章</span><br><span class="line">├── themes 		#主题</span><br><span class="line">├── _config.yml 	#全局配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<h2 id="启动站点"><a href="#启动站点" class="headerlink" title="启动站点"></a>启动站点</h2><p>执行 hexo server 启动站点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到站点了。</p>
<h2 id="部署站点"><a href="#部署站点" class="headerlink" title="部署站点"></a>部署站点</h2><p>编辑文件 <code>_config.yml</code> ，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repository: https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：冒号后面要留 <strong>空格</strong>！！</p>
<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p><strong>方法1</strong>、<code>hexo n</code>创建新文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;我的第一篇hexo博客&quot;</span><br><span class="line">INFO  Created: ~/hexo-blog/source/_posts/我的第一篇hexo博客.md</span><br></pre></td></tr></table></figure>
<p>然后用编辑器打开编辑即可。</p>
<p><strong>方法2</strong>、直接在 <code>source/_posts</code> 中新建一个md文件，进行编辑</p>
<p>在hexo-blog文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中输入<code>http://localhost:4000</code>就可以看到新加的文章了。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>执行 <code>hexo d</code> ，发现如下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">hexo-site@0.0.0 /Users/xiaqunfeng/hexo-blog</span><br><span class="line">└── hexo-deployer-git@0.2.0</span><br></pre></td></tr></table></figure>
<p>再执行 <code>hexo d</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Username for &apos;https://github.com&apos;: xiaqunfeng</span><br><span class="line">Password for &apos;https://xiaqunfeng@github.com&apos;: </span><br><span class="line">To https://github.com/xiaqunfeng/xiaqunfeng.github.io.git</span><br><span class="line"> * [new branch]      HEAD -&gt; master</span><br><span class="line">Branch master set up to track remote branch master from https://github.com/xiaqunfeng/xiaqunfeng.github.io.git.</span><br><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></table></figure>
<p>输入github的用户名和密码即可。此时，博客已经完全搭建起来了。</p>
<p>在浏览器中输入：<a href="https://xiaqunfeng.github.io/" target="_blank" rel="noopener">https://xiaqunfeng.github.io/</a> 即可访问。</p>
<p>预览如下： <img src="http://ojet8bprn.bkt.clouddn.com/hexo-new.png" alt=""></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>自己google一下hexo主题，选一个自己喜欢的，然后git clone下来。比如 Next 主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<p>然后打开_config.yml文件，替换其中的 <code>theme</code> 属性，默认为 <code>landscape</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g #生成静态页面，生成的内容在public文件夹下</span><br><span class="line">$ hexo s #启动本地服务，进行文章预览调试。hexo s --debug 命令可以用来调试</span><br></pre></td></tr></table></figure>
<h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>1、清理之前生成的内容，即public文件。</p>
<p><strong>注意</strong>：这一步必须要，不然有时因为缓存问题，服务器更新不了主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>2、生成静态文件并部署到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g #生成静态文件</span><br><span class="line">$ hexo d #部署到github</span><br></pre></td></tr></table></figure>
<p>上面两个命令可以合并为一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g #在部署前先生成</span><br></pre></td></tr></table></figure>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><blockquote>
<p>update 2017.06.25。已购买域名，特来补充完善。</p>
</blockquote>
<p>1、购买域名</p>
<p>某乎<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="noopener">这里</a>有各种推荐，自己可以参考的看看。</p>
<p>godaddy地址: <a href="https://www.godaddy.com/" target="_blank" rel="noopener">https://www.godaddy.com</a></p>
<p>阿里云域名地址: <a href="http://wanwang.aliyun.com/" target="_blank" rel="noopener">http://wanwang.aliyun.com</a></p>
<p><strong>总结</strong><br>某乎上那些推荐都看了一遍，也琢磨了一下，最后发现，还是阿里云上的比较便宜，然后操作起来也比较方便，于是就在阿里云上买了。</p>
<p>我的域名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.xiaqunfeng.cc</span><br></pre></td></tr></table></figure></p>
<p><strong>关于域名选择</strong></p>
<p>.com .cn .net .org 这种比较适合网站比较大的，当然，价格也贵一点，.com .cn 还需要网站备案什么的。现在一些其他后缀也很不错，比如 .cc .me .im .pro .top .info 等等，这些资料大家可以自己去查，就不细说了，强烈推荐 .me 和 .cc ，不过 .me 比 .cc贵，特别是买的时间越久或者续费都贵。我的 .cc 16块一年，哈哈，便宜，然后也挺好。</p>
<p>2、域名解析</p>
<p>域名解析-&gt;解析设置-&gt;添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，可以随便填一个，或者两个都填，线路就默认，CNAME记录值填你的github博客网址</p>
<p>我的如下：</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/domain-hexo.jpg" alt="domain"></p>
<p>3、创建<code>CNAME</code>文件</p>
<p>这一步没做的话，打开网址访问不来博客。</p>
<p>在hexo 博客的根目录下source文件夹里创建CNAME文件，里面填上域名信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat CNAME</span><br><span class="line">xiaqunfeng.cc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：如果里面填的是 <a href="http://www.xiaqunfeng.cc，那以后就只能用它来访问；如果填的是" target="_blank" rel="noopener">www.xiaqunfeng.cc，那以后就只能用它来访问；如果填的是</a> xiaqunfeng.cc，那以后用 <a href="http://www.xiaqunfeng.cc" target="_blank" rel="noopener">www.xiaqunfeng.cc</a> 和 xiaqunfeng.cc 都可以访问。</p>
</blockquote>
<p>等待生效，一般几分钟就好了，然后就可通过域名浏览你的博客主页了。</p>
<blockquote>
<p>update 2019.01.04。又购买了一个域名，来补充一下</p>
</blockquote>
<p>之前购买的.cc域名不能进行ICP备案，因为需要ICP备案的域名，所以就又买了一个，这次购买的比较参考了<a href="https://www.v2ex.com/t/491716" target="_blank" rel="noopener">v2ex</a>上大家的讨论，我最终比较了四个网站：namesilo、namecheap、name.com和之前购买过的阿里云，最后还是选了阿里云的.site域名，首年8块，我一次性新注册10年，共一百多块钱，还是很便宜的。</p>
<h2 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h2><p>1、注册clustrmaps，点击<a href="https://clustrmaps.com/" target="_blank" rel="noopener">官网</a>进行注册</p>
<p>2、注册完以后点击<strong>Create New Widget</strong> 创建新的widget，输入自己博客的站点地址；</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/clustrmaps_01.jpg" alt="1"></p>
<p>3、然后选择你的<strong>Widget</strong> 类型</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/clustrmaps_02.jpg" alt="2"></p>
<p>4、拷贝所选择的 widget对应的安装代码，将代码添加到对应主题下的 <code>layout/_partial/footer.ejs</code> 中即可</p>
<p>Map widget</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/clustrmaps_02.jpg" alt="3"></p>
<p>Globe widget</p>
<p><img src="http://oow6unnib.bkt.clouddn.com/clustrmaps_04.jpg" alt="4"></p>
<p>我的主题是yilia，所以添加的路径是：<code>themes/yilia/layout/_partial/footer.ejs</code></p>
<p>最终显示结果，请见本人<a href="http://xiaqunfeng.cc">主页</a>最下面。</p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
